/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/_virtual/_rollupPluginBabelHelpers.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/_virtual/_rollupPluginBabelHelpers.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"extends\": () => (/* binding */ _extends)\n/* harmony export */ });\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/_virtual/_rollupPluginBabelHelpers.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/core.js":
/*!*******************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/core.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"apps\": () => (/* binding */ apps),\n/* harmony export */   \"common\": () => (/* binding */ common),\n/* harmony export */   \"config\": () => (/* binding */ config),\n/* harmony export */   \"data\": () => (/* binding */ data),\n/* harmony export */   \"extend\": () => (/* binding */ extend),\n/* harmony export */   \"isDefined\": () => (/* binding */ isDefined),\n/* harmony export */   \"revision\": () => (/* binding */ revision),\n/* harmony export */   \"type\": () => (/* binding */ type),\n/* harmony export */   \"version\": () => (/* binding */ version)\n/* harmony export */ });\nconst version = '1.60.0';\nconst revision = '5afe45b2f';\nconst config = {};\nconst common = {};\nconst apps = {};\nconst data = {};\nconst _typeLookup = function () {\n  const result = {};\n  const names = ['Array', 'Object', 'Function', 'Date', 'RegExp', 'Float32Array'];\n  for (let i = 0; i < names.length; i++) result['[object ' + names[i] + ']'] = names[i].toLowerCase();\n  return result;\n}();\nfunction type(obj) {\n  if (obj === null) {\n    return 'null';\n  }\n  const type = typeof obj;\n  if (type === 'undefined' || type === 'number' || type === 'string' || type === 'boolean') {\n    return type;\n  }\n  return _typeLookup[Object.prototype.toString.call(obj)];\n}\nfunction extend(target, ex) {\n  for (const prop in ex) {\n    const copy = ex[prop];\n    if (type(copy) === 'object') {\n      target[prop] = extend({}, copy);\n    } else if (type(copy) === 'array') {\n      target[prop] = extend([], copy);\n    } else {\n      target[prop] = copy;\n    }\n  }\n  return target;\n}\nfunction isDefined(o) {\n  let a;\n  return o !== a;\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/core.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js":
/*!****************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EventHandler\": () => (/* binding */ EventHandler)\n/* harmony export */ });\nclass EventHandler {\n  constructor() {\n    this._callbacks = {};\n    this._callbackActive = {};\n  }\n  initEventHandler() {\n    this._callbacks = {};\n    this._callbackActive = {};\n  }\n  _addCallback(name, callback, scope, once = false) {\n    if (!name || typeof name !== 'string' || !callback) return;\n    if (!this._callbacks[name]) this._callbacks[name] = [];\n    if (this._callbackActive[name] && this._callbackActive[name] === this._callbacks[name]) this._callbackActive[name] = this._callbackActive[name].slice();\n    this._callbacks[name].push({\n      callback: callback,\n      scope: scope || this,\n      once: once\n    });\n  }\n  on(name, callback, scope) {\n    this._addCallback(name, callback, scope, false);\n    return this;\n  }\n  off(name, callback, scope) {\n    if (name) {\n      if (this._callbackActive[name] && this._callbackActive[name] === this._callbacks[name]) this._callbackActive[name] = this._callbackActive[name].slice();\n    } else {\n      for (const key in this._callbackActive) {\n        if (!this._callbacks[key]) continue;\n        if (this._callbacks[key] !== this._callbackActive[key]) continue;\n        this._callbackActive[key] = this._callbackActive[key].slice();\n      }\n    }\n    if (!name) {\n      this._callbacks = {};\n    } else if (!callback) {\n      if (this._callbacks[name]) this._callbacks[name] = [];\n    } else {\n      const events = this._callbacks[name];\n      if (!events) return this;\n      let count = events.length;\n      for (let i = 0; i < count; i++) {\n        if (events[i].callback !== callback) continue;\n        if (scope && events[i].scope !== scope) continue;\n        events[i--] = events[--count];\n      }\n      events.length = count;\n    }\n    return this;\n  }\n  fire(name, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {\n    if (!name || !this._callbacks[name]) return this;\n    let callbacks;\n    if (!this._callbackActive[name]) {\n      this._callbackActive[name] = this._callbacks[name];\n    } else {\n      if (this._callbackActive[name] === this._callbacks[name]) this._callbackActive[name] = this._callbackActive[name].slice();\n      callbacks = this._callbacks[name].slice();\n    }\n    for (let i = 0; (callbacks || this._callbackActive[name]) && i < (callbacks || this._callbackActive[name]).length; i++) {\n      const evt = (callbacks || this._callbackActive[name])[i];\n      evt.callback.call(evt.scope, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\n      if (evt.once) {\n        const existingCallback = this._callbacks[name];\n        const ind = existingCallback ? existingCallback.indexOf(evt) : -1;\n        if (ind !== -1) {\n          if (this._callbackActive[name] === existingCallback) this._callbackActive[name] = this._callbackActive[name].slice();\n          this._callbacks[name].splice(ind, 1);\n        }\n      }\n    }\n    if (!callbacks) this._callbackActive[name] = null;\n    return this;\n  }\n  once(name, callback, scope) {\n    this._addCallback(name, callback, scope, true);\n    return this;\n  }\n  hasEvent(name) {\n    return this._callbacks[name] && this._callbacks[name].length !== 0 || false;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/events.js":
/*!*********************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/events.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"events\": () => (/* binding */ events)\n/* harmony export */ });\n/* harmony import */ var _event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n\n\nconst events = {\n  attach: function (target) {\n    const ev = events;\n    target._addCallback = ev._addCallback;\n    target.on = ev.on;\n    target.off = ev.off;\n    target.fire = ev.fire;\n    target.once = ev.once;\n    target.hasEvent = ev.hasEvent;\n    target._callbacks = {};\n    target._callbackActive = {};\n    return target;\n  },\n  _addCallback: _event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler.prototype._addCallback,\n  on: _event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler.prototype.on,\n  off: _event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler.prototype.off,\n  fire: _event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler.prototype.fire,\n  once: _event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler.prototype.once,\n  hasEvent: _event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler.prototype.hasEvent\n};\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/events.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/guid.js":
/*!*******************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/guid.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"guid\": () => (/* binding */ guid)\n/* harmony export */ });\nconst guid = {\n  create: function () {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n      const r = Math.random() * 16 | 0;\n      const v = c === 'x' ? r : r & 0x3 | 0x8;\n      return v.toString(16);\n    });\n  }\n};\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/guid.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/hash.js":
/*!*******************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/hash.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"hashCode\": () => (/* binding */ hashCode)\n/* harmony export */ });\nfunction hashCode(str) {\n  let hash = 0;\n  for (let i = 0, len = str.length; i < len; i++) {\n    hash = (hash << 5) - hash + str.charCodeAt(i);\n    hash |= 0;\n  }\n  return hash;\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/hash.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/indexed-list.js":
/*!***************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/indexed-list.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IndexedList\": () => (/* binding */ IndexedList)\n/* harmony export */ });\nclass IndexedList {\n  constructor() {\n    this._list = [];\n    this._index = {};\n  }\n  push(key, item) {\n    if (this._index[key]) {\n      throw Error('Key already in index ' + key);\n    }\n    const location = this._list.push(item) - 1;\n    this._index[key] = location;\n  }\n  has(key) {\n    return this._index[key] !== undefined;\n  }\n  get(key) {\n    const location = this._index[key];\n    if (location !== undefined) {\n      return this._list[location];\n    }\n    return null;\n  }\n  remove(key) {\n    const location = this._index[key];\n    if (location !== undefined) {\n      this._list.splice(location, 1);\n      delete this._index[key];\n      for (key in this._index) {\n        const idx = this._index[key];\n        if (idx > location) {\n          this._index[key] = idx - 1;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  list() {\n    return this._list;\n  }\n  clear() {\n    this._list.length = 0;\n    for (const prop in this._index) {\n      delete this._index[prop];\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/indexed-list.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js":
/*!*************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Color\": () => (/* binding */ Color)\n/* harmony export */ });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n\n\nclass Color {\n  constructor(r = 0, g = 0, b = 0, a = 1) {\n    const length = r.length;\n    if (length === 3 || length === 4) {\n      this.r = r[0];\n      this.g = r[1];\n      this.b = r[2];\n      this.a = r[3] !== undefined ? r[3] : 1;\n    } else {\n      this.r = r;\n      this.g = g;\n      this.b = b;\n      this.a = a;\n    }\n  }\n  clone() {\n    const cstr = this.constructor;\n    return new cstr(this.r, this.g, this.b, this.a);\n  }\n  copy(rhs) {\n    this.r = rhs.r;\n    this.g = rhs.g;\n    this.b = rhs.b;\n    this.a = rhs.a;\n    return this;\n  }\n  equals(rhs) {\n    return this.r === rhs.r && this.g === rhs.g && this.b === rhs.b && this.a === rhs.a;\n  }\n  set(r, g, b, a = 1) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    this.a = a;\n    return this;\n  }\n  lerp(lhs, rhs, alpha) {\n    this.r = lhs.r + alpha * (rhs.r - lhs.r);\n    this.g = lhs.g + alpha * (rhs.g - lhs.g);\n    this.b = lhs.b + alpha * (rhs.b - lhs.b);\n    this.a = lhs.a + alpha * (rhs.a - lhs.a);\n    return this;\n  }\n  fromString(hex) {\n    const i = parseInt(hex.replace('#', '0x'), 16);\n    let bytes;\n    if (hex.length > 7) {\n      bytes = _math_js__WEBPACK_IMPORTED_MODULE_0__.math.intToBytes32(i);\n    } else {\n      bytes = _math_js__WEBPACK_IMPORTED_MODULE_0__.math.intToBytes24(i);\n      bytes[3] = 255;\n    }\n    this.set(bytes[0] / 255, bytes[1] / 255, bytes[2] / 255, bytes[3] / 255);\n    return this;\n  }\n  toString(alpha) {\n    let s = '#' + ((1 << 24) + (Math.round(this.r * 255) << 16) + (Math.round(this.g * 255) << 8) + Math.round(this.b * 255)).toString(16).slice(1);\n    if (alpha === true) {\n      const a = Math.round(this.a * 255).toString(16);\n      if (this.a < 16 / 255) {\n        s += '0' + a;\n      } else {\n        s += a;\n      }\n    }\n    return s;\n  }\n}\nColor.BLACK = Object.freeze(new Color(0, 0, 0, 1));\nColor.BLUE = Object.freeze(new Color(0, 0, 1, 1));\nColor.CYAN = Object.freeze(new Color(0, 1, 1, 1));\nColor.GRAY = Object.freeze(new Color(0.5, 0.5, 0.5, 1));\nColor.GREEN = Object.freeze(new Color(0, 1, 0, 1));\nColor.MAGENTA = Object.freeze(new Color(1, 0, 1, 1));\nColor.RED = Object.freeze(new Color(1, 0, 0, 1));\nColor.WHITE = Object.freeze(new Color(1, 1, 1, 1));\nColor.YELLOW = Object.freeze(new Color(1, 1, 0, 1));\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/math/constants.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/math/constants.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CURVE_CARDINAL\": () => (/* binding */ CURVE_CARDINAL),\n/* harmony export */   \"CURVE_CATMULL\": () => (/* binding */ CURVE_CATMULL),\n/* harmony export */   \"CURVE_LINEAR\": () => (/* binding */ CURVE_LINEAR),\n/* harmony export */   \"CURVE_SMOOTHSTEP\": () => (/* binding */ CURVE_SMOOTHSTEP),\n/* harmony export */   \"CURVE_SPLINE\": () => (/* binding */ CURVE_SPLINE),\n/* harmony export */   \"CURVE_STEP\": () => (/* binding */ CURVE_STEP)\n/* harmony export */ });\nconst CURVE_LINEAR = 0;\nconst CURVE_SMOOTHSTEP = 1;\nconst CURVE_CATMULL = 2;\nconst CURVE_CARDINAL = 3;\nconst CURVE_SPLINE = 4;\nconst CURVE_STEP = 5;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/math/constants.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/math/curve-evaluator.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/math/curve-evaluator.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CurveEvaluator\": () => (/* binding */ CurveEvaluator)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/constants.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n\n\n\nclass CurveEvaluator {\n  constructor(curve, time = 0) {\n    this._curve = curve;\n    this._left = -Infinity;\n    this._right = Infinity;\n    this._recip = 0;\n    this._p0 = 0;\n    this._p1 = 0;\n    this._m0 = 0;\n    this._m1 = 0;\n    this._reset(time);\n  }\n  evaluate(time, forceReset = false) {\n    if (forceReset || time < this._left || time >= this._right) {\n      this._reset(time);\n    }\n    let result;\n    const type = this._curve.type;\n    if (type === _constants_js__WEBPACK_IMPORTED_MODULE_0__.CURVE_STEP) {\n      result = this._p0;\n    } else {\n      const t = this._recip === 0 ? 0 : (time - this._left) * this._recip;\n      if (type === _constants_js__WEBPACK_IMPORTED_MODULE_0__.CURVE_LINEAR) {\n        result = _math_js__WEBPACK_IMPORTED_MODULE_1__.math.lerp(this._p0, this._p1, t);\n      } else if (type === _constants_js__WEBPACK_IMPORTED_MODULE_0__.CURVE_SMOOTHSTEP) {\n        result = _math_js__WEBPACK_IMPORTED_MODULE_1__.math.lerp(this._p0, this._p1, t * t * (3 - 2 * t));\n      } else {\n        result = this._evaluateHermite(this._p0, this._p1, this._m0, this._m1, t);\n      }\n    }\n    return result;\n  }\n  _reset(time) {\n    const keys = this._curve.keys;\n    const len = keys.length;\n    if (!len) {\n      this._left = -Infinity;\n      this._right = Infinity;\n      this._recip = 0;\n      this._p0 = this._p1 = this._m0 = this._m1 = 0;\n    } else {\n      if (time < keys[0][0]) {\n        this._left = -Infinity;\n        this._right = keys[0][0];\n        this._recip = 0;\n        this._p0 = this._p1 = keys[0][1];\n        this._m0 = this._m1 = 0;\n      } else if (time >= keys[len - 1][0]) {\n        this._left = keys[len - 1][0];\n        this._right = Infinity;\n        this._recip = 0;\n        this._p0 = this._p1 = keys[len - 1][1];\n        this._m0 = this._m1 = 0;\n      } else {\n        let index = 0;\n        while (time >= keys[index + 1][0]) {\n          index++;\n        }\n        this._left = keys[index][0];\n        this._right = keys[index + 1][0];\n        const diff = 1.0 / (this._right - this._left);\n        this._recip = isFinite(diff) ? diff : 0;\n        this._p0 = keys[index][1];\n        this._p1 = keys[index + 1][1];\n        if (this._isHermite()) {\n          this._calcTangents(keys, index);\n        }\n      }\n    }\n  }\n  _isHermite() {\n    return this._curve.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__.CURVE_CATMULL || this._curve.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__.CURVE_CARDINAL || this._curve.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__.CURVE_SPLINE;\n  }\n  _calcTangents(keys, index) {\n    let a;\n    const b = keys[index];\n    const c = keys[index + 1];\n    let d;\n    if (index === 0) {\n      a = [keys[0][0] + (keys[0][0] - keys[1][0]), keys[0][1] + (keys[0][1] - keys[1][1])];\n    } else {\n      a = keys[index - 1];\n    }\n    if (index === keys.length - 2) {\n      d = [keys[index + 1][0] + (keys[index + 1][0] - keys[index][0]), keys[index + 1][1] + (keys[index + 1][1] - keys[index][1])];\n    } else {\n      d = keys[index + 2];\n    }\n    if (this._curve.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__.CURVE_SPLINE) {\n      const s1_ = 2 * (c[0] - b[0]) / (c[0] - a[0]);\n      const s2_ = 2 * (c[0] - b[0]) / (d[0] - b[0]);\n      this._m0 = this._curve.tension * (isFinite(s1_) ? s1_ : 0) * (c[1] - a[1]);\n      this._m1 = this._curve.tension * (isFinite(s2_) ? s2_ : 0) * (d[1] - b[1]);\n    } else {\n      const s1 = (c[0] - b[0]) / (b[0] - a[0]);\n      const s2 = (c[0] - b[0]) / (d[0] - c[0]);\n      const a_ = b[1] + (a[1] - b[1]) * (isFinite(s1) ? s1 : 0);\n      const d_ = c[1] + (d[1] - c[1]) * (isFinite(s2) ? s2 : 0);\n      const tension = this._curve.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__.CURVE_CATMULL ? 0.5 : this._curve.tension;\n      this._m0 = tension * (c[1] - a_);\n      this._m1 = tension * (d_ - b[1]);\n    }\n  }\n  _evaluateHermite(p0, p1, m0, m1, t) {\n    const t2 = t * t;\n    const twot = t + t;\n    const omt = 1 - t;\n    const omt2 = omt * omt;\n    return p0 * ((1 + twot) * omt2) + m0 * (t * omt2) + p1 * (t2 * (3 - twot)) + m1 * (t2 * (t - 1));\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/math/curve-evaluator.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/math/curve-set.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/math/curve-set.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CurveSet\": () => (/* binding */ CurveSet)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/constants.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/curve.js\");\n/* harmony import */ var _curve_evaluator_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curve-evaluator.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/curve-evaluator.js\");\n\n\n\n\nclass CurveSet {\n  constructor() {\n    this.curves = [];\n    this._type = _constants_js__WEBPACK_IMPORTED_MODULE_0__.CURVE_SMOOTHSTEP;\n    if (arguments.length > 1) {\n      for (let i = 0; i < arguments.length; i++) {\n        this.curves.push(new _curve_js__WEBPACK_IMPORTED_MODULE_1__.Curve(arguments[i]));\n      }\n    } else {\n      if (arguments.length === 0) {\n        this.curves.push(new _curve_js__WEBPACK_IMPORTED_MODULE_1__.Curve());\n      } else {\n        const arg = arguments[0];\n        if (typeof arg === 'number') {\n          for (let i = 0; i < arg; i++) {\n            this.curves.push(new _curve_js__WEBPACK_IMPORTED_MODULE_1__.Curve());\n          }\n        } else {\n          for (let i = 0; i < arg.length; i++) {\n            this.curves.push(new _curve_js__WEBPACK_IMPORTED_MODULE_1__.Curve(arg[i]));\n          }\n        }\n      }\n    }\n  }\n  get length() {\n    return this.curves.length;\n  }\n  set type(value) {\n    this._type = value;\n    for (let i = 0; i < this.curves.length; i++) {\n      this.curves[i].type = value;\n    }\n  }\n  get type() {\n    return this._type;\n  }\n  get(index) {\n    return this.curves[index];\n  }\n  value(time, result = []) {\n    const length = this.curves.length;\n    result.length = length;\n    for (let i = 0; i < length; i++) {\n      result[i] = this.curves[i].value(time);\n    }\n    return result;\n  }\n  clone() {\n    const result = new this.constructor();\n    result.curves = [];\n    for (let i = 0; i < this.curves.length; i++) {\n      result.curves.push(this.curves[i].clone());\n    }\n    result._type = this._type;\n    return result;\n  }\n  quantize(precision) {\n    precision = Math.max(precision, 2);\n    const numCurves = this.curves.length;\n    const values = new Float32Array(precision * numCurves);\n    const step = 1.0 / (precision - 1);\n    for (let c = 0; c < numCurves; c++) {\n      const ev = new _curve_evaluator_js__WEBPACK_IMPORTED_MODULE_2__.CurveEvaluator(this.curves[c]);\n      for (let i = 0; i < precision; i++) {\n        values[i * numCurves + c] = ev.evaluate(step * i);\n      }\n    }\n    return values;\n  }\n  quantizeClamped(precision, min, max) {\n    const result = this.quantize(precision);\n    for (let i = 0; i < result.length; ++i) {\n      result[i] = Math.min(max, Math.max(min, result[i]));\n    }\n    return result;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/math/curve-set.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/math/curve.js":
/*!*************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/math/curve.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Curve\": () => (/* binding */ Curve)\n/* harmony export */ });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/core.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/constants.js\");\n/* harmony import */ var _curve_evaluator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve-evaluator.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/curve-evaluator.js\");\n\n\n\n\nclass Curve {\n  constructor(data) {\n    this.keys = [];\n    this.type = _constants_js__WEBPACK_IMPORTED_MODULE_0__.CURVE_SMOOTHSTEP;\n    this.tension = 0.5;\n    this._eval = new _curve_evaluator_js__WEBPACK_IMPORTED_MODULE_1__.CurveEvaluator(this);\n    if (data) {\n      for (let i = 0; i < data.length - 1; i += 2) {\n        this.keys.push([data[i], data[i + 1]]);\n      }\n    }\n    this.sort();\n  }\n  get length() {\n    return this.keys.length;\n  }\n  add(time, value) {\n    const keys = this.keys;\n    const len = keys.length;\n    let i = 0;\n    for (; i < len; i++) {\n      if (keys[i][0] > time) {\n        break;\n      }\n    }\n    const key = [time, value];\n    this.keys.splice(i, 0, key);\n    return key;\n  }\n  get(index) {\n    return this.keys[index];\n  }\n  sort() {\n    this.keys.sort(function (a, b) {\n      return a[0] - b[0];\n    });\n  }\n  value(time) {\n    return this._eval.evaluate(time, true);\n  }\n  closest(time) {\n    const keys = this.keys;\n    const length = keys.length;\n    let min = 2;\n    let result = null;\n    for (let i = 0; i < length; i++) {\n      const diff = Math.abs(time - keys[i][0]);\n      if (min >= diff) {\n        min = diff;\n        result = keys[i];\n      } else {\n        break;\n      }\n    }\n    return result;\n  }\n  clone() {\n    const result = new this.constructor();\n    result.keys = (0,_core_js__WEBPACK_IMPORTED_MODULE_2__.extend)(result.keys, this.keys);\n    result.type = this.type;\n    result.tension = this.tension;\n    return result;\n  }\n  quantize(precision) {\n    precision = Math.max(precision, 2);\n    const values = new Float32Array(precision);\n    const step = 1.0 / (precision - 1);\n    values[0] = this._eval.evaluate(0, true);\n    for (let i = 1; i < precision; i++) {\n      values[i] = this._eval.evaluate(step * i);\n    }\n    return values;\n  }\n  quantizeClamped(precision, min, max) {\n    const result = this.quantize(precision);\n    for (let i = 0; i < result.length; ++i) {\n      result[i] = Math.min(max, Math.max(min, result[i]));\n    }\n    return result;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/math/curve.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/math/float-packing.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/math/float-packing.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FloatPacking\": () => (/* binding */ FloatPacking)\n/* harmony export */ });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n\n\nconst oneDiv255 = 1 / 255;\nconst floatView = new Float32Array(1);\nconst int32View = new Int32Array(floatView.buffer);\nclass FloatPacking {\n  static float2Half(value) {\n    floatView[0] = value;\n    const x = int32View[0];\n    let bits = x >> 16 & 0x8000;\n    let m = x >> 12 & 0x07ff;\n    const e = x >> 23 & 0xff;\n    if (e < 103) {\n      return bits;\n    }\n    if (e > 142) {\n      bits |= 0x7c00;\n      bits |= (e === 255 ? 0 : 1) && x & 0x007fffff;\n      return bits;\n    }\n    if (e < 113) {\n      m |= 0x0800;\n      bits |= (m >> 114 - e) + (m >> 113 - e & 1);\n      return bits;\n    }\n    bits |= e - 112 << 10 | m >> 1;\n    bits += m & 1;\n    return bits;\n  }\n  static float2Bytes(value, array, offset, numBytes) {\n    const enc1 = 255.0 * value % 1;\n    array[offset + 0] = Math.round((value % 1 - oneDiv255 * enc1) * 255);\n    if (numBytes > 1) {\n      const enc2 = 65025.0 * value % 1;\n      array[offset + 1] = Math.round((enc1 - oneDiv255 * enc2) * 255);\n      if (numBytes > 2) {\n        const enc3 = 16581375.0 * value % 1;\n        array[offset + 2] = Math.round((enc2 - oneDiv255 * enc3) * 255);\n        if (numBytes > 3) {\n          array[offset + 3] = Math.round(enc3 * 255);\n        }\n      }\n    }\n  }\n  static float2BytesRange(value, array, offset, min, max, numBytes) {\n    value = _math_js__WEBPACK_IMPORTED_MODULE_0__.math.clamp((value - min) / (max - min), 0, 1);\n    FloatPacking.float2Bytes(value, array, offset, numBytes);\n  }\n  static float2MantissaExponent(value, array, offset, numBytes) {\n    const exponent = Math.floor(Math.log2(Math.abs(value))) + 1;\n    value /= Math.pow(2, exponent);\n    FloatPacking.float2BytesRange(value, array, offset, -1, 1, numBytes - 1);\n    array[offset + numBytes - 1] = Math.round(exponent + 127);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/math/float-packing.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat3.js":
/*!************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat3.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Mat3\": () => (/* binding */ Mat3)\n/* harmony export */ });\n/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n\n\nclass Mat3 {\n  constructor() {\n    const data = new Float32Array(9);\n    data[0] = data[4] = data[8] = 1;\n    this.data = data;\n  }\n  clone() {\n    const cstr = this.constructor;\n    return new cstr().copy(this);\n  }\n  copy(rhs) {\n    const src = rhs.data;\n    const dst = this.data;\n    dst[0] = src[0];\n    dst[1] = src[1];\n    dst[2] = src[2];\n    dst[3] = src[3];\n    dst[4] = src[4];\n    dst[5] = src[5];\n    dst[6] = src[6];\n    dst[7] = src[7];\n    dst[8] = src[8];\n    return this;\n  }\n  set(src) {\n    const dst = this.data;\n    dst[0] = src[0];\n    dst[1] = src[1];\n    dst[2] = src[2];\n    dst[3] = src[3];\n    dst[4] = src[4];\n    dst[5] = src[5];\n    dst[6] = src[6];\n    dst[7] = src[7];\n    dst[8] = src[8];\n    return this;\n  }\n  equals(rhs) {\n    const l = this.data;\n    const r = rhs.data;\n    return l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8];\n  }\n  isIdentity() {\n    const m = this.data;\n    return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 1 && m[5] === 0 && m[6] === 0 && m[7] === 0 && m[8] === 1;\n  }\n  setIdentity() {\n    const m = this.data;\n    m[0] = 1;\n    m[1] = 0;\n    m[2] = 0;\n    m[3] = 0;\n    m[4] = 1;\n    m[5] = 0;\n    m[6] = 0;\n    m[7] = 0;\n    m[8] = 1;\n    return this;\n  }\n  toString() {\n    return '[' + this.data.join(', ') + ']';\n  }\n  transpose() {\n    const m = this.data;\n    let tmp;\n    tmp = m[1];\n    m[1] = m[3];\n    m[3] = tmp;\n    tmp = m[2];\n    m[2] = m[6];\n    m[6] = tmp;\n    tmp = m[5];\n    m[5] = m[7];\n    m[7] = tmp;\n    return this;\n  }\n  setFromMat4(m) {\n    const src = m.data;\n    const dst = this.data;\n    dst[0] = src[0];\n    dst[1] = src[1];\n    dst[2] = src[2];\n    dst[3] = src[4];\n    dst[4] = src[5];\n    dst[5] = src[6];\n    dst[6] = src[8];\n    dst[7] = src[9];\n    dst[8] = src[10];\n    return this;\n  }\n  transformVector(vec, res = new _vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3()) {\n    const m = this.data;\n    const x = vec.x;\n    const y = vec.y;\n    const z = vec.z;\n    res.x = x * m[0] + y * m[3] + z * m[6];\n    res.y = x * m[1] + y * m[4] + z * m[7];\n    res.z = x * m[2] + y * m[5] + z * m[8];\n    return res;\n  }\n}\nMat3.IDENTITY = Object.freeze(new Mat3());\nMat3.ZERO = Object.freeze(new Mat3().set([0, 0, 0, 0, 0, 0, 0, 0, 0]));\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat3.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js":
/*!************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Mat4\": () => (/* binding */ Mat4)\n/* harmony export */ });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _vec2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vec4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec4.js\");\n\n\n\n\n\nconst _halfSize = new _vec2_js__WEBPACK_IMPORTED_MODULE_0__.Vec2();\nconst x = new _vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst y = new _vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst z = new _vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst scale = new _vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nclass Mat4 {\n  constructor() {\n    const data = new Float32Array(16);\n    data[0] = data[5] = data[10] = data[15] = 1;\n    this.data = data;\n  }\n  static _getPerspectiveHalfSize(halfSize, fov, aspect, znear, fovIsHorizontal) {\n    if (fovIsHorizontal) {\n      halfSize.x = znear * Math.tan(fov * Math.PI / 360);\n      halfSize.y = halfSize.x / aspect;\n    } else {\n      halfSize.y = znear * Math.tan(fov * Math.PI / 360);\n      halfSize.x = halfSize.y * aspect;\n    }\n  }\n  add2(lhs, rhs) {\n    const a = lhs.data,\n      b = rhs.data,\n      r = this.data;\n    r[0] = a[0] + b[0];\n    r[1] = a[1] + b[1];\n    r[2] = a[2] + b[2];\n    r[3] = a[3] + b[3];\n    r[4] = a[4] + b[4];\n    r[5] = a[5] + b[5];\n    r[6] = a[6] + b[6];\n    r[7] = a[7] + b[7];\n    r[8] = a[8] + b[8];\n    r[9] = a[9] + b[9];\n    r[10] = a[10] + b[10];\n    r[11] = a[11] + b[11];\n    r[12] = a[12] + b[12];\n    r[13] = a[13] + b[13];\n    r[14] = a[14] + b[14];\n    r[15] = a[15] + b[15];\n    return this;\n  }\n  add(rhs) {\n    return this.add2(this, rhs);\n  }\n  clone() {\n    const cstr = this.constructor;\n    return new cstr().copy(this);\n  }\n  copy(rhs) {\n    const src = rhs.data,\n      dst = this.data;\n    dst[0] = src[0];\n    dst[1] = src[1];\n    dst[2] = src[2];\n    dst[3] = src[3];\n    dst[4] = src[4];\n    dst[5] = src[5];\n    dst[6] = src[6];\n    dst[7] = src[7];\n    dst[8] = src[8];\n    dst[9] = src[9];\n    dst[10] = src[10];\n    dst[11] = src[11];\n    dst[12] = src[12];\n    dst[13] = src[13];\n    dst[14] = src[14];\n    dst[15] = src[15];\n    return this;\n  }\n  equals(rhs) {\n    const l = this.data,\n      r = rhs.data;\n    return l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8] && l[9] === r[9] && l[10] === r[10] && l[11] === r[11] && l[12] === r[12] && l[13] === r[13] && l[14] === r[14] && l[15] === r[15];\n  }\n  isIdentity() {\n    const m = this.data;\n    return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 0 && m[5] === 1 && m[6] === 0 && m[7] === 0 && m[8] === 0 && m[9] === 0 && m[10] === 1 && m[11] === 0 && m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1;\n  }\n  mul2(lhs, rhs) {\n    const a = lhs.data;\n    const b = rhs.data;\n    const r = this.data;\n    const a00 = a[0];\n    const a01 = a[1];\n    const a02 = a[2];\n    const a03 = a[3];\n    const a10 = a[4];\n    const a11 = a[5];\n    const a12 = a[6];\n    const a13 = a[7];\n    const a20 = a[8];\n    const a21 = a[9];\n    const a22 = a[10];\n    const a23 = a[11];\n    const a30 = a[12];\n    const a31 = a[13];\n    const a32 = a[14];\n    const a33 = a[15];\n    let b0, b1, b2, b3;\n    b0 = b[0];\n    b1 = b[1];\n    b2 = b[2];\n    b3 = b[3];\n    r[0] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;\n    r[1] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;\n    r[2] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;\n    r[3] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;\n    b0 = b[4];\n    b1 = b[5];\n    b2 = b[6];\n    b3 = b[7];\n    r[4] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;\n    r[5] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;\n    r[6] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;\n    r[7] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;\n    b0 = b[8];\n    b1 = b[9];\n    b2 = b[10];\n    b3 = b[11];\n    r[8] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;\n    r[9] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;\n    r[10] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;\n    r[11] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;\n    b0 = b[12];\n    b1 = b[13];\n    b2 = b[14];\n    b3 = b[15];\n    r[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;\n    r[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;\n    r[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;\n    r[15] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;\n    return this;\n  }\n  mulAffine2(lhs, rhs) {\n    const a = lhs.data;\n    const b = rhs.data;\n    const r = this.data;\n    const a00 = a[0];\n    const a01 = a[1];\n    const a02 = a[2];\n    const a10 = a[4];\n    const a11 = a[5];\n    const a12 = a[6];\n    const a20 = a[8];\n    const a21 = a[9];\n    const a22 = a[10];\n    const a30 = a[12];\n    const a31 = a[13];\n    const a32 = a[14];\n    let b0, b1, b2;\n    b0 = b[0];\n    b1 = b[1];\n    b2 = b[2];\n    r[0] = a00 * b0 + a10 * b1 + a20 * b2;\n    r[1] = a01 * b0 + a11 * b1 + a21 * b2;\n    r[2] = a02 * b0 + a12 * b1 + a22 * b2;\n    r[3] = 0;\n    b0 = b[4];\n    b1 = b[5];\n    b2 = b[6];\n    r[4] = a00 * b0 + a10 * b1 + a20 * b2;\n    r[5] = a01 * b0 + a11 * b1 + a21 * b2;\n    r[6] = a02 * b0 + a12 * b1 + a22 * b2;\n    r[7] = 0;\n    b0 = b[8];\n    b1 = b[9];\n    b2 = b[10];\n    r[8] = a00 * b0 + a10 * b1 + a20 * b2;\n    r[9] = a01 * b0 + a11 * b1 + a21 * b2;\n    r[10] = a02 * b0 + a12 * b1 + a22 * b2;\n    r[11] = 0;\n    b0 = b[12];\n    b1 = b[13];\n    b2 = b[14];\n    r[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30;\n    r[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31;\n    r[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32;\n    r[15] = 1;\n    return this;\n  }\n  mul(rhs) {\n    return this.mul2(this, rhs);\n  }\n  transformPoint(vec, res = new _vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3()) {\n    const m = this.data;\n    const x = vec.x;\n    const y = vec.y;\n    const z = vec.z;\n    res.x = x * m[0] + y * m[4] + z * m[8] + m[12];\n    res.y = x * m[1] + y * m[5] + z * m[9] + m[13];\n    res.z = x * m[2] + y * m[6] + z * m[10] + m[14];\n    return res;\n  }\n  transformVector(vec, res = new _vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3()) {\n    const m = this.data;\n    const x = vec.x;\n    const y = vec.y;\n    const z = vec.z;\n    res.x = x * m[0] + y * m[4] + z * m[8];\n    res.y = x * m[1] + y * m[5] + z * m[9];\n    res.z = x * m[2] + y * m[6] + z * m[10];\n    return res;\n  }\n  transformVec4(vec, res = new _vec4_js__WEBPACK_IMPORTED_MODULE_2__.Vec4()) {\n    const m = this.data;\n    const x = vec.x;\n    const y = vec.y;\n    const z = vec.z;\n    const w = vec.w;\n    res.x = x * m[0] + y * m[4] + z * m[8] + w * m[12];\n    res.y = x * m[1] + y * m[5] + z * m[9] + w * m[13];\n    res.z = x * m[2] + y * m[6] + z * m[10] + w * m[14];\n    res.w = x * m[3] + y * m[7] + z * m[11] + w * m[15];\n    return res;\n  }\n  setLookAt(position, target, up) {\n    z.sub2(position, target).normalize();\n    y.copy(up).normalize();\n    x.cross(y, z).normalize();\n    y.cross(z, x);\n    const r = this.data;\n    r[0] = x.x;\n    r[1] = x.y;\n    r[2] = x.z;\n    r[3] = 0;\n    r[4] = y.x;\n    r[5] = y.y;\n    r[6] = y.z;\n    r[7] = 0;\n    r[8] = z.x;\n    r[9] = z.y;\n    r[10] = z.z;\n    r[11] = 0;\n    r[12] = position.x;\n    r[13] = position.y;\n    r[14] = position.z;\n    r[15] = 1;\n    return this;\n  }\n  setFrustum(left, right, bottom, top, znear, zfar) {\n    const temp1 = 2 * znear;\n    const temp2 = right - left;\n    const temp3 = top - bottom;\n    const temp4 = zfar - znear;\n    const r = this.data;\n    r[0] = temp1 / temp2;\n    r[1] = 0;\n    r[2] = 0;\n    r[3] = 0;\n    r[4] = 0;\n    r[5] = temp1 / temp3;\n    r[6] = 0;\n    r[7] = 0;\n    r[8] = (right + left) / temp2;\n    r[9] = (top + bottom) / temp3;\n    r[10] = (-zfar - znear) / temp4;\n    r[11] = -1;\n    r[12] = 0;\n    r[13] = 0;\n    r[14] = -temp1 * zfar / temp4;\n    r[15] = 0;\n    return this;\n  }\n  setPerspective(fov, aspect, znear, zfar, fovIsHorizontal) {\n    Mat4._getPerspectiveHalfSize(_halfSize, fov, aspect, znear, fovIsHorizontal);\n    return this.setFrustum(-_halfSize.x, _halfSize.x, -_halfSize.y, _halfSize.y, znear, zfar);\n  }\n  setOrtho(left, right, bottom, top, near, far) {\n    const r = this.data;\n    r[0] = 2 / (right - left);\n    r[1] = 0;\n    r[2] = 0;\n    r[3] = 0;\n    r[4] = 0;\n    r[5] = 2 / (top - bottom);\n    r[6] = 0;\n    r[7] = 0;\n    r[8] = 0;\n    r[9] = 0;\n    r[10] = -2 / (far - near);\n    r[11] = 0;\n    r[12] = -(right + left) / (right - left);\n    r[13] = -(top + bottom) / (top - bottom);\n    r[14] = -(far + near) / (far - near);\n    r[15] = 1;\n    return this;\n  }\n  setFromAxisAngle(axis, angle) {\n    angle *= _math_js__WEBPACK_IMPORTED_MODULE_3__.math.DEG_TO_RAD;\n    const x = axis.x;\n    const y = axis.y;\n    const z = axis.z;\n    const c = Math.cos(angle);\n    const s = Math.sin(angle);\n    const t = 1 - c;\n    const tx = t * x;\n    const ty = t * y;\n    const m = this.data;\n    m[0] = tx * x + c;\n    m[1] = tx * y + s * z;\n    m[2] = tx * z - s * y;\n    m[3] = 0;\n    m[4] = tx * y - s * z;\n    m[5] = ty * y + c;\n    m[6] = ty * z + s * x;\n    m[7] = 0;\n    m[8] = tx * z + s * y;\n    m[9] = ty * z - x * s;\n    m[10] = t * z * z + c;\n    m[11] = 0;\n    m[12] = 0;\n    m[13] = 0;\n    m[14] = 0;\n    m[15] = 1;\n    return this;\n  }\n  setTranslate(x, y, z) {\n    const m = this.data;\n    m[0] = 1;\n    m[1] = 0;\n    m[2] = 0;\n    m[3] = 0;\n    m[4] = 0;\n    m[5] = 1;\n    m[6] = 0;\n    m[7] = 0;\n    m[8] = 0;\n    m[9] = 0;\n    m[10] = 1;\n    m[11] = 0;\n    m[12] = x;\n    m[13] = y;\n    m[14] = z;\n    m[15] = 1;\n    return this;\n  }\n  setScale(x, y, z) {\n    const m = this.data;\n    m[0] = x;\n    m[1] = 0;\n    m[2] = 0;\n    m[3] = 0;\n    m[4] = 0;\n    m[5] = y;\n    m[6] = 0;\n    m[7] = 0;\n    m[8] = 0;\n    m[9] = 0;\n    m[10] = z;\n    m[11] = 0;\n    m[12] = 0;\n    m[13] = 0;\n    m[14] = 0;\n    m[15] = 1;\n    return this;\n  }\n  setViewport(x, y, width, height) {\n    const m = this.data;\n    m[0] = width * 0.5;\n    m[1] = 0;\n    m[2] = 0;\n    m[3] = 0;\n    m[4] = 0;\n    m[5] = height * 0.5;\n    m[6] = 0;\n    m[7] = 0;\n    m[8] = 0;\n    m[9] = 0;\n    m[10] = 0.5;\n    m[11] = 0;\n    m[12] = x + width * 0.5;\n    m[13] = y + height * 0.5;\n    m[14] = 0.5;\n    m[15] = 1;\n    return this;\n  }\n  invert() {\n    const m = this.data;\n    const a00 = m[0];\n    const a01 = m[1];\n    const a02 = m[2];\n    const a03 = m[3];\n    const a10 = m[4];\n    const a11 = m[5];\n    const a12 = m[6];\n    const a13 = m[7];\n    const a20 = m[8];\n    const a21 = m[9];\n    const a22 = m[10];\n    const a23 = m[11];\n    const a30 = m[12];\n    const a31 = m[13];\n    const a32 = m[14];\n    const a33 = m[15];\n    const b00 = a00 * a11 - a01 * a10;\n    const b01 = a00 * a12 - a02 * a10;\n    const b02 = a00 * a13 - a03 * a10;\n    const b03 = a01 * a12 - a02 * a11;\n    const b04 = a01 * a13 - a03 * a11;\n    const b05 = a02 * a13 - a03 * a12;\n    const b06 = a20 * a31 - a21 * a30;\n    const b07 = a20 * a32 - a22 * a30;\n    const b08 = a20 * a33 - a23 * a30;\n    const b09 = a21 * a32 - a22 * a31;\n    const b10 = a21 * a33 - a23 * a31;\n    const b11 = a22 * a33 - a23 * a32;\n    const det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n    if (det === 0) {\n      this.setIdentity();\n    } else {\n      const invDet = 1 / det;\n      m[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;\n      m[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;\n      m[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;\n      m[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;\n      m[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;\n      m[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;\n      m[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;\n      m[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;\n      m[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;\n      m[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;\n      m[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;\n      m[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;\n      m[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;\n      m[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;\n      m[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;\n      m[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;\n    }\n    return this;\n  }\n  set(src) {\n    const dst = this.data;\n    dst[0] = src[0];\n    dst[1] = src[1];\n    dst[2] = src[2];\n    dst[3] = src[3];\n    dst[4] = src[4];\n    dst[5] = src[5];\n    dst[6] = src[6];\n    dst[7] = src[7];\n    dst[8] = src[8];\n    dst[9] = src[9];\n    dst[10] = src[10];\n    dst[11] = src[11];\n    dst[12] = src[12];\n    dst[13] = src[13];\n    dst[14] = src[14];\n    dst[15] = src[15];\n    return this;\n  }\n  setIdentity() {\n    const m = this.data;\n    m[0] = 1;\n    m[1] = 0;\n    m[2] = 0;\n    m[3] = 0;\n    m[4] = 0;\n    m[5] = 1;\n    m[6] = 0;\n    m[7] = 0;\n    m[8] = 0;\n    m[9] = 0;\n    m[10] = 1;\n    m[11] = 0;\n    m[12] = 0;\n    m[13] = 0;\n    m[14] = 0;\n    m[15] = 1;\n    return this;\n  }\n  setTRS(t, r, s) {\n    const qx = r.x;\n    const qy = r.y;\n    const qz = r.z;\n    const qw = r.w;\n    const sx = s.x;\n    const sy = s.y;\n    const sz = s.z;\n    const x2 = qx + qx;\n    const y2 = qy + qy;\n    const z2 = qz + qz;\n    const xx = qx * x2;\n    const xy = qx * y2;\n    const xz = qx * z2;\n    const yy = qy * y2;\n    const yz = qy * z2;\n    const zz = qz * z2;\n    const wx = qw * x2;\n    const wy = qw * y2;\n    const wz = qw * z2;\n    const m = this.data;\n    m[0] = (1 - (yy + zz)) * sx;\n    m[1] = (xy + wz) * sx;\n    m[2] = (xz - wy) * sx;\n    m[3] = 0;\n    m[4] = (xy - wz) * sy;\n    m[5] = (1 - (xx + zz)) * sy;\n    m[6] = (yz + wx) * sy;\n    m[7] = 0;\n    m[8] = (xz + wy) * sz;\n    m[9] = (yz - wx) * sz;\n    m[10] = (1 - (xx + yy)) * sz;\n    m[11] = 0;\n    m[12] = t.x;\n    m[13] = t.y;\n    m[14] = t.z;\n    m[15] = 1;\n    return this;\n  }\n  transpose() {\n    let tmp;\n    const m = this.data;\n    tmp = m[1];\n    m[1] = m[4];\n    m[4] = tmp;\n    tmp = m[2];\n    m[2] = m[8];\n    m[8] = tmp;\n    tmp = m[3];\n    m[3] = m[12];\n    m[12] = tmp;\n    tmp = m[6];\n    m[6] = m[9];\n    m[9] = tmp;\n    tmp = m[7];\n    m[7] = m[13];\n    m[13] = tmp;\n    tmp = m[11];\n    m[11] = m[14];\n    m[14] = tmp;\n    return this;\n  }\n  invertTo3x3(res) {\n    const m = this.data;\n    const r = res.data;\n    const m0 = m[0];\n    const m1 = m[1];\n    const m2 = m[2];\n    const m4 = m[4];\n    const m5 = m[5];\n    const m6 = m[6];\n    const m8 = m[8];\n    const m9 = m[9];\n    const m10 = m[10];\n    const a11 = m10 * m5 - m6 * m9;\n    const a21 = -m10 * m1 + m2 * m9;\n    const a31 = m6 * m1 - m2 * m5;\n    const a12 = -m10 * m4 + m6 * m8;\n    const a22 = m10 * m0 - m2 * m8;\n    const a32 = -m6 * m0 + m2 * m4;\n    const a13 = m9 * m4 - m5 * m8;\n    const a23 = -m9 * m0 + m1 * m8;\n    const a33 = m5 * m0 - m1 * m4;\n    const det = m0 * a11 + m1 * a12 + m2 * a13;\n    if (det === 0) {\n      return this;\n    }\n    const idet = 1 / det;\n    r[0] = idet * a11;\n    r[1] = idet * a21;\n    r[2] = idet * a31;\n    r[3] = idet * a12;\n    r[4] = idet * a22;\n    r[5] = idet * a32;\n    r[6] = idet * a13;\n    r[7] = idet * a23;\n    r[8] = idet * a33;\n    return this;\n  }\n  getTranslation(t = new _vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3()) {\n    return t.set(this.data[12], this.data[13], this.data[14]);\n  }\n  getX(x = new _vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3()) {\n    return x.set(this.data[0], this.data[1], this.data[2]);\n  }\n  getY(y = new _vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3()) {\n    return y.set(this.data[4], this.data[5], this.data[6]);\n  }\n  getZ(z = new _vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3()) {\n    return z.set(this.data[8], this.data[9], this.data[10]);\n  }\n  getScale(scale = new _vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3()) {\n    this.getX(x);\n    this.getY(y);\n    this.getZ(z);\n    scale.set(x.length(), y.length(), z.length());\n    return scale;\n  }\n  setFromEulerAngles(ex, ey, ez) {\n    ex *= _math_js__WEBPACK_IMPORTED_MODULE_3__.math.DEG_TO_RAD;\n    ey *= _math_js__WEBPACK_IMPORTED_MODULE_3__.math.DEG_TO_RAD;\n    ez *= _math_js__WEBPACK_IMPORTED_MODULE_3__.math.DEG_TO_RAD;\n    const s1 = Math.sin(-ex);\n    const c1 = Math.cos(-ex);\n    const s2 = Math.sin(-ey);\n    const c2 = Math.cos(-ey);\n    const s3 = Math.sin(-ez);\n    const c3 = Math.cos(-ez);\n    const m = this.data;\n    m[0] = c2 * c3;\n    m[1] = -c2 * s3;\n    m[2] = s2;\n    m[3] = 0;\n    m[4] = c1 * s3 + c3 * s1 * s2;\n    m[5] = c1 * c3 - s1 * s2 * s3;\n    m[6] = -c2 * s1;\n    m[7] = 0;\n    m[8] = s1 * s3 - c1 * c3 * s2;\n    m[9] = c3 * s1 + c1 * s2 * s3;\n    m[10] = c1 * c2;\n    m[11] = 0;\n    m[12] = 0;\n    m[13] = 0;\n    m[14] = 0;\n    m[15] = 1;\n    return this;\n  }\n  getEulerAngles(eulers = new _vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3()) {\n    this.getScale(scale);\n    const sx = scale.x;\n    const sy = scale.y;\n    const sz = scale.z;\n    if (sx === 0 || sy === 0 || sz === 0) return eulers.set(0, 0, 0);\n    const m = this.data;\n    const y = Math.asin(-m[2] / sx);\n    const halfPi = Math.PI * 0.5;\n    let x, z;\n    if (y < halfPi) {\n      if (y > -halfPi) {\n        x = Math.atan2(m[6] / sy, m[10] / sz);\n        z = Math.atan2(m[1] / sx, m[0] / sx);\n      } else {\n        z = 0;\n        x = -Math.atan2(m[4] / sy, m[5] / sy);\n      }\n    } else {\n      z = 0;\n      x = Math.atan2(m[4] / sy, m[5] / sy);\n    }\n    return eulers.set(x, y, z).mulScalar(_math_js__WEBPACK_IMPORTED_MODULE_3__.math.RAD_TO_DEG);\n  }\n  toString() {\n    return '[' + this.data.join(', ') + ']';\n  }\n}\nMat4.IDENTITY = Object.freeze(new Mat4());\nMat4.ZERO = Object.freeze(new Mat4().set([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]));\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js":
/*!************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"math\": () => (/* binding */ math)\n/* harmony export */ });\nconst math = {\n  DEG_TO_RAD: Math.PI / 180,\n  RAD_TO_DEG: 180 / Math.PI,\n  clamp: function (value, min, max) {\n    if (value >= max) return max;\n    if (value <= min) return min;\n    return value;\n  },\n  intToBytes24: function (i) {\n    const r = i >> 16 & 0xff;\n    const g = i >> 8 & 0xff;\n    const b = i & 0xff;\n    return [r, g, b];\n  },\n  intToBytes32: function (i) {\n    const r = i >> 24 & 0xff;\n    const g = i >> 16 & 0xff;\n    const b = i >> 8 & 0xff;\n    const a = i & 0xff;\n    return [r, g, b, a];\n  },\n  bytesToInt24: function (r, g, b) {\n    if (r.length) {\n      b = r[2];\n      g = r[1];\n      r = r[0];\n    }\n    return r << 16 | g << 8 | b;\n  },\n  bytesToInt32: function (r, g, b, a) {\n    if (r.length) {\n      a = r[3];\n      b = r[2];\n      g = r[1];\n      r = r[0];\n    }\n    return (r << 24 | g << 16 | b << 8 | a) >>> 0;\n  },\n  lerp: function (a, b, alpha) {\n    return a + (b - a) * math.clamp(alpha, 0, 1);\n  },\n  lerpAngle: function (a, b, alpha) {\n    if (b - a > 180) {\n      b -= 360;\n    }\n    if (b - a < -180) {\n      b += 360;\n    }\n    return math.lerp(a, b, math.clamp(alpha, 0, 1));\n  },\n  powerOfTwo: function (x) {\n    return x !== 0 && !(x & x - 1);\n  },\n  nextPowerOfTwo: function (val) {\n    val--;\n    val |= val >> 1;\n    val |= val >> 2;\n    val |= val >> 4;\n    val |= val >> 8;\n    val |= val >> 16;\n    val++;\n    return val;\n  },\n  nearestPowerOfTwo: function (val) {\n    return Math.pow(2, Math.round(Math.log(val) / Math.log(2)));\n  },\n  random: function (min, max) {\n    const diff = max - min;\n    return Math.random() * diff + min;\n  },\n  smoothstep: function (min, max, x) {\n    if (x <= min) return 0;\n    if (x >= max) return 1;\n    x = (x - min) / (max - min);\n    return x * x * (3 - 2 * x);\n  },\n  smootherstep: function (min, max, x) {\n    if (x <= min) return 0;\n    if (x >= max) return 1;\n    x = (x - min) / (max - min);\n    return x * x * x * (x * (x * 6 - 15) + 10);\n  },\n  roundUp: function (numToRound, multiple) {\n    if (multiple === 0) return numToRound;\n    return Math.ceil(numToRound / multiple) * multiple;\n  },\n  between: function (num, a, b, inclusive) {\n    const min = Math.min(a, b);\n    const max = Math.max(a, b);\n    return inclusive ? num >= min && num <= max : num > min && num < max;\n  }\n};\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/math/quat.js":
/*!************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/math/quat.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Quat\": () => (/* binding */ Quat)\n/* harmony export */ });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n\n\n\nclass Quat {\n  constructor(x = 0, y = 0, z = 0, w = 1) {\n    if (x.length === 4) {\n      this.x = x[0];\n      this.y = x[1];\n      this.z = x[2];\n      this.w = x[3];\n    } else {\n      this.x = x;\n      this.y = y;\n      this.z = z;\n      this.w = w;\n    }\n  }\n  clone() {\n    const cstr = this.constructor;\n    return new cstr(this.x, this.y, this.z, this.w);\n  }\n  conjugate() {\n    this.x *= -1;\n    this.y *= -1;\n    this.z *= -1;\n    return this;\n  }\n  copy(rhs) {\n    this.x = rhs.x;\n    this.y = rhs.y;\n    this.z = rhs.z;\n    this.w = rhs.w;\n    return this;\n  }\n  equals(rhs) {\n    return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;\n  }\n  getAxisAngle(axis) {\n    let rad = Math.acos(this.w) * 2;\n    const s = Math.sin(rad / 2);\n    if (s !== 0) {\n      axis.x = this.x / s;\n      axis.y = this.y / s;\n      axis.z = this.z / s;\n      if (axis.x < 0 || axis.y < 0 || axis.z < 0) {\n        axis.x *= -1;\n        axis.y *= -1;\n        axis.z *= -1;\n        rad *= -1;\n      }\n    } else {\n      axis.x = 1;\n      axis.y = 0;\n      axis.z = 0;\n    }\n    return rad * _math_js__WEBPACK_IMPORTED_MODULE_0__.math.RAD_TO_DEG;\n  }\n  getEulerAngles(eulers = new _vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3()) {\n    let x, y, z;\n    const qx = this.x;\n    const qy = this.y;\n    const qz = this.z;\n    const qw = this.w;\n    const a2 = 2 * (qw * qy - qx * qz);\n    if (a2 <= -0.99999) {\n      x = 2 * Math.atan2(qx, qw);\n      y = -Math.PI / 2;\n      z = 0;\n    } else if (a2 >= 0.99999) {\n      x = 2 * Math.atan2(qx, qw);\n      y = Math.PI / 2;\n      z = 0;\n    } else {\n      x = Math.atan2(2 * (qw * qx + qy * qz), 1 - 2 * (qx * qx + qy * qy));\n      y = Math.asin(a2);\n      z = Math.atan2(2 * (qw * qz + qx * qy), 1 - 2 * (qy * qy + qz * qz));\n    }\n    return eulers.set(x, y, z).mulScalar(_math_js__WEBPACK_IMPORTED_MODULE_0__.math.RAD_TO_DEG);\n  }\n  invert() {\n    return this.conjugate().normalize();\n  }\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n  }\n  lengthSq() {\n    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n  }\n  mul(rhs) {\n    const q1x = this.x;\n    const q1y = this.y;\n    const q1z = this.z;\n    const q1w = this.w;\n    const q2x = rhs.x;\n    const q2y = rhs.y;\n    const q2z = rhs.z;\n    const q2w = rhs.w;\n    this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;\n    this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;\n    this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;\n    this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;\n    return this;\n  }\n  mul2(lhs, rhs) {\n    const q1x = lhs.x;\n    const q1y = lhs.y;\n    const q1z = lhs.z;\n    const q1w = lhs.w;\n    const q2x = rhs.x;\n    const q2y = rhs.y;\n    const q2z = rhs.z;\n    const q2w = rhs.w;\n    this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;\n    this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;\n    this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;\n    this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;\n    return this;\n  }\n  normalize() {\n    let len = this.length();\n    if (len === 0) {\n      this.x = this.y = this.z = 0;\n      this.w = 1;\n    } else {\n      len = 1 / len;\n      this.x *= len;\n      this.y *= len;\n      this.z *= len;\n      this.w *= len;\n    }\n    return this;\n  }\n  set(x, y, z, w) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n    return this;\n  }\n  setFromAxisAngle(axis, angle) {\n    angle *= 0.5 * _math_js__WEBPACK_IMPORTED_MODULE_0__.math.DEG_TO_RAD;\n    const sa = Math.sin(angle);\n    const ca = Math.cos(angle);\n    this.x = sa * axis.x;\n    this.y = sa * axis.y;\n    this.z = sa * axis.z;\n    this.w = ca;\n    return this;\n  }\n  setFromEulerAngles(ex, ey, ez) {\n    if (ex instanceof _vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3) {\n      const vec = ex;\n      ex = vec.x;\n      ey = vec.y;\n      ez = vec.z;\n    }\n    const halfToRad = 0.5 * _math_js__WEBPACK_IMPORTED_MODULE_0__.math.DEG_TO_RAD;\n    ex *= halfToRad;\n    ey *= halfToRad;\n    ez *= halfToRad;\n    const sx = Math.sin(ex);\n    const cx = Math.cos(ex);\n    const sy = Math.sin(ey);\n    const cy = Math.cos(ey);\n    const sz = Math.sin(ez);\n    const cz = Math.cos(ez);\n    this.x = sx * cy * cz - cx * sy * sz;\n    this.y = cx * sy * cz + sx * cy * sz;\n    this.z = cx * cy * sz - sx * sy * cz;\n    this.w = cx * cy * cz + sx * sy * sz;\n    return this;\n  }\n  setFromMat4(m) {\n    let m00, m01, m02, m10, m11, m12, m20, m21, m22, s, rs, lx, ly, lz;\n    m = m.data;\n    m00 = m[0];\n    m01 = m[1];\n    m02 = m[2];\n    m10 = m[4];\n    m11 = m[5];\n    m12 = m[6];\n    m20 = m[8];\n    m21 = m[9];\n    m22 = m[10];\n    lx = m00 * m00 + m01 * m01 + m02 * m02;\n    if (lx === 0) return this;\n    lx = 1 / Math.sqrt(lx);\n    ly = m10 * m10 + m11 * m11 + m12 * m12;\n    if (ly === 0) return this;\n    ly = 1 / Math.sqrt(ly);\n    lz = m20 * m20 + m21 * m21 + m22 * m22;\n    if (lz === 0) return this;\n    lz = 1 / Math.sqrt(lz);\n    m00 *= lx;\n    m01 *= lx;\n    m02 *= lx;\n    m10 *= ly;\n    m11 *= ly;\n    m12 *= ly;\n    m20 *= lz;\n    m21 *= lz;\n    m22 *= lz;\n    const tr = m00 + m11 + m22;\n    if (tr >= 0) {\n      s = Math.sqrt(tr + 1);\n      this.w = s * 0.5;\n      s = 0.5 / s;\n      this.x = (m12 - m21) * s;\n      this.y = (m20 - m02) * s;\n      this.z = (m01 - m10) * s;\n    } else {\n      if (m00 > m11) {\n        if (m00 > m22) {\n          rs = m00 - (m11 + m22) + 1;\n          rs = Math.sqrt(rs);\n          this.x = rs * 0.5;\n          rs = 0.5 / rs;\n          this.w = (m12 - m21) * rs;\n          this.y = (m01 + m10) * rs;\n          this.z = (m02 + m20) * rs;\n        } else {\n          rs = m22 - (m00 + m11) + 1;\n          rs = Math.sqrt(rs);\n          this.z = rs * 0.5;\n          rs = 0.5 / rs;\n          this.w = (m01 - m10) * rs;\n          this.x = (m20 + m02) * rs;\n          this.y = (m21 + m12) * rs;\n        }\n      } else if (m11 > m22) {\n        rs = m11 - (m22 + m00) + 1;\n        rs = Math.sqrt(rs);\n        this.y = rs * 0.5;\n        rs = 0.5 / rs;\n        this.w = (m20 - m02) * rs;\n        this.z = (m12 + m21) * rs;\n        this.x = (m10 + m01) * rs;\n      } else {\n        rs = m22 - (m00 + m11) + 1;\n        rs = Math.sqrt(rs);\n        this.z = rs * 0.5;\n        rs = 0.5 / rs;\n        this.w = (m01 - m10) * rs;\n        this.x = (m20 + m02) * rs;\n        this.y = (m21 + m12) * rs;\n      }\n    }\n    return this;\n  }\n  slerp(lhs, rhs, alpha) {\n    const lx = lhs.x;\n    const ly = lhs.y;\n    const lz = lhs.z;\n    const lw = lhs.w;\n    let rx = rhs.x;\n    let ry = rhs.y;\n    let rz = rhs.z;\n    let rw = rhs.w;\n    let cosHalfTheta = lw * rw + lx * rx + ly * ry + lz * rz;\n    if (cosHalfTheta < 0) {\n      rw = -rw;\n      rx = -rx;\n      ry = -ry;\n      rz = -rz;\n      cosHalfTheta = -cosHalfTheta;\n    }\n    if (Math.abs(cosHalfTheta) >= 1) {\n      this.w = lw;\n      this.x = lx;\n      this.y = ly;\n      this.z = lz;\n      return this;\n    }\n    const halfTheta = Math.acos(cosHalfTheta);\n    const sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);\n    if (Math.abs(sinHalfTheta) < 0.001) {\n      this.w = lw * 0.5 + rw * 0.5;\n      this.x = lx * 0.5 + rx * 0.5;\n      this.y = ly * 0.5 + ry * 0.5;\n      this.z = lz * 0.5 + rz * 0.5;\n      return this;\n    }\n    const ratioA = Math.sin((1 - alpha) * halfTheta) / sinHalfTheta;\n    const ratioB = Math.sin(alpha * halfTheta) / sinHalfTheta;\n    this.w = lw * ratioA + rw * ratioB;\n    this.x = lx * ratioA + rx * ratioB;\n    this.y = ly * ratioA + ry * ratioB;\n    this.z = lz * ratioA + rz * ratioB;\n    return this;\n  }\n  transformVector(vec, res = new _vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3()) {\n    const x = vec.x,\n      y = vec.y,\n      z = vec.z;\n    const qx = this.x,\n      qy = this.y,\n      qz = this.z,\n      qw = this.w;\n    const ix = qw * x + qy * z - qz * y;\n    const iy = qw * y + qz * x - qx * z;\n    const iz = qw * z + qx * y - qy * x;\n    const iw = -qx * x - qy * y - qz * z;\n    res.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n    res.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n    res.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n    return res;\n  }\n  toString() {\n    return `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`;\n  }\n}\nQuat.IDENTITY = Object.freeze(new Quat(0, 0, 0, 1));\nQuat.ZERO = Object.freeze(new Quat(0, 0, 0, 0));\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/math/quat.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/math/random.js":
/*!**************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/math/random.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"random\": () => (/* binding */ random)\n/* harmony export */ });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n\n\nconst _goldenAngle = 2.399963229728653;\nconst random = {\n  circlePoint: function (point) {\n    const r = Math.sqrt(Math.random());\n    const theta = Math.random() * 2 * Math.PI;\n    point.x = r * Math.cos(theta);\n    point.y = r * Math.sin(theta);\n  },\n  circlePointDeterministic: function (point, index, numPoints) {\n    const theta = index * _goldenAngle;\n    const r = Math.sqrt(index) / Math.sqrt(numPoints);\n    point.x = r * Math.cos(theta);\n    point.y = r * Math.sin(theta);\n  },\n  spherePointDeterministic: function (point, index, numPoints, start = 0, end = 1) {\n    start = 1 - 2 * start;\n    end = 1 - 2 * end;\n    const y = _math_js__WEBPACK_IMPORTED_MODULE_0__.math.lerp(start, end, index / numPoints);\n    const radius = Math.sqrt(1 - y * y);\n    const theta = _goldenAngle * index;\n    point.x = Math.cos(theta) * radius;\n    point.y = y;\n    point.z = Math.sin(theta) * radius;\n  },\n  radicalInverse: function (i) {\n    let bits = (i << 16 | i >>> 16) >>> 0;\n    bits = ((bits & 0x55555555) << 1 | (bits & 0xAAAAAAAA) >>> 1) >>> 0;\n    bits = ((bits & 0x33333333) << 2 | (bits & 0xCCCCCCCC) >>> 2) >>> 0;\n    bits = ((bits & 0x0F0F0F0F) << 4 | (bits & 0xF0F0F0F0) >>> 4) >>> 0;\n    bits = ((bits & 0x00FF00FF) << 8 | (bits & 0xFF00FF00) >>> 8) >>> 0;\n    return bits * 2.3283064365386963e-10;\n  }\n};\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/math/random.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js":
/*!************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Vec2\": () => (/* binding */ Vec2)\n/* harmony export */ });\nclass Vec2 {\n  constructor(x = 0, y = 0) {\n    if (x.length === 2) {\n      this.x = x[0];\n      this.y = x[1];\n    } else {\n      this.x = x;\n      this.y = y;\n    }\n  }\n  add(rhs) {\n    this.x += rhs.x;\n    this.y += rhs.y;\n    return this;\n  }\n  add2(lhs, rhs) {\n    this.x = lhs.x + rhs.x;\n    this.y = lhs.y + rhs.y;\n    return this;\n  }\n  addScalar(scalar) {\n    this.x += scalar;\n    this.y += scalar;\n    return this;\n  }\n  clone() {\n    const cstr = this.constructor;\n    return new cstr(this.x, this.y);\n  }\n  copy(rhs) {\n    this.x = rhs.x;\n    this.y = rhs.y;\n    return this;\n  }\n  cross(rhs) {\n    return this.x * rhs.y - this.y * rhs.x;\n  }\n  distance(rhs) {\n    const x = this.x - rhs.x;\n    const y = this.y - rhs.y;\n    return Math.sqrt(x * x + y * y);\n  }\n  div(rhs) {\n    this.x /= rhs.x;\n    this.y /= rhs.y;\n    return this;\n  }\n  div2(lhs, rhs) {\n    this.x = lhs.x / rhs.x;\n    this.y = lhs.y / rhs.y;\n    return this;\n  }\n  divScalar(scalar) {\n    this.x /= scalar;\n    this.y /= scalar;\n    return this;\n  }\n  dot(rhs) {\n    return this.x * rhs.x + this.y * rhs.y;\n  }\n  equals(rhs) {\n    return this.x === rhs.x && this.y === rhs.y;\n  }\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n  lengthSq() {\n    return this.x * this.x + this.y * this.y;\n  }\n  lerp(lhs, rhs, alpha) {\n    this.x = lhs.x + alpha * (rhs.x - lhs.x);\n    this.y = lhs.y + alpha * (rhs.y - lhs.y);\n    return this;\n  }\n  mul(rhs) {\n    this.x *= rhs.x;\n    this.y *= rhs.y;\n    return this;\n  }\n  mul2(lhs, rhs) {\n    this.x = lhs.x * rhs.x;\n    this.y = lhs.y * rhs.y;\n    return this;\n  }\n  mulScalar(scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    return this;\n  }\n  normalize() {\n    const lengthSq = this.x * this.x + this.y * this.y;\n    if (lengthSq > 0) {\n      const invLength = 1 / Math.sqrt(lengthSq);\n      this.x *= invLength;\n      this.y *= invLength;\n    }\n    return this;\n  }\n  floor() {\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n    return this;\n  }\n  ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n    return this;\n  }\n  round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    return this;\n  }\n  min(rhs) {\n    if (rhs.x < this.x) this.x = rhs.x;\n    if (rhs.y < this.y) this.y = rhs.y;\n    return this;\n  }\n  max(rhs) {\n    if (rhs.x > this.x) this.x = rhs.x;\n    if (rhs.y > this.y) this.y = rhs.y;\n    return this;\n  }\n  set(x, y) {\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  sub(rhs) {\n    this.x -= rhs.x;\n    this.y -= rhs.y;\n    return this;\n  }\n  sub2(lhs, rhs) {\n    this.x = lhs.x - rhs.x;\n    this.y = lhs.y - rhs.y;\n    return this;\n  }\n  subScalar(scalar) {\n    this.x -= scalar;\n    this.y -= scalar;\n    return this;\n  }\n  toString() {\n    return `[${this.x}, ${this.y}]`;\n  }\n  static angleRad(lhs, rhs) {\n    return Math.atan2(lhs.x * rhs.y - lhs.y * rhs.x, lhs.x * rhs.x + lhs.y * rhs.y);\n  }\n}\nVec2.ZERO = Object.freeze(new Vec2(0, 0));\nVec2.ONE = Object.freeze(new Vec2(1, 1));\nVec2.UP = Object.freeze(new Vec2(0, 1));\nVec2.DOWN = Object.freeze(new Vec2(0, -1));\nVec2.RIGHT = Object.freeze(new Vec2(1, 0));\nVec2.LEFT = Object.freeze(new Vec2(-1, 0));\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js":
/*!************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Vec3\": () => (/* binding */ Vec3)\n/* harmony export */ });\nclass Vec3 {\n  constructor(x = 0, y = 0, z = 0) {\n    if (x.length === 3) {\n      this.x = x[0];\n      this.y = x[1];\n      this.z = x[2];\n    } else {\n      this.x = x;\n      this.y = y;\n      this.z = z;\n    }\n  }\n  add(rhs) {\n    this.x += rhs.x;\n    this.y += rhs.y;\n    this.z += rhs.z;\n    return this;\n  }\n  add2(lhs, rhs) {\n    this.x = lhs.x + rhs.x;\n    this.y = lhs.y + rhs.y;\n    this.z = lhs.z + rhs.z;\n    return this;\n  }\n  addScalar(scalar) {\n    this.x += scalar;\n    this.y += scalar;\n    this.z += scalar;\n    return this;\n  }\n  clone() {\n    const cstr = this.constructor;\n    return new cstr(this.x, this.y, this.z);\n  }\n  copy(rhs) {\n    this.x = rhs.x;\n    this.y = rhs.y;\n    this.z = rhs.z;\n    return this;\n  }\n  cross(lhs, rhs) {\n    const lx = lhs.x;\n    const ly = lhs.y;\n    const lz = lhs.z;\n    const rx = rhs.x;\n    const ry = rhs.y;\n    const rz = rhs.z;\n    this.x = ly * rz - ry * lz;\n    this.y = lz * rx - rz * lx;\n    this.z = lx * ry - rx * ly;\n    return this;\n  }\n  distance(rhs) {\n    const x = this.x - rhs.x;\n    const y = this.y - rhs.y;\n    const z = this.z - rhs.z;\n    return Math.sqrt(x * x + y * y + z * z);\n  }\n  div(rhs) {\n    this.x /= rhs.x;\n    this.y /= rhs.y;\n    this.z /= rhs.z;\n    return this;\n  }\n  div2(lhs, rhs) {\n    this.x = lhs.x / rhs.x;\n    this.y = lhs.y / rhs.y;\n    this.z = lhs.z / rhs.z;\n    return this;\n  }\n  divScalar(scalar) {\n    this.x /= scalar;\n    this.y /= scalar;\n    this.z /= scalar;\n    return this;\n  }\n  dot(rhs) {\n    return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;\n  }\n  equals(rhs) {\n    return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z;\n  }\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n  }\n  lengthSq() {\n    return this.x * this.x + this.y * this.y + this.z * this.z;\n  }\n  lerp(lhs, rhs, alpha) {\n    this.x = lhs.x + alpha * (rhs.x - lhs.x);\n    this.y = lhs.y + alpha * (rhs.y - lhs.y);\n    this.z = lhs.z + alpha * (rhs.z - lhs.z);\n    return this;\n  }\n  mul(rhs) {\n    this.x *= rhs.x;\n    this.y *= rhs.y;\n    this.z *= rhs.z;\n    return this;\n  }\n  mul2(lhs, rhs) {\n    this.x = lhs.x * rhs.x;\n    this.y = lhs.y * rhs.y;\n    this.z = lhs.z * rhs.z;\n    return this;\n  }\n  mulScalar(scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    this.z *= scalar;\n    return this;\n  }\n  normalize() {\n    const lengthSq = this.x * this.x + this.y * this.y + this.z * this.z;\n    if (lengthSq > 0) {\n      const invLength = 1 / Math.sqrt(lengthSq);\n      this.x *= invLength;\n      this.y *= invLength;\n      this.z *= invLength;\n    }\n    return this;\n  }\n  floor() {\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n    this.z = Math.floor(this.z);\n    return this;\n  }\n  ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n    this.z = Math.ceil(this.z);\n    return this;\n  }\n  round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    this.z = Math.round(this.z);\n    return this;\n  }\n  min(rhs) {\n    if (rhs.x < this.x) this.x = rhs.x;\n    if (rhs.y < this.y) this.y = rhs.y;\n    if (rhs.z < this.z) this.z = rhs.z;\n    return this;\n  }\n  max(rhs) {\n    if (rhs.x > this.x) this.x = rhs.x;\n    if (rhs.y > this.y) this.y = rhs.y;\n    if (rhs.z > this.z) this.z = rhs.z;\n    return this;\n  }\n  project(rhs) {\n    const a_dot_b = this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;\n    const b_dot_b = rhs.x * rhs.x + rhs.y * rhs.y + rhs.z * rhs.z;\n    const s = a_dot_b / b_dot_b;\n    this.x = rhs.x * s;\n    this.y = rhs.y * s;\n    this.z = rhs.z * s;\n    return this;\n  }\n  set(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    return this;\n  }\n  sub(rhs) {\n    this.x -= rhs.x;\n    this.y -= rhs.y;\n    this.z -= rhs.z;\n    return this;\n  }\n  sub2(lhs, rhs) {\n    this.x = lhs.x - rhs.x;\n    this.y = lhs.y - rhs.y;\n    this.z = lhs.z - rhs.z;\n    return this;\n  }\n  subScalar(scalar) {\n    this.x -= scalar;\n    this.y -= scalar;\n    this.z -= scalar;\n    return this;\n  }\n  toString() {\n    return `[${this.x}, ${this.y}, ${this.z}]`;\n  }\n}\nVec3.ZERO = Object.freeze(new Vec3(0, 0, 0));\nVec3.ONE = Object.freeze(new Vec3(1, 1, 1));\nVec3.UP = Object.freeze(new Vec3(0, 1, 0));\nVec3.DOWN = Object.freeze(new Vec3(0, -1, 0));\nVec3.RIGHT = Object.freeze(new Vec3(1, 0, 0));\nVec3.LEFT = Object.freeze(new Vec3(-1, 0, 0));\nVec3.FORWARD = Object.freeze(new Vec3(0, 0, -1));\nVec3.BACK = Object.freeze(new Vec3(0, 0, 1));\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec4.js":
/*!************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec4.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Vec4\": () => (/* binding */ Vec4)\n/* harmony export */ });\nclass Vec4 {\n  constructor(x = 0, y = 0, z = 0, w = 0) {\n    if (x.length === 4) {\n      this.x = x[0];\n      this.y = x[1];\n      this.z = x[2];\n      this.w = x[3];\n    } else {\n      this.x = x;\n      this.y = y;\n      this.z = z;\n      this.w = w;\n    }\n  }\n  add(rhs) {\n    this.x += rhs.x;\n    this.y += rhs.y;\n    this.z += rhs.z;\n    this.w += rhs.w;\n    return this;\n  }\n  add2(lhs, rhs) {\n    this.x = lhs.x + rhs.x;\n    this.y = lhs.y + rhs.y;\n    this.z = lhs.z + rhs.z;\n    this.w = lhs.w + rhs.w;\n    return this;\n  }\n  addScalar(scalar) {\n    this.x += scalar;\n    this.y += scalar;\n    this.z += scalar;\n    this.w += scalar;\n    return this;\n  }\n  clone() {\n    const cstr = this.constructor;\n    return new cstr(this.x, this.y, this.z, this.w);\n  }\n  copy(rhs) {\n    this.x = rhs.x;\n    this.y = rhs.y;\n    this.z = rhs.z;\n    this.w = rhs.w;\n    return this;\n  }\n  div(rhs) {\n    this.x /= rhs.x;\n    this.y /= rhs.y;\n    this.z /= rhs.z;\n    this.w /= rhs.w;\n    return this;\n  }\n  div2(lhs, rhs) {\n    this.x = lhs.x / rhs.x;\n    this.y = lhs.y / rhs.y;\n    this.z = lhs.z / rhs.z;\n    this.w = lhs.w / rhs.w;\n    return this;\n  }\n  divScalar(scalar) {\n    this.x /= scalar;\n    this.y /= scalar;\n    this.z /= scalar;\n    this.w /= scalar;\n    return this;\n  }\n  dot(rhs) {\n    return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z + this.w * rhs.w;\n  }\n  equals(rhs) {\n    return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;\n  }\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n  }\n  lengthSq() {\n    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n  }\n  lerp(lhs, rhs, alpha) {\n    this.x = lhs.x + alpha * (rhs.x - lhs.x);\n    this.y = lhs.y + alpha * (rhs.y - lhs.y);\n    this.z = lhs.z + alpha * (rhs.z - lhs.z);\n    this.w = lhs.w + alpha * (rhs.w - lhs.w);\n    return this;\n  }\n  mul(rhs) {\n    this.x *= rhs.x;\n    this.y *= rhs.y;\n    this.z *= rhs.z;\n    this.w *= rhs.w;\n    return this;\n  }\n  mul2(lhs, rhs) {\n    this.x = lhs.x * rhs.x;\n    this.y = lhs.y * rhs.y;\n    this.z = lhs.z * rhs.z;\n    this.w = lhs.w * rhs.w;\n    return this;\n  }\n  mulScalar(scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    this.z *= scalar;\n    this.w *= scalar;\n    return this;\n  }\n  normalize() {\n    const lengthSq = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n    if (lengthSq > 0) {\n      const invLength = 1 / Math.sqrt(lengthSq);\n      this.x *= invLength;\n      this.y *= invLength;\n      this.z *= invLength;\n      this.w *= invLength;\n    }\n    return this;\n  }\n  floor() {\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n    this.z = Math.floor(this.z);\n    this.w = Math.floor(this.w);\n    return this;\n  }\n  ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n    this.z = Math.ceil(this.z);\n    this.w = Math.ceil(this.w);\n    return this;\n  }\n  round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    this.z = Math.round(this.z);\n    this.w = Math.round(this.w);\n    return this;\n  }\n  min(rhs) {\n    if (rhs.x < this.x) this.x = rhs.x;\n    if (rhs.y < this.y) this.y = rhs.y;\n    if (rhs.z < this.z) this.z = rhs.z;\n    if (rhs.w < this.w) this.w = rhs.w;\n    return this;\n  }\n  max(rhs) {\n    if (rhs.x > this.x) this.x = rhs.x;\n    if (rhs.y > this.y) this.y = rhs.y;\n    if (rhs.z > this.z) this.z = rhs.z;\n    if (rhs.w > this.w) this.w = rhs.w;\n    return this;\n  }\n  set(x, y, z, w) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n    return this;\n  }\n  sub(rhs) {\n    this.x -= rhs.x;\n    this.y -= rhs.y;\n    this.z -= rhs.z;\n    this.w -= rhs.w;\n    return this;\n  }\n  sub2(lhs, rhs) {\n    this.x = lhs.x - rhs.x;\n    this.y = lhs.y - rhs.y;\n    this.z = lhs.z - rhs.z;\n    this.w = lhs.w - rhs.w;\n    return this;\n  }\n  subScalar(scalar) {\n    this.x -= scalar;\n    this.y -= scalar;\n    this.z -= scalar;\n    this.w -= scalar;\n    return this;\n  }\n  toString() {\n    return `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`;\n  }\n}\nVec4.ZERO = Object.freeze(new Vec4(0, 0, 0, 0));\nVec4.ONE = Object.freeze(new Vec4(1, 1, 1, 1));\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec4.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/object-pool.js":
/*!**************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/object-pool.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ObjectPool\": () => (/* binding */ ObjectPool)\n/* harmony export */ });\nclass ObjectPool {\n  constructor(constructorFunc, size) {\n    this._constructor = constructorFunc;\n    this._pool = [];\n    this._count = 0;\n    this._resize(size);\n  }\n  _resize(size) {\n    if (size > this._pool.length) {\n      for (let i = this._pool.length; i < size; i++) {\n        this._pool[i] = new this._constructor();\n      }\n    }\n  }\n  allocate() {\n    if (this._count >= this._pool.length) {\n      this._resize(this._pool.length * 2);\n    }\n    return this._pool[this._count++];\n  }\n  freeAll() {\n    this._count = 0;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/object-pool.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/path.js":
/*!*******************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/path.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"path\": () => (/* binding */ path)\n/* harmony export */ });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/core.js\");\n\n\nconst path = {\n  delimiter: '/',\n  join: function () {\n    const num = arguments.length;\n    let result = arguments[0];\n    for (let index = 0; index < num - 1; ++index) {\n      const one = arguments[index];\n      const two = arguments[index + 1];\n      if (!(0,_core_js__WEBPACK_IMPORTED_MODULE_0__.isDefined)(one) || !(0,_core_js__WEBPACK_IMPORTED_MODULE_0__.isDefined)(two)) {\n        throw new Error('undefined argument to pc.path.join');\n      }\n      if (two[0] === path.delimiter) {\n        result = two;\n        continue;\n      }\n      if (one && two && one[one.length - 1] !== path.delimiter && two[0] !== path.delimiter) {\n        result += path.delimiter + two;\n      } else {\n        result += two;\n      }\n    }\n    return result;\n  },\n  normalize: function (pathname) {\n    const lead = pathname.startsWith(path.delimiter);\n    const trail = pathname.endsWith(path.delimiter);\n    const parts = pathname.split('/');\n    let result = '';\n    let cleaned = [];\n    for (let i = 0; i < parts.length; i++) {\n      if (parts[i] === '') continue;\n      if (parts[i] === '.') continue;\n      if (parts[i] === '..' && cleaned.length > 0) {\n        cleaned = cleaned.slice(0, cleaned.length - 2);\n        continue;\n      }\n      if (i > 0) cleaned.push(path.delimiter);\n      cleaned.push(parts[i]);\n    }\n    result = cleaned.join('');\n    if (!lead && result[0] === path.delimiter) {\n      result = result.slice(1);\n    }\n    if (trail && result[result.length - 1] !== path.delimiter) {\n      result += path.delimiter;\n    }\n    return result;\n  },\n  split: function (pathname) {\n    const lastDelimiterIndex = pathname.lastIndexOf(path.delimiter);\n    if (lastDelimiterIndex !== -1) {\n      return [pathname.substring(0, lastDelimiterIndex), pathname.substring(lastDelimiterIndex + 1)];\n    }\n    return [\"\", pathname];\n  },\n  getBasename: function (pathname) {\n    return path.split(pathname)[1];\n  },\n  getDirectory: function (pathname) {\n    return path.split(pathname)[0];\n  },\n  getExtension: function (pathname) {\n    const ext = pathname.split('?')[0].split('.').pop();\n    if (ext !== pathname) {\n      return '.' + ext;\n    }\n    return '';\n  },\n  isRelativePath: function (pathname) {\n    return pathname.charAt(0) !== '/' && pathname.match(/:\\/\\//) === null;\n  },\n  extractPath: function (pathname) {\n    let result = '';\n    const parts = pathname.split('/');\n    let i = 0;\n    if (parts.length > 1) {\n      if (path.isRelativePath(pathname)) {\n        if (parts[0] === '.') {\n          for (i = 0; i < parts.length - 1; ++i) {\n            result += i === 0 ? parts[i] : '/' + parts[i];\n          }\n        } else if (parts[0] === '..') {\n          for (i = 0; i < parts.length - 1; ++i) {\n            result += i === 0 ? parts[i] : '/' + parts[i];\n          }\n        } else {\n          result = '.';\n          for (i = 0; i < parts.length - 1; ++i) {\n            result += '/' + parts[i];\n          }\n        }\n      } else {\n        for (i = 0; i < parts.length - 1; ++i) {\n          result += i === 0 ? parts[i] : '/' + parts[i];\n        }\n      }\n    }\n    return result;\n  }\n};\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/path.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/platform.js":
/*!***********************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/platform.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"platform\": () => (/* binding */ platform)\n/* harmony export */ });\nlet desktop = false;\nlet mobile = false;\nlet windows = false;\nlet xbox = false;\nlet android = false;\nlet ios = false;\nlet touch = false;\nlet gamepads = false;\nlet workers = false;\nlet passiveEvents = false;\nif (typeof navigator !== 'undefined') {\n  const ua = navigator.userAgent;\n  if (/(windows|mac os|linux|cros)/i.test(ua)) desktop = true;\n  if (/xbox/i.test(ua)) xbox = true;\n  if (/(windows phone|iemobile|wpdesktop)/i.test(ua)) {\n    desktop = false;\n    mobile = true;\n    windows = true;\n  } else if (/android/i.test(ua)) {\n    desktop = false;\n    mobile = true;\n    android = true;\n  } else if (/ip([ao]d|hone)/i.test(ua)) {\n    desktop = false;\n    mobile = true;\n    ios = true;\n  }\n  if (typeof window !== 'undefined') {\n    touch = 'ontouchstart' in window || 'maxTouchPoints' in navigator && navigator.maxTouchPoints > 0;\n  }\n  gamepads = 'getGamepads' in navigator;\n  workers = typeof Worker !== 'undefined';\n  try {\n    const opts = Object.defineProperty({}, 'passive', {\n      get: function () {\n        passiveEvents = true;\n        return false;\n      }\n    });\n    window.addEventListener('testpassive', null, opts);\n    window.removeEventListener('testpassive', null, opts);\n  } catch (e) {}\n}\nconst environment = typeof window !== 'undefined' ? 'browser' : 'node';\nconst platform = {\n  environment: environment,\n  global: environment === 'browser' ? window : __webpack_require__.g,\n  browser: environment === 'browser',\n  desktop: desktop,\n  mobile: mobile,\n  ios: ios,\n  android: android,\n  windows: windows,\n  xbox: xbox,\n  gamepads: gamepads,\n  touch: touch,\n  workers: workers,\n  passiveEvents: passiveEvents\n};\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/platform.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/preprocessor.js":
/*!***************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/preprocessor.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Preprocessor\": () => (/* binding */ Preprocessor)\n/* harmony export */ });\n\n\nconst KEYWORD = /[ \\t]*#(ifn?def|if|endif|else|elif|define|undef|extension)/g;\nconst DEFINE = /define[ \\t]+([^\\n]+)\\r?(?:\\n|$)/g;\nconst EXTENSION = /extension[ \\t]+([\\w-]+)[ \\t]*:[ \\t]*(enable|require)/g;\nconst UNDEF = /undef[ \\t]+([^\\n]+)\\r?(?:\\n|$)/g;\nconst IF = /(ifdef|ifndef|if)[ \\t]*([^\\r\\n]+)\\r?\\n/g;\nconst ENDIF = /(endif|else|elif)([ \\t]+[^\\r\\n]+)?\\r?(?:\\n|$)/g;\nconst IDENTIFIER = /([\\w-]+)/;\nconst DEFINED = /(!|\\s)?defined\\(([\\w-]+)\\)/;\nconst INVALID = /[><=|&+-]/g;\nclass Preprocessor {\n  static run(source) {\n    source = source.replace(/\\/\\*[\\s\\S]*?\\*\\/|([^\\\\:]|^)\\/\\/.*$/gm, '$1');\n    source = source.split(/\\r?\\n/).map(line => line.trimEnd()).join('\\n');\n    source = this._preprocess(source);\n    if (source !== null) {\n      source = source.split(/\\r?\\n/).map(line => line.trim() === '' ? '' : line).join('\\n');\n      source = source.replace(/(\\n\\n){3,}/gm, '\\n\\n');\n    }\n    return source;\n  }\n  static _preprocess(source) {\n    const originalSource = source;\n    const stack = [];\n    let error = false;\n    const defines = new Map();\n    let match;\n    while ((match = KEYWORD.exec(source)) !== null) {\n      const keyword = match[1];\n      switch (keyword) {\n        case 'define':\n          {\n            DEFINE.lastIndex = match.index;\n            const define = DEFINE.exec(source);\n            error || (error = define === null);\n            const expression = define[1];\n            IDENTIFIER.lastIndex = define.index;\n            const identifierValue = IDENTIFIER.exec(expression);\n            const identifier = identifierValue[1];\n            let value = expression.substring(identifier.length).trim();\n            if (value === \"\") value = \"true\";\n            const keep = Preprocessor._keep(stack);\n            if (keep) {\n              defines.set(identifier, value);\n            }\n            KEYWORD.lastIndex = define.index + define[0].length;\n            break;\n          }\n        case 'undef':\n          {\n            UNDEF.lastIndex = match.index;\n            const undef = UNDEF.exec(source);\n            const identifier = undef[1].trim();\n            const keep = Preprocessor._keep(stack);\n            if (keep) {\n              defines.delete(identifier);\n            }\n            KEYWORD.lastIndex = undef.index + undef[0].length;\n            break;\n          }\n        case 'extension':\n          {\n            EXTENSION.lastIndex = match.index;\n            const extension = EXTENSION.exec(source);\n            error || (error = extension === null);\n            if (extension) {\n              const identifier = extension[1];\n              const keep = Preprocessor._keep(stack);\n              if (keep) {\n                defines.set(identifier, \"true\");\n              }\n            }\n            KEYWORD.lastIndex = extension.index + extension[0].length;\n            break;\n          }\n        case 'ifdef':\n        case 'ifndef':\n        case 'if':\n          {\n            IF.lastIndex = match.index;\n            const iff = IF.exec(source);\n            const expression = iff[2];\n            const evaluated = Preprocessor.evaluate(expression, defines);\n            error || (error = evaluated.error);\n            let result = evaluated.result;\n            if (keyword === 'ifndef') {\n              result = !result;\n            }\n            stack.push({\n              anyKeep: result,\n              keep: result,\n              start: match.index,\n              end: IF.lastIndex\n            });\n            KEYWORD.lastIndex = iff.index + iff[0].length;\n            break;\n          }\n        case 'endif':\n        case 'else':\n        case 'elif':\n          {\n            ENDIF.lastIndex = match.index;\n            const endif = ENDIF.exec(source);\n            const blockInfo = stack.pop();\n            const blockCode = blockInfo.keep ? source.substring(blockInfo.end, match.index) : \"\";\n            source = source.substring(0, blockInfo.start) + blockCode + source.substring(ENDIF.lastIndex);\n            KEYWORD.lastIndex = blockInfo.start + blockCode.length;\n            const endifCommand = endif[1];\n            if (endifCommand === 'else' || endifCommand === 'elif') {\n              let result = false;\n              if (!blockInfo.anyKeep) {\n                if (endifCommand === 'else') {\n                  result = !blockInfo.keep;\n                } else {\n                  const evaluated = Preprocessor.evaluate(endif[2], defines);\n                  result = evaluated.result;\n                  error || (error = evaluated.error);\n                }\n              }\n              stack.push({\n                anyKeep: blockInfo.anyKeep || result,\n                keep: result,\n                start: KEYWORD.lastIndex,\n                end: KEYWORD.lastIndex\n              });\n            }\n            break;\n          }\n      }\n    }\n    if (error) {\n      console.warn(\"Failed to preprocess shader: \", {\n        source: originalSource\n      });\n      return originalSource;\n    }\n    return source;\n  }\n  static _keep(stack) {\n    for (let i = 0; i < stack.length; i++) {\n      if (!stack[i].keep) return false;\n    }\n    return true;\n  }\n  static evaluate(expression, defines) {\n    const correct = INVALID.exec(expression) === null;\n    let invert = false;\n    const defined = DEFINED.exec(expression);\n    if (defined) {\n      invert = defined[1] === '!';\n      expression = defined[2];\n    }\n    expression = expression.trim();\n    let exists = defines.has(expression);\n    if (invert) {\n      exists = !exists;\n    }\n    return {\n      result: exists,\n      error: !correct\n    };\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/preprocessor.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/read-stream.js":
/*!**************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/read-stream.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ReadStream\": () => (/* binding */ ReadStream)\n/* harmony export */ });\nclass ReadStream {\n  constructor(arraybuffer) {\n    this.arraybuffer = arraybuffer;\n    this.dataView = new DataView(arraybuffer);\n    this.offset = 0;\n    this.stack = [];\n  }\n  get remainingBytes() {\n    return this.dataView.byteLength - this.offset;\n  }\n  reset(offset = 0) {\n    this.offset = offset;\n  }\n  skip(bytes) {\n    this.offset += bytes;\n  }\n  align(bytes) {\n    this.offset = this.offset + bytes - 1 & ~(bytes - 1);\n  }\n  _inc(amount) {\n    this.offset += amount;\n    return this.offset - amount;\n  }\n  readChar() {\n    return String.fromCharCode(this.dataView.getUint8(this.offset++));\n  }\n  readChars(numChars) {\n    let result = '';\n    for (let i = 0; i < numChars; ++i) {\n      result += this.readChar();\n    }\n    return result;\n  }\n  readU8() {\n    return this.dataView.getUint8(this.offset++);\n  }\n  readU16() {\n    return this.dataView.getUint16(this._inc(2), true);\n  }\n  readU32() {\n    return this.dataView.getUint32(this._inc(4), true);\n  }\n  readU64() {\n    return this.readU32() + 2 ** 32 * this.readU32();\n  }\n  readU32be() {\n    return this.dataView.getUint32(this._inc(4), false);\n  }\n  readArray(result) {\n    for (let i = 0; i < result.length; ++i) {\n      result[i] = this.readU8();\n    }\n  }\n  readLine() {\n    const view = this.dataView;\n    let result = '';\n    while (true) {\n      if (this.offset >= view.byteLength) {\n        break;\n      }\n      const c = String.fromCharCode(this.readU8());\n      if (c === '\\n') {\n        break;\n      }\n      result += c;\n    }\n    return result;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/read-stream.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/ref-counted-cache.js":
/*!********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/ref-counted-cache.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RefCountedCache\": () => (/* binding */ RefCountedCache)\n/* harmony export */ });\nclass RefCountedCache {\n  constructor() {\n    this.cache = new Map();\n  }\n  destroy() {\n    this.cache.forEach((refCount, object) => {\n      object.destroy();\n    });\n    this.cache.clear();\n  }\n  incRef(object) {\n    const refCount = (this.cache.get(object) || 0) + 1;\n    this.cache.set(object, refCount);\n  }\n  decRef(object) {\n    if (object) {\n      let refCount = this.cache.get(object);\n      if (refCount) {\n        refCount--;\n        if (refCount === 0) {\n          this.cache.delete(object);\n          object.destroy();\n        } else {\n          this.cache.set(object, refCount);\n        }\n      }\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/ref-counted-cache.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/ref-counted-object.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/ref-counted-object.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RefCountedObject\": () => (/* binding */ RefCountedObject)\n/* harmony export */ });\nclass RefCountedObject {\n  constructor() {\n    this._refCount = 0;\n  }\n  incRefCount() {\n    this._refCount++;\n  }\n  decRefCount() {\n    this._refCount--;\n  }\n  get refCount() {\n    return this._refCount;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/ref-counted-object.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/set-utils.js":
/*!************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/set-utils.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"set\": () => (/* binding */ set)\n/* harmony export */ });\nconst set = {\n  equals: function (set1, set2) {\n    if (set1.size !== set2.size) {\n      return false;\n    }\n    for (const item of set1) {\n      if (!set2.has(item)) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/set-utils.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/shape/bounding-box.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/shape/bounding-box.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BoundingBox\": () => (/* binding */ BoundingBox)\n/* harmony export */ });\n/* harmony import */ var _math_vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n\n\n\nconst tmpVecA = new _math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst tmpVecB = new _math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst tmpVecC = new _math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst tmpVecD = new _math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst tmpVecE = new _math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nclass BoundingBox {\n  constructor(center = new _math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(), halfExtents = new _math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(0.5, 0.5, 0.5)) {\n    this.center = center;\n    this.halfExtents = halfExtents;\n    this._min = new _math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n    this._max = new _math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n  }\n  add(other) {\n    const tc = this.center;\n    const tcx = tc.x;\n    const tcy = tc.y;\n    const tcz = tc.z;\n    const th = this.halfExtents;\n    const thx = th.x;\n    const thy = th.y;\n    const thz = th.z;\n    let tminx = tcx - thx;\n    let tmaxx = tcx + thx;\n    let tminy = tcy - thy;\n    let tmaxy = tcy + thy;\n    let tminz = tcz - thz;\n    let tmaxz = tcz + thz;\n    const oc = other.center;\n    const ocx = oc.x;\n    const ocy = oc.y;\n    const ocz = oc.z;\n    const oh = other.halfExtents;\n    const ohx = oh.x;\n    const ohy = oh.y;\n    const ohz = oh.z;\n    const ominx = ocx - ohx;\n    const omaxx = ocx + ohx;\n    const ominy = ocy - ohy;\n    const omaxy = ocy + ohy;\n    const ominz = ocz - ohz;\n    const omaxz = ocz + ohz;\n    if (ominx < tminx) tminx = ominx;\n    if (omaxx > tmaxx) tmaxx = omaxx;\n    if (ominy < tminy) tminy = ominy;\n    if (omaxy > tmaxy) tmaxy = omaxy;\n    if (ominz < tminz) tminz = ominz;\n    if (omaxz > tmaxz) tmaxz = omaxz;\n    tc.x = (tminx + tmaxx) * 0.5;\n    tc.y = (tminy + tmaxy) * 0.5;\n    tc.z = (tminz + tmaxz) * 0.5;\n    th.x = (tmaxx - tminx) * 0.5;\n    th.y = (tmaxy - tminy) * 0.5;\n    th.z = (tmaxz - tminz) * 0.5;\n  }\n  copy(src) {\n    this.center.copy(src.center);\n    this.halfExtents.copy(src.halfExtents);\n  }\n  clone() {\n    return new BoundingBox(this.center.clone(), this.halfExtents.clone());\n  }\n  intersects(other) {\n    const aMax = this.getMax();\n    const aMin = this.getMin();\n    const bMax = other.getMax();\n    const bMin = other.getMin();\n    return aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;\n  }\n  _intersectsRay(ray, point) {\n    const tMin = tmpVecA.copy(this.getMin()).sub(ray.origin);\n    const tMax = tmpVecB.copy(this.getMax()).sub(ray.origin);\n    const dir = ray.direction;\n    if (dir.x === 0) {\n      tMin.x = tMin.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n      tMax.x = tMax.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n    } else {\n      tMin.x /= dir.x;\n      tMax.x /= dir.x;\n    }\n    if (dir.y === 0) {\n      tMin.y = tMin.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n      tMax.y = tMax.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n    } else {\n      tMin.y /= dir.y;\n      tMax.y /= dir.y;\n    }\n    if (dir.z === 0) {\n      tMin.z = tMin.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n      tMax.z = tMax.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n    } else {\n      tMin.z /= dir.z;\n      tMax.z /= dir.z;\n    }\n    const realMin = tmpVecC.set(Math.min(tMin.x, tMax.x), Math.min(tMin.y, tMax.y), Math.min(tMin.z, tMax.z));\n    const realMax = tmpVecD.set(Math.max(tMin.x, tMax.x), Math.max(tMin.y, tMax.y), Math.max(tMin.z, tMax.z));\n    const minMax = Math.min(Math.min(realMax.x, realMax.y), realMax.z);\n    const maxMin = Math.max(Math.max(realMin.x, realMin.y), realMin.z);\n    const intersects = minMax >= maxMin && maxMin >= 0;\n    if (intersects) point.copy(ray.direction).mulScalar(maxMin).add(ray.origin);\n    return intersects;\n  }\n  _fastIntersectsRay(ray) {\n    const diff = tmpVecA;\n    const cross = tmpVecB;\n    const prod = tmpVecC;\n    const absDiff = tmpVecD;\n    const absDir = tmpVecE;\n    const rayDir = ray.direction;\n    diff.sub2(ray.origin, this.center);\n    absDiff.set(Math.abs(diff.x), Math.abs(diff.y), Math.abs(diff.z));\n    prod.mul2(diff, rayDir);\n    if (absDiff.x > this.halfExtents.x && prod.x >= 0) return false;\n    if (absDiff.y > this.halfExtents.y && prod.y >= 0) return false;\n    if (absDiff.z > this.halfExtents.z && prod.z >= 0) return false;\n    absDir.set(Math.abs(rayDir.x), Math.abs(rayDir.y), Math.abs(rayDir.z));\n    cross.cross(rayDir, diff);\n    cross.set(Math.abs(cross.x), Math.abs(cross.y), Math.abs(cross.z));\n    if (cross.x > this.halfExtents.y * absDir.z + this.halfExtents.z * absDir.y) return false;\n    if (cross.y > this.halfExtents.x * absDir.z + this.halfExtents.z * absDir.x) return false;\n    if (cross.z > this.halfExtents.x * absDir.y + this.halfExtents.y * absDir.x) return false;\n    return true;\n  }\n  intersectsRay(ray, point) {\n    if (point) {\n      return this._intersectsRay(ray, point);\n    }\n    return this._fastIntersectsRay(ray);\n  }\n  setMinMax(min, max) {\n    this.center.add2(max, min).mulScalar(0.5);\n    this.halfExtents.sub2(max, min).mulScalar(0.5);\n  }\n  getMin() {\n    return this._min.copy(this.center).sub(this.halfExtents);\n  }\n  getMax() {\n    return this._max.copy(this.center).add(this.halfExtents);\n  }\n  containsPoint(point) {\n    const min = this.getMin();\n    const max = this.getMax();\n    if (point.x < min.x || point.x > max.x || point.y < min.y || point.y > max.y || point.z < min.z || point.z > max.z) {\n      return false;\n    }\n    return true;\n  }\n  setFromTransformedAabb(aabb, m, ignoreScale = false) {\n    const ac = aabb.center;\n    const ar = aabb.halfExtents;\n    const d = m.data;\n    let mx0 = d[0];\n    let mx1 = d[4];\n    let mx2 = d[8];\n    let my0 = d[1];\n    let my1 = d[5];\n    let my2 = d[9];\n    let mz0 = d[2];\n    let mz1 = d[6];\n    let mz2 = d[10];\n    if (ignoreScale) {\n      let lengthSq = mx0 * mx0 + mx1 * mx1 + mx2 * mx2;\n      if (lengthSq > 0) {\n        const invLength = 1 / Math.sqrt(lengthSq);\n        mx0 *= invLength;\n        mx1 *= invLength;\n        mx2 *= invLength;\n      }\n      lengthSq = my0 * my0 + my1 * my1 + my2 * my2;\n      if (lengthSq > 0) {\n        const invLength = 1 / Math.sqrt(lengthSq);\n        my0 *= invLength;\n        my1 *= invLength;\n        my2 *= invLength;\n      }\n      lengthSq = mz0 * mz0 + mz1 * mz1 + mz2 * mz2;\n      if (lengthSq > 0) {\n        const invLength = 1 / Math.sqrt(lengthSq);\n        mz0 *= invLength;\n        mz1 *= invLength;\n        mz2 *= invLength;\n      }\n    }\n    this.center.set(d[12] + mx0 * ac.x + mx1 * ac.y + mx2 * ac.z, d[13] + my0 * ac.x + my1 * ac.y + my2 * ac.z, d[14] + mz0 * ac.x + mz1 * ac.y + mz2 * ac.z);\n    this.halfExtents.set(Math.abs(mx0) * ar.x + Math.abs(mx1) * ar.y + Math.abs(mx2) * ar.z, Math.abs(my0) * ar.x + Math.abs(my1) * ar.y + Math.abs(my2) * ar.z, Math.abs(mz0) * ar.x + Math.abs(mz1) * ar.y + Math.abs(mz2) * ar.z);\n  }\n  static computeMinMax(vertices, min, max, numVerts = vertices.length / 3) {\n    if (numVerts > 0) {\n      min.set(vertices[0], vertices[1], vertices[2]);\n      max.set(vertices[0], vertices[1], vertices[2]);\n      for (let i = 1; i < numVerts; i++) {\n        const x = vertices[i * 3 + 0];\n        const y = vertices[i * 3 + 1];\n        const z = vertices[i * 3 + 2];\n        if (x < min.x) min.x = x;\n        if (y < min.y) min.y = y;\n        if (z < min.z) min.z = z;\n        if (x > max.x) max.x = x;\n        if (y > max.y) max.y = y;\n        if (z > max.z) max.z = z;\n      }\n    }\n  }\n  compute(vertices, numVerts) {\n    BoundingBox.computeMinMax(vertices, tmpVecA, tmpVecB, numVerts);\n    this.setMinMax(tmpVecA, tmpVecB);\n  }\n  intersectsBoundingSphere(sphere) {\n    const sq = this._distanceToBoundingSphereSq(sphere);\n    if (sq <= sphere.radius * sphere.radius) {\n      return true;\n    }\n    return false;\n  }\n  _distanceToBoundingSphereSq(sphere) {\n    const boxMin = this.getMin();\n    const boxMax = this.getMax();\n    let sq = 0;\n    const axis = ['x', 'y', 'z'];\n    for (let i = 0; i < 3; ++i) {\n      let out = 0;\n      const pn = sphere.center[axis[i]];\n      const bMin = boxMin[axis[i]];\n      const bMax = boxMax[axis[i]];\n      let val = 0;\n      if (pn < bMin) {\n        val = bMin - pn;\n        out += val * val;\n      }\n      if (pn > bMax) {\n        val = pn - bMax;\n        out += val * val;\n      }\n      sq += out;\n    }\n    return sq;\n  }\n  _expand(expandMin, expandMax) {\n    tmpVecA.add2(this.getMin(), expandMin);\n    tmpVecB.add2(this.getMax(), expandMax);\n    this.setMinMax(tmpVecA, tmpVecB);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/shape/bounding-box.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/shape/bounding-sphere.js":
/*!************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/shape/bounding-sphere.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BoundingSphere\": () => (/* binding */ BoundingSphere)\n/* harmony export */ });\n/* harmony import */ var _math_vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n\n\n\nconst tmpVecA = new _math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst tmpVecB = new _math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nclass BoundingSphere {\n  constructor(center = new _math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(), radius = 0.5) {\n    this.center = center;\n    this.radius = radius;\n  }\n  containsPoint(point) {\n    const lenSq = tmpVecA.sub2(point, this.center).lengthSq();\n    const r = this.radius;\n    return lenSq < r * r;\n  }\n  intersectsRay(ray, point) {\n    const m = tmpVecA.copy(ray.origin).sub(this.center);\n    const b = m.dot(tmpVecB.copy(ray.direction).normalize());\n    const c = m.dot(m) - this.radius * this.radius;\n    if (c > 0 && b > 0) return false;\n    const discr = b * b - c;\n    if (discr < 0) return false;\n    const t = Math.abs(-b - Math.sqrt(discr));\n    if (point) point.copy(ray.direction).mulScalar(t).add(ray.origin);\n    return true;\n  }\n  intersectsBoundingSphere(sphere) {\n    tmpVecA.sub2(sphere.center, this.center);\n    const totalRadius = sphere.radius + this.radius;\n    if (tmpVecA.lengthSq() <= totalRadius * totalRadius) {\n      return true;\n    }\n    return false;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/shape/bounding-sphere.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/shape/frustum.js":
/*!****************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/shape/frustum.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Frustum\": () => (/* binding */ Frustum)\n/* harmony export */ });\nclass Frustum {\n  constructor() {\n    this.planes = [];\n    for (let i = 0; i < 6; i++) this.planes[i] = [];\n  }\n  setFromMat4(matrix) {\n    const vpm = matrix.data;\n    let plane;\n    const planes = this.planes;\n    plane = planes[0];\n    plane[0] = vpm[3] - vpm[0];\n    plane[1] = vpm[7] - vpm[4];\n    plane[2] = vpm[11] - vpm[8];\n    plane[3] = vpm[15] - vpm[12];\n    let t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);\n    plane[0] /= t;\n    plane[1] /= t;\n    plane[2] /= t;\n    plane[3] /= t;\n    plane = planes[1];\n    plane[0] = vpm[3] + vpm[0];\n    plane[1] = vpm[7] + vpm[4];\n    plane[2] = vpm[11] + vpm[8];\n    plane[3] = vpm[15] + vpm[12];\n    t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);\n    plane[0] /= t;\n    plane[1] /= t;\n    plane[2] /= t;\n    plane[3] /= t;\n    plane = planes[2];\n    plane[0] = vpm[3] + vpm[1];\n    plane[1] = vpm[7] + vpm[5];\n    plane[2] = vpm[11] + vpm[9];\n    plane[3] = vpm[15] + vpm[13];\n    t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);\n    plane[0] /= t;\n    plane[1] /= t;\n    plane[2] /= t;\n    plane[3] /= t;\n    plane = planes[3];\n    plane[0] = vpm[3] - vpm[1];\n    plane[1] = vpm[7] - vpm[5];\n    plane[2] = vpm[11] - vpm[9];\n    plane[3] = vpm[15] - vpm[13];\n    t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);\n    plane[0] /= t;\n    plane[1] /= t;\n    plane[2] /= t;\n    plane[3] /= t;\n    plane = planes[4];\n    plane[0] = vpm[3] - vpm[2];\n    plane[1] = vpm[7] - vpm[6];\n    plane[2] = vpm[11] - vpm[10];\n    plane[3] = vpm[15] - vpm[14];\n    t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);\n    plane[0] /= t;\n    plane[1] /= t;\n    plane[2] /= t;\n    plane[3] /= t;\n    plane = planes[5];\n    plane[0] = vpm[3] + vpm[2];\n    plane[1] = vpm[7] + vpm[6];\n    plane[2] = vpm[11] + vpm[10];\n    plane[3] = vpm[15] + vpm[14];\n    t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);\n    plane[0] /= t;\n    plane[1] /= t;\n    plane[2] /= t;\n    plane[3] /= t;\n  }\n  containsPoint(point) {\n    let p, plane;\n    for (p = 0; p < 6; p++) {\n      plane = this.planes[p];\n      if (plane[0] * point.x + plane[1] * point.y + plane[2] * point.z + plane[3] <= 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n  containsSphere(sphere) {\n    let c = 0;\n    let d;\n    let p;\n    const sr = sphere.radius;\n    const sc = sphere.center;\n    const scx = sc.x;\n    const scy = sc.y;\n    const scz = sc.z;\n    const planes = this.planes;\n    let plane;\n    for (p = 0; p < 6; p++) {\n      plane = planes[p];\n      d = plane[0] * scx + plane[1] * scy + plane[2] * scz + plane[3];\n      if (d <= -sr) return 0;\n      if (d > sr) c++;\n    }\n    return c === 6 ? 2 : 1;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/shape/frustum.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/shape/plane.js":
/*!**************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/shape/plane.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Plane\": () => (/* binding */ Plane)\n/* harmony export */ });\n/* harmony import */ var _math_vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n\n\nconst tmpVecA = new _math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nclass Plane {\n  constructor(point = new _math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(), normal = new _math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(0, 0, 1)) {\n    this.point = point;\n    this.normal = normal;\n  }\n  intersectsLine(start, end, point) {\n    const d = -this.normal.dot(this.point);\n    const d0 = this.normal.dot(start) + d;\n    const d1 = this.normal.dot(end) + d;\n    const t = d0 / (d0 - d1);\n    const intersects = t >= 0 && t <= 1;\n    if (intersects && point) point.lerp(start, end, t);\n    return intersects;\n  }\n  intersectsRay(ray, point) {\n    const pointToOrigin = tmpVecA.sub2(this.point, ray.origin);\n    const t = this.normal.dot(pointToOrigin) / this.normal.dot(ray.direction);\n    const intersects = t >= 0;\n    if (intersects && point) point.copy(ray.direction).mulScalar(t).add(ray.origin);\n    return intersects;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/shape/plane.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/shape/ray.js":
/*!************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/shape/ray.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Ray\": () => (/* binding */ Ray)\n/* harmony export */ });\n/* harmony import */ var _math_vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n\n\n\nclass Ray {\n  constructor(origin = new _math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(), direction = new _math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(0, 0, -1)) {\n    this.origin = origin;\n    this.direction = direction;\n  }\n  set(origin, direction) {\n    this.origin.copy(origin);\n    this.direction.copy(direction);\n    return this;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/shape/ray.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/sort.js":
/*!*******************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/sort.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"sortPriority\": () => (/* binding */ sortPriority)\n/* harmony export */ });\nconst cmpPriority = (a, b) => a.priority - b.priority;\nconst sortPriority = arr => arr.sort(cmpPriority);\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/sort.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/sorted-loop-array.js":
/*!********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/sorted-loop-array.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SortedLoopArray\": () => (/* binding */ SortedLoopArray)\n/* harmony export */ });\nclass SortedLoopArray {\n  constructor(args) {\n    this.items = [];\n    this.length = 0;\n    this.loopIndex = -1;\n    this._sortBy = args.sortBy;\n    this._sortHandler = this._doSort.bind(this);\n  }\n  _binarySearch(item) {\n    let left = 0;\n    let right = this.items.length - 1;\n    const search = item[this._sortBy];\n    let middle;\n    let current;\n    while (left <= right) {\n      middle = Math.floor((left + right) / 2);\n      current = this.items[middle][this._sortBy];\n      if (current <= search) {\n        left = middle + 1;\n      } else if (current > search) {\n        right = middle - 1;\n      }\n    }\n    return left;\n  }\n  _doSort(a, b) {\n    const sortBy = this._sortBy;\n    return a[sortBy] - b[sortBy];\n  }\n  insert(item) {\n    const index = this._binarySearch(item);\n    this.items.splice(index, 0, item);\n    this.length++;\n    if (this.loopIndex >= index) {\n      this.loopIndex++;\n    }\n  }\n  append(item) {\n    this.items.push(item);\n    this.length++;\n  }\n  remove(item) {\n    const idx = this.items.indexOf(item);\n    if (idx < 0) return;\n    this.items.splice(idx, 1);\n    this.length--;\n    if (this.loopIndex >= idx) {\n      this.loopIndex--;\n    }\n  }\n  sort() {\n    const current = this.loopIndex >= 0 ? this.items[this.loopIndex] : null;\n    this.items.sort(this._sortHandler);\n    if (current !== null) {\n      this.loopIndex = this.items.indexOf(current);\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/sorted-loop-array.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/string.js":
/*!*********************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/string.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"string\": () => (/* binding */ string)\n/* harmony export */ });\nconst ASCII_LOWERCASE = 'abcdefghijklmnopqrstuvwxyz';\nconst ASCII_UPPERCASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\nconst ASCII_LETTERS = ASCII_LOWERCASE + ASCII_UPPERCASE;\nconst HIGH_SURROGATE_BEGIN = 0xD800;\nconst HIGH_SURROGATE_END = 0xDBFF;\nconst LOW_SURROGATE_BEGIN = 0xDC00;\nconst LOW_SURROGATE_END = 0xDFFF;\nconst ZERO_WIDTH_JOINER = 0x200D;\nconst REGIONAL_INDICATOR_BEGIN = 0x1F1E6;\nconst REGIONAL_INDICATOR_END = 0x1F1FF;\nconst FITZPATRICK_MODIFIER_BEGIN = 0x1F3FB;\nconst FITZPATRICK_MODIFIER_END = 0x1F3FF;\nconst DIACRITICAL_MARKS_BEGIN = 0x20D0;\nconst DIACRITICAL_MARKS_END = 0x20FF;\nconst VARIATION_MODIFIER_BEGIN = 0xFE00;\nconst VARIATION_MODIFIER_END = 0xFE0F;\nfunction getCodePointData(string, i = 0) {\n  const size = string.length;\n  if (i < 0 || i >= size) {\n    return null;\n  }\n  const first = string.charCodeAt(i);\n  if (size > 1 && first >= HIGH_SURROGATE_BEGIN && first <= HIGH_SURROGATE_END) {\n    const second = string.charCodeAt(i + 1);\n    if (second >= LOW_SURROGATE_BEGIN && second <= LOW_SURROGATE_END) {\n      return {\n        code: (first - HIGH_SURROGATE_BEGIN) * 0x400 + second - LOW_SURROGATE_BEGIN + 0x10000,\n        long: true\n      };\n    }\n  }\n  return {\n    code: first,\n    long: false\n  };\n}\nfunction isCodeBetween(string, begin, end) {\n  if (!string) return false;\n  const codeData = getCodePointData(string);\n  if (codeData) {\n    const code = codeData.code;\n    return code >= begin && code <= end;\n  }\n  return false;\n}\nfunction numCharsToTakeForNextSymbol(string, index) {\n  if (index === string.length - 1) {\n    return 1;\n  }\n  if (isCodeBetween(string[index], HIGH_SURROGATE_BEGIN, HIGH_SURROGATE_END)) {\n    const first = string.substring(index, index + 2);\n    const second = string.substring(index + 2, index + 4);\n    if (isCodeBetween(second, FITZPATRICK_MODIFIER_BEGIN, FITZPATRICK_MODIFIER_END) || isCodeBetween(first, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END) && isCodeBetween(second, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END)) {\n      return 4;\n    }\n    if (isCodeBetween(second, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {\n      return 3;\n    }\n    return 2;\n  }\n  if (isCodeBetween(string[index + 1], VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {\n    return 2;\n  }\n  return 1;\n}\nconst string = {\n  ASCII_LOWERCASE: ASCII_LOWERCASE,\n  ASCII_UPPERCASE: ASCII_UPPERCASE,\n  ASCII_LETTERS: ASCII_LETTERS,\n  format: function (s) {\n    for (let i = 1; i < arguments.length; i++) {\n      s = s.replace('{' + (i - 1) + '}', arguments[i]);\n    }\n    return s;\n  },\n  toBool: function (s, strict = false) {\n    if (s === 'true') {\n      return true;\n    }\n    if (strict) {\n      if (s === 'false') {\n        return false;\n      }\n      throw new TypeError('Not a boolean string');\n    }\n    return false;\n  },\n  getCodePoint: function (string, i) {\n    const codePointData = getCodePointData(string, i);\n    return codePointData && codePointData.code;\n  },\n  getCodePoints: function (string) {\n    if (typeof string !== 'string') {\n      throw new TypeError('Not a string');\n    }\n    let i = 0;\n    const arr = [];\n    let codePoint;\n    while (!!(codePoint = getCodePointData(string, i))) {\n      arr.push(codePoint.code);\n      i += codePoint.long ? 2 : 1;\n    }\n    return arr;\n  },\n  getSymbols: function (string) {\n    if (typeof string !== 'string') {\n      throw new TypeError('Not a string');\n    }\n    let index = 0;\n    const length = string.length;\n    const output = [];\n    let take = 0;\n    let ch;\n    while (index < length) {\n      take += numCharsToTakeForNextSymbol(string, index + take);\n      ch = string[index + take];\n      if (isCodeBetween(ch, DIACRITICAL_MARKS_BEGIN, DIACRITICAL_MARKS_END)) {\n        ch = string[index + take++];\n      }\n      if (isCodeBetween(ch, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {\n        ch = string[index + take++];\n      }\n      if (ch && ch.charCodeAt(0) === ZERO_WIDTH_JOINER) {\n        ch = string[index + take++];\n        continue;\n      }\n      const char = string.substring(index, index + take);\n      output.push(char);\n      index += take;\n      take = 0;\n    }\n    return output;\n  },\n  fromCodePoint: function () {\n    const chars = [];\n    let current;\n    let codePoint;\n    let units;\n    for (let i = 0; i < arguments.length; ++i) {\n      current = Number(arguments[i]);\n      codePoint = current - 0x10000;\n      units = current > 0xFFFF ? [(codePoint >> 10) + 0xD800, codePoint % 0x400 + 0xDC00] : [current];\n      chars.push(String.fromCharCode.apply(null, units));\n    }\n    return chars.join('');\n  }\n};\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/string.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/tags-cache.js":
/*!*************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/tags-cache.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TagsCache\": () => (/* binding */ TagsCache)\n/* harmony export */ });\nclass TagsCache {\n  constructor(key = null) {\n    this._index = {};\n    this._key = key;\n  }\n  addItem(item) {\n    const tags = item.tags._list;\n    for (const tag of tags) this.add(tag, item);\n  }\n  removeItem(item) {\n    const tags = item.tags._list;\n    for (const tag of tags) this.remove(tag, item);\n  }\n  add(tag, item) {\n    if (this._index[tag] && this._index[tag].list.indexOf(item) !== -1) return;\n    if (!this._index[tag]) {\n      this._index[tag] = {\n        list: []\n      };\n      if (this._key) this._index[tag].keys = {};\n    }\n    this._index[tag].list.push(item);\n    if (this._key) this._index[tag].keys[item[this._key]] = item;\n  }\n  remove(tag, item) {\n    if (!this._index[tag]) return;\n    if (this._key) {\n      if (!this._index[tag].keys[item[this._key]]) return;\n    }\n    const ind = this._index[tag].list.indexOf(item);\n    if (ind === -1) return;\n    this._index[tag].list.splice(ind, 1);\n    if (this._key) delete this._index[tag].keys[item[this._key]];\n    if (this._index[tag].list.length === 0) delete this._index[tag];\n  }\n  find(args) {\n    const index = {};\n    const items = [];\n    let item, tag, tags, tagsRest, missingIndex;\n    const sort = (a, b) => {\n      return this._index[a].list.length - this._index[b].list.length;\n    };\n    for (let i = 0; i < args.length; i++) {\n      tag = args[i];\n      if (tag instanceof Array) {\n        if (tag.length === 0) continue;\n        if (tag.length === 1) {\n          tag = tag[0];\n        } else {\n          missingIndex = false;\n          for (let t = 0; t < tag.length; t++) {\n            if (!this._index[tag[t]]) {\n              missingIndex = true;\n              break;\n            }\n          }\n          if (missingIndex) continue;\n          tags = tag.slice(0).sort(sort);\n          tagsRest = tags.slice(1);\n          if (tagsRest.length === 1) tagsRest = tagsRest[0];\n          for (let n = 0; n < this._index[tags[0]].list.length; n++) {\n            item = this._index[tags[0]].list[n];\n            if ((this._key ? !index[item[this._key]] : items.indexOf(item) === -1) && item.tags.has(tagsRest)) {\n              if (this._key) index[item[this._key]] = true;\n              items.push(item);\n            }\n          }\n          continue;\n        }\n      }\n      if (tag && typeof tag === 'string' && this._index[tag]) {\n        for (let n = 0; n < this._index[tag].list.length; n++) {\n          item = this._index[tag].list[n];\n          if (this._key) {\n            if (!index[item[this._key]]) {\n              index[item[this._key]] = true;\n              items.push(item);\n            }\n          } else if (items.indexOf(item) === -1) {\n            items.push(item);\n          }\n        }\n      }\n    }\n    return items;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/tags-cache.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/tags.js":
/*!*******************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/tags.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Tags\": () => (/* binding */ Tags)\n/* harmony export */ });\n/* harmony import */ var _event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n\n\nclass Tags extends _event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor(parent) {\n    super();\n    this._index = {};\n    this._list = [];\n    this._parent = parent;\n  }\n  add() {\n    let changed = false;\n    const tags = this._processArguments(arguments, true);\n    if (!tags.length) return changed;\n    for (let i = 0; i < tags.length; i++) {\n      if (this._index[tags[i]]) continue;\n      changed = true;\n      this._index[tags[i]] = true;\n      this._list.push(tags[i]);\n      this.fire('add', tags[i], this._parent);\n    }\n    if (changed) this.fire('change', this._parent);\n    return changed;\n  }\n  remove() {\n    let changed = false;\n    if (!this._list.length) return changed;\n    const tags = this._processArguments(arguments, true);\n    if (!tags.length) return changed;\n    for (let i = 0; i < tags.length; i++) {\n      if (!this._index[tags[i]]) continue;\n      changed = true;\n      delete this._index[tags[i]];\n      this._list.splice(this._list.indexOf(tags[i]), 1);\n      this.fire('remove', tags[i], this._parent);\n    }\n    if (changed) this.fire('change', this._parent);\n    return changed;\n  }\n  clear() {\n    if (!this._list.length) return;\n    const tags = this._list.slice(0);\n    this._list = [];\n    this._index = {};\n    for (let i = 0; i < tags.length; i++) this.fire('remove', tags[i], this._parent);\n    this.fire('change', this._parent);\n  }\n  has() {\n    if (!this._list.length) return false;\n    return this._has(this._processArguments(arguments));\n  }\n  _has(tags) {\n    if (!this._list.length || !tags.length) return false;\n    for (let i = 0; i < tags.length; i++) {\n      if (tags[i].length === 1) {\n        if (this._index[tags[i][0]]) return true;\n      } else {\n        let multiple = true;\n        for (let t = 0; t < tags[i].length; t++) {\n          if (this._index[tags[i][t]]) continue;\n          multiple = false;\n          break;\n        }\n        if (multiple) return true;\n      }\n    }\n    return false;\n  }\n  list() {\n    return this._list.slice(0);\n  }\n  _processArguments(args, flat) {\n    const tags = [];\n    let tmp = [];\n    if (!args || !args.length) return tags;\n    for (let i = 0; i < args.length; i++) {\n      if (args[i] instanceof Array) {\n        if (!flat) tmp = [];\n        for (let t = 0; t < args[i].length; t++) {\n          if (typeof args[i][t] !== 'string') continue;\n          if (flat) {\n            tags.push(args[i][t]);\n          } else {\n            tmp.push(args[i][t]);\n          }\n        }\n        if (!flat && tmp.length) tags.push(tmp);\n      } else if (typeof args[i] === 'string') {\n        if (flat) {\n          tags.push(args[i]);\n        } else {\n          tags.push([args[i]]);\n        }\n      }\n    }\n    return tags;\n  }\n  get size() {\n    return this._list.length;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/tags.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/time.js":
/*!*******************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/time.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Timer\": () => (/* binding */ Timer),\n/* harmony export */   \"now\": () => (/* binding */ now)\n/* harmony export */ });\nconst now = typeof window !== 'undefined' && window.performance && window.performance.now && window.performance.timing ? performance.now.bind(performance) : Date.now;\nclass Timer {\n  constructor() {\n    this._isRunning = false;\n    this._a = 0;\n    this._b = 0;\n  }\n  start() {\n    this._isRunning = true;\n    this._a = now();\n  }\n  stop() {\n    this._isRunning = false;\n    this._b = now();\n  }\n  getMilliseconds() {\n    return this._b - this._a;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/time.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/uri.js":
/*!******************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/uri.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"URI\": () => (/* binding */ URI),\n/* harmony export */   \"createURI\": () => (/* binding */ createURI)\n/* harmony export */ });\nfunction createURI(options) {\n  let s = '';\n  if ((options.authority || options.scheme) && (options.host || options.hostpath)) {\n    throw new Error('Can\\'t have \\'scheme\\' or \\'authority\\' and \\'host\\' or \\'hostpath\\' option');\n  }\n  if (options.host && options.hostpath) {\n    throw new Error('Can\\'t have \\'host\\' and \\'hostpath\\' option');\n  }\n  if (options.path && options.hostpath) {\n    throw new Error('Can\\'t have \\'path\\' and \\'hostpath\\' option');\n  }\n  if (options.scheme) {\n    s += options.scheme + ':';\n  }\n  if (options.authority) {\n    s += '//' + options.authority;\n  }\n  if (options.host) {\n    s += options.host;\n  }\n  if (options.path) {\n    s += options.path;\n  }\n  if (options.hostpath) {\n    s += options.hostpath;\n  }\n  if (options.query) {\n    s += '?' + options.query;\n  }\n  if (options.fragment) {\n    s += '#' + options.fragment;\n  }\n  return s;\n}\nconst re = /^(([^:\\/?#]+):)?(\\/\\/([^\\/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\nclass URI {\n  constructor(uri) {\n    const result = uri.match(re);\n    this.scheme = result[2];\n    this.authority = result[4];\n    this.path = result[5];\n    this.query = result[7];\n    this.fragment = result[9];\n  }\n  toString() {\n    let s = '';\n    if (this.scheme) {\n      s += this.scheme + ':';\n    }\n    if (this.authority) {\n      s += '//' + this.authority;\n    }\n    s += this.path;\n    if (this.query) {\n      s += '?' + this.query;\n    }\n    if (this.fragment) {\n      s += '#' + this.fragment;\n    }\n    return s;\n  }\n  getQuery() {\n    const result = {};\n    if (this.query) {\n      const queryParams = decodeURIComponent(this.query).split('&');\n      for (const queryParam of queryParams) {\n        const pair = queryParam.split('=');\n        result[pair[0]] = pair[1];\n      }\n    }\n    return result;\n  }\n  setQuery(params) {\n    let q = '';\n    for (const key in params) {\n      if (params.hasOwnProperty(key)) {\n        if (q !== '') {\n          q += '&';\n        }\n        q += encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);\n      }\n    }\n    this.query = q;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/uri.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/core/wasm-module.js":
/*!**************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/core/wasm-module.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WasmModule\": () => (/* binding */ WasmModule)\n/* harmony export */ });\nconst cachedResult = func => {\n  const uninitToken = {};\n  let result = uninitToken;\n  return () => {\n    if (result === uninitToken) {\n      result = func();\n    }\n    return result;\n  };\n};\nclass Impl {\n  static loadScript(url, callback) {\n    const s = document.createElement('script');\n    s.setAttribute('src', url);\n    s.onload = () => {\n      callback(null);\n    };\n    s.onerror = () => {\n      callback(`Failed to load script='${url}'`);\n    };\n    document.body.appendChild(s);\n  }\n  static loadWasm(moduleName, config, callback) {\n    const loadUrl = Impl.wasmSupported() && config.glueUrl && config.wasmUrl ? config.glueUrl : config.fallbackUrl;\n    if (loadUrl) {\n      Impl.loadScript(loadUrl, err => {\n        if (err) {\n          callback(err, null);\n        } else {\n          const module = window[moduleName];\n          window[moduleName] = undefined;\n          module({\n            locateFile: () => config.wasmUrl,\n            onAbort: () => {\n              callback('wasm module aborted.');\n            }\n          }).then(instance => {\n            callback(null, instance);\n          });\n        }\n      });\n    } else {\n      callback('No supported wasm modules found.', null);\n    }\n  }\n  static getModule(name) {\n    if (!Impl.modules.hasOwnProperty(name)) {\n      Impl.modules[name] = {\n        config: null,\n        initializing: false,\n        instance: null,\n        callbacks: []\n      };\n    }\n    return Impl.modules[name];\n  }\n  static initialize(moduleName, module) {\n    if (module.initializing) {\n      return;\n    }\n    const config = module.config;\n    if (config.glueUrl || config.wasmUrl || config.fallbackUrl) {\n      module.initializing = true;\n      Impl.loadWasm(moduleName, config, (err, instance) => {\n        if (err) {\n          if (config.errorHandler) {\n            config.errorHandler(err);\n          } else {\n            console.error(`failed to initialize module=${moduleName} error=${err}`);\n          }\n        } else {\n          module.instance = instance;\n          module.callbacks.forEach(callback => {\n            callback(instance);\n          });\n        }\n      });\n    }\n  }\n}\nImpl.modules = {};\nImpl.wasmSupported = cachedResult(() => {\n  try {\n    if (typeof WebAssembly === \"object\" && typeof WebAssembly.instantiate === \"function\") {\n      const module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));\n      if (module instanceof WebAssembly.Module) return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;\n    }\n  } catch (e) {}\n  return false;\n});\nclass WasmModule {\n  static setConfig(moduleName, config) {\n    const module = Impl.getModule(moduleName);\n    module.config = config;\n    if (module.callbacks.length > 0) {\n      Impl.initialize(moduleName, module);\n    }\n  }\n  static getInstance(moduleName, callback) {\n    const module = Impl.getModule(moduleName);\n    if (module.instance) {\n      callback(module.instance);\n    } else {\n      module.callbacks.push(callback);\n      if (module.config) {\n        Impl.initialize(moduleName, module);\n      }\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/core/wasm-module.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/binder/anim-binder.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/binder/anim-binder.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimBinder\": () => (/* binding */ AnimBinder)\n/* harmony export */ });\nclass AnimBinder {\n  static joinPath(pathSegments, character) {\n    character = character || '.';\n    const escape = function escape(string) {\n      return string.replace(/\\\\/g, '\\\\\\\\').replace(new RegExp('\\\\' + character, 'g'), '\\\\' + character);\n    };\n    return pathSegments.map(escape).join(character);\n  }\n  static splitPath(path, character) {\n    character = character || '.';\n    const result = [];\n    let curr = \"\";\n    let i = 0;\n    while (i < path.length) {\n      let c = path[i++];\n      if (c === '\\\\' && i < path.length) {\n        c = path[i++];\n        if (c === '\\\\' || c === character) {\n          curr += c;\n        } else {\n          curr += '\\\\' + c;\n        }\n      } else if (c === character) {\n        result.push(curr);\n        curr = '';\n      } else {\n        curr += c;\n      }\n    }\n    if (curr.length > 0) {\n      result.push(curr);\n    }\n    return result;\n  }\n  static encode(entityPath, component, propertyPath) {\n    return `${Array.isArray(entityPath) ? entityPath.join('/') : entityPath}/${component}/${Array.isArray(propertyPath) ? propertyPath.join('/') : propertyPath}`;\n  }\n  resolve(path) {\n    return null;\n  }\n  unresolve(path) {}\n  update(deltaTime) {}\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/binder/anim-binder.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/binder/default-anim-binder.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/binder/default-anim-binder.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DefaultAnimBinder\": () => (/* binding */ DefaultAnimBinder)\n/* harmony export */ });\n/* harmony import */ var _anim_binder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./anim-binder.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/binder/anim-binder.js\");\n/* harmony import */ var _evaluator_anim_target_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../evaluator/anim-target.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-target.js\");\n/* harmony import */ var _entity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../entity.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/entity.js\");\n\n\n\n\n\nclass DefaultAnimBinder {\n  constructor(graph) {\n    this._isPathInMask = (path, checkMaskValue) => {\n      const maskItem = this._mask[path];\n      if (!maskItem) return false;else if (maskItem.children || checkMaskValue && maskItem.value !== false) return true;\n      return false;\n    };\n    this.graph = graph;\n    if (!graph) return;\n    this._mask = null;\n    const nodes = {};\n    const flatten = function flatten(node) {\n      nodes[node.name] = node;\n      for (let i = 0; i < node.children.length; ++i) {\n        flatten(node.children[i]);\n      }\n    };\n    flatten(graph);\n    this.nodes = nodes;\n    this.targetCache = {};\n    const findMeshInstances = function findMeshInstances(node) {\n      let object = node;\n      while (object && !(object instanceof _entity_js__WEBPACK_IMPORTED_MODULE_0__.Entity)) {\n        object = object.parent;\n      }\n      let meshInstances;\n      if (object) {\n        if (object.render) {\n          meshInstances = object.render.meshInstances;\n        } else if (object.model) {\n          meshInstances = object.model.meshInstances;\n        }\n      }\n      return meshInstances;\n    };\n    this.nodeCounts = {};\n    this.activeNodes = [];\n    this.handlers = {\n      'localPosition': function (node) {\n        const object = node.localPosition;\n        const func = function func(value) {\n          object.set(...value);\n        };\n        return DefaultAnimBinder.createAnimTarget(func, 'vector', 3, node, 'localPosition');\n      },\n      'localRotation': function (node) {\n        const object = node.localRotation;\n        const func = function func(value) {\n          object.set(...value);\n        };\n        return DefaultAnimBinder.createAnimTarget(func, 'quaternion', 4, node, 'localRotation');\n      },\n      'localScale': function (node) {\n        const object = node.localScale;\n        const func = function func(value) {\n          object.set(...value);\n        };\n        return DefaultAnimBinder.createAnimTarget(func, 'vector', 3, node, 'localScale');\n      },\n      'weight': function (node, weightName) {\n        if (weightName.indexOf('name.') === 0) {\n          weightName = weightName.replace('name.', '');\n        } else {\n          weightName = Number(weightName);\n        }\n        const meshInstances = findMeshInstances(node);\n        let setters;\n        if (meshInstances) {\n          for (let i = 0; i < meshInstances.length; ++i) {\n            if (meshInstances[i].node.name === node.name && meshInstances[i].morphInstance) {\n              const morphInstance = meshInstances[i].morphInstance;\n              const func = value => {\n                morphInstance.setWeight(weightName, value[0]);\n              };\n              if (!setters) setters = [];\n              setters.push(func);\n            }\n          }\n        }\n        if (setters) {\n          const callSetters = value => {\n            for (let i = 0; i < setters.length; ++i) {\n              setters[i](value);\n            }\n          };\n          return DefaultAnimBinder.createAnimTarget(callSetters, 'number', 1, node, `weight.${weightName}`);\n        }\n        return null;\n      },\n      'materialTexture': (node, textureName) => {\n        const meshInstances = findMeshInstances(node);\n        if (meshInstances) {\n          let meshInstance;\n          for (let i = 0; i < meshInstances.length; ++i) {\n            if (meshInstances[i].node.name === node.name) {\n              meshInstance = meshInstances[i];\n              break;\n            }\n          }\n          if (meshInstance) {\n            const func = value => {\n              const textureAsset = this.animComponent.system.app.assets.get(value[0]);\n              if (textureAsset && textureAsset.resource && textureAsset.type === 'texture') {\n                meshInstance.material[textureName] = textureAsset.resource;\n                meshInstance.material.update();\n              }\n            };\n            return DefaultAnimBinder.createAnimTarget(func, 'vector', 1, node, 'materialTexture', 'material');\n          }\n        }\n        return null;\n      }\n    };\n  }\n  _isPathActive(path) {\n    if (!this._mask) return true;\n    const rootNodeNames = [path.entityPath[0], this.graph.name];\n    for (let j = 0; j < rootNodeNames.length; ++j) {\n      let currEntityPath = rootNodeNames[j];\n      if (this._isPathInMask(currEntityPath, path.entityPath.length === 1)) return true;\n      for (let i = 1; i < path.entityPath.length; i++) {\n        currEntityPath += '/' + path.entityPath[i];\n        if (this._isPathInMask(currEntityPath, i === path.entityPath.length - 1)) return true;\n      }\n    }\n    return false;\n  }\n  findNode(path) {\n    if (!this._isPathActive(path)) {\n      return null;\n    }\n    let node;\n    if (this.graph) {\n      node = this.graph.findByPath(path.entityPath);\n      if (!node) {\n        node = this.graph.findByPath(path.entityPath.slice(1));\n      }\n    }\n    if (!node) {\n      node = this.nodes[path.entityPath[path.entityPath.length - 1] || \"\"];\n    }\n    return node;\n  }\n  static createAnimTarget(func, type, valueCount, node, propertyPath, componentType) {\n    const targetPath = _anim_binder_js__WEBPACK_IMPORTED_MODULE_1__.AnimBinder.encode(node.path, componentType ? componentType : 'entity', propertyPath);\n    return new _evaluator_anim_target_js__WEBPACK_IMPORTED_MODULE_2__.AnimTarget(func, type, valueCount, targetPath);\n  }\n  resolve(path) {\n    const encodedPath = _anim_binder_js__WEBPACK_IMPORTED_MODULE_1__.AnimBinder.encode(path.entityPath, path.component, path.propertyPath);\n    let target = this.targetCache[encodedPath];\n    if (target) return target;\n    const node = this.findNode(path);\n    if (!node) {\n      return null;\n    }\n    const handler = this.handlers[path.propertyPath];\n    if (!handler) {\n      return null;\n    }\n    target = handler(node);\n    if (!target) {\n      return null;\n    }\n    this.targetCache[encodedPath] = target;\n    if (!this.nodeCounts[node.path]) {\n      this.activeNodes.push(node);\n      this.nodeCounts[node.path] = 1;\n    } else {\n      this.nodeCounts[node.path]++;\n    }\n    return target;\n  }\n  unresolve(path) {\n    if (path.component !== 'graph') return;\n    const node = this.nodes[path.entityPath[path.entityPath.length - 1] || \"\"];\n    this.nodeCounts[node.path]--;\n    if (this.nodeCounts[node.path] === 0) {\n      const activeNodes = this.activeNodes;\n      const i = activeNodes.indexOf(node.node);\n      const len = activeNodes.length;\n      if (i < len - 1) {\n        activeNodes[i] = activeNodes[len - 1];\n      }\n      activeNodes.pop();\n    }\n  }\n  update(deltaTime) {\n    const activeNodes = this.activeNodes;\n    for (let i = 0; i < activeNodes.length; ++i) {\n      activeNodes[i]._dirtifyLocal();\n    }\n  }\n  assignMask(mask) {\n    if (mask !== this._mask) {\n      this._mask = mask;\n      return true;\n    }\n    return false;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/binder/default-anim-binder.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/constants.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/constants.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"INTERPOLATION_CUBIC\": () => (/* binding */ INTERPOLATION_CUBIC),\n/* harmony export */   \"INTERPOLATION_LINEAR\": () => (/* binding */ INTERPOLATION_LINEAR),\n/* harmony export */   \"INTERPOLATION_STEP\": () => (/* binding */ INTERPOLATION_STEP)\n/* harmony export */ });\nconst INTERPOLATION_STEP = 0;\nconst INTERPOLATION_LINEAR = 1;\nconst INTERPOLATION_CUBIC = 2;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/constants.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-blend-tree-1d.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-blend-tree-1d.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimBlendTree1D\": () => (/* binding */ AnimBlendTree1D)\n/* harmony export */ });\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _anim_blend_tree_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./anim-blend-tree.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-blend-tree.js\");\n\n\n\nclass AnimBlendTree1D extends _anim_blend_tree_js__WEBPACK_IMPORTED_MODULE_0__.AnimBlendTree {\n  constructor(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {\n    children.sort((a, b) => a.point - b.point);\n    super(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);\n  }\n  calculateWeights() {\n    if (this.updateParameterValues()) return;\n    let weightedDurationSum = 0.0;\n    this._children[0].weight = 0.0;\n    for (let i = 0; i < this._children.length; i++) {\n      const c1 = this._children[i];\n      if (i !== this._children.length - 1) {\n        const c2 = this._children[i + 1];\n        if (c1.point === c2.point) {\n          c1.weight = 0.5;\n          c2.weight = 0.5;\n        } else if (_core_math_math_js__WEBPACK_IMPORTED_MODULE_1__.math.between(this._parameterValues[0], c1.point, c2.point, true)) {\n          const child2Distance = Math.abs(c1.point - c2.point);\n          const parameterDistance = Math.abs(c1.point - this._parameterValues[0]);\n          const weight = (child2Distance - parameterDistance) / child2Distance;\n          c1.weight = weight;\n          c2.weight = 1.0 - weight;\n        } else {\n          c2.weight = 0.0;\n        }\n      }\n      if (this._syncAnimations) {\n        weightedDurationSum += c1.animTrack.duration / c1.absoluteSpeed * c1.weight;\n      }\n    }\n    if (this._syncAnimations) {\n      for (let i = 0; i < this._children.length; i++) {\n        const child = this._children[i];\n        child.weightedSpeed = child.animTrack.duration / child.absoluteSpeed / weightedDurationSum;\n      }\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-blend-tree-1d.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-blend-tree-2d-cartesian.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-blend-tree-2d-cartesian.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimBlendTreeCartesian2D\": () => (/* binding */ AnimBlendTreeCartesian2D)\n/* harmony export */ });\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _anim_blend_tree_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./anim-blend-tree.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-blend-tree.js\");\n\n\n\n\nclass AnimBlendTreeCartesian2D extends _anim_blend_tree_js__WEBPACK_IMPORTED_MODULE_0__.AnimBlendTree {\n  pointDistanceCache(i, j) {\n    const pointKey = `${i}${j}`;\n    if (!this._pointCache[pointKey]) {\n      this._pointCache[pointKey] = this._children[j].point.clone().sub(this._children[i].point);\n    }\n    return this._pointCache[pointKey];\n  }\n  calculateWeights() {\n    if (this.updateParameterValues()) return;\n    let weightSum, weightedDurationSum;\n    AnimBlendTreeCartesian2D._p.set(...this._parameterValues);\n    weightSum = 0.0;\n    weightedDurationSum = 0.0;\n    for (let i = 0; i < this._children.length; i++) {\n      const child = this._children[i];\n      const pi = child.point;\n      AnimBlendTreeCartesian2D._pip.set(AnimBlendTreeCartesian2D._p.x, AnimBlendTreeCartesian2D._p.y).sub(pi);\n      let minj = Number.MAX_VALUE;\n      for (let j = 0; j < this._children.length; j++) {\n        if (i === j) continue;\n        const pipj = this.pointDistanceCache(i, j);\n        const result = _core_math_math_js__WEBPACK_IMPORTED_MODULE_1__.math.clamp(1.0 - AnimBlendTreeCartesian2D._pip.dot(pipj) / pipj.lengthSq(), 0.0, 1.0);\n        if (result < minj) minj = result;\n      }\n      child.weight = minj;\n      weightSum += minj;\n      if (this._syncAnimations) {\n        weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;\n      }\n    }\n    for (let i = 0; i < this._children.length; i++) {\n      const child = this._children[i];\n      child.weight = child._weight / weightSum;\n      if (this._syncAnimations) {\n        child.weightedSpeed = child.animTrack.duration / child.absoluteSpeed / weightedDurationSum;\n      }\n    }\n  }\n}\nAnimBlendTreeCartesian2D._p = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_2__.Vec2();\nAnimBlendTreeCartesian2D._pip = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_2__.Vec2();\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-blend-tree-2d-cartesian.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-blend-tree-2d-directional.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-blend-tree-2d-directional.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimBlendTreeDirectional2D\": () => (/* binding */ AnimBlendTreeDirectional2D)\n/* harmony export */ });\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _anim_blend_tree_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./anim-blend-tree.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-blend-tree.js\");\n\n\n\n\nclass AnimBlendTreeDirectional2D extends _anim_blend_tree_js__WEBPACK_IMPORTED_MODULE_0__.AnimBlendTree {\n  pointCache(i, j) {\n    const pointKey = `${i}${j}`;\n    if (!this._pointCache[pointKey]) {\n      this._pointCache[pointKey] = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_1__.Vec2((this._children[j].pointLength - this._children[i].pointLength) / ((this._children[j].pointLength + this._children[i].pointLength) / 2), _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_1__.Vec2.angleRad(this._children[i].point, this._children[j].point) * 2.0);\n    }\n    return this._pointCache[pointKey];\n  }\n  calculateWeights() {\n    if (this.updateParameterValues()) return;\n    let weightSum, weightedDurationSum;\n    AnimBlendTreeDirectional2D._p.set(...this._parameterValues);\n    const pLength = AnimBlendTreeDirectional2D._p.length();\n    weightSum = 0.0;\n    weightedDurationSum = 0.0;\n    for (let i = 0; i < this._children.length; i++) {\n      const child = this._children[i];\n      const pi = child.point;\n      const piLength = child.pointLength;\n      let minj = Number.MAX_VALUE;\n      for (let j = 0; j < this._children.length; j++) {\n        if (i === j) continue;\n        const pipj = this.pointCache(i, j);\n        const pjLength = this._children[j].pointLength;\n        AnimBlendTreeDirectional2D._pip.set((pLength - piLength) / ((pjLength + piLength) / 2), _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_1__.Vec2.angleRad(pi, AnimBlendTreeDirectional2D._p) * 2.0);\n        const result = _core_math_math_js__WEBPACK_IMPORTED_MODULE_2__.math.clamp(1.0 - Math.abs(AnimBlendTreeDirectional2D._pip.dot(pipj) / pipj.lengthSq()), 0.0, 1.0);\n        if (result < minj) minj = result;\n      }\n      child.weight = minj;\n      weightSum += minj;\n      if (this._syncAnimations) {\n        weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;\n      }\n    }\n    for (let i = 0; i < this._children.length; i++) {\n      const child = this._children[i];\n      child.weight = child._weight / weightSum;\n      if (this._syncAnimations) {\n        const weightedChildDuration = child.animTrack.duration / weightedDurationSum * weightSum;\n        child.weightedSpeed = child.absoluteSpeed * weightedChildDuration;\n      }\n    }\n  }\n}\nAnimBlendTreeDirectional2D._p = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_1__.Vec2();\nAnimBlendTreeDirectional2D._pip = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_1__.Vec2();\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-blend-tree-2d-directional.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-blend-tree-direct.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-blend-tree-direct.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimBlendTreeDirect\": () => (/* binding */ AnimBlendTreeDirect)\n/* harmony export */ });\n/* harmony import */ var _anim_blend_tree_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./anim-blend-tree.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-blend-tree.js\");\n\n\nclass AnimBlendTreeDirect extends _anim_blend_tree_js__WEBPACK_IMPORTED_MODULE_0__.AnimBlendTree {\n  calculateWeights() {\n    if (this.updateParameterValues()) return;\n    let weightSum = 0.0;\n    let weightedDurationSum = 0.0;\n    for (let i = 0; i < this._children.length; i++) {\n      weightSum += Math.max(this._parameterValues[i], 0.0);\n      if (this._syncAnimations) {\n        const child = this._children[i];\n        weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;\n      }\n    }\n    for (let i = 0; i < this._children.length; i++) {\n      const child = this._children[i];\n      const weight = Math.max(this._parameterValues[i], 0.0);\n      if (weightSum) {\n        child.weight = weight / weightSum;\n        if (this._syncAnimations) {\n          child.weightedSpeed = child.animTrack.duration / child.absoluteSpeed / weightedDurationSum;\n        }\n      } else {\n        child.weight = 0.0;\n        if (this._syncAnimations) {\n          child.weightedSpeed = 0;\n        }\n      }\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-blend-tree-direct.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-blend-tree.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-blend-tree.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimBlendTree\": () => (/* binding */ AnimBlendTree)\n/* harmony export */ });\n/* harmony import */ var _anim_node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./anim-node.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-node.js\");\n\n\nclass AnimBlendTree extends _anim_node_js__WEBPACK_IMPORTED_MODULE_0__.AnimNode {\n  constructor(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {\n    super(state, parent, name, point);\n    this._parameters = parameters;\n    this._parameterValues = new Array(parameters.length);\n    this._children = [];\n    this._findParameter = findParameter;\n    this._syncAnimations = syncAnimations !== false;\n    this._pointCache = {};\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.children) {\n        this._children.push(createTree(child.type, this, null, name, 1.0, child.parameter ? [child.parameter] : child.parameters, child.children, createTree, findParameter));\n      } else {\n        this._children.push(new _anim_node_js__WEBPACK_IMPORTED_MODULE_0__.AnimNode(state, this, child.name, child.point, child.speed));\n      }\n    }\n  }\n  get weight() {\n    this.calculateWeights();\n    return this._parent ? this._parent.weight * this._weight : this._weight;\n  }\n  get syncAnimations() {\n    return this._syncAnimations;\n  }\n  getChild(name) {\n    for (let i = 0; i < this._children.length; i++) {\n      if (this._children[i].name === name) return this._children[i];\n    }\n    return null;\n  }\n  updateParameterValues() {\n    let paramsEqual = true;\n    for (let i = 0; i < this._parameterValues.length; i++) {\n      const updatedParameter = this._findParameter(this._parameters[i]).value;\n      if (this._parameterValues[i] !== updatedParameter) {\n        this._parameterValues[i] = updatedParameter;\n        paramsEqual = false;\n      }\n    }\n    return paramsEqual;\n  }\n  getNodeWeightedDuration(i) {\n    return this._children[i].animTrack.duration / this._children[i].speedMultiplier * this._children[i].weight;\n  }\n  getNodeCount() {\n    let count = 0;\n    for (let i = 0; i < this._children.length; i++) {\n      const child = this._children[i];\n      if (child.constructor === AnimBlendTree) {\n        count += this._children[i].getNodeCount();\n      } else {\n        count++;\n      }\n    }\n    return count;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-blend-tree.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-controller.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-controller.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimController\": () => (/* binding */ AnimController)\n/* harmony export */ });\n/* harmony import */ var _virtual_rollupPluginBabelHelpers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../_virtual/_rollupPluginBabelHelpers.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/_virtual/_rollupPluginBabelHelpers.js\");\n/* harmony import */ var _core_sort_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/sort.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/sort.js\");\n/* harmony import */ var _evaluator_anim_clip_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../evaluator/anim-clip.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-clip.js\");\n/* harmony import */ var _anim_state_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./anim-state.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-state.js\");\n/* harmony import */ var _anim_node_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./anim-node.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-node.js\");\n/* harmony import */ var _anim_transition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./anim-transition.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-transition.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/constants.js\");\n\n\n\n\n\n\n\n\n\nclass AnimController {\n  constructor(animEvaluator, states, transitions, parameters, activate, eventHandler, consumedTriggers) {\n    this._animEvaluator = animEvaluator;\n    this._states = {};\n    this._stateNames = [];\n    this._eventHandler = eventHandler;\n    this._consumedTriggers = consumedTriggers;\n    for (let i = 0; i < states.length; i++) {\n      this._states[states[i].name] = new _anim_state_js__WEBPACK_IMPORTED_MODULE_0__.AnimState(this, states[i].name, states[i].speed, states[i].loop, states[i].blendTree);\n      this._stateNames.push(states[i].name);\n    }\n    this._transitions = transitions.map(transition => {\n      return new _anim_transition_js__WEBPACK_IMPORTED_MODULE_1__.AnimTransition((0,_virtual_rollupPluginBabelHelpers_js__WEBPACK_IMPORTED_MODULE_2__[\"extends\"])({}, transition));\n    });\n    this._findTransitionsFromStateCache = {};\n    this._findTransitionsBetweenStatesCache = {};\n    this._parameters = parameters;\n    this._previousStateName = null;\n    this._activeStateName = _constants_js__WEBPACK_IMPORTED_MODULE_3__.ANIM_STATE_START;\n    this._playing = false;\n    this._activate = activate;\n    this._currTransitionTime = 1.0;\n    this._totalTransitionTime = 1.0;\n    this._isTransitioning = false;\n    this._transitionInterruptionSource = _constants_js__WEBPACK_IMPORTED_MODULE_3__.ANIM_INTERRUPTION_NONE;\n    this._transitionPreviousStates = [];\n    this._timeInState = 0;\n    this._timeInStateBefore = 0;\n  }\n  get animEvaluator() {\n    return this._animEvaluator;\n  }\n  set activeState(stateName) {\n    this._activeStateName = stateName;\n  }\n  get activeState() {\n    return this._findState(this._activeStateName);\n  }\n  get activeStateName() {\n    return this._activeStateName;\n  }\n  get activeStateAnimations() {\n    return this.activeState.animations;\n  }\n  set previousState(stateName) {\n    this._previousStateName = stateName;\n  }\n  get previousState() {\n    return this._findState(this._previousStateName);\n  }\n  get previousStateName() {\n    return this._previousStateName;\n  }\n  get playable() {\n    let playable = true;\n    for (let i = 0; i < this._stateNames.length; i++) {\n      if (!this._states[this._stateNames[i]].playable) {\n        playable = false;\n      }\n    }\n    return playable;\n  }\n  set playing(value) {\n    this._playing = value;\n  }\n  get playing() {\n    return this._playing;\n  }\n  get activeStateProgress() {\n    return this._getActiveStateProgressForTime(this._timeInState);\n  }\n  get activeStateDuration() {\n    if (this.activeStateName === _constants_js__WEBPACK_IMPORTED_MODULE_3__.ANIM_STATE_START || this.activeStateName === _constants_js__WEBPACK_IMPORTED_MODULE_3__.ANIM_STATE_END) return 0.0;\n    let maxDuration = 0.0;\n    for (let i = 0; i < this.activeStateAnimations.length; i++) {\n      const activeClip = this._animEvaluator.findClip(this.activeStateAnimations[i].name);\n      if (activeClip) {\n        maxDuration = Math.max(maxDuration, activeClip.track.duration);\n      }\n    }\n    return maxDuration;\n  }\n  set activeStateCurrentTime(time) {\n    this._timeInStateBefore = time;\n    this._timeInState = time;\n    for (let i = 0; i < this.activeStateAnimations.length; i++) {\n      const clip = this.animEvaluator.findClip(this.activeStateAnimations[i].name);\n      if (clip) {\n        clip.time = time;\n      }\n    }\n  }\n  get activeStateCurrentTime() {\n    return this._timeInState;\n  }\n  get transitioning() {\n    return this._isTransitioning;\n  }\n  get transitionProgress() {\n    return this._currTransitionTime / this._totalTransitionTime;\n  }\n  get states() {\n    return this._stateNames;\n  }\n  assignMask(mask) {\n    return this._animEvaluator.assignMask(mask);\n  }\n  _findState(stateName) {\n    return this._states[stateName];\n  }\n  _getActiveStateProgressForTime(time) {\n    if (this.activeStateName === _constants_js__WEBPACK_IMPORTED_MODULE_3__.ANIM_STATE_START || this.activeStateName === _constants_js__WEBPACK_IMPORTED_MODULE_3__.ANIM_STATE_END || this.activeStateName === _constants_js__WEBPACK_IMPORTED_MODULE_3__.ANIM_STATE_ANY) return 1.0;\n    const activeClip = this._animEvaluator.findClip(this.activeStateAnimations[0].name);\n    if (activeClip) {\n      return activeClip.progressForTime(time);\n    }\n    return null;\n  }\n  _findTransitionsFromState(stateName) {\n    let transitions = this._findTransitionsFromStateCache[stateName];\n    if (!transitions) {\n      transitions = this._transitions.filter(function (transition) {\n        return transition.from === stateName;\n      });\n      (0,_core_sort_js__WEBPACK_IMPORTED_MODULE_4__.sortPriority)(transitions);\n      this._findTransitionsFromStateCache[stateName] = transitions;\n    }\n    return transitions;\n  }\n  _findTransitionsBetweenStates(sourceStateName, destinationStateName) {\n    let transitions = this._findTransitionsBetweenStatesCache[sourceStateName + '->' + destinationStateName];\n    if (!transitions) {\n      transitions = this._transitions.filter(function (transition) {\n        return transition.from === sourceStateName && transition.to === destinationStateName;\n      });\n      (0,_core_sort_js__WEBPACK_IMPORTED_MODULE_4__.sortPriority)(transitions);\n      this._findTransitionsBetweenStatesCache[sourceStateName + '->' + destinationStateName] = transitions;\n    }\n    return transitions;\n  }\n  _transitionHasConditionsMet(transition) {\n    const conditions = transition.conditions;\n    for (let i = 0; i < conditions.length; i++) {\n      const condition = conditions[i];\n      const parameter = this.findParameter(condition.parameterName);\n      switch (condition.predicate) {\n        case _constants_js__WEBPACK_IMPORTED_MODULE_3__.ANIM_GREATER_THAN:\n          if (!(parameter.value > condition.value)) return false;\n          break;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_3__.ANIM_LESS_THAN:\n          if (!(parameter.value < condition.value)) return false;\n          break;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_3__.ANIM_GREATER_THAN_EQUAL_TO:\n          if (!(parameter.value >= condition.value)) return false;\n          break;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_3__.ANIM_LESS_THAN_EQUAL_TO:\n          if (!(parameter.value <= condition.value)) return false;\n          break;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_3__.ANIM_EQUAL_TO:\n          if (!(parameter.value === condition.value)) return false;\n          break;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_3__.ANIM_NOT_EQUAL_TO:\n          if (!(parameter.value !== condition.value)) return false;\n          break;\n      }\n    }\n    return true;\n  }\n  _findTransition(from, to) {\n    let transitions = [];\n    if (from && to) {\n      transitions = transitions.concat(this._findTransitionsBetweenStates(from, to));\n    } else {\n      if (!this._isTransitioning) {\n        transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));\n        transitions = transitions.concat(this._findTransitionsFromState(_constants_js__WEBPACK_IMPORTED_MODULE_3__.ANIM_STATE_ANY));\n      } else {\n        switch (this._transitionInterruptionSource) {\n          case _constants_js__WEBPACK_IMPORTED_MODULE_3__.ANIM_INTERRUPTION_PREV:\n            transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));\n            transitions = transitions.concat(this._findTransitionsFromState(_constants_js__WEBPACK_IMPORTED_MODULE_3__.ANIM_STATE_ANY));\n            break;\n          case _constants_js__WEBPACK_IMPORTED_MODULE_3__.ANIM_INTERRUPTION_NEXT:\n            transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));\n            transitions = transitions.concat(this._findTransitionsFromState(_constants_js__WEBPACK_IMPORTED_MODULE_3__.ANIM_STATE_ANY));\n            break;\n          case _constants_js__WEBPACK_IMPORTED_MODULE_3__.ANIM_INTERRUPTION_PREV_NEXT:\n            transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));\n            transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));\n            transitions = transitions.concat(this._findTransitionsFromState(_constants_js__WEBPACK_IMPORTED_MODULE_3__.ANIM_STATE_ANY));\n            break;\n          case _constants_js__WEBPACK_IMPORTED_MODULE_3__.ANIM_INTERRUPTION_NEXT_PREV:\n            transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));\n            transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));\n            transitions = transitions.concat(this._findTransitionsFromState(_constants_js__WEBPACK_IMPORTED_MODULE_3__.ANIM_STATE_ANY));\n            break;\n        }\n      }\n    }\n    transitions = transitions.filter(transition => {\n      if (transition.to === this.activeStateName) {\n        return false;\n      }\n      if (transition.hasExitTime) {\n        let progressBefore = this._getActiveStateProgressForTime(this._timeInStateBefore);\n        let progress = this._getActiveStateProgressForTime(this._timeInState);\n        if (transition.exitTime < 1.0 && this.activeState.loop) {\n          progressBefore -= Math.floor(progressBefore);\n          progress -= Math.floor(progress);\n        }\n        if (!(transition.exitTime > progressBefore && transition.exitTime <= progress)) {\n          return null;\n        }\n      }\n      return this._transitionHasConditionsMet(transition);\n    });\n    if (transitions.length > 0) {\n      const transition = transitions[0];\n      if (transition.to === _constants_js__WEBPACK_IMPORTED_MODULE_3__.ANIM_STATE_END) {\n        const startTransition = this._findTransitionsFromState(_constants_js__WEBPACK_IMPORTED_MODULE_3__.ANIM_STATE_START)[0];\n        transition.to = startTransition.to;\n      }\n      return transition;\n    }\n    return null;\n  }\n  updateStateFromTransition(transition) {\n    let state;\n    let animation;\n    let clip;\n    this.previousState = transition.from ? this.activeStateName : null;\n    this.activeState = transition.to;\n    for (let i = 0; i < transition.conditions.length; i++) {\n      const condition = transition.conditions[i];\n      const parameter = this.findParameter(condition.parameterName);\n      if (parameter.type === _constants_js__WEBPACK_IMPORTED_MODULE_3__.ANIM_PARAMETER_TRIGGER) {\n        this._consumedTriggers.add(condition.parameterName);\n      }\n    }\n    if (this.previousState) {\n      if (!this._isTransitioning) {\n        this._transitionPreviousStates = [];\n      }\n      this._transitionPreviousStates.push({\n        name: this._previousStateName,\n        weight: 1\n      });\n      const interpolatedTime = Math.min(this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1, 1.0);\n      for (let i = 0; i < this._transitionPreviousStates.length; i++) {\n        if (!this._isTransitioning) {\n          this._transitionPreviousStates[i].weight = 1.0;\n        } else if (i !== this._transitionPreviousStates.length - 1) {\n          this._transitionPreviousStates[i].weight *= 1.0 - interpolatedTime;\n        } else {\n          this._transitionPreviousStates[i].weight = interpolatedTime;\n        }\n        state = this._findState(this._transitionPreviousStates[i].name);\n        for (let j = 0; j < state.animations.length; j++) {\n          animation = state.animations[j];\n          clip = this._animEvaluator.findClip(animation.name + '.previous.' + i);\n          if (!clip) {\n            clip = this._animEvaluator.findClip(animation.name);\n            clip.name = animation.name + '.previous.' + i;\n          }\n          if (i !== this._transitionPreviousStates.length - 1) {\n            clip.pause();\n          }\n        }\n      }\n    }\n    this._isTransitioning = true;\n    this._totalTransitionTime = transition.time;\n    this._currTransitionTime = 0;\n    this._transitionInterruptionSource = transition.interruptionSource;\n    const activeState = this.activeState;\n    const hasTransitionOffset = transition.transitionOffset && transition.transitionOffset > 0.0 && transition.transitionOffset < 1.0;\n    let timeInState = 0;\n    let timeInStateBefore = 0;\n    if (hasTransitionOffset) {\n      const offsetTime = activeState.timelineDuration * transition.transitionOffset;\n      timeInState = offsetTime;\n      timeInStateBefore = offsetTime;\n    }\n    this._timeInState = timeInState;\n    this._timeInStateBefore = timeInStateBefore;\n    for (let i = 0; i < activeState.animations.length; i++) {\n      clip = this._animEvaluator.findClip(activeState.animations[i].name);\n      if (!clip) {\n        const speed = Number.isFinite(activeState.animations[i].speed) ? activeState.animations[i].speed : activeState.speed;\n        clip = new _evaluator_anim_clip_js__WEBPACK_IMPORTED_MODULE_5__.AnimClip(activeState.animations[i].animTrack, this._timeInState, speed, true, activeState.loop, this._eventHandler);\n        clip.name = activeState.animations[i].name;\n        this._animEvaluator.addClip(clip);\n      } else {\n        clip.reset();\n      }\n      if (transition.time > 0) {\n        clip.blendWeight = 0.0;\n      } else {\n        clip.blendWeight = activeState.animations[i].normalizedWeight;\n      }\n      clip.play();\n      if (hasTransitionOffset) {\n        clip.time = activeState.timelineDuration * transition.transitionOffset;\n      } else {\n        const startTime = activeState.speed >= 0 ? 0 : this.activeStateDuration;\n        clip.time = startTime;\n      }\n    }\n  }\n  _transitionToState(newStateName) {\n    if (!this._findState(newStateName)) {\n      return;\n    }\n    let transition = this._findTransition(this._activeStateName, newStateName);\n    if (!transition) {\n      this._animEvaluator.removeClips();\n      transition = new _anim_transition_js__WEBPACK_IMPORTED_MODULE_1__.AnimTransition({\n        from: null,\n        to: newStateName\n      });\n    }\n    this.updateStateFromTransition(transition);\n  }\n  assignAnimation(pathString, animTrack, speed, loop) {\n    const path = pathString.split('.');\n    let state = this._findState(path[0]);\n    if (!state) {\n      state = new _anim_state_js__WEBPACK_IMPORTED_MODULE_0__.AnimState(this, path[0], 1.0);\n      this._states[path[0]] = state;\n      this._stateNames.push(path[0]);\n    }\n    state.addAnimation(path, animTrack);\n    if (speed !== undefined) {\n      state.speed = speed;\n    }\n    if (loop !== undefined) {\n      state.loop = loop;\n    }\n    if (!this._playing && this._activate && this.playable) {\n      this.play();\n    }\n  }\n  removeNodeAnimations(nodeName) {\n    if (_constants_js__WEBPACK_IMPORTED_MODULE_3__.ANIM_CONTROL_STATES.indexOf(nodeName) !== -1) {\n      return false;\n    }\n    const state = this._findState(nodeName);\n    if (!state) {\n      return false;\n    }\n    state.animations = [];\n    return true;\n  }\n  play(stateName) {\n    if (stateName) {\n      this._transitionToState(stateName);\n    }\n    this._playing = true;\n  }\n  pause() {\n    this._playing = false;\n  }\n  reset() {\n    this._previousStateName = null;\n    this._activeStateName = _constants_js__WEBPACK_IMPORTED_MODULE_3__.ANIM_STATE_START;\n    this._playing = false;\n    this._currTransitionTime = 1.0;\n    this._totalTransitionTime = 1.0;\n    this._isTransitioning = false;\n    this._timeInState = 0;\n    this._timeInStateBefore = 0;\n    this._animEvaluator.removeClips();\n  }\n  rebind() {\n    this._animEvaluator.rebind();\n  }\n  update(dt) {\n    if (!this._playing) {\n      return;\n    }\n    let state;\n    let animation;\n    let clip;\n    this._timeInStateBefore = this._timeInState;\n    this._timeInState += dt * this.activeState.speed;\n    const transition = this._findTransition(this._activeStateName);\n    if (transition) this.updateStateFromTransition(transition);\n    if (this._isTransitioning) {\n      this._currTransitionTime += dt;\n      if (this._currTransitionTime <= this._totalTransitionTime) {\n        const interpolatedTime = this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1;\n        for (let i = 0; i < this._transitionPreviousStates.length; i++) {\n          state = this._findState(this._transitionPreviousStates[i].name);\n          const stateWeight = this._transitionPreviousStates[i].weight;\n          for (let j = 0; j < state.animations.length; j++) {\n            animation = state.animations[j];\n            clip = this._animEvaluator.findClip(animation.name + '.previous.' + i);\n            if (clip) {\n              clip.blendWeight = (1.0 - interpolatedTime) * animation.normalizedWeight * stateWeight;\n            }\n          }\n        }\n        state = this.activeState;\n        for (let i = 0; i < state.animations.length; i++) {\n          animation = state.animations[i];\n          this._animEvaluator.findClip(animation.name).blendWeight = interpolatedTime * animation.normalizedWeight;\n        }\n      } else {\n        this._isTransitioning = false;\n        const activeClips = this.activeStateAnimations.length;\n        const totalClips = this._animEvaluator.clips.length;\n        for (let i = 0; i < totalClips - activeClips; i++) {\n          this._animEvaluator.removeClip(0);\n        }\n        this._transitionPreviousStates = [];\n        state = this.activeState;\n        for (let i = 0; i < state.animations.length; i++) {\n          animation = state.animations[i];\n          clip = this._animEvaluator.findClip(animation.name);\n          if (clip) {\n            clip.blendWeight = animation.normalizedWeight;\n          }\n        }\n      }\n    } else {\n      if (this.activeState._blendTree.constructor !== _anim_node_js__WEBPACK_IMPORTED_MODULE_6__.AnimNode) {\n        state = this.activeState;\n        for (let i = 0; i < state.animations.length; i++) {\n          animation = state.animations[i];\n          clip = this._animEvaluator.findClip(animation.name);\n          if (clip) {\n            clip.blendWeight = animation.normalizedWeight;\n            if (animation.parent.syncAnimations) {\n              clip.speed = animation.speed;\n            }\n          }\n        }\n      }\n    }\n    this._animEvaluator.update(dt);\n  }\n  findParameter(name) {\n    return this._parameters[name];\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-controller.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-node.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-node.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimNode\": () => (/* binding */ AnimNode)\n/* harmony export */ });\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n\n\nclass AnimNode {\n  constructor(state, parent, name, point, speed = 1) {\n    this._state = state;\n    this._parent = parent;\n    this._name = name;\n    if (Array.isArray(point)) {\n      this._point = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_0__.Vec2(point[0], point[1]);\n      this._pointLength = this._point.length();\n    } else {\n      this._point = point;\n      this._pointLength = point;\n    }\n    this._speed = speed;\n    this._weightedSpeed = 1.0;\n    this._weight = 1.0;\n    this._animTrack = null;\n  }\n  get parent() {\n    return this._parent;\n  }\n  get name() {\n    return this._name;\n  }\n  get path() {\n    return this._parent ? this._parent.path + '.' + this._name : this._name;\n  }\n  get point() {\n    return this._point;\n  }\n  get pointLength() {\n    return this._pointLength;\n  }\n  set weight(value) {\n    this._weight = value;\n  }\n  get weight() {\n    return this._parent ? this._parent.weight * this._weight : this._weight;\n  }\n  get normalizedWeight() {\n    const totalWeight = this._state.totalWeight;\n    if (totalWeight === 0.0) return 0.0;\n    return this.weight / totalWeight;\n  }\n  get speed() {\n    return this._weightedSpeed * this._speed;\n  }\n  get absoluteSpeed() {\n    return Math.abs(this._speed);\n  }\n  set weightedSpeed(weightedSpeed) {\n    this._weightedSpeed = weightedSpeed;\n  }\n  get weightedSpeed() {\n    return this._weightedSpeed;\n  }\n  set animTrack(value) {\n    this._animTrack = value;\n  }\n  get animTrack() {\n    return this._animTrack;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-node.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-state.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-state.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimState\": () => (/* binding */ AnimState)\n/* harmony export */ });\n/* harmony import */ var _anim_blend_tree_1d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./anim-blend-tree-1d.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-blend-tree-1d.js\");\n/* harmony import */ var _anim_blend_tree_2d_cartesian_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./anim-blend-tree-2d-cartesian.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-blend-tree-2d-cartesian.js\");\n/* harmony import */ var _anim_blend_tree_2d_directional_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./anim-blend-tree-2d-directional.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-blend-tree-2d-directional.js\");\n/* harmony import */ var _anim_blend_tree_direct_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./anim-blend-tree-direct.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-blend-tree-direct.js\");\n/* harmony import */ var _anim_node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./anim-node.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-node.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/constants.js\");\n\n\n\n\n\n\n\n\nclass AnimState {\n  constructor(controller, name, speed, loop, blendTree) {\n    this._controller = controller;\n    this._name = name;\n    this._animations = {};\n    this._animationList = [];\n    this._speed = speed || 1.0;\n    this._loop = loop === undefined ? true : loop;\n    const findParameter = this._controller.findParameter.bind(this._controller);\n    if (blendTree) {\n      this._blendTree = this._createTree(blendTree.type, this, null, name, 1.0, blendTree.parameter ? [blendTree.parameter] : blendTree.parameters, blendTree.children, blendTree.syncAnimations, this._createTree, findParameter);\n    } else {\n      this._blendTree = new _anim_node_js__WEBPACK_IMPORTED_MODULE_0__.AnimNode(this, null, name, 1.0, speed);\n    }\n  }\n  _createTree(type, state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {\n    switch (type) {\n      case _constants_js__WEBPACK_IMPORTED_MODULE_1__.ANIM_BLEND_1D:\n        return new _anim_blend_tree_1d_js__WEBPACK_IMPORTED_MODULE_2__.AnimBlendTree1D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);\n      case _constants_js__WEBPACK_IMPORTED_MODULE_1__.ANIM_BLEND_2D_CARTESIAN:\n        return new _anim_blend_tree_2d_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.AnimBlendTreeCartesian2D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);\n      case _constants_js__WEBPACK_IMPORTED_MODULE_1__.ANIM_BLEND_2D_DIRECTIONAL:\n        return new _anim_blend_tree_2d_directional_js__WEBPACK_IMPORTED_MODULE_4__.AnimBlendTreeDirectional2D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);\n      case _constants_js__WEBPACK_IMPORTED_MODULE_1__.ANIM_BLEND_DIRECT:\n        return new _anim_blend_tree_direct_js__WEBPACK_IMPORTED_MODULE_5__.AnimBlendTreeDirect(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);\n    }\n    return undefined;\n  }\n  _getNodeFromPath(path) {\n    let currNode = this._blendTree;\n    for (let i = 1; i < path.length; i++) {\n      currNode = currNode.getChild(path[i]);\n    }\n    return currNode;\n  }\n  addAnimation(path, animTrack) {\n    const pathString = path.join('.');\n    const indexOfAnimation = this._animationList.findIndex(function (animation) {\n      return animation.path === pathString;\n    });\n    if (indexOfAnimation >= 0) {\n      this._animationList[indexOfAnimation].animTrack = animTrack;\n    } else {\n      const node = this._getNodeFromPath(path);\n      node.animTrack = animTrack;\n      this._animationList.push(node);\n    }\n  }\n  get name() {\n    return this._name;\n  }\n  set animations(value) {\n    this._animationList = value;\n  }\n  get animations() {\n    return this._animationList;\n  }\n  set speed(value) {\n    this._speed = value;\n  }\n  get speed() {\n    return this._speed;\n  }\n  set loop(value) {\n    this._loop = value;\n  }\n  get loop() {\n    return this._loop;\n  }\n  get nodeCount() {\n    if (!this._blendTree || this._blendTree.constructor === _anim_node_js__WEBPACK_IMPORTED_MODULE_0__.AnimNode) return 1;\n    return this._blendTree.getNodeCount();\n  }\n  get playable() {\n    return _constants_js__WEBPACK_IMPORTED_MODULE_1__.ANIM_CONTROL_STATES.indexOf(this.name) !== -1 || this.animations.length === this.nodeCount;\n  }\n  get looping() {\n    if (this.animations.length > 0) {\n      const trackClipName = this.name + '.' + this.animations[0].animTrack.name;\n      const trackClip = this._controller.animEvaluator.findClip(trackClipName);\n      if (trackClip) {\n        return trackClip.loop;\n      }\n    }\n    return false;\n  }\n  get totalWeight() {\n    let sum = 0;\n    for (let i = 0; i < this.animations.length; i++) {\n      sum += this.animations[i].weight;\n    }\n    return sum;\n  }\n  get timelineDuration() {\n    let duration = 0;\n    for (let i = 0; i < this.animations.length; i++) {\n      const animation = this.animations[i];\n      if (animation.animTrack.duration > duration) {\n        duration = animation.animTrack.duration;\n      }\n    }\n    return duration;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-state.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-transition.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-transition.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimTransition\": () => (/* binding */ AnimTransition)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/constants.js\");\n\n\nclass AnimTransition {\n  constructor({\n    from,\n    to,\n    time = 0,\n    priority = 0,\n    conditions = [],\n    exitTime = null,\n    transitionOffset = null,\n    interruptionSource = _constants_js__WEBPACK_IMPORTED_MODULE_0__.ANIM_INTERRUPTION_NONE\n  }) {\n    this._from = from;\n    this._to = to;\n    this._time = time;\n    this._priority = priority;\n    this._conditions = conditions;\n    this._exitTime = exitTime;\n    this._transitionOffset = transitionOffset;\n    this._interruptionSource = interruptionSource;\n  }\n  get from() {\n    return this._from;\n  }\n  set to(value) {\n    this._to = value;\n  }\n  get to() {\n    return this._to;\n  }\n  get time() {\n    return this._time;\n  }\n  get priority() {\n    return this._priority;\n  }\n  get conditions() {\n    return this._conditions;\n  }\n  get exitTime() {\n    return this._exitTime;\n  }\n  get transitionOffset() {\n    return this._transitionOffset;\n  }\n  get interruptionSource() {\n    return this._interruptionSource;\n  }\n  get hasExitTime() {\n    return !!this.exitTime;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-transition.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/constants.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/constants.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ANIM_BLEND_1D\": () => (/* binding */ ANIM_BLEND_1D),\n/* harmony export */   \"ANIM_BLEND_2D_CARTESIAN\": () => (/* binding */ ANIM_BLEND_2D_CARTESIAN),\n/* harmony export */   \"ANIM_BLEND_2D_DIRECTIONAL\": () => (/* binding */ ANIM_BLEND_2D_DIRECTIONAL),\n/* harmony export */   \"ANIM_BLEND_DIRECT\": () => (/* binding */ ANIM_BLEND_DIRECT),\n/* harmony export */   \"ANIM_CONTROL_STATES\": () => (/* binding */ ANIM_CONTROL_STATES),\n/* harmony export */   \"ANIM_EQUAL_TO\": () => (/* binding */ ANIM_EQUAL_TO),\n/* harmony export */   \"ANIM_GREATER_THAN\": () => (/* binding */ ANIM_GREATER_THAN),\n/* harmony export */   \"ANIM_GREATER_THAN_EQUAL_TO\": () => (/* binding */ ANIM_GREATER_THAN_EQUAL_TO),\n/* harmony export */   \"ANIM_INTERRUPTION_NEXT\": () => (/* binding */ ANIM_INTERRUPTION_NEXT),\n/* harmony export */   \"ANIM_INTERRUPTION_NEXT_PREV\": () => (/* binding */ ANIM_INTERRUPTION_NEXT_PREV),\n/* harmony export */   \"ANIM_INTERRUPTION_NONE\": () => (/* binding */ ANIM_INTERRUPTION_NONE),\n/* harmony export */   \"ANIM_INTERRUPTION_PREV\": () => (/* binding */ ANIM_INTERRUPTION_PREV),\n/* harmony export */   \"ANIM_INTERRUPTION_PREV_NEXT\": () => (/* binding */ ANIM_INTERRUPTION_PREV_NEXT),\n/* harmony export */   \"ANIM_LAYER_ADDITIVE\": () => (/* binding */ ANIM_LAYER_ADDITIVE),\n/* harmony export */   \"ANIM_LAYER_OVERWRITE\": () => (/* binding */ ANIM_LAYER_OVERWRITE),\n/* harmony export */   \"ANIM_LESS_THAN\": () => (/* binding */ ANIM_LESS_THAN),\n/* harmony export */   \"ANIM_LESS_THAN_EQUAL_TO\": () => (/* binding */ ANIM_LESS_THAN_EQUAL_TO),\n/* harmony export */   \"ANIM_NOT_EQUAL_TO\": () => (/* binding */ ANIM_NOT_EQUAL_TO),\n/* harmony export */   \"ANIM_PARAMETER_BOOLEAN\": () => (/* binding */ ANIM_PARAMETER_BOOLEAN),\n/* harmony export */   \"ANIM_PARAMETER_FLOAT\": () => (/* binding */ ANIM_PARAMETER_FLOAT),\n/* harmony export */   \"ANIM_PARAMETER_INTEGER\": () => (/* binding */ ANIM_PARAMETER_INTEGER),\n/* harmony export */   \"ANIM_PARAMETER_TRIGGER\": () => (/* binding */ ANIM_PARAMETER_TRIGGER),\n/* harmony export */   \"ANIM_STATE_ANY\": () => (/* binding */ ANIM_STATE_ANY),\n/* harmony export */   \"ANIM_STATE_END\": () => (/* binding */ ANIM_STATE_END),\n/* harmony export */   \"ANIM_STATE_START\": () => (/* binding */ ANIM_STATE_START)\n/* harmony export */ });\nconst ANIM_INTERRUPTION_NONE = 'NONE';\nconst ANIM_INTERRUPTION_PREV = 'PREV_STATE';\nconst ANIM_INTERRUPTION_NEXT = 'NEXT_STATE';\nconst ANIM_INTERRUPTION_PREV_NEXT = 'PREV_STATE_NEXT_STATE';\nconst ANIM_INTERRUPTION_NEXT_PREV = 'NEXT_STATE_PREV_STATE';\nconst ANIM_GREATER_THAN = 'GREATER_THAN';\nconst ANIM_LESS_THAN = 'LESS_THAN';\nconst ANIM_GREATER_THAN_EQUAL_TO = 'GREATER_THAN_EQUAL_TO';\nconst ANIM_LESS_THAN_EQUAL_TO = 'LESS_THAN_EQUAL_TO';\nconst ANIM_EQUAL_TO = 'EQUAL_TO';\nconst ANIM_NOT_EQUAL_TO = 'NOT_EQUAL_TO';\nconst ANIM_PARAMETER_INTEGER = 'INTEGER';\nconst ANIM_PARAMETER_FLOAT = 'FLOAT';\nconst ANIM_PARAMETER_BOOLEAN = 'BOOLEAN';\nconst ANIM_PARAMETER_TRIGGER = 'TRIGGER';\nconst ANIM_BLEND_1D = '1D';\nconst ANIM_BLEND_2D_DIRECTIONAL = '2D_DIRECTIONAL';\nconst ANIM_BLEND_2D_CARTESIAN = '2D_CARTESIAN';\nconst ANIM_BLEND_DIRECT = 'DIRECT';\nconst ANIM_STATE_START = 'START';\nconst ANIM_STATE_END = 'END';\nconst ANIM_STATE_ANY = 'ANY';\nconst ANIM_CONTROL_STATES = [ANIM_STATE_START, ANIM_STATE_END, ANIM_STATE_ANY];\nconst ANIM_LAYER_OVERWRITE = 'OVERWRITE';\nconst ANIM_LAYER_ADDITIVE = 'ADDITIVE';\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/constants.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-blend.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-blend.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimBlend\": () => (/* binding */ AnimBlend)\n/* harmony export */ });\nclass AnimBlend {\n  static dot(a, b) {\n    const len = a.length;\n    let result = 0;\n    for (let i = 0; i < len; ++i) {\n      result += a[i] * b[i];\n    }\n    return result;\n  }\n  static normalize(a) {\n    let l = AnimBlend.dot(a, a);\n    if (l > 0) {\n      l = 1.0 / Math.sqrt(l);\n      const len = a.length;\n      for (let i = 0; i < len; ++i) {\n        a[i] *= l;\n      }\n    }\n  }\n  static set(a, b, type) {\n    const len = a.length;\n    if (type === 'quaternion') {\n      let l = AnimBlend.dot(b, b);\n      if (l > 0) {\n        l = 1.0 / Math.sqrt(l);\n      }\n      for (let i = 0; i < len; ++i) {\n        a[i] = b[i] * l;\n      }\n    } else {\n      for (let i = 0; i < len; ++i) {\n        a[i] = b[i];\n      }\n    }\n  }\n  static blendVec(a, b, t, additive) {\n    const it = additive ? 1.0 : 1.0 - t;\n    const len = a.length;\n    for (let i = 0; i < len; ++i) {\n      a[i] = a[i] * it + b[i] * t;\n    }\n  }\n  static blendQuat(a, b, t, additive) {\n    const len = a.length;\n    const it = additive ? 1.0 : 1.0 - t;\n    if (AnimBlend.dot(a, b) < 0) {\n      t = -t;\n    }\n    for (let i = 0; i < len; ++i) {\n      a[i] = a[i] * it + b[i] * t;\n    }\n    if (!additive) {\n      AnimBlend.normalize(a);\n    }\n  }\n  static blend(a, b, t, type, additive) {\n    if (type === 'quaternion') {\n      AnimBlend.blendQuat(a, b, t, additive);\n    } else {\n      AnimBlend.blendVec(a, b, t, additive);\n    }\n  }\n  static stableSort(a, lessFunc) {\n    const len = a.length;\n    for (let i = 0; i < len - 1; ++i) {\n      for (let j = i + 1; j < len; ++j) {\n        if (lessFunc(a[j], a[i])) {\n          const tmp = a[i];\n          a[i] = a[j];\n          a[j] = tmp;\n        }\n      }\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-blend.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-cache.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-cache.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimCache\": () => (/* binding */ AnimCache)\n/* harmony export */ });\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/constants.js\");\n\n\n\nclass AnimCache {\n  constructor() {\n    this._left = Infinity;\n    this._right = -Infinity;\n    this._len = 0;\n    this._recip = 0;\n    this._p0 = 0;\n    this._p1 = 0;\n    this._t = 0;\n    this._hermite = {\n      valid: false,\n      p0: 0,\n      m0: 0,\n      p1: 0,\n      m1: 0\n    };\n  }\n  update(time, input) {\n    if (time < this._left || time >= this._right) {\n      const len = input.length;\n      if (!len) {\n        this._left = -Infinity;\n        this._right = Infinity;\n        this._len = 0;\n        this._recip = 0;\n        this._p0 = this._p1 = 0;\n      } else {\n        if (time < input[0]) {\n          this._left = -Infinity;\n          this._right = input[0];\n          this._len = 0;\n          this._recip = 0;\n          this._p0 = this._p1 = 0;\n        } else if (time >= input[len - 1]) {\n          this._left = input[len - 1];\n          this._right = Infinity;\n          this._len = 0;\n          this._recip = 0;\n          this._p0 = this._p1 = len - 1;\n        } else {\n          const index = this._findKey(time, input);\n          this._left = input[index];\n          this._right = input[index + 1];\n          this._len = this._right - this._left;\n          const diff = 1.0 / this._len;\n          this._recip = isFinite(diff) ? diff : 0;\n          this._p0 = index;\n          this._p1 = index + 1;\n        }\n      }\n    }\n    this._t = this._recip === 0 ? 0 : (time - this._left) * this._recip;\n    this._hermite.valid = false;\n  }\n  _findKey(time, input) {\n    let index = 0;\n    while (time >= input[index + 1]) {\n      index++;\n    }\n    return index;\n  }\n  eval(result, interpolation, output) {\n    const data = output._data;\n    const comp = output._components;\n    const idx0 = this._p0 * comp;\n    if (interpolation === _constants_js__WEBPACK_IMPORTED_MODULE_0__.INTERPOLATION_STEP) {\n      for (let i = 0; i < comp; ++i) {\n        result[i] = data[idx0 + i];\n      }\n    } else {\n      const t = this._t;\n      const idx1 = this._p1 * comp;\n      switch (interpolation) {\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.INTERPOLATION_LINEAR:\n          for (let i = 0; i < comp; ++i) {\n            result[i] = _core_math_math_js__WEBPACK_IMPORTED_MODULE_1__.math.lerp(data[idx0 + i], data[idx1 + i], t);\n          }\n          break;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.INTERPOLATION_CUBIC:\n          {\n            const hermite = this._hermite;\n            if (!hermite.valid) {\n              const t2 = t * t;\n              const twot = t + t;\n              const omt = 1 - t;\n              const omt2 = omt * omt;\n              hermite.valid = true;\n              hermite.p0 = (1 + twot) * omt2;\n              hermite.m0 = t * omt2;\n              hermite.p1 = t2 * (3 - twot);\n              hermite.m1 = t2 * (t - 1);\n            }\n            const p0 = (this._p0 * 3 + 1) * comp;\n            const m0 = (this._p0 * 3 + 2) * comp;\n            const p1 = (this._p1 * 3 + 1) * comp;\n            const m1 = (this._p1 * 3 + 0) * comp;\n            for (let i = 0; i < comp; ++i) {\n              result[i] = hermite.p0 * data[p0 + i] + hermite.m0 * data[m0 + i] * this._len + hermite.p1 * data[p1 + i] + hermite.m1 * data[m1 + i] * this._len;\n            }\n            break;\n          }\n      }\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-cache.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-clip.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-clip.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimClip\": () => (/* binding */ AnimClip)\n/* harmony export */ });\n/* harmony import */ var _virtual_rollupPluginBabelHelpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../_virtual/_rollupPluginBabelHelpers.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/_virtual/_rollupPluginBabelHelpers.js\");\n/* harmony import */ var _anim_snapshot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./anim-snapshot.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-snapshot.js\");\n\n\n\nclass AnimClip {\n  constructor(track, time, speed, playing, loop, eventHandler) {\n    this._name = track.name;\n    this._track = track;\n    this._snapshot = new _anim_snapshot_js__WEBPACK_IMPORTED_MODULE_0__.AnimSnapshot(track);\n    this._playing = playing;\n    this._time = time;\n    this._speed = speed;\n    this._loop = loop;\n    this._blendWeight = 1.0;\n    this._blendOrder = 0.0;\n    this._eventHandler = eventHandler;\n    this.alignCursorToCurrentTime();\n  }\n  set name(name) {\n    this._name = name;\n  }\n  get name() {\n    return this._name;\n  }\n  get track() {\n    return this._track;\n  }\n  get snapshot() {\n    return this._snapshot;\n  }\n  set time(time) {\n    this._time = time;\n    this.alignCursorToCurrentTime();\n  }\n  get time() {\n    return this._time;\n  }\n  set speed(speed) {\n    this._speed = speed;\n  }\n  get speed() {\n    return this._speed;\n  }\n  set loop(loop) {\n    this._loop = loop;\n  }\n  get loop() {\n    return this._loop;\n  }\n  set blendWeight(blendWeight) {\n    this._blendWeight = blendWeight;\n  }\n  get blendWeight() {\n    return this._blendWeight;\n  }\n  set blendOrder(blendOrder) {\n    this._blendOrder = blendOrder;\n  }\n  get blendOrder() {\n    return this._blendOrder;\n  }\n  set eventCursor(value) {\n    this._eventCursor = value;\n  }\n  get eventCursor() {\n    return this._eventCursor;\n  }\n  alignCursorToCurrentTime() {\n    this._eventCursor = 0;\n    while (this._track.events[this._eventCursor] && this._track.events[this._eventCursor].time < this.time) {\n      this._eventCursor++;\n    }\n  }\n  activeEventsForFrame(frameStartTime, frameEndTime) {\n    if (frameStartTime === 0) {\n      this.eventCursor = 0;\n    }\n    let clippedFrameDuration;\n    if (frameEndTime > this.track.duration) {\n      clippedFrameDuration = frameEndTime - this.track.duration;\n      frameEndTime = this.track.duration;\n    }\n    while (this.track.events[this.eventCursor] && this.track.events[this.eventCursor].time >= frameStartTime && (frameEndTime === this.track.duration ? this.track.events[this.eventCursor].time <= frameEndTime : this.track.events[this.eventCursor].time < frameEndTime)) {\n      const event = this.track.events[this.eventCursor];\n      this._eventHandler.fire(event.name, (0,_virtual_rollupPluginBabelHelpers_js__WEBPACK_IMPORTED_MODULE_1__[\"extends\"])({\n        track: this.track\n      }, event));\n      this.eventCursor++;\n    }\n    if (Number.isFinite(clippedFrameDuration)) {\n      this.activeEventsForFrame(0, clippedFrameDuration);\n    }\n  }\n  progressForTime(time) {\n    return time * this._speed / this._track.duration;\n  }\n  _update(deltaTime) {\n    if (this._playing) {\n      let time = this._time;\n      const duration = this._track.duration;\n      const speed = this._speed;\n      const loop = this._loop;\n      if (this._track.events.length > 0 && duration > 0) {\n        this.activeEventsForFrame(time, time + speed * deltaTime);\n      }\n      time += speed * deltaTime;\n      if (speed >= 0) {\n        if (time > duration) {\n          if (loop) {\n            time = time % duration || 0;\n          } else {\n            time = this._track.duration;\n            this.pause();\n          }\n        }\n      } else {\n        if (time < 0) {\n          if (loop) {\n            time = duration + (time % duration || 0);\n          } else {\n            time = 0;\n            this.pause();\n          }\n        }\n      }\n      this._time = time;\n    }\n    if (this._time !== this._snapshot._time) {\n      this._track.eval(this._time, this._snapshot);\n    }\n  }\n  play() {\n    this._playing = true;\n    this._time = 0;\n  }\n  stop() {\n    this._playing = false;\n    this._time = 0;\n  }\n  pause() {\n    this._playing = false;\n  }\n  resume() {\n    this._playing = true;\n  }\n  reset() {\n    this._time = 0;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-clip.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-curve.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-curve.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimCurve\": () => (/* binding */ AnimCurve)\n/* harmony export */ });\nclass AnimCurve {\n  constructor(paths, input, output, interpolation) {\n    this._paths = paths;\n    this._input = input;\n    this._output = output;\n    this._interpolation = interpolation;\n  }\n  get paths() {\n    return this._paths;\n  }\n  get input() {\n    return this._input;\n  }\n  get output() {\n    return this._output;\n  }\n  get interpolation() {\n    return this._interpolation;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-curve.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-data.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-data.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimData\": () => (/* binding */ AnimData)\n/* harmony export */ });\nclass AnimData {\n  constructor(components, data) {\n    this._components = components;\n    this._data = data;\n  }\n  get components() {\n    return this._components;\n  }\n  get data() {\n    return this._data;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-data.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-evaluator.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-evaluator.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimEvaluator\": () => (/* binding */ AnimEvaluator)\n/* harmony export */ });\n/* harmony import */ var _anim_target_value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./anim-target-value.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-target-value.js\");\n/* harmony import */ var _anim_blend_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./anim-blend.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-blend.js\");\n\n\n\nclass AnimEvaluator {\n  constructor(binder) {\n    this._binder = binder;\n    this._clips = [];\n    this._inputs = [];\n    this._outputs = [];\n    this._targets = {};\n  }\n  get clips() {\n    return this._clips;\n  }\n  addClip(clip) {\n    const targets = this._targets;\n    const binder = this._binder;\n    const curves = clip.track.curves;\n    const snapshot = clip.snapshot;\n    const inputs = [];\n    const outputs = [];\n    for (let i = 0; i < curves.length; ++i) {\n      const curve = curves[i];\n      const paths = curve.paths;\n      for (let j = 0; j < paths.length; ++j) {\n        const path = paths[j];\n        const resolved = binder.resolve(path);\n        let target = targets[resolved && resolved.targetPath || null];\n        if (!target && resolved) {\n          target = {\n            target: resolved,\n            value: [],\n            curves: 0,\n            blendCounter: 0\n          };\n          for (let k = 0; k < target.target.components; ++k) {\n            target.value.push(0);\n          }\n          targets[resolved.targetPath] = target;\n          if (binder.animComponent) {\n            if (!binder.animComponent.targets[resolved.targetPath]) {\n              let type;\n              if (resolved.targetPath.substring(resolved.targetPath.length - 13) === 'localRotation') {\n                type = _anim_target_value_js__WEBPACK_IMPORTED_MODULE_0__.AnimTargetValue.TYPE_QUAT;\n              } else {\n                type = _anim_target_value_js__WEBPACK_IMPORTED_MODULE_0__.AnimTargetValue.TYPE_VEC3;\n              }\n              binder.animComponent.targets[resolved.targetPath] = new _anim_target_value_js__WEBPACK_IMPORTED_MODULE_0__.AnimTargetValue(binder.animComponent, type);\n            }\n            binder.animComponent.targets[resolved.targetPath].layerCounter++;\n            binder.animComponent.targets[resolved.targetPath].setMask(binder.layerIndex, 1);\n          }\n        }\n        if (target) {\n          target.curves++;\n          inputs.push(snapshot._results[i]);\n          outputs.push(target);\n        }\n      }\n    }\n    this._clips.push(clip);\n    this._inputs.push(inputs);\n    this._outputs.push(outputs);\n  }\n  removeClip(index) {\n    const targets = this._targets;\n    const binder = this._binder;\n    const clips = this._clips;\n    const clip = clips[index];\n    const curves = clip.track.curves;\n    for (let i = 0; i < curves.length; ++i) {\n      const curve = curves[i];\n      const paths = curve.paths;\n      for (let j = 0; j < paths.length; ++j) {\n        const path = paths[j];\n        const target = this._binder.resolve(path);\n        if (target) {\n          target.curves--;\n          if (target.curves === 0) {\n            binder.unresolve(path);\n            delete targets[target.targetPath];\n            if (binder.animComponent) {\n              binder.animComponent.targets[target.targetPath].layerCounter--;\n            }\n          }\n        }\n      }\n    }\n    clips.splice(index, 1);\n    this._inputs.splice(index, 1);\n    this._outputs.splice(index, 1);\n  }\n  removeClips() {\n    while (this._clips.length > 0) {\n      this.removeClip(0);\n    }\n  }\n  findClip(name) {\n    const clips = this._clips;\n    for (let i = 0; i < clips.length; ++i) {\n      const clip = clips[i];\n      if (clip.name === name) {\n        return clip;\n      }\n    }\n    return null;\n  }\n  rebind() {\n    this._binder.rebind();\n    this._targets = {};\n    const clips = [...this.clips];\n    this.removeClips();\n    clips.forEach(clip => {\n      this.addClip(clip);\n    });\n  }\n  assignMask(mask) {\n    return this._binder.assignMask(mask);\n  }\n  update(deltaTime) {\n    const clips = this._clips;\n    const order = clips.map(function (c, i) {\n      return i;\n    });\n    _anim_blend_js__WEBPACK_IMPORTED_MODULE_1__.AnimBlend.stableSort(order, function (a, b) {\n      return clips[a].blendOrder < clips[b].blendOrder;\n    });\n    for (let i = 0; i < order.length; ++i) {\n      const index = order[i];\n      const clip = clips[index];\n      const inputs = this._inputs[index];\n      const outputs = this._outputs[index];\n      const blendWeight = clip.blendWeight;\n      if (blendWeight > 0.0) {\n        clip._update(deltaTime);\n      }\n      let input;\n      let output;\n      let value;\n      if (blendWeight >= 1.0) {\n        for (let j = 0; j < inputs.length; ++j) {\n          input = inputs[j];\n          output = outputs[j];\n          value = output.value;\n          _anim_blend_js__WEBPACK_IMPORTED_MODULE_1__.AnimBlend.set(value, input, output.target.type);\n          output.blendCounter++;\n        }\n      } else if (blendWeight > 0.0) {\n        for (let j = 0; j < inputs.length; ++j) {\n          input = inputs[j];\n          output = outputs[j];\n          value = output.value;\n          if (output.blendCounter === 0) {\n            _anim_blend_js__WEBPACK_IMPORTED_MODULE_1__.AnimBlend.set(value, input, output.target.type);\n          } else {\n            _anim_blend_js__WEBPACK_IMPORTED_MODULE_1__.AnimBlend.blend(value, input, blendWeight, output.target.type);\n          }\n          output.blendCounter++;\n        }\n      }\n    }\n    const targets = this._targets;\n    const binder = this._binder;\n    for (const path in targets) {\n      if (targets.hasOwnProperty(path)) {\n        const target = targets[path];\n        if (binder.animComponent && target.target.isTransform) {\n          const animTarget = binder.animComponent.targets[path];\n          if (animTarget.counter === animTarget.layerCounter) {\n            animTarget.counter = 0;\n          }\n          if (!animTarget.path) {\n            animTarget.path = path;\n            animTarget.baseValue = target.target.get();\n            animTarget.setter = target.target.set;\n          }\n          animTarget.updateValue(binder.layerIndex, target.value);\n          animTarget.counter++;\n        } else {\n          target.target.set(target.value);\n        }\n        target.blendCounter = 0;\n      }\n    }\n    binder.update(deltaTime);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-evaluator.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-events.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-events.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimEvents\": () => (/* binding */ AnimEvents)\n/* harmony export */ });\nclass AnimEvents {\n  constructor(events) {\n    this._events = [...events];\n    this._events.sort((a, b) => a.time - b.time);\n  }\n  get events() {\n    return this._events;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-events.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-snapshot.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-snapshot.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimSnapshot\": () => (/* binding */ AnimSnapshot)\n/* harmony export */ });\n/* harmony import */ var _anim_cache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./anim-cache.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-cache.js\");\n\n\nclass AnimSnapshot {\n  constructor(animTrack) {\n    this._name = animTrack.name + 'Snapshot';\n    this._time = -1;\n    this._cache = [];\n    this._results = [];\n    for (let i = 0; i < animTrack._inputs.length; ++i) {\n      this._cache[i] = new _anim_cache_js__WEBPACK_IMPORTED_MODULE_0__.AnimCache();\n    }\n    const curves = animTrack._curves;\n    const outputs = animTrack._outputs;\n    for (let i = 0; i < curves.length; ++i) {\n      const curve = curves[i];\n      const output = outputs[curve._output];\n      const storage = [];\n      for (let j = 0; j < output._components; ++j) {\n        storage[j] = 0;\n      }\n      this._results[i] = storage;\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-snapshot.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-target-value.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-target-value.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimTargetValue\": () => (/* binding */ AnimTargetValue)\n/* harmony export */ });\n/* harmony import */ var _core_math_quat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/math/quat.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/quat.js\");\n/* harmony import */ var _controller_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../controller/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/constants.js\");\n/* harmony import */ var _anim_blend_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./anim-blend.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-blend.js\");\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n\n\n\n\n\nclass AnimTargetValue {\n  constructor(component, type) {\n    this._component = component;\n    this.mask = new Int8Array(component.layers.length);\n    this.weights = new Float32Array(component.layers.length);\n    this.totalWeight = 0;\n    this.counter = 0;\n    this.layerCounter = 0;\n    this.valueType = type;\n    this.dirty = true;\n    this.value = type === AnimTargetValue.TYPE_QUAT ? [0, 0, 0, 1] : [0, 0, 0];\n    this.baseValue = null;\n    this.setter = null;\n  }\n  get _normalizeWeights() {\n    return this._component.normalizeWeights;\n  }\n  getWeight(index) {\n    if (this.dirty) this.updateWeights();\n    if (this._normalizeWeights && this.totalWeight === 0 || !this.mask[index]) {\n      return 0;\n    } else if (this._normalizeWeights) {\n      return this.weights[index] / this.totalWeight;\n    }\n    return _core_math_math_js__WEBPACK_IMPORTED_MODULE_0__.math.clamp(this.weights[index], 0, 1);\n  }\n  _layerBlendType(index) {\n    return this._component.layers[index].blendType;\n  }\n  setMask(index, value) {\n    this.mask[index] = value;\n    if (this._normalizeWeights) {\n      if (this._component.layers[index].blendType === _controller_constants_js__WEBPACK_IMPORTED_MODULE_1__.ANIM_LAYER_OVERWRITE) {\n        this.mask = this.mask.fill(0, 0, index);\n      }\n      this.dirty = true;\n    }\n  }\n  updateWeights() {\n    this.totalWeight = 0;\n    for (let i = 0; i < this.weights.length; i++) {\n      this.weights[i] = this._component.layers[i].weight;\n      this.totalWeight += this.mask[i] * this.weights[i];\n    }\n    this.dirty = false;\n  }\n  updateValue(index, value) {\n    if (this.counter === 0) {\n      _anim_blend_js__WEBPACK_IMPORTED_MODULE_2__.AnimBlend.set(this.value, AnimTargetValue.IDENTITY_QUAT_ARR, this.valueType);\n      if (!this._normalizeWeights) {\n        _anim_blend_js__WEBPACK_IMPORTED_MODULE_2__.AnimBlend.blend(this.value, this.baseValue, 1, this.valueType);\n      }\n    }\n    if (!this.mask[index] || this.getWeight(index) === 0) return;\n    if (this._layerBlendType(index) === _controller_constants_js__WEBPACK_IMPORTED_MODULE_1__.ANIM_LAYER_ADDITIVE && !this._normalizeWeights) {\n      if (this.valueType === AnimTargetValue.TYPE_QUAT) {\n        const v = AnimTargetValue.q1.set(this.value[0], this.value[1], this.value[2], this.value[3]);\n        const aV1 = AnimTargetValue.q2.set(this.baseValue[0], this.baseValue[1], this.baseValue[2], this.baseValue[3]);\n        const aV2 = AnimTargetValue.q3.set(value[0], value[1], value[2], value[3]);\n        const aV = aV1.invert().mul(aV2);\n        aV.slerp(_core_math_quat_js__WEBPACK_IMPORTED_MODULE_3__.Quat.IDENTITY, aV, this.getWeight(index));\n        v.mul(aV);\n        AnimTargetValue.quatArr[0] = v.x;\n        AnimTargetValue.quatArr[1] = v.y;\n        AnimTargetValue.quatArr[2] = v.z;\n        AnimTargetValue.quatArr[3] = v.w;\n        _anim_blend_js__WEBPACK_IMPORTED_MODULE_2__.AnimBlend.set(this.value, AnimTargetValue.quatArr, this.valueType);\n      } else {\n        AnimTargetValue.vecArr[0] = value[0] - this.baseValue[0];\n        AnimTargetValue.vecArr[1] = value[1] - this.baseValue[1];\n        AnimTargetValue.vecArr[2] = value[2] - this.baseValue[2];\n        _anim_blend_js__WEBPACK_IMPORTED_MODULE_2__.AnimBlend.blend(this.value, AnimTargetValue.vecArr, this.getWeight(index), this.valueType, true);\n      }\n    } else {\n      _anim_blend_js__WEBPACK_IMPORTED_MODULE_2__.AnimBlend.blend(this.value, value, this.getWeight(index), this.valueType);\n    }\n    if (this.setter) this.setter(this.value);\n  }\n  unbind() {\n    if (this.setter) {\n      this.setter(this.baseValue);\n    }\n  }\n}\nAnimTargetValue.TYPE_QUAT = 'quaternion';\nAnimTargetValue.TYPE_VEC3 = 'vector3';\nAnimTargetValue.q1 = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_3__.Quat();\nAnimTargetValue.q2 = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_3__.Quat();\nAnimTargetValue.q3 = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_3__.Quat();\nAnimTargetValue.quatArr = [0, 0, 0, 1];\nAnimTargetValue.vecArr = [0, 0, 0];\nAnimTargetValue.IDENTITY_QUAT_ARR = [0, 0, 0, 1];\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-target-value.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-target.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-target.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimTarget\": () => (/* binding */ AnimTarget)\n/* harmony export */ });\nclass AnimTarget {\n  constructor(func, type, components, targetPath) {\n    if (func.set) {\n      this._set = func.set;\n      this._get = func.get;\n    } else {\n      this._set = func;\n    }\n    this._type = type;\n    this._components = components;\n    this._targetPath = targetPath;\n    this._isTransform = this._targetPath.substring(this._targetPath.length - 13) === 'localRotation' || this._targetPath.substring(this._targetPath.length - 13) === 'localPosition' || this._targetPath.substring(this._targetPath.length - 10) === 'localScale';\n  }\n  get set() {\n    return this._set;\n  }\n  get get() {\n    return this._get;\n  }\n  get type() {\n    return this._type;\n  }\n  get components() {\n    return this._components;\n  }\n  get targetPath() {\n    return this._targetPath;\n  }\n  get isTransform() {\n    return this._isTransform;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-target.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-track.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-track.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimTrack\": () => (/* binding */ AnimTrack)\n/* harmony export */ });\n/* harmony import */ var _anim_events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./anim-events.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-events.js\");\n\n\nclass AnimTrack {\n  constructor(name, duration, inputs, outputs, curves, animEvents = new _anim_events_js__WEBPACK_IMPORTED_MODULE_0__.AnimEvents([])) {\n    this._name = name;\n    this._duration = duration;\n    this._inputs = inputs;\n    this._outputs = outputs;\n    this._curves = curves;\n    this._animEvents = animEvents;\n  }\n  get name() {\n    return this._name;\n  }\n  get duration() {\n    return this._duration;\n  }\n  get inputs() {\n    return this._inputs;\n  }\n  get outputs() {\n    return this._outputs;\n  }\n  get curves() {\n    return this._curves;\n  }\n  set events(animEvents) {\n    this._animEvents = animEvents;\n  }\n  get events() {\n    return this._animEvents.events;\n  }\n  eval(time, snapshot) {\n    snapshot._time = time;\n    const inputs = this._inputs;\n    const outputs = this._outputs;\n    const curves = this._curves;\n    const cache = snapshot._cache;\n    const results = snapshot._results;\n    for (let i = 0; i < inputs.length; ++i) {\n      cache[i].update(time, inputs[i]._data);\n    }\n    for (let i = 0; i < curves.length; ++i) {\n      const curve = curves[i];\n      const output = outputs[curve._output];\n      const result = results[i];\n      cache[curve._input].eval(result, curve._interpolation, output);\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-track.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/state-graph/anim-state-graph.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/state-graph/anim-state-graph.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimStateGraph\": () => (/* binding */ AnimStateGraph)\n/* harmony export */ });\nclass AnimStateGraph {\n  constructor(data) {\n    this._layers = [];\n    this._parameters = {};\n    if (!Array.isArray(data.layers)) {\n      for (const layerId in data.layers) {\n        const dataLayer = data.layers[layerId];\n        const layer = {\n          name: dataLayer.name,\n          blendType: dataLayer.blendType,\n          weight: dataLayer.weight,\n          states: [],\n          transitions: []\n        };\n        for (let i = 0; i < dataLayer.states.length; i++) {\n          layer.states.push(data.states[dataLayer.states[i]]);\n        }\n        for (let i = 0; i < dataLayer.transitions.length; i++) {\n          const dataLayerTransition = data.transitions[dataLayer.transitions[i]];\n          if (dataLayerTransition.conditions && !Array.isArray(dataLayerTransition.conditions)) {\n            const conditionKeys = Object.keys(dataLayerTransition.conditions);\n            const conditions = [];\n            for (let j = 0; j < conditionKeys.length; j++) {\n              const condition = dataLayerTransition.conditions[conditionKeys[j]];\n              if (condition.parameterName) {\n                conditions.push(condition);\n              }\n            }\n            dataLayerTransition.conditions = conditions;\n          }\n          if (Number.isInteger(dataLayerTransition.from)) {\n            dataLayerTransition.from = data.states[dataLayerTransition.from].name;\n          }\n          if (Number.isInteger(dataLayerTransition.to)) {\n            dataLayerTransition.to = data.states[dataLayerTransition.to].name;\n          }\n          layer.transitions.push(dataLayerTransition);\n        }\n        this._layers.push(layer);\n      }\n    } else {\n      this._layers = data.layers;\n    }\n    for (const paramId in data.parameters) {\n      const param = data.parameters[paramId];\n      this._parameters[param.name] = {\n        type: param.type,\n        value: param.value\n      };\n    }\n  }\n  get parameters() {\n    return Object.assign({}, this._parameters);\n  }\n  get layers() {\n    return this._layers;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/state-graph/anim-state-graph.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/app-base.js":
/*!****************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/app-base.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AppBase\": () => (/* binding */ AppBase),\n/* harmony export */   \"app\": () => (/* binding */ app)\n/* harmony export */ });\n/* harmony import */ var _core_platform_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ../core/platform.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/platform.js\");\n/* harmony import */ var _core_time_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ../core/time.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/time.js\");\n/* harmony import */ var _core_path_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ../core/path.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/path.js\");\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _core_math_color_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ../core/math/color.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n/* harmony import */ var _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ../core/math/mat4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js\");\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _core_math_quat_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ../core/math/quat.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/quat.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_graphics_device_access_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../platform/graphics/graphics-device-access.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/graphics-device-access.js\");\n/* harmony import */ var _platform_net_http_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../platform/net/http.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/net/http.js\");\n/* harmony import */ var _scene_constants_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../scene/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _scene_shader_lib_get_program_library_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../scene/shader-lib/get-program-library.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/get-program-library.js\");\n/* harmony import */ var _scene_shader_lib_program_library_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../scene/shader-lib/program-library.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/program-library.js\");\n/* harmony import */ var _scene_renderer_forward_renderer_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../scene/renderer/forward-renderer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/forward-renderer.js\");\n/* harmony import */ var _scene_frame_graph_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../scene/frame-graph.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/frame-graph.js\");\n/* harmony import */ var _scene_area_light_luts_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../scene/area-light-luts.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/area-light-luts.js\");\n/* harmony import */ var _scene_layer_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../scene/layer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/layer.js\");\n/* harmony import */ var _scene_composition_layer_composition_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../scene/composition/layer-composition.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/composition/layer-composition.js\");\n/* harmony import */ var _scene_scene_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../scene/scene.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/scene.js\");\n/* harmony import */ var _scene_materials_material_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ../scene/materials/material.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/material.js\");\n/* harmony import */ var _scene_lighting_lights_buffer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../scene/lighting/lights-buffer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/lighting/lights-buffer.js\");\n/* harmony import */ var _scene_materials_standard_material_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../scene/materials/standard-material.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material.js\");\n/* harmony import */ var _scene_materials_default_material_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../scene/materials/default-material.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/default-material.js\");\n/* harmony import */ var _asset_asset_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./asset/asset.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset.js\");\n/* harmony import */ var _asset_asset_registry_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./asset/asset-registry.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset-registry.js\");\n/* harmony import */ var _bundle_bundle_registry_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./bundle/bundle-registry.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/bundle/bundle-registry.js\");\n/* harmony import */ var _components_registry_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./components/registry.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/registry.js\");\n/* harmony import */ var _scene_graphics_scene_grab_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../scene/graphics/scene-grab.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/graphics/scene-grab.js\");\n/* harmony import */ var _handlers_bundle_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./handlers/bundle.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/bundle.js\");\n/* harmony import */ var _handlers_loader_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./handlers/loader.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/loader.js\");\n/* harmony import */ var _i18n_i18n_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./i18n/i18n.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/i18n/i18n.js\");\n/* harmony import */ var _script_script_registry_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./script/script-registry.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/script/script-registry.js\");\n/* harmony import */ var _entity_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./entity.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/entity.js\");\n/* harmony import */ var _scene_registry_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./scene-registry.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/scene-registry.js\");\n/* harmony import */ var _script_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./script.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/script.js\");\n/* harmony import */ var _stats_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./stats.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/stats.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/constants.js\");\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./globals.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/globals.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Progress {\n  constructor(length) {\n    this.length = length;\n    this.count = 0;\n  }\n  inc() {\n    this.count++;\n  }\n  done() {\n    return this.count === this.length;\n  }\n}\nlet app = null;\nclass AppBase extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor(canvas) {\n    super();\n    AppBase._applications[canvas.id] = this;\n    (0,_globals_js__WEBPACK_IMPORTED_MODULE_1__.setApplication)(this);\n    app = this;\n    this._destroyRequested = false;\n    this._inFrameUpdate = false;\n    this._time = 0;\n    this.timeScale = 1;\n    this.maxDeltaTime = 0.1;\n    this.frame = 0;\n    this.autoRender = true;\n    this.renderNextFrame = false;\n    this.useLegacyScriptAttributeCloning = _script_js__WEBPACK_IMPORTED_MODULE_2__.script.legacy;\n    this._librariesLoaded = false;\n    this._fillMode = _constants_js__WEBPACK_IMPORTED_MODULE_3__.FILLMODE_KEEP_ASPECT;\n    this._resolutionMode = _constants_js__WEBPACK_IMPORTED_MODULE_3__.RESOLUTION_FIXED;\n    this._allowResize = true;\n    this.context = this;\n  }\n  init(appOptions) {\n    const device = appOptions.graphicsDevice;\n    this.graphicsDevice = device;\n    _platform_graphics_graphics_device_access_js__WEBPACK_IMPORTED_MODULE_4__.GraphicsDeviceAccess.set(device);\n    this._initDefaultMaterial();\n    this._initProgramLibrary();\n    this.stats = new _stats_js__WEBPACK_IMPORTED_MODULE_5__.ApplicationStats(device);\n    this._soundManager = appOptions.soundManager;\n    this.loader = new _handlers_loader_js__WEBPACK_IMPORTED_MODULE_6__.ResourceLoader(this);\n    _scene_lighting_lights_buffer_js__WEBPACK_IMPORTED_MODULE_7__.LightsBuffer.init(device);\n    this._entityIndex = {};\n    this.scene = new _scene_scene_js__WEBPACK_IMPORTED_MODULE_8__.Scene(device);\n    this._registerSceneImmediate(this.scene);\n    this.root = new _entity_js__WEBPACK_IMPORTED_MODULE_9__.Entity();\n    this.root._enabledInHierarchy = true;\n    this.assets = new _asset_asset_registry_js__WEBPACK_IMPORTED_MODULE_10__.AssetRegistry(this.loader);\n    if (appOptions.assetPrefix) this.assets.prefix = appOptions.assetPrefix;\n    this.bundles = new _bundle_bundle_registry_js__WEBPACK_IMPORTED_MODULE_11__.BundleRegistry(this.assets);\n    this.enableBundles = typeof TextDecoder !== 'undefined';\n    this.scriptsOrder = appOptions.scriptsOrder || [];\n    this.scripts = new _script_script_registry_js__WEBPACK_IMPORTED_MODULE_12__.ScriptRegistry(this);\n    this.i18n = new _i18n_i18n_js__WEBPACK_IMPORTED_MODULE_13__.I18n(this);\n    this.scenes = new _scene_registry_js__WEBPACK_IMPORTED_MODULE_14__.SceneRegistry(this);\n    const self = this;\n    this.defaultLayerWorld = new _scene_layer_js__WEBPACK_IMPORTED_MODULE_15__.Layer({\n      name: \"World\",\n      id: _scene_constants_js__WEBPACK_IMPORTED_MODULE_16__.LAYERID_WORLD\n    });\n    this.sceneGrab = new _scene_graphics_scene_grab_js__WEBPACK_IMPORTED_MODULE_17__.SceneGrab(this.graphicsDevice, this.scene);\n    this.defaultLayerDepth = this.sceneGrab.layer;\n    this.defaultLayerSkybox = new _scene_layer_js__WEBPACK_IMPORTED_MODULE_15__.Layer({\n      enabled: true,\n      name: \"Skybox\",\n      id: _scene_constants_js__WEBPACK_IMPORTED_MODULE_16__.LAYERID_SKYBOX,\n      opaqueSortMode: _scene_constants_js__WEBPACK_IMPORTED_MODULE_16__.SORTMODE_NONE\n    });\n    this.defaultLayerUi = new _scene_layer_js__WEBPACK_IMPORTED_MODULE_15__.Layer({\n      enabled: true,\n      name: \"UI\",\n      id: _scene_constants_js__WEBPACK_IMPORTED_MODULE_16__.LAYERID_UI,\n      transparentSortMode: _scene_constants_js__WEBPACK_IMPORTED_MODULE_16__.SORTMODE_MANUAL,\n      passThrough: false\n    });\n    this.defaultLayerImmediate = new _scene_layer_js__WEBPACK_IMPORTED_MODULE_15__.Layer({\n      enabled: true,\n      name: \"Immediate\",\n      id: _scene_constants_js__WEBPACK_IMPORTED_MODULE_16__.LAYERID_IMMEDIATE,\n      opaqueSortMode: _scene_constants_js__WEBPACK_IMPORTED_MODULE_16__.SORTMODE_NONE,\n      passThrough: true\n    });\n    const defaultLayerComposition = new _scene_composition_layer_composition_js__WEBPACK_IMPORTED_MODULE_18__.LayerComposition(\"default\");\n    defaultLayerComposition.pushOpaque(this.defaultLayerWorld);\n    defaultLayerComposition.pushOpaque(this.defaultLayerDepth);\n    defaultLayerComposition.pushOpaque(this.defaultLayerSkybox);\n    defaultLayerComposition.pushTransparent(this.defaultLayerWorld);\n    defaultLayerComposition.pushOpaque(this.defaultLayerImmediate);\n    defaultLayerComposition.pushTransparent(this.defaultLayerImmediate);\n    defaultLayerComposition.pushTransparent(this.defaultLayerUi);\n    this.scene.layers = defaultLayerComposition;\n    this.scene.on('set:layers', function (oldComp, newComp) {\n      const list = newComp.layerList;\n      let layer;\n      for (let i = 0; i < list.length; i++) {\n        layer = list[i];\n        switch (layer.id) {\n          case _scene_constants_js__WEBPACK_IMPORTED_MODULE_16__.LAYERID_DEPTH:\n            self.sceneGrab.patch(layer);\n            break;\n          case _scene_constants_js__WEBPACK_IMPORTED_MODULE_16__.LAYERID_UI:\n            layer.passThrough = self.defaultLayerUi.passThrough;\n            break;\n          case _scene_constants_js__WEBPACK_IMPORTED_MODULE_16__.LAYERID_IMMEDIATE:\n            layer.passThrough = self.defaultLayerImmediate.passThrough;\n            break;\n        }\n      }\n    });\n    _scene_area_light_luts_js__WEBPACK_IMPORTED_MODULE_19__.AreaLightLuts.createPlaceholder(device);\n    this.renderer = new _scene_renderer_forward_renderer_js__WEBPACK_IMPORTED_MODULE_20__.ForwardRenderer(device);\n    this.renderer.scene = this.scene;\n    this.frameGraph = new _scene_frame_graph_js__WEBPACK_IMPORTED_MODULE_21__.FrameGraph();\n    this.lightmapper = null;\n    if (appOptions.lightmapper) {\n      this.lightmapper = new appOptions.lightmapper(device, this.root, this.scene, this.renderer, this.assets);\n      this.once('prerender', this._firstBake, this);\n    }\n    this._batcher = null;\n    if (appOptions.batchManager) {\n      this._batcher = new appOptions.batchManager(device, this.root, this.scene);\n      this.once('prerender', this._firstBatch, this);\n    }\n    this.keyboard = appOptions.keyboard || null;\n    this.mouse = appOptions.mouse || null;\n    this.touch = appOptions.touch || null;\n    this.gamepads = appOptions.gamepads || null;\n    this.elementInput = appOptions.elementInput || null;\n    if (this.elementInput) this.elementInput.app = this;\n    this.xr = appOptions.xr ? new appOptions.xr(this) : null;\n    if (this.elementInput) this.elementInput.attachSelectEvents();\n    this._inTools = false;\n    this._skyboxAsset = null;\n    this._scriptPrefix = appOptions.scriptPrefix || '';\n    if (this.enableBundles) {\n      this.loader.addHandler(\"bundle\", new _handlers_bundle_js__WEBPACK_IMPORTED_MODULE_22__.BundleHandler(this));\n    }\n    appOptions.resourceHandlers.forEach(resourceHandler => {\n      const handler = new resourceHandler(this);\n      this.loader.addHandler(handler.handlerType, handler);\n    });\n    this.systems = new _components_registry_js__WEBPACK_IMPORTED_MODULE_23__.ComponentSystemRegistry();\n    appOptions.componentSystems.forEach(componentSystem => {\n      this.systems.add(new componentSystem(this));\n    });\n    this._visibilityChangeHandler = this.onVisibilityChange.bind(this);\n    if (typeof document !== 'undefined') {\n      if (document.hidden !== undefined) {\n        this._hiddenAttr = 'hidden';\n        document.addEventListener('visibilitychange', this._visibilityChangeHandler, false);\n      } else if (document.mozHidden !== undefined) {\n        this._hiddenAttr = 'mozHidden';\n        document.addEventListener('mozvisibilitychange', this._visibilityChangeHandler, false);\n      } else if (document.msHidden !== undefined) {\n        this._hiddenAttr = 'msHidden';\n        document.addEventListener('msvisibilitychange', this._visibilityChangeHandler, false);\n      } else if (document.webkitHidden !== undefined) {\n        this._hiddenAttr = 'webkitHidden';\n        document.addEventListener('webkitvisibilitychange', this._visibilityChangeHandler, false);\n      }\n    }\n    this.tick = makeTick(this);\n  }\n  static getApplication(id) {\n    return id ? AppBase._applications[id] : (0,_globals_js__WEBPACK_IMPORTED_MODULE_1__.getApplication)();\n  }\n  _initDefaultMaterial() {\n    const material = new _scene_materials_standard_material_js__WEBPACK_IMPORTED_MODULE_24__.StandardMaterial();\n    material.name = \"Default Material\";\n    material.shadingModel = _scene_constants_js__WEBPACK_IMPORTED_MODULE_16__.SPECULAR_BLINN;\n    (0,_scene_materials_default_material_js__WEBPACK_IMPORTED_MODULE_25__.setDefaultMaterial)(this.graphicsDevice, material);\n  }\n  _initProgramLibrary() {\n    const library = new _scene_shader_lib_program_library_js__WEBPACK_IMPORTED_MODULE_26__.ProgramLibrary(this.graphicsDevice, new _scene_materials_standard_material_js__WEBPACK_IMPORTED_MODULE_24__.StandardMaterial());\n    (0,_scene_shader_lib_get_program_library_js__WEBPACK_IMPORTED_MODULE_27__.setProgramLibrary)(this.graphicsDevice, library);\n  }\n  get soundManager() {\n    return this._soundManager;\n  }\n  get batcher() {\n    return this._batcher;\n  }\n  get fillMode() {\n    return this._fillMode;\n  }\n  get resolutionMode() {\n    return this._resolutionMode;\n  }\n  configure(url, callback) {\n    _platform_net_http_js__WEBPACK_IMPORTED_MODULE_28__.http.get(url, (err, response) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n      const props = response.application_properties;\n      const scenes = response.scenes;\n      const assets = response.assets;\n      this._parseApplicationProperties(props, err => {\n        this._parseScenes(scenes);\n        this._parseAssets(assets);\n        if (!err) {\n          callback(null);\n        } else {\n          callback(err);\n        }\n      });\n    });\n  }\n  preload(callback) {\n    this.fire(\"preload:start\");\n    const assets = this.assets.list({\n      preload: true\n    });\n    const progress = new Progress(assets.length);\n    let _done = false;\n    const done = () => {\n      if (!this.graphicsDevice) {\n        return;\n      }\n      if (!_done && progress.done()) {\n        _done = true;\n        this.fire(\"preload:end\");\n        callback();\n      }\n    };\n    const total = assets.length;\n    if (progress.length) {\n      const onAssetLoad = asset => {\n        progress.inc();\n        this.fire('preload:progress', progress.count / total);\n        if (progress.done()) done();\n      };\n      const onAssetError = (err, asset) => {\n        progress.inc();\n        this.fire('preload:progress', progress.count / total);\n        if (progress.done()) done();\n      };\n      for (let i = 0; i < assets.length; i++) {\n        if (!assets[i].loaded) {\n          assets[i].once('load', onAssetLoad);\n          assets[i].once('error', onAssetError);\n          this.assets.load(assets[i]);\n        } else {\n          progress.inc();\n          this.fire(\"preload:progress\", progress.count / total);\n          if (progress.done()) done();\n        }\n      }\n    } else {\n      done();\n    }\n  }\n  _preloadScripts(sceneData, callback) {\n    if (!_script_js__WEBPACK_IMPORTED_MODULE_2__.script.legacy) {\n      callback();\n      return;\n    }\n    this.systems.script.preloading = true;\n    const scripts = this._getScriptReferences(sceneData);\n    const l = scripts.length;\n    const progress = new Progress(l);\n    const regex = /^http(s)?:\\/\\//;\n    if (l) {\n      const onLoad = (err, ScriptType) => {\n        if (err) console.error(err);\n        progress.inc();\n        if (progress.done()) {\n          this.systems.script.preloading = false;\n          callback();\n        }\n      };\n      for (let i = 0; i < l; i++) {\n        let scriptUrl = scripts[i];\n        if (!regex.test(scriptUrl.toLowerCase()) && this._scriptPrefix) scriptUrl = _core_path_js__WEBPACK_IMPORTED_MODULE_29__.path.join(this._scriptPrefix, scripts[i]);\n        this.loader.load(scriptUrl, 'script', onLoad);\n      }\n    } else {\n      this.systems.script.preloading = false;\n      callback();\n    }\n  }\n  _parseApplicationProperties(props, callback) {\n    if (typeof props.maxAssetRetries === 'number' && props.maxAssetRetries > 0) {\n      this.loader.enableRetry(props.maxAssetRetries);\n    }\n    if (!props.useDevicePixelRatio) props.useDevicePixelRatio = props.use_device_pixel_ratio;\n    if (!props.resolutionMode) props.resolutionMode = props.resolution_mode;\n    if (!props.fillMode) props.fillMode = props.fill_mode;\n    this._width = props.width;\n    this._height = props.height;\n    if (props.useDevicePixelRatio) {\n      this.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n    }\n    this.setCanvasResolution(props.resolutionMode, this._width, this._height);\n    this.setCanvasFillMode(props.fillMode, this._width, this._height);\n    if (props.layers && props.layerOrder) {\n      const composition = new _scene_composition_layer_composition_js__WEBPACK_IMPORTED_MODULE_18__.LayerComposition(\"application\");\n      const layers = {};\n      for (const key in props.layers) {\n        const data = props.layers[key];\n        data.id = parseInt(key, 10);\n        data.enabled = data.id !== _scene_constants_js__WEBPACK_IMPORTED_MODULE_16__.LAYERID_DEPTH;\n        layers[key] = new _scene_layer_js__WEBPACK_IMPORTED_MODULE_15__.Layer(data);\n      }\n      for (let i = 0, len = props.layerOrder.length; i < len; i++) {\n        const sublayer = props.layerOrder[i];\n        const layer = layers[sublayer.layer];\n        if (!layer) continue;\n        if (sublayer.transparent) {\n          composition.pushTransparent(layer);\n        } else {\n          composition.pushOpaque(layer);\n        }\n        composition.subLayerEnabled[i] = sublayer.enabled;\n      }\n      this.scene.layers = composition;\n    }\n    if (props.batchGroups) {\n      const batcher = this.batcher;\n      if (batcher) {\n        for (let i = 0, len = props.batchGroups.length; i < len; i++) {\n          const grp = props.batchGroups[i];\n          batcher.addGroup(grp.name, grp.dynamic, grp.maxAabbSize, grp.id, grp.layers);\n        }\n      }\n    }\n    if (props.i18nAssets) {\n      this.i18n.assets = props.i18nAssets;\n    }\n    this._loadLibraries(props.libraries, callback);\n  }\n  _loadLibraries(urls, callback) {\n    const len = urls.length;\n    let count = len;\n    const regex = /^http(s)?:\\/\\//;\n    if (len) {\n      const onLoad = (err, script) => {\n        count--;\n        if (err) {\n          callback(err);\n        } else if (count === 0) {\n          this.onLibrariesLoaded();\n          callback(null);\n        }\n      };\n      for (let i = 0; i < len; ++i) {\n        let url = urls[i];\n        if (!regex.test(url.toLowerCase()) && this._scriptPrefix) url = _core_path_js__WEBPACK_IMPORTED_MODULE_29__.path.join(this._scriptPrefix, url);\n        this.loader.load(url, 'script', onLoad);\n      }\n    } else {\n      this.onLibrariesLoaded();\n      callback(null);\n    }\n  }\n  _parseScenes(scenes) {\n    if (!scenes) return;\n    for (let i = 0; i < scenes.length; i++) {\n      this.scenes.add(scenes[i].name, scenes[i].url);\n    }\n  }\n  _parseAssets(assets) {\n    const list = [];\n    const scriptsIndex = {};\n    const bundlesIndex = {};\n    if (!_script_js__WEBPACK_IMPORTED_MODULE_2__.script.legacy) {\n      for (let i = 0; i < this.scriptsOrder.length; i++) {\n        const id = this.scriptsOrder[i];\n        if (!assets[id]) continue;\n        scriptsIndex[id] = true;\n        list.push(assets[id]);\n      }\n      if (this.enableBundles) {\n        for (const id in assets) {\n          if (assets[id].type === 'bundle') {\n            bundlesIndex[id] = true;\n            list.push(assets[id]);\n          }\n        }\n      }\n      for (const id in assets) {\n        if (scriptsIndex[id] || bundlesIndex[id]) continue;\n        list.push(assets[id]);\n      }\n    } else {\n      if (this.enableBundles) {\n        for (const id in assets) {\n          if (assets[id].type === 'bundle') {\n            bundlesIndex[id] = true;\n            list.push(assets[id]);\n          }\n        }\n      }\n      for (const id in assets) {\n        if (bundlesIndex[id]) continue;\n        list.push(assets[id]);\n      }\n    }\n    for (let i = 0; i < list.length; i++) {\n      const data = list[i];\n      const asset = new _asset_asset_js__WEBPACK_IMPORTED_MODULE_30__.Asset(data.name, data.type, data.file, data.data);\n      asset.id = parseInt(data.id, 10);\n      asset.preload = data.preload ? data.preload : false;\n      asset.loaded = data.type === 'script' && data.data && data.data.loadingType > 0;\n      asset.tags.add(data.tags);\n      if (data.i18n) {\n        for (const locale in data.i18n) {\n          asset.addLocalizedAssetId(locale, data.i18n[locale]);\n        }\n      }\n      this.assets.add(asset);\n    }\n  }\n  _getScriptReferences(scene) {\n    let priorityScripts = [];\n    if (scene.settings.priority_scripts) {\n      priorityScripts = scene.settings.priority_scripts;\n    }\n    const _scripts = [];\n    const _index = {};\n    for (let i = 0; i < priorityScripts.length; i++) {\n      _scripts.push(priorityScripts[i]);\n      _index[priorityScripts[i]] = true;\n    }\n    const entities = scene.entities;\n    for (const key in entities) {\n      if (!entities[key].components.script) {\n        continue;\n      }\n      const scripts = entities[key].components.script.scripts;\n      for (let i = 0; i < scripts.length; i++) {\n        if (_index[scripts[i].url]) continue;\n        _scripts.push(scripts[i].url);\n        _index[scripts[i].url] = true;\n      }\n    }\n    return _scripts;\n  }\n  start() {\n    this.frame = 0;\n    this.fire(\"start\", {\n      timestamp: (0,_core_time_js__WEBPACK_IMPORTED_MODULE_31__.now)(),\n      target: this\n    });\n    if (!this._librariesLoaded) {\n      this.onLibrariesLoaded();\n    }\n    this.systems.fire('initialize', this.root);\n    this.fire('initialize');\n    this.systems.fire('postInitialize', this.root);\n    this.systems.fire('postPostInitialize', this.root);\n    this.fire('postinitialize');\n    this.tick();\n  }\n  inputUpdate(dt) {\n    if (this.controller) {\n      this.controller.update(dt);\n    }\n    if (this.mouse) {\n      this.mouse.update();\n    }\n    if (this.keyboard) {\n      this.keyboard.update();\n    }\n    if (this.gamepads) {\n      this.gamepads.update();\n    }\n  }\n  update(dt) {\n    this.frame++;\n    this.graphicsDevice.updateClientRect();\n    if (_script_js__WEBPACK_IMPORTED_MODULE_2__.script.legacy) this.systems.fire('fixedUpdate', 1.0 / 60.0);\n    this.systems.fire(this._inTools ? 'toolsUpdate' : 'update', dt);\n    this.systems.fire('animationUpdate', dt);\n    this.systems.fire('postUpdate', dt);\n    this.fire(\"update\", dt);\n    this.inputUpdate(dt);\n  }\n  render() {\n    this.fire('prerender');\n    this.root.syncHierarchy();\n    if (this._batcher) {\n      this._batcher.updateAll();\n    }\n    this.renderComposition(this.scene.layers);\n    this.fire('postrender');\n  }\n  renderComposition(layerComposition) {\n    this.renderer.buildFrameGraph(this.frameGraph, layerComposition);\n    this.frameGraph.render(this.graphicsDevice);\n  }\n  _fillFrameStatsBasic(now, dt, ms) {\n    const stats = this.stats.frame;\n    stats.dt = dt;\n    stats.ms = ms;\n    if (now > stats._timeToCountFrames) {\n      stats.fps = stats._fpsAccum;\n      stats._fpsAccum = 0;\n      stats._timeToCountFrames = now + 1000;\n    } else {\n      stats._fpsAccum++;\n    }\n    this.stats.drawCalls.total = this.graphicsDevice._drawCallsPerFrame;\n    this.graphicsDevice._drawCallsPerFrame = 0;\n  }\n  _fillFrameStats() {\n    let stats = this.stats.frame;\n    stats.cameras = this.renderer._camerasRendered;\n    stats.materials = this.renderer._materialSwitches;\n    stats.shaders = this.graphicsDevice._shaderSwitchesPerFrame;\n    stats.shadowMapUpdates = this.renderer._shadowMapUpdates;\n    stats.shadowMapTime = this.renderer._shadowMapTime;\n    stats.depthMapTime = this.renderer._depthMapTime;\n    stats.forwardTime = this.renderer._forwardTime;\n    const prims = this.graphicsDevice._primsPerFrame;\n    stats.triangles = prims[_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_32__.PRIMITIVE_TRIANGLES] / 3 + Math.max(prims[_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_32__.PRIMITIVE_TRISTRIP] - 2, 0) + Math.max(prims[_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_32__.PRIMITIVE_TRIFAN] - 2, 0);\n    stats.cullTime = this.renderer._cullTime;\n    stats.sortTime = this.renderer._sortTime;\n    stats.skinTime = this.renderer._skinTime;\n    stats.morphTime = this.renderer._morphTime;\n    stats.lightClusters = this.renderer._lightClusters;\n    stats.lightClustersTime = this.renderer._lightClustersTime;\n    stats.otherPrimitives = 0;\n    for (let i = 0; i < prims.length; i++) {\n      if (i < _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_32__.PRIMITIVE_TRIANGLES) {\n        stats.otherPrimitives += prims[i];\n      }\n      prims[i] = 0;\n    }\n    this.renderer._camerasRendered = 0;\n    this.renderer._materialSwitches = 0;\n    this.renderer._shadowMapUpdates = 0;\n    this.graphicsDevice._shaderSwitchesPerFrame = 0;\n    this.renderer._cullTime = 0;\n    this.renderer._layerCompositionUpdateTime = 0;\n    this.renderer._lightClustersTime = 0;\n    this.renderer._sortTime = 0;\n    this.renderer._skinTime = 0;\n    this.renderer._morphTime = 0;\n    this.renderer._shadowMapTime = 0;\n    this.renderer._depthMapTime = 0;\n    this.renderer._forwardTime = 0;\n    stats = this.stats.drawCalls;\n    stats.forward = this.renderer._forwardDrawCalls;\n    stats.culled = this.renderer._numDrawCallsCulled;\n    stats.depth = 0;\n    stats.shadow = this.renderer._shadowDrawCalls;\n    stats.skinned = this.renderer._skinDrawCalls;\n    stats.immediate = 0;\n    stats.instanced = 0;\n    stats.removedByInstancing = 0;\n    stats.misc = stats.total - (stats.forward + stats.shadow);\n    this.renderer._depthDrawCalls = 0;\n    this.renderer._shadowDrawCalls = 0;\n    this.renderer._forwardDrawCalls = 0;\n    this.renderer._numDrawCallsCulled = 0;\n    this.renderer._skinDrawCalls = 0;\n    this.renderer._immediateRendered = 0;\n    this.renderer._instancedDrawCalls = 0;\n    this.stats.misc.renderTargetCreationTime = this.graphicsDevice.renderTargetCreationTime;\n    stats = this.stats.particles;\n    stats.updatesPerFrame = stats._updatesPerFrame;\n    stats.frameTime = stats._frameTime;\n    stats._updatesPerFrame = 0;\n    stats._frameTime = 0;\n  }\n  setCanvasFillMode(mode, width, height) {\n    this._fillMode = mode;\n    this.resizeCanvas(width, height);\n  }\n  setCanvasResolution(mode, width, height) {\n    this._resolutionMode = mode;\n    if (mode === _constants_js__WEBPACK_IMPORTED_MODULE_3__.RESOLUTION_AUTO && width === undefined) {\n      width = this.graphicsDevice.canvas.clientWidth;\n      height = this.graphicsDevice.canvas.clientHeight;\n    }\n    this.graphicsDevice.resizeCanvas(width, height);\n  }\n  isHidden() {\n    return document[this._hiddenAttr];\n  }\n  onVisibilityChange() {\n    if (this.isHidden()) {\n      if (this._soundManager) {\n        this._soundManager.suspend();\n      }\n    } else {\n      if (this._soundManager) {\n        this._soundManager.resume();\n      }\n    }\n  }\n  resizeCanvas(width, height) {\n    if (!this._allowResize) return undefined;\n    if (this.xr && this.xr.session) return undefined;\n    const windowWidth = window.innerWidth;\n    const windowHeight = window.innerHeight;\n    if (this._fillMode === _constants_js__WEBPACK_IMPORTED_MODULE_3__.FILLMODE_KEEP_ASPECT) {\n      const r = this.graphicsDevice.canvas.width / this.graphicsDevice.canvas.height;\n      const winR = windowWidth / windowHeight;\n      if (r > winR) {\n        width = windowWidth;\n        height = width / r;\n      } else {\n        height = windowHeight;\n        width = height * r;\n      }\n    } else if (this._fillMode === _constants_js__WEBPACK_IMPORTED_MODULE_3__.FILLMODE_FILL_WINDOW) {\n      width = windowWidth;\n      height = windowHeight;\n    }\n    this.graphicsDevice.canvas.style.width = width + 'px';\n    this.graphicsDevice.canvas.style.height = height + 'px';\n    this.updateCanvasSize();\n    return {\n      width: width,\n      height: height\n    };\n  }\n  updateCanvasSize() {\n    var _this$xr;\n    if (!this._allowResize || (_this$xr = this.xr) != null && _this$xr.active) {\n      return;\n    }\n    if (this._resolutionMode === _constants_js__WEBPACK_IMPORTED_MODULE_3__.RESOLUTION_AUTO) {\n      const canvas = this.graphicsDevice.canvas;\n      this.graphicsDevice.resizeCanvas(canvas.clientWidth, canvas.clientHeight);\n    }\n  }\n  onLibrariesLoaded() {\n    this._librariesLoaded = true;\n    if (this.systems.rigidbody) {\n      this.systems.rigidbody.onLibraryLoaded();\n    }\n  }\n  applySceneSettings(settings) {\n    let asset;\n    if (this.systems.rigidbody && typeof Ammo !== 'undefined') {\n      const gravity = settings.physics.gravity;\n      this.systems.rigidbody.gravity.set(gravity[0], gravity[1], gravity[2]);\n    }\n    this.scene.applySettings(settings);\n    if (settings.render.hasOwnProperty('skybox')) {\n      if (settings.render.skybox) {\n        asset = this.assets.get(settings.render.skybox);\n        if (asset) {\n          this.setSkybox(asset);\n        } else {\n          this.assets.once('add:' + settings.render.skybox, this.setSkybox, this);\n        }\n      } else {\n        this.setSkybox(null);\n      }\n    }\n  }\n  setAreaLightLuts(ltcMat1, ltcMat2) {\n    if (ltcMat1 && ltcMat2) {\n      _scene_area_light_luts_js__WEBPACK_IMPORTED_MODULE_19__.AreaLightLuts.set(this.graphicsDevice, ltcMat1, ltcMat2);\n    }\n  }\n  setSkybox(asset) {\n    if (asset !== this._skyboxAsset) {\n      const onSkyboxRemoved = () => {\n        this.setSkybox(null);\n      };\n      const onSkyboxChanged = () => {\n        this.scene.setSkybox(this._skyboxAsset ? this._skyboxAsset.resources : null);\n      };\n      if (this._skyboxAsset) {\n        this.assets.off('load:' + this._skyboxAsset.id, onSkyboxChanged, this);\n        this.assets.off('remove:' + this._skyboxAsset.id, onSkyboxRemoved, this);\n        this._skyboxAsset.off('change', onSkyboxChanged, this);\n      }\n      this._skyboxAsset = asset;\n      if (this._skyboxAsset) {\n        this.assets.on('load:' + this._skyboxAsset.id, onSkyboxChanged, this);\n        this.assets.once('remove:' + this._skyboxAsset.id, onSkyboxRemoved, this);\n        this._skyboxAsset.on('change', onSkyboxChanged, this);\n        if (this.scene.skyboxMip === 0 && !this._skyboxAsset.loadFaces) {\n          this._skyboxAsset.loadFaces = true;\n        }\n        this.assets.load(this._skyboxAsset);\n      }\n      onSkyboxChanged();\n    }\n  }\n  _firstBake() {\n    var _this$lightmapper;\n    (_this$lightmapper = this.lightmapper) == null ? void 0 : _this$lightmapper.bake(null, this.scene.lightmapMode);\n  }\n  _firstBatch() {\n    var _this$batcher;\n    (_this$batcher = this.batcher) == null ? void 0 : _this$batcher.generate();\n  }\n  _processTimestamp(timestamp) {\n    return timestamp;\n  }\n  drawLine(start, end, color, depthTest, layer) {\n    this.scene.drawLine(start, end, color, depthTest, layer);\n  }\n  drawLines(positions, colors, depthTest = true, layer = this.scene.defaultDrawLayer) {\n    this.scene.drawLines(positions, colors, depthTest, layer);\n  }\n  drawLineArrays(positions, colors, depthTest = true, layer = this.scene.defaultDrawLayer) {\n    this.scene.drawLineArrays(positions, colors, depthTest, layer);\n  }\n  drawWireSphere(center, radius, color = _core_math_color_js__WEBPACK_IMPORTED_MODULE_33__.Color.WHITE, segments = 20, depthTest = true, layer = this.scene.defaultDrawLayer) {\n    this.scene.immediate.drawWireSphere(center, radius, color, segments, depthTest, layer);\n  }\n  drawWireAlignedBox(minPoint, maxPoint, color = _core_math_color_js__WEBPACK_IMPORTED_MODULE_33__.Color.WHITE, depthTest = true, layer = this.scene.defaultDrawLayer) {\n    this.scene.immediate.drawWireAlignedBox(minPoint, maxPoint, color, depthTest, layer);\n  }\n  drawMeshInstance(meshInstance, layer = this.scene.defaultDrawLayer) {\n    this.scene.immediate.drawMesh(null, null, null, meshInstance, layer);\n  }\n  drawMesh(mesh, material, matrix, layer = this.scene.defaultDrawLayer) {\n    this.scene.immediate.drawMesh(material, matrix, mesh, null, layer);\n  }\n  drawQuad(matrix, material, layer = this.scene.defaultDrawLayer) {\n    this.scene.immediate.drawMesh(material, matrix, this.scene.immediate.getQuadMesh(), null, layer);\n  }\n  drawTexture(x, y, width, height, texture, material, layer = this.scene.defaultDrawLayer) {\n    const matrix = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_34__.Mat4();\n    matrix.setTRS(new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_35__.Vec3(x, y, 0.0), _core_math_quat_js__WEBPACK_IMPORTED_MODULE_36__.Quat.IDENTITY, new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_35__.Vec3(width, height, 0.0));\n    if (!material) {\n      material = new _scene_materials_material_js__WEBPACK_IMPORTED_MODULE_37__.Material();\n      material.setParameter(\"colorMap\", texture);\n      material.shader = this.scene.immediate.getTextureShader();\n      material.update();\n    }\n    this.drawQuad(matrix, material, layer);\n  }\n  drawDepthTexture(x, y, width, height, layer = this.scene.defaultDrawLayer) {\n    const material = new _scene_materials_material_js__WEBPACK_IMPORTED_MODULE_37__.Material();\n    material.shader = this.scene.immediate.getDepthTextureShader();\n    material.update();\n    this.drawTexture(x, y, width, height, null, material, layer);\n  }\n  destroy() {\n    var _this$lightmapper2;\n    if (this._inFrameUpdate) {\n      this._destroyRequested = true;\n      return;\n    }\n    const canvasId = this.graphicsDevice.canvas.id;\n    this.off('librariesloaded');\n    if (typeof document !== 'undefined') {\n      document.removeEventListener('visibilitychange', this._visibilityChangeHandler, false);\n      document.removeEventListener('mozvisibilitychange', this._visibilityChangeHandler, false);\n      document.removeEventListener('msvisibilitychange', this._visibilityChangeHandler, false);\n      document.removeEventListener('webkitvisibilitychange', this._visibilityChangeHandler, false);\n    }\n    this._visibilityChangeHandler = null;\n    this.root.destroy();\n    this.root = null;\n    if (this.mouse) {\n      this.mouse.off();\n      this.mouse.detach();\n      this.mouse = null;\n    }\n    if (this.keyboard) {\n      this.keyboard.off();\n      this.keyboard.detach();\n      this.keyboard = null;\n    }\n    if (this.touch) {\n      this.touch.off();\n      this.touch.detach();\n      this.touch = null;\n    }\n    if (this.elementInput) {\n      this.elementInput.detach();\n      this.elementInput = null;\n    }\n    if (this.controller) {\n      this.controller = null;\n    }\n    this.systems.destroy();\n    if (this.scene.layers) {\n      this.scene.layers.destroy();\n    }\n    const assets = this.assets.list();\n    for (let i = 0; i < assets.length; i++) {\n      assets[i].unload();\n      assets[i].off();\n    }\n    this.assets.off();\n    this.bundles.destroy();\n    this.bundles = null;\n    this.i18n.destroy();\n    this.i18n = null;\n    for (const key in this.loader.getHandler('script')._cache) {\n      const element = this.loader.getHandler('script')._cache[key];\n      const parent = element.parentNode;\n      if (parent) parent.removeChild(element);\n    }\n    this.loader.getHandler('script')._cache = {};\n    this.loader.destroy();\n    this.loader = null;\n    this.scene.destroy();\n    this.scene = null;\n    this.systems = null;\n    this.context = null;\n    this.scripts.destroy();\n    this.scripts = null;\n    this.scenes.destroy();\n    this.scenes = null;\n    (_this$lightmapper2 = this.lightmapper) == null ? void 0 : _this$lightmapper2.destroy();\n    this.lightmapper = null;\n    if (this._batcher) {\n      this._batcher.destroy();\n      this._batcher = null;\n    }\n    this._entityIndex = {};\n    this.defaultLayerDepth.onPreRenderOpaque = null;\n    this.defaultLayerDepth.onPostRenderOpaque = null;\n    this.defaultLayerDepth.onDisable = null;\n    this.defaultLayerDepth.onEnable = null;\n    this.defaultLayerDepth = null;\n    this.defaultLayerWorld = null;\n    this == null ? void 0 : this.xr.end();\n    this == null ? void 0 : this.xr.destroy();\n    this.renderer.destroy();\n    this.renderer = null;\n    this.graphicsDevice.destroy();\n    this.graphicsDevice = null;\n    this.tick = null;\n    this.off();\n    if (this._soundManager) {\n      this._soundManager.destroy();\n      this._soundManager = null;\n    }\n    _script_js__WEBPACK_IMPORTED_MODULE_2__.script.app = null;\n    AppBase._applications[canvasId] = null;\n    if ((0,_globals_js__WEBPACK_IMPORTED_MODULE_1__.getApplication)() === this) {\n      (0,_globals_js__WEBPACK_IMPORTED_MODULE_1__.setApplication)(null);\n    }\n  }\n  getEntityFromIndex(guid) {\n    return this._entityIndex[guid];\n  }\n  _registerSceneImmediate(scene) {\n    this.on('postrender', scene.immediate.onPostRender, scene.immediate);\n  }\n}\nAppBase._applications = {};\nconst _frameEndData = {};\nconst makeTick = function makeTick(_app) {\n  const application = _app;\n  let frameRequest;\n  return function (timestamp, frame) {\n    var _application$xr;\n    if (!application.graphicsDevice) return;\n    (0,_globals_js__WEBPACK_IMPORTED_MODULE_1__.setApplication)(application);\n    if (frameRequest) {\n      window.cancelAnimationFrame(frameRequest);\n      frameRequest = null;\n    }\n    app = application;\n    const currentTime = application._processTimestamp(timestamp) || (0,_core_time_js__WEBPACK_IMPORTED_MODULE_31__.now)();\n    const ms = currentTime - (application._time || currentTime);\n    let dt = ms / 1000.0;\n    dt = _core_math_math_js__WEBPACK_IMPORTED_MODULE_38__.math.clamp(dt, 0, application.maxDeltaTime);\n    dt *= application.timeScale;\n    application._time = currentTime;\n    if ((_application$xr = application.xr) != null && _application$xr.session) {\n      frameRequest = application.xr.session.requestAnimationFrame(application.tick);\n    } else {\n      frameRequest = _core_platform_js__WEBPACK_IMPORTED_MODULE_39__.platform.browser ? window.requestAnimationFrame(application.tick) : null;\n    }\n    if (application.graphicsDevice.contextLost) return;\n    application._fillFrameStatsBasic(currentTime, dt, ms);\n    application._inFrameUpdate = true;\n    application.fire(\"frameupdate\", ms);\n    let shouldRenderFrame = true;\n    if (frame) {\n      var _application$xr2;\n      shouldRenderFrame = (_application$xr2 = application.xr) == null ? void 0 : _application$xr2.update(frame);\n      application.graphicsDevice.defaultFramebuffer = frame.session.renderState.baseLayer.framebuffer;\n    } else {\n      application.graphicsDevice.defaultFramebuffer = null;\n    }\n    if (shouldRenderFrame) {\n      application.update(dt);\n      application.fire(\"framerender\");\n      if (application.autoRender || application.renderNextFrame) {\n        application.updateCanvasSize();\n        application.render();\n        application.renderNextFrame = false;\n      }\n      _frameEndData.timestamp = (0,_core_time_js__WEBPACK_IMPORTED_MODULE_31__.now)();\n      _frameEndData.target = application;\n      application.fire(\"frameend\", _frameEndData);\n    }\n    application._inFrameUpdate = false;\n    if (application._destroyRequested) {\n      application.destroy();\n    }\n  };\n};\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/app-base.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/app-options.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/app-options.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AppOptions\": () => (/* binding */ AppOptions)\n/* harmony export */ });\nclass AppOptions {\n  constructor() {\n    this.elementInput = void 0;\n    this.keyboard = void 0;\n    this.mouse = void 0;\n    this.touch = void 0;\n    this.gamepads = void 0;\n    this.scriptPrefix = void 0;\n    this.assetPrefix = void 0;\n    this.scriptsOrder = void 0;\n    this.soundManager = void 0;\n    this.graphicsDevice = void 0;\n    this.lightmapper = void 0;\n    this.batchManager = void 0;\n    this.xr = void 0;\n    this.componentSystems = [];\n    this.resourceHandlers = [];\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/app-options.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/application.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/application.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Application\": () => (/* binding */ Application)\n/* harmony export */ });\n/* harmony import */ var _core_platform_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/platform.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/platform.js\");\n/* harmony import */ var _platform_graphics_webgl_webgl_graphics_device_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../platform/graphics/webgl/webgl-graphics-device.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-graphics-device.js\");\n/* harmony import */ var _platform_sound_manager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../platform/sound/manager.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/sound/manager.js\");\n/* harmony import */ var _lightmapper_lightmapper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lightmapper/lightmapper.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/lightmapper/lightmapper.js\");\n/* harmony import */ var _scene_batching_batch_manager_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../scene/batching/batch-manager.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/batching/batch-manager.js\");\n/* harmony import */ var _app_base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./app-base.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/app-base.js\");\n/* harmony import */ var _app_options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./app-options.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/app-options.js\");\n/* harmony import */ var _script_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./script.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/script.js\");\n/* harmony import */ var _components_animation_system_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./components/animation/system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/animation/system.js\");\n/* harmony import */ var _components_anim_system_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./components/anim/system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/anim/system.js\");\n/* harmony import */ var _components_audio_listener_system_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./components/audio-listener/system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/audio-listener/system.js\");\n/* harmony import */ var _components_audio_source_system_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./components/audio-source/system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/audio-source/system.js\");\n/* harmony import */ var _components_button_system_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./components/button/system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/button/system.js\");\n/* harmony import */ var _components_collision_system_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./components/collision/system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/collision/system.js\");\n/* harmony import */ var _components_element_system_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./components/element/system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/system.js\");\n/* harmony import */ var _components_joint_system_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./components/joint/system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/joint/system.js\");\n/* harmony import */ var _components_layout_child_system_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./components/layout-child/system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-child/system.js\");\n/* harmony import */ var _components_layout_group_system_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./components/layout-group/system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-group/system.js\");\n/* harmony import */ var _components_model_system_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./components/model/system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/model/system.js\");\n/* harmony import */ var _components_particle_system_system_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./components/particle-system/system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/particle-system/system.js\");\n/* harmony import */ var _components_render_system_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./components/render/system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/render/system.js\");\n/* harmony import */ var _components_rigid_body_system_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./components/rigid-body/system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/rigid-body/system.js\");\n/* harmony import */ var _components_screen_system_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./components/screen/system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/screen/system.js\");\n/* harmony import */ var _components_script_legacy_system_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./components/script-legacy/system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/script-legacy/system.js\");\n/* harmony import */ var _components_scroll_view_system_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./components/scroll-view/system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/scroll-view/system.js\");\n/* harmony import */ var _components_scrollbar_system_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./components/scrollbar/system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/scrollbar/system.js\");\n/* harmony import */ var _components_sound_system_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./components/sound/system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sound/system.js\");\n/* harmony import */ var _components_sprite_system_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./components/sprite/system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sprite/system.js\");\n/* harmony import */ var _components_zone_system_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./components/zone/system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/zone/system.js\");\n/* harmony import */ var _components_camera_system_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./components/camera/system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/camera/system.js\");\n/* harmony import */ var _components_light_system_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./components/light/system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/light/system.js\");\n/* harmony import */ var _components_script_system_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./components/script/system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/script/system.js\");\n/* harmony import */ var _handlers_render_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./handlers/render.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/render.js\");\n/* harmony import */ var _handlers_animation_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./handlers/animation.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/animation.js\");\n/* harmony import */ var _handlers_anim_clip_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./handlers/anim-clip.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/anim-clip.js\");\n/* harmony import */ var _handlers_anim_state_graph_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./handlers/anim-state-graph.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/anim-state-graph.js\");\n/* harmony import */ var _handlers_audio_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./handlers/audio.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/audio.js\");\n/* harmony import */ var _handlers_binary_js__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./handlers/binary.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/binary.js\");\n/* harmony import */ var _handlers_container_js__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./handlers/container.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/container.js\");\n/* harmony import */ var _handlers_css_js__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./handlers/css.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/css.js\");\n/* harmony import */ var _handlers_cubemap_js__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./handlers/cubemap.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/cubemap.js\");\n/* harmony import */ var _handlers_folder_js__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./handlers/folder.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/folder.js\");\n/* harmony import */ var _handlers_font_js__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./handlers/font.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/font.js\");\n/* harmony import */ var _handlers_hierarchy_js__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./handlers/hierarchy.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/hierarchy.js\");\n/* harmony import */ var _handlers_html_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./handlers/html.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/html.js\");\n/* harmony import */ var _handlers_json_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./handlers/json.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/json.js\");\n/* harmony import */ var _handlers_material_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./handlers/material.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/material.js\");\n/* harmony import */ var _handlers_model_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./handlers/model.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/model.js\");\n/* harmony import */ var _handlers_scene_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./handlers/scene.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/scene.js\");\n/* harmony import */ var _handlers_script_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./handlers/script.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/script.js\");\n/* harmony import */ var _handlers_shader_js__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./handlers/shader.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/shader.js\");\n/* harmony import */ var _handlers_sprite_js__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./handlers/sprite.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/sprite.js\");\n/* harmony import */ var _handlers_template_js__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./handlers/template.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/template.js\");\n/* harmony import */ var _handlers_text_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./handlers/text.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/text.js\");\n/* harmony import */ var _handlers_texture_atlas_js__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./handlers/texture-atlas.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/texture-atlas.js\");\n/* harmony import */ var _handlers_texture_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./handlers/texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/texture.js\");\n/* harmony import */ var _xr_xr_manager_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./xr/xr-manager.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-manager.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Application extends _app_base_js__WEBPACK_IMPORTED_MODULE_0__.AppBase {\n  constructor(canvas, options = {}) {\n    super(canvas);\n    const appOptions = new _app_options_js__WEBPACK_IMPORTED_MODULE_1__.AppOptions();\n    appOptions.graphicsDevice = this.createDevice(canvas, options);\n    this.addComponentSystems(appOptions);\n    this.addResourceHandles(appOptions);\n    appOptions.elementInput = options.elementInput;\n    appOptions.keyboard = options.keyboard;\n    appOptions.mouse = options.mouse;\n    appOptions.touch = options.touch;\n    appOptions.gamepads = options.gamepads;\n    appOptions.scriptPrefix = options.scriptPrefix;\n    appOptions.assetPrefix = options.assetPrefix;\n    appOptions.scriptsOrder = options.scriptsOrder;\n    appOptions.soundManager = new _platform_sound_manager_js__WEBPACK_IMPORTED_MODULE_2__.SoundManager();\n    appOptions.lightmapper = _lightmapper_lightmapper_js__WEBPACK_IMPORTED_MODULE_3__.Lightmapper;\n    appOptions.batchManager = _scene_batching_batch_manager_js__WEBPACK_IMPORTED_MODULE_4__.BatchManager;\n    appOptions.xr = _xr_xr_manager_js__WEBPACK_IMPORTED_MODULE_5__.XrManager;\n    this.init(appOptions);\n  }\n  createDevice(canvas, options) {\n    if (!options.graphicsDeviceOptions) {\n      options.graphicsDeviceOptions = {};\n    }\n    if (_core_platform_js__WEBPACK_IMPORTED_MODULE_6__.platform.browser && !!navigator.xr) {\n      options.graphicsDeviceOptions.xrCompatible = true;\n    }\n    options.graphicsDeviceOptions.alpha = options.graphicsDeviceOptions.alpha || false;\n    return new _platform_graphics_webgl_webgl_graphics_device_js__WEBPACK_IMPORTED_MODULE_7__.WebglGraphicsDevice(canvas, options.graphicsDeviceOptions);\n  }\n  addComponentSystems(appOptions) {\n    appOptions.componentSystems = [_components_rigid_body_system_js__WEBPACK_IMPORTED_MODULE_8__.RigidBodyComponentSystem, _components_collision_system_js__WEBPACK_IMPORTED_MODULE_9__.CollisionComponentSystem, _components_joint_system_js__WEBPACK_IMPORTED_MODULE_10__.JointComponentSystem, _components_animation_system_js__WEBPACK_IMPORTED_MODULE_11__.AnimationComponentSystem, _components_anim_system_js__WEBPACK_IMPORTED_MODULE_12__.AnimComponentSystem, _components_model_system_js__WEBPACK_IMPORTED_MODULE_13__.ModelComponentSystem, _components_render_system_js__WEBPACK_IMPORTED_MODULE_14__.RenderComponentSystem, _components_camera_system_js__WEBPACK_IMPORTED_MODULE_15__.CameraComponentSystem, _components_light_system_js__WEBPACK_IMPORTED_MODULE_16__.LightComponentSystem, _script_js__WEBPACK_IMPORTED_MODULE_17__.script.legacy ? _components_script_legacy_system_js__WEBPACK_IMPORTED_MODULE_18__.ScriptLegacyComponentSystem : _components_script_system_js__WEBPACK_IMPORTED_MODULE_19__.ScriptComponentSystem, _components_audio_source_system_js__WEBPACK_IMPORTED_MODULE_20__.AudioSourceComponentSystem, _components_sound_system_js__WEBPACK_IMPORTED_MODULE_21__.SoundComponentSystem, _components_audio_listener_system_js__WEBPACK_IMPORTED_MODULE_22__.AudioListenerComponentSystem, _components_particle_system_system_js__WEBPACK_IMPORTED_MODULE_23__.ParticleSystemComponentSystem, _components_screen_system_js__WEBPACK_IMPORTED_MODULE_24__.ScreenComponentSystem, _components_element_system_js__WEBPACK_IMPORTED_MODULE_25__.ElementComponentSystem, _components_button_system_js__WEBPACK_IMPORTED_MODULE_26__.ButtonComponentSystem, _components_scroll_view_system_js__WEBPACK_IMPORTED_MODULE_27__.ScrollViewComponentSystem, _components_scrollbar_system_js__WEBPACK_IMPORTED_MODULE_28__.ScrollbarComponentSystem, _components_sprite_system_js__WEBPACK_IMPORTED_MODULE_29__.SpriteComponentSystem, _components_layout_group_system_js__WEBPACK_IMPORTED_MODULE_30__.LayoutGroupComponentSystem, _components_layout_child_system_js__WEBPACK_IMPORTED_MODULE_31__.LayoutChildComponentSystem, _components_zone_system_js__WEBPACK_IMPORTED_MODULE_32__.ZoneComponentSystem];\n  }\n  addResourceHandles(appOptions) {\n    appOptions.resourceHandlers = [_handlers_render_js__WEBPACK_IMPORTED_MODULE_33__.RenderHandler, _handlers_animation_js__WEBPACK_IMPORTED_MODULE_34__.AnimationHandler, _handlers_anim_clip_js__WEBPACK_IMPORTED_MODULE_35__.AnimClipHandler, _handlers_anim_state_graph_js__WEBPACK_IMPORTED_MODULE_36__.AnimStateGraphHandler, _handlers_model_js__WEBPACK_IMPORTED_MODULE_37__.ModelHandler, _handlers_material_js__WEBPACK_IMPORTED_MODULE_38__.MaterialHandler, _handlers_texture_js__WEBPACK_IMPORTED_MODULE_39__.TextureHandler, _handlers_text_js__WEBPACK_IMPORTED_MODULE_40__.TextHandler, _handlers_json_js__WEBPACK_IMPORTED_MODULE_41__.JsonHandler, _handlers_audio_js__WEBPACK_IMPORTED_MODULE_42__.AudioHandler, _handlers_script_js__WEBPACK_IMPORTED_MODULE_43__.ScriptHandler, _handlers_scene_js__WEBPACK_IMPORTED_MODULE_44__.SceneHandler, _handlers_cubemap_js__WEBPACK_IMPORTED_MODULE_45__.CubemapHandler, _handlers_html_js__WEBPACK_IMPORTED_MODULE_46__.HtmlHandler, _handlers_css_js__WEBPACK_IMPORTED_MODULE_47__.CssHandler, _handlers_shader_js__WEBPACK_IMPORTED_MODULE_48__.ShaderHandler, _handlers_hierarchy_js__WEBPACK_IMPORTED_MODULE_49__.HierarchyHandler, _handlers_folder_js__WEBPACK_IMPORTED_MODULE_50__.FolderHandler, _handlers_font_js__WEBPACK_IMPORTED_MODULE_51__.FontHandler, _handlers_binary_js__WEBPACK_IMPORTED_MODULE_52__.BinaryHandler, _handlers_texture_atlas_js__WEBPACK_IMPORTED_MODULE_53__.TextureAtlasHandler, _handlers_sprite_js__WEBPACK_IMPORTED_MODULE_54__.SpriteHandler, _handlers_template_js__WEBPACK_IMPORTED_MODULE_55__.TemplateHandler, _handlers_container_js__WEBPACK_IMPORTED_MODULE_56__.ContainerHandler];\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/application.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset-file.js":
/*!************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset-file.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AssetFile\": () => (/* binding */ AssetFile)\n/* harmony export */ });\nclass AssetFile {\n  constructor(url, filename, hash, size, opt, contents) {\n    this.url = url || '';\n    this.filename = filename || '';\n    this.hash = hash === undefined ? null : hash;\n    this.size = size === undefined ? null : size;\n    this.opt = opt === undefined ? null : opt;\n    this.contents = contents || null;\n  }\n  equals(other) {\n    return this.url === other.url && this.filename === other.filename && this.hash === other.hash && this.size === other.size && this.opt === other.opt && this.contents === other.contents;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset-file.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset-localized.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset-localized.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LocalizedAsset\": () => (/* binding */ LocalizedAsset)\n/* harmony export */ });\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _asset_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./asset.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset.js\");\n\n\n\nclass LocalizedAsset extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor(app) {\n    super();\n    this._app = app;\n    app.i18n.on('set:locale', this._onSetLocale, this);\n    this._autoLoad = false;\n    this._disableLocalization = false;\n    this._defaultAsset = null;\n    this._localizedAsset = null;\n  }\n  set defaultAsset(value) {\n    const id = value instanceof _asset_js__WEBPACK_IMPORTED_MODULE_1__.Asset ? value.id : value;\n    if (this._defaultAsset === id) return;\n    if (this._defaultAsset) {\n      this._unbindDefaultAsset();\n    }\n    this._defaultAsset = id;\n    if (this._defaultAsset) {\n      this._bindDefaultAsset();\n    }\n    this._onSetLocale(this._app.i18n.locale);\n  }\n  get defaultAsset() {\n    return this._defaultAsset;\n  }\n  set localizedAsset(value) {\n    const id = value instanceof _asset_js__WEBPACK_IMPORTED_MODULE_1__.Asset ? value.id : value;\n    if (this._localizedAsset === id) {\n      return;\n    }\n    if (this._localizedAsset) {\n      this._app.assets.off('add:' + this._localizedAsset, this._onLocalizedAssetAdd, this);\n      this._unbindLocalizedAsset();\n      this._localizedAsset = null;\n    }\n    this._localizedAsset = id;\n    if (this._localizedAsset) {\n      const asset = this._app.assets.get(this._localizedAsset);\n      if (!asset) {\n        this._app.assets.once('add:' + this._localizedAsset, this._onLocalizedAssetAdd, this);\n      } else {\n        this._bindLocalizedAsset();\n      }\n    }\n  }\n  get localizedAsset() {\n    return this._localizedAsset;\n  }\n  set autoLoad(value) {\n    if (this._autoLoad === value) return;\n    this._autoLoad = value;\n    if (this._autoLoad && this._localizedAsset) {\n      this._unbindLocalizedAsset();\n      this._bindLocalizedAsset();\n    }\n  }\n  get autoLoad() {\n    return this._autoLoad;\n  }\n  set disableLocalization(value) {\n    if (this._disableLocalization === value) return;\n    this._disableLocalization = value;\n    this._onSetLocale(this._app.i18n.locale);\n  }\n  get disableLocalization() {\n    return this._disableLocalization;\n  }\n  _bindDefaultAsset() {\n    const asset = this._app.assets.get(this._defaultAsset);\n    if (!asset) {\n      this._app.assets.once('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);\n    } else {\n      this._onDefaultAssetAdd(asset);\n    }\n  }\n  _unbindDefaultAsset() {\n    if (!this._defaultAsset) return;\n    this._app.assets.off('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);\n    const asset = this._app.assets.get(this._defaultAsset);\n    if (!asset) return;\n    asset.off('add:localized', this._onLocaleAdd, this);\n    asset.off('remove:localized', this._onLocaleRemove, this);\n    asset.off('remove', this._onDefaultAssetRemove, this);\n  }\n  _onDefaultAssetAdd(asset) {\n    if (this._defaultAsset !== asset.id) return;\n    asset.on('add:localized', this._onLocaleAdd, this);\n    asset.on('remove:localized', this._onLocaleRemove, this);\n    asset.once('remove', this._onDefaultAssetRemove, this);\n  }\n  _onDefaultAssetRemove(asset) {\n    if (this._defaultAsset !== asset.id) return;\n    asset.off('add:localized', this._onLocaleAdd, this);\n    asset.off('remove:localized', this._onLocaleAdd, this);\n    this._app.assets.once('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);\n  }\n  _bindLocalizedAsset() {\n    if (!this._autoLoad) return;\n    const asset = this._app.assets.get(this._localizedAsset);\n    if (!asset) return;\n    asset.on('load', this._onLocalizedAssetLoad, this);\n    asset.on('change', this._onLocalizedAssetChange, this);\n    asset.on('remove', this._onLocalizedAssetRemove, this);\n    if (asset.resource) {\n      this._onLocalizedAssetLoad(asset);\n    } else {\n      this._app.assets.load(asset);\n    }\n  }\n  _unbindLocalizedAsset() {\n    const asset = this._app.assets.get(this._localizedAsset);\n    if (!asset) return;\n    asset.off('load', this._onLocalizedAssetLoad, this);\n    asset.off('change', this._onLocalizedAssetChange, this);\n    asset.off('remove', this._onLocalizedAssetRemove, this);\n  }\n  _onLocalizedAssetAdd(asset) {\n    if (this._localizedAsset !== asset.id) return;\n    this._bindLocalizedAsset();\n  }\n  _onLocalizedAssetLoad(asset) {\n    this.fire('load', asset);\n  }\n  _onLocalizedAssetChange(asset, name, newValue, oldValue) {\n    this.fire('change', asset, name, newValue, oldValue);\n  }\n  _onLocalizedAssetRemove(asset) {\n    if (this._localizedAsset === asset.id) {\n      this.localizedAsset = this._defaultAsset;\n    }\n    this.fire('remove', asset);\n  }\n  _onLocaleAdd(locale, assetId) {\n    if (this._app.i18n.locale !== locale) return;\n    this._onSetLocale(locale);\n  }\n  _onLocaleRemove(locale, assetId) {\n    if (this._app.i18n.locale !== locale) return;\n    this._onSetLocale(locale);\n  }\n  _onSetLocale(locale) {\n    if (!this._defaultAsset) {\n      this.localizedAsset = null;\n      return;\n    }\n    const asset = this._app.assets.get(this._defaultAsset);\n    if (!asset || this._disableLocalization) {\n      this.localizedAsset = this._defaultAsset;\n      return;\n    }\n    const localizedAssetId = asset.getLocalizedAssetId(locale);\n    if (!localizedAssetId) {\n      this.localizedAsset = this._defaultAsset;\n      return;\n    }\n    this.localizedAsset = localizedAssetId;\n  }\n  destroy() {\n    this.defaultAsset = null;\n    this._app.i18n.off('set:locale', this._onSetLocale, this);\n    this.off();\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset-localized.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset-reference.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset-reference.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AssetReference\": () => (/* binding */ AssetReference)\n/* harmony export */ });\nclass AssetReference {\n  constructor(propertyName, parent, registry, callbacks, scope) {\n    this.propertyName = propertyName;\n    this.parent = parent;\n    this._scope = scope;\n    this._registry = registry;\n    this.id = null;\n    this.url = null;\n    this.asset = null;\n    this._onAssetLoad = callbacks.load;\n    this._onAssetAdd = callbacks.add;\n    this._onAssetRemove = callbacks.remove;\n    this._onAssetUnload = callbacks.unload;\n  }\n  set id(value) {\n    if (this.url) throw Error('Can\\'t set id and url');\n    this._unbind();\n    this._id = value;\n    this.asset = this._registry.get(this._id);\n    this._bind();\n  }\n  get id() {\n    return this._id;\n  }\n  set url(value) {\n    if (this.id) throw Error('Can\\'t set id and url');\n    this._unbind();\n    this._url = value;\n    this.asset = this._registry.getByUrl(this._url);\n    this._bind();\n  }\n  get url() {\n    return this._url;\n  }\n  _bind() {\n    if (this.id) {\n      if (this._onAssetLoad) this._registry.on('load:' + this.id, this._onLoad, this);\n      if (this._onAssetAdd) this._registry.once('add:' + this.id, this._onAdd, this);\n      if (this._onAssetRemove) this._registry.on('remove:' + this.id, this._onRemove, this);\n      if (this._onAssetUnload) this._registry.on('unload:' + this.id, this._onUnload, this);\n    }\n    if (this.url) {\n      if (this._onAssetLoad) this._registry.on('load:url:' + this.url, this._onLoad, this);\n      if (this._onAssetAdd) this._registry.once('add:url:' + this.url, this._onAdd, this);\n      if (this._onAssetRemove) this._registry.on('remove:url:' + this.url, this._onRemove, this);\n    }\n  }\n  _unbind() {\n    if (this.id) {\n      if (this._onAssetLoad) this._registry.off('load:' + this.id, this._onLoad, this);\n      if (this._onAssetAdd) this._registry.off('add:' + this.id, this._onAdd, this);\n      if (this._onAssetRemove) this._registry.off('remove:' + this.id, this._onRemove, this);\n      if (this._onAssetUnload) this._registry.off('unload:' + this.id, this._onUnload, this);\n    }\n    if (this.url) {\n      if (this._onAssetLoad) this._registry.off('load:' + this.url, this._onLoad, this);\n      if (this._onAssetAdd) this._registry.off('add:' + this.url, this._onAdd, this);\n      if (this._onAssetRemove) this._registry.off('remove:' + this.url, this._onRemove, this);\n    }\n  }\n  _onLoad(asset) {\n    this._onAssetLoad.call(this._scope, this.propertyName, this.parent, asset);\n  }\n  _onAdd(asset) {\n    this.asset = asset;\n    this._onAssetAdd.call(this._scope, this.propertyName, this.parent, asset);\n  }\n  _onRemove(asset) {\n    this._onAssetRemove.call(this._scope, this.propertyName, this.parent, asset);\n    this.asset = null;\n  }\n  _onUnload(asset) {\n    this._onAssetUnload.call(this._scope, this.propertyName, this.parent, asset);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset-reference.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset-registry.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset-registry.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AssetRegistry\": () => (/* binding */ AssetRegistry)\n/* harmony export */ });\n/* harmony import */ var _core_path_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/path.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/path.js\");\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _core_tags_cache_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/tags-cache.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/tags-cache.js\");\n/* harmony import */ var _scene_materials_standard_material_parameters_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../scene/materials/standard-material-parameters.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material-parameters.js\");\n/* harmony import */ var _script_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../script.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/script.js\");\n/* harmony import */ var _asset_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./asset.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset.js\");\n\n\n\n\n\n\n\n\nclass AssetRegistry extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor(loader) {\n    super();\n    this._loader = loader;\n    this._assets = [];\n    this._cache = {};\n    this._names = {};\n    this._tags = new _core_tags_cache_js__WEBPACK_IMPORTED_MODULE_1__.TagsCache('_id');\n    this._urls = {};\n    this.prefix = null;\n  }\n  list(filters) {\n    filters = filters || {};\n    return this._assets.filter(asset => {\n      let include = true;\n      if (filters.preload !== undefined) {\n        include = asset.preload === filters.preload;\n      }\n      return include;\n    });\n  }\n  add(asset) {\n    const index = this._assets.push(asset) - 1;\n    let url;\n    this._cache[asset.id] = index;\n    if (!this._names[asset.name]) this._names[asset.name] = [];\n    this._names[asset.name].push(index);\n    if (asset.file) {\n      url = asset.file.url;\n      this._urls[url] = index;\n    }\n    asset.registry = this;\n    this._tags.addItem(asset);\n    asset.tags.on('add', this._onTagAdd, this);\n    asset.tags.on('remove', this._onTagRemove, this);\n    this.fire('add', asset);\n    this.fire('add:' + asset.id, asset);\n    if (url) this.fire('add:url:' + url, asset);\n    if (asset.preload) this.load(asset);\n  }\n  remove(asset) {\n    const idx = this._cache[asset.id];\n    const url = asset.file ? asset.file.url : null;\n    if (idx !== undefined) {\n      this._assets.splice(idx, 1);\n      delete this._cache[asset.id];\n      this._names = {};\n      this._urls = [];\n      for (let i = 0, l = this._assets.length; i < l; i++) {\n        const a = this._assets[i];\n        this._cache[a.id] = i;\n        if (!this._names[a.name]) {\n          this._names[a.name] = [];\n        }\n        this._names[a.name].push(i);\n        if (a.file) {\n          this._urls[a.file.url] = i;\n        }\n      }\n      this._tags.removeItem(asset);\n      asset.tags.off('add', this._onTagAdd, this);\n      asset.tags.off('remove', this._onTagRemove, this);\n      asset.fire('remove', asset);\n      this.fire('remove', asset);\n      this.fire('remove:' + asset.id, asset);\n      if (url) this.fire('remove:url:' + url, asset);\n      return true;\n    }\n    return false;\n  }\n  get(id) {\n    const idx = this._cache[id];\n    return this._assets[idx];\n  }\n  getByUrl(url) {\n    const idx = this._urls[url];\n    return this._assets[idx];\n  }\n  load(asset) {\n    if (asset.loading || asset.loaded) {\n      return;\n    }\n    const file = asset.file;\n    const _opened = resource => {\n      if (resource instanceof Array) {\n        asset.resources = resource;\n      } else {\n        asset.resource = resource;\n      }\n      this._loader.patch(asset, this);\n      this.fire('load', asset);\n      this.fire('load:' + asset.id, asset);\n      if (file && file.url) this.fire('load:url:' + file.url, asset);\n      asset.fire('load', asset);\n    };\n    const _loaded = (err, resource, extra) => {\n      asset.loaded = true;\n      asset.loading = false;\n      if (err) {\n        this.fire('error', err, asset);\n        this.fire('error:' + asset.id, err, asset);\n        asset.fire('error', err, asset);\n      } else {\n        if (!_script_js__WEBPACK_IMPORTED_MODULE_2__.script.legacy && asset.type === 'script') {\n          const handler = this._loader.getHandler('script');\n          if (handler._cache[asset.id] && handler._cache[asset.id].parentNode === document.head) {\n            document.head.removeChild(handler._cache[asset.id]);\n          }\n          handler._cache[asset.id] = extra;\n        }\n        _opened(resource);\n      }\n    };\n    if (file || asset.type === 'cubemap') {\n      this.fire('load:start', asset);\n      this.fire('load:' + asset.id + ':start', asset);\n      asset.loading = true;\n      this._loader.load(asset.getFileUrl(), asset.type, _loaded, asset);\n    } else {\n      const resource = this._loader.open(asset.type, asset.data);\n      asset.loaded = true;\n      _opened(resource);\n    }\n  }\n  loadFromUrl(url, type, callback) {\n    this.loadFromUrlAndFilename(url, null, type, callback);\n  }\n  loadFromUrlAndFilename(url, filename, type, callback) {\n    const name = _core_path_js__WEBPACK_IMPORTED_MODULE_3__.path.getBasename(filename || url);\n    const file = {\n      filename: filename || name,\n      url: url\n    };\n    let asset = this.getByUrl(url);\n    if (!asset) {\n      asset = new _asset_js__WEBPACK_IMPORTED_MODULE_4__.Asset(name, type, file);\n      this.add(asset);\n    } else if (asset.loaded) {\n      callback(asset.loadFromUrlError || null, asset);\n      return;\n    }\n    const startLoad = asset => {\n      asset.once('load', loadedAsset => {\n        if (type === 'material') {\n          this._loadTextures(loadedAsset, (err, textures) => {\n            callback(err, loadedAsset);\n          });\n        } else {\n          callback(null, loadedAsset);\n        }\n      });\n      asset.once('error', err => {\n        if (err) {\n          this.loadFromUrlError = err;\n        }\n        callback(err, asset);\n      });\n      this.load(asset);\n    };\n    if (asset.resource) {\n      callback(null, asset);\n    } else if (type === 'model') {\n      this._loadModel(asset, startLoad);\n    } else {\n      startLoad(asset);\n    }\n  }\n  _loadModel(modelAsset, continuation) {\n    const url = modelAsset.getFileUrl();\n    const ext = _core_path_js__WEBPACK_IMPORTED_MODULE_3__.path.getExtension(url);\n    if (ext === '.json' || ext === '.glb') {\n      const dir = _core_path_js__WEBPACK_IMPORTED_MODULE_3__.path.getDirectory(url);\n      const basename = _core_path_js__WEBPACK_IMPORTED_MODULE_3__.path.getBasename(url);\n      const mappingUrl = _core_path_js__WEBPACK_IMPORTED_MODULE_3__.path.join(dir, basename.replace(ext, '.mapping.json'));\n      this._loader.load(mappingUrl, 'json', (err, data) => {\n        if (err) {\n          modelAsset.data = {\n            mapping: []\n          };\n          continuation(modelAsset);\n        } else {\n          this._loadMaterials(modelAsset, data, (e, materials) => {\n            modelAsset.data = data;\n            continuation(modelAsset);\n          });\n        }\n      });\n    } else {\n      continuation(modelAsset);\n    }\n  }\n  _loadMaterials(modelAsset, mapping, callback) {\n    const materials = [];\n    let count = 0;\n    const onMaterialLoaded = (err, materialAsset) => {\n      this._loadTextures(materialAsset, (err, textures) => {\n        materials.push(materialAsset);\n        if (materials.length === count) {\n          callback(null, materials);\n        }\n      });\n    };\n    for (let i = 0; i < mapping.mapping.length; i++) {\n      const path = mapping.mapping[i].path;\n      if (path) {\n        count++;\n        const url = modelAsset.getAbsoluteUrl(path);\n        this.loadFromUrl(url, 'material', onMaterialLoaded);\n      }\n    }\n    if (count === 0) {\n      callback(null, materials);\n    }\n  }\n  _loadTextures(materialAsset, callback) {\n    const textures = [];\n    let count = 0;\n    const data = materialAsset.data;\n    if (data.mappingFormat !== 'path') {\n      callback(null, textures);\n      return;\n    }\n    const onTextureLoaded = (err, texture) => {\n      if (err) console.error(err);\n      textures.push(texture);\n      if (textures.length === count) {\n        callback(null, textures);\n      }\n    };\n    const texParams = _scene_materials_standard_material_parameters_js__WEBPACK_IMPORTED_MODULE_5__.standardMaterialTextureParameters;\n    for (let i = 0; i < texParams.length; i++) {\n      const path = data[texParams[i]];\n      if (path && typeof path === 'string') {\n        count++;\n        const url = materialAsset.getAbsoluteUrl(path);\n        this.loadFromUrl(url, 'texture', onTextureLoaded);\n      }\n    }\n    if (count === 0) {\n      callback(null, textures);\n    }\n  }\n  findAll(name, type) {\n    const idxs = this._names[name];\n    if (idxs) {\n      const assets = idxs.map(idx => {\n        return this._assets[idx];\n      });\n      if (type) {\n        return assets.filter(asset => {\n          return asset.type === type;\n        });\n      }\n      return assets;\n    }\n    return [];\n  }\n  _onTagAdd(tag, asset) {\n    this._tags.add(tag, asset);\n  }\n  _onTagRemove(tag, asset) {\n    this._tags.remove(tag, asset);\n  }\n  findByTag() {\n    return this._tags.find(arguments);\n  }\n  filter(callback) {\n    return this._assets.filter(asset => callback(asset));\n  }\n  find(name, type) {\n    const asset = this.findAll(name, type);\n    return asset.length > 0 ? asset[0] : null;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset-registry.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Asset\": () => (/* binding */ Asset)\n/* harmony export */ });\n/* harmony import */ var _core_path_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/path.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/path.js\");\n/* harmony import */ var _core_tags_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/tags.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/tags.js\");\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _i18n_utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../i18n/utils.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/i18n/utils.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/constants.js\");\n/* harmony import */ var _asset_file_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./asset-file.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset-file.js\");\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../globals.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/globals.js\");\n/* harmony import */ var _platform_net_http_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../platform/net/http.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/net/http.js\");\n\n\n\n\n\n\n\n\n\nlet assetIdCounter = -1;\nconst VARIANT_SUPPORT = {\n  pvr: 'extCompressedTexturePVRTC',\n  dxt: 'extCompressedTextureS3TC',\n  etc2: 'extCompressedTextureETC',\n  etc1: 'extCompressedTextureETC1',\n  basis: 'canvas'\n};\nconst VARIANT_DEFAULT_PRIORITY = ['pvr', 'dxt', 'etc2', 'etc1', 'basis'];\nclass Asset extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor(name, type, file, data, options) {\n    super();\n    this._id = assetIdCounter--;\n    this.name = name || '';\n    this.type = type;\n    this.tags = new _core_tags_js__WEBPACK_IMPORTED_MODULE_1__.Tags(this);\n    this._preload = false;\n    this._file = null;\n    this._data = data || {};\n    this.options = options || {};\n    this._resources = [];\n    this._i18n = {};\n    this.loaded = false;\n    this.loading = false;\n    this.registry = null;\n    if (file) this.file = file;\n  }\n  set id(value) {\n    this._id = value;\n  }\n  get id() {\n    return this._id;\n  }\n  set file(value) {\n    if (value && value.variants && ['texture', 'textureatlas', 'bundle'].indexOf(this.type) !== -1) {\n      var _this$registry, _this$registry$_loade;\n      const app = ((_this$registry = this.registry) == null ? void 0 : (_this$registry$_loade = _this$registry._loader) == null ? void 0 : _this$registry$_loade._app) || (0,_globals_js__WEBPACK_IMPORTED_MODULE_2__.getApplication)();\n      const device = app == null ? void 0 : app.graphicsDevice;\n      if (device) {\n        for (let i = 0, len = VARIANT_DEFAULT_PRIORITY.length; i < len; i++) {\n          const variant = VARIANT_DEFAULT_PRIORITY[i];\n          if (value.variants[variant] && device[VARIANT_SUPPORT[variant]]) {\n            value = value.variants[variant];\n            break;\n          }\n          if (app.enableBundles) {\n            const bundles = app.bundles.listBundlesForAsset(this);\n            if (bundles && bundles.find(b => {\n              var _b$file;\n              return b == null ? void 0 : (_b$file = b.file) == null ? void 0 : _b$file.variants[variant];\n            })) {\n              break;\n            }\n          }\n        }\n      }\n    }\n    const oldFile = this._file;\n    const newFile = value ? new _asset_file_js__WEBPACK_IMPORTED_MODULE_3__.AssetFile(value.url, value.filename, value.hash, value.size, value.opt, value.contents) : null;\n    if (!!newFile !== !!oldFile || newFile && !newFile.equals(oldFile)) {\n      this._file = newFile;\n      this.fire('change', this, 'file', newFile, oldFile);\n      this.reload();\n    }\n  }\n  get file() {\n    return this._file;\n  }\n  set data(value) {\n    const old = this._data;\n    this._data = value;\n    if (value !== old) {\n      this.fire('change', this, 'data', value, old);\n      if (this.loaded) this.registry._loader.patch(this, this.registry);\n    }\n  }\n  get data() {\n    return this._data;\n  }\n  set resource(value) {\n    const _old = this._resources[0];\n    this._resources[0] = value;\n    this.fire('change', this, 'resource', value, _old);\n  }\n  get resource() {\n    return this._resources[0];\n  }\n  set resources(value) {\n    const _old = this._resources;\n    this._resources = value;\n    this.fire('change', this, 'resources', value, _old);\n  }\n  get resources() {\n    return this._resources;\n  }\n  set preload(value) {\n    value = !!value;\n    if (this._preload === value) return;\n    this._preload = value;\n    if (this._preload && !this.loaded && !this.loading && this.registry) this.registry.load(this);\n  }\n  get preload() {\n    return this._preload;\n  }\n  set loadFaces(value) {\n    value = !!value;\n    if (!this.hasOwnProperty('_loadFaces') || value !== this._loadFaces) {\n      this._loadFaces = value;\n      if (this.loaded) this.registry._loader.patch(this, this.registry);\n    }\n  }\n  get loadFaces() {\n    return this._loadFaces;\n  }\n  getFileUrl() {\n    const file = this.file;\n    if (!file || !file.url) return null;\n    let url = file.url;\n    if (this.registry && this.registry.prefix && !_constants_js__WEBPACK_IMPORTED_MODULE_4__.ABSOLUTE_URL.test(url)) url = this.registry.prefix + url;\n    if (this.type !== 'script' && file.hash) {\n      const separator = url.indexOf('?') !== -1 ? '&' : '?';\n      url += separator + 't=' + file.hash;\n    }\n    return url;\n  }\n  getAbsoluteUrl(relativePath) {\n    if (relativePath.startsWith('blob:') || relativePath.startsWith('data:')) {\n      return relativePath;\n    }\n    const base = _core_path_js__WEBPACK_IMPORTED_MODULE_5__.path.getDirectory(this.file.url);\n    return _core_path_js__WEBPACK_IMPORTED_MODULE_5__.path.join(base, relativePath);\n  }\n  getLocalizedAssetId(locale) {\n    locale = (0,_i18n_utils_js__WEBPACK_IMPORTED_MODULE_6__.findAvailableLocale)(locale, this._i18n);\n    return this._i18n[locale] || null;\n  }\n  addLocalizedAssetId(locale, assetId) {\n    this._i18n[locale] = assetId;\n    this.fire('add:localized', locale, assetId);\n  }\n  removeLocalizedAssetId(locale) {\n    const assetId = this._i18n[locale];\n    if (assetId) {\n      delete this._i18n[locale];\n      this.fire('remove:localized', locale, assetId);\n    }\n  }\n  ready(callback, scope) {\n    scope = scope || this;\n    if (this.loaded) {\n      callback.call(scope, this);\n    } else {\n      this.once('load', function (asset) {\n        callback.call(scope, asset);\n      });\n    }\n  }\n  reload() {\n    if (this.loaded) {\n      this.loaded = false;\n      this.registry.load(this);\n    }\n  }\n  unload() {\n    if (!this.loaded && this._resources.length === 0) return;\n    this.fire('unload', this);\n    this.registry.fire('unload:' + this.id, this);\n    const old = this._resources;\n    this.resources = [];\n    this.loaded = false;\n    if (this.file) {\n      this.registry._loader.clearCache(this.getFileUrl(), this.type);\n    }\n    for (let i = 0; i < old.length; ++i) {\n      const resource = old[i];\n      if (resource && resource.destroy) {\n        resource.destroy();\n      }\n    }\n  }\n  static fetchArrayBuffer(loadUrl, callback, asset, maxRetries = 0) {\n    var _asset$file;\n    if (asset != null && (_asset$file = asset.file) != null && _asset$file.contents) {\n      setTimeout(() => {\n        callback(null, asset.file.contents);\n      });\n    } else {\n      _platform_net_http_js__WEBPACK_IMPORTED_MODULE_7__.http.get(loadUrl, {\n        cache: true,\n        responseType: 'arraybuffer',\n        retry: maxRetries > 0,\n        maxRetries: maxRetries\n      }, callback);\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/constants.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/constants.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ABSOLUTE_URL\": () => (/* binding */ ABSOLUTE_URL),\n/* harmony export */   \"ASSET_ANIMATION\": () => (/* binding */ ASSET_ANIMATION),\n/* harmony export */   \"ASSET_AUDIO\": () => (/* binding */ ASSET_AUDIO),\n/* harmony export */   \"ASSET_CONTAINER\": () => (/* binding */ ASSET_CONTAINER),\n/* harmony export */   \"ASSET_CSS\": () => (/* binding */ ASSET_CSS),\n/* harmony export */   \"ASSET_CUBEMAP\": () => (/* binding */ ASSET_CUBEMAP),\n/* harmony export */   \"ASSET_HTML\": () => (/* binding */ ASSET_HTML),\n/* harmony export */   \"ASSET_IMAGE\": () => (/* binding */ ASSET_IMAGE),\n/* harmony export */   \"ASSET_JSON\": () => (/* binding */ ASSET_JSON),\n/* harmony export */   \"ASSET_MATERIAL\": () => (/* binding */ ASSET_MATERIAL),\n/* harmony export */   \"ASSET_MODEL\": () => (/* binding */ ASSET_MODEL),\n/* harmony export */   \"ASSET_SCRIPT\": () => (/* binding */ ASSET_SCRIPT),\n/* harmony export */   \"ASSET_SHADER\": () => (/* binding */ ASSET_SHADER),\n/* harmony export */   \"ASSET_TEXT\": () => (/* binding */ ASSET_TEXT),\n/* harmony export */   \"ASSET_TEXTURE\": () => (/* binding */ ASSET_TEXTURE),\n/* harmony export */   \"ASSET_TEXTUREATLAS\": () => (/* binding */ ASSET_TEXTUREATLAS)\n/* harmony export */ });\nconst ABSOLUTE_URL = new RegExp('^' + '\\\\s*' + '(?:' + '(?:' + '[a-z]+[a-z0-9\\\\-\\\\+\\\\.]*' + ':' + ')?' + '//' + '|' + 'data:' + '|blob:' + ')', 'i');\nconst ASSET_ANIMATION = 'animation';\nconst ASSET_AUDIO = 'audio';\nconst ASSET_IMAGE = 'image';\nconst ASSET_JSON = 'json';\nconst ASSET_MODEL = 'model';\nconst ASSET_MATERIAL = 'material';\nconst ASSET_TEXT = 'text';\nconst ASSET_TEXTURE = 'texture';\nconst ASSET_TEXTUREATLAS = 'textureatlas';\nconst ASSET_CUBEMAP = 'cubemap';\nconst ASSET_SHADER = 'shader';\nconst ASSET_CSS = 'css';\nconst ASSET_HTML = 'html';\nconst ASSET_SCRIPT = 'script';\nconst ASSET_CONTAINER = 'container';\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/constants.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/bundle/bundle-registry.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/bundle/bundle-registry.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BundleRegistry\": () => (/* binding */ BundleRegistry)\n/* harmony export */ });\nclass BundleRegistry {\n  constructor(assets) {\n    this._assets = assets;\n    this._bundleAssets = {};\n    this._assetsInBundles = {};\n    this._urlsInBundles = {};\n    this._fileRequests = {};\n    this._assets.on('add', this._onAssetAdded, this);\n    this._assets.on('remove', this._onAssetRemoved, this);\n  }\n  _onAssetAdded(asset) {\n    if (asset.type === 'bundle') {\n      this._bundleAssets[asset.id] = asset;\n      this._registerBundleEventListeners(asset.id);\n      for (let i = 0, len = asset.data.assets.length; i < len; i++) {\n        this._indexAssetInBundle(asset.data.assets[i], asset);\n      }\n    } else {\n      if (this._assetsInBundles[asset.id]) {\n        this._indexAssetFileUrls(asset);\n      }\n    }\n  }\n  _registerBundleEventListeners(bundleAssetId) {\n    this._assets.on('load:' + bundleAssetId, this._onBundleLoaded, this);\n    this._assets.on('error:' + bundleAssetId, this._onBundleError, this);\n  }\n  _unregisterBundleEventListeners(bundleAssetId) {\n    this._assets.off('load:' + bundleAssetId, this._onBundleLoaded, this);\n    this._assets.off('error:' + bundleAssetId, this._onBundleError, this);\n  }\n  _indexAssetInBundle(assetId, bundleAsset) {\n    if (!this._assetsInBundles[assetId]) {\n      this._assetsInBundles[assetId] = [bundleAsset];\n    } else {\n      const bundles = this._assetsInBundles[assetId];\n      const idx = bundles.indexOf(bundleAsset);\n      if (idx === -1) {\n        bundles.push(bundleAsset);\n      }\n    }\n    const asset = this._assets.get(assetId);\n    if (asset) {\n      this._indexAssetFileUrls(asset);\n    }\n  }\n  _indexAssetFileUrls(asset) {\n    const urls = this._getAssetFileUrls(asset);\n    if (!urls) return;\n    for (let i = 0, len = urls.length; i < len; i++) {\n      const url = urls[i];\n      this._urlsInBundles[url] = this._assetsInBundles[asset.id];\n    }\n  }\n  _getAssetFileUrls(asset) {\n    let url = asset.getFileUrl();\n    if (!url) return null;\n    url = this._normalizeUrl(url);\n    const urls = [url];\n    if (asset.type === 'font') {\n      const numFiles = asset.data.info.maps.length;\n      for (let i = 1; i < numFiles; i++) {\n        urls.push(url.replace('.png', i + '.png'));\n      }\n    }\n    return urls;\n  }\n  _normalizeUrl(url) {\n    return url && url.split('?')[0];\n  }\n  _onAssetRemoved(asset) {\n    if (asset.type === 'bundle') {\n      delete this._bundleAssets[asset.id];\n      this._unregisterBundleEventListeners(asset.id);\n      for (const id in this._assetsInBundles) {\n        const array = this._assetsInBundles[id];\n        const idx = array.indexOf(asset);\n        if (idx !== -1) {\n          array.splice(idx, 1);\n          if (!array.length) {\n            delete this._assetsInBundles[id];\n            for (const url in this._urlsInBundles) {\n              if (this._urlsInBundles[url] === array) {\n                delete this._urlsInBundles[url];\n              }\n            }\n          }\n        }\n      }\n      this._onBundleError(`Bundle ${asset.id} was removed`, asset);\n    } else if (this._assetsInBundles[asset.id]) {\n      delete this._assetsInBundles[asset.id];\n      const urls = this._getAssetFileUrls(asset);\n      for (let i = 0, len = urls.length; i < len; i++) {\n        delete this._urlsInBundles[urls[i]];\n      }\n    }\n  }\n  _onBundleLoaded(bundleAsset) {\n    if (!bundleAsset.resource) {\n      this._onBundleError(`Bundle ${bundleAsset.id} failed to load`, bundleAsset);\n      return;\n    }\n    requestAnimationFrame(() => {\n      if (!this._fileRequests) {\n        return;\n      }\n      for (const url in this._fileRequests) {\n        const bundles = this._urlsInBundles[url];\n        if (!bundles || bundles.indexOf(bundleAsset) === -1) continue;\n        const decodedUrl = decodeURIComponent(url);\n        let err = null;\n        if (!bundleAsset.resource.hasBlobUrl(decodedUrl)) {\n          err = `Bundle ${bundleAsset.id} does not contain URL ${url}`;\n        }\n        const requests = this._fileRequests[url];\n        for (let i = 0, len = requests.length; i < len; i++) {\n          if (err) {\n            requests[i](err);\n          } else {\n            requests[i](null, bundleAsset.resource.getBlobUrl(decodedUrl));\n          }\n        }\n        delete this._fileRequests[url];\n      }\n    });\n  }\n  _onBundleError(err, bundleAsset) {\n    for (const url in this._fileRequests) {\n      const bundle = this._findLoadedOrLoadingBundleForUrl(url);\n      if (!bundle) {\n        const requests = this._fileRequests[url];\n        for (let i = 0, len = requests.length; i < len; i++) {\n          requests[i](err);\n        }\n        delete this._fileRequests[url];\n      }\n    }\n  }\n  _findLoadedOrLoadingBundleForUrl(url) {\n    const bundles = this._urlsInBundles[url];\n    if (!bundles) return null;\n    const len = bundles.length;\n    for (let i = 0; i < len; i++) {\n      if (bundles[i].loaded && bundles[i].resource) {\n        return bundles[i];\n      }\n    }\n    for (let i = 0; i < len; i++) {\n      if (bundles[i].loading) {\n        return bundles[i];\n      }\n    }\n    return null;\n  }\n  listBundlesForAsset(asset) {\n    return this._assetsInBundles[asset.id] || null;\n  }\n  list() {\n    const result = [];\n    for (const id in this._bundleAssets) {\n      result.push(this._bundleAssets[id]);\n    }\n    return result;\n  }\n  hasUrl(url) {\n    return !!this._urlsInBundles[url];\n  }\n  canLoadUrl(url) {\n    return !!this._findLoadedOrLoadingBundleForUrl(url);\n  }\n  loadUrl(url, callback) {\n    const bundle = this._findLoadedOrLoadingBundleForUrl(url);\n    if (!bundle) {\n      callback(`URL ${url} not found in any bundles`);\n      return;\n    }\n    if (bundle.loaded) {\n      const decodedUrl = decodeURIComponent(url);\n      if (!bundle.resource.hasBlobUrl(decodedUrl)) {\n        callback(`Bundle ${bundle.id} does not contain URL ${url}`);\n        return;\n      }\n      callback(null, bundle.resource.getBlobUrl(decodedUrl));\n    } else if (this._fileRequests.hasOwnProperty(url)) {\n      this._fileRequests[url].push(callback);\n    } else {\n      this._fileRequests[url] = [callback];\n    }\n  }\n  destroy() {\n    this._assets.off('add', this._onAssetAdded, this);\n    this._assets.off('remove', this._onAssetRemoved, this);\n    for (const id in this._bundleAssets) {\n      this._unregisterBundleEventListeners(id);\n    }\n    this._assets = null;\n    this._bundleAssets = null;\n    this._assetsInBundles = null;\n    this._urlsInBundles = null;\n    this._fileRequests = null;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/bundle/bundle-registry.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/bundle/bundle.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/bundle/bundle.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Bundle\": () => (/* binding */ Bundle)\n/* harmony export */ });\nclass Bundle {\n  constructor(files) {\n    this._blobUrls = {};\n    for (let i = 0, len = files.length; i < len; i++) {\n      if (files[i].url) {\n        this._blobUrls[files[i].name] = files[i].url;\n      }\n    }\n  }\n  hasBlobUrl(url) {\n    return !!this._blobUrls[url];\n  }\n  getBlobUrl(url) {\n    return this._blobUrls[url];\n  }\n  destroy() {\n    for (const key in this._blobUrls) {\n      URL.revokeObjectURL(this._blobUrls[key]);\n    }\n    this._blobUrls = null;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/bundle/bundle.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/anim/component-binder.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/anim/component-binder.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimComponentBinder\": () => (/* binding */ AnimComponentBinder)\n/* harmony export */ });\n/* harmony import */ var _anim_evaluator_anim_target_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../anim/evaluator/anim-target.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-target.js\");\n/* harmony import */ var _anim_binder_default_anim_binder_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../anim/binder/default-anim-binder.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/binder/default-anim-binder.js\");\n/* harmony import */ var _anim_binder_anim_binder_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../anim/binder/anim-binder.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/binder/anim-binder.js\");\n/* harmony import */ var _core_math_color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/math/color.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n/* harmony import */ var _core_math_quat_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/math/quat.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/quat.js\");\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/math/vec4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec4.js\");\n\n\n\n\n\n\n\n\n\nconst v2 = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_0__.Vec2();\nconst v3 = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst v4 = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_2__.Vec4();\nconst c = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_3__.Color();\nconst q = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_4__.Quat();\nclass AnimComponentBinder extends _anim_binder_default_anim_binder_js__WEBPACK_IMPORTED_MODULE_5__.DefaultAnimBinder {\n  constructor(animComponent, graph, layerName, mask, layerIndex) {\n    super(graph);\n    this.animComponent = animComponent;\n    this._mask = mask;\n    this.layerName = layerName;\n    this.layerIndex = layerIndex;\n  }\n  static _packFloat(values) {\n    return values[0];\n  }\n  static _packBoolean(values) {\n    return !!values[0];\n  }\n  static _packVec2(values) {\n    v2.x = values[0];\n    v2.y = values[1];\n    return v2;\n  }\n  static _packVec3(values) {\n    v3.x = values[0];\n    v3.y = values[1];\n    v3.z = values[2];\n    return v3;\n  }\n  static _packVec4(values) {\n    v4.x = values[0];\n    v4.y = values[1];\n    v4.z = values[2];\n    v4.w = values[3];\n    return v4;\n  }\n  static _packColor(values) {\n    c.r = values[0];\n    c.g = values[1];\n    c.b = values[2];\n    c.a = values[3];\n    return c;\n  }\n  static _packQuat(values) {\n    q.x = values[0];\n    q.y = values[1];\n    q.z = values[2];\n    q.w = values[3];\n    return q;\n  }\n  resolve(path) {\n    const encodedPath = _anim_binder_anim_binder_js__WEBPACK_IMPORTED_MODULE_6__.AnimBinder.encode(path.entityPath, path.component, path.propertyPath);\n    let target = this.targetCache[encodedPath];\n    if (target) return target;\n    let entity;\n    let propertyComponent;\n    let targetPath;\n    switch (path.component) {\n      case 'entity':\n        entity = this._getEntityFromHierarchy(path.entityPath);\n        targetPath = _anim_binder_anim_binder_js__WEBPACK_IMPORTED_MODULE_6__.AnimBinder.encode(entity.path, 'entity', path.propertyPath);\n        propertyComponent = entity;\n        break;\n      case 'graph':\n        propertyComponent = this.findNode(path);\n        if (!propertyComponent) return null;\n        targetPath = _anim_binder_anim_binder_js__WEBPACK_IMPORTED_MODULE_6__.AnimBinder.encode(propertyComponent.path, 'graph', path.propertyPath);\n        break;\n      default:\n        entity = this._getEntityFromHierarchy(path.entityPath);\n        propertyComponent = entity.findComponent(path.component);\n        if (!propertyComponent) return null;\n        targetPath = _anim_binder_anim_binder_js__WEBPACK_IMPORTED_MODULE_6__.AnimBinder.encode(entity.path, path.component, path.propertyPath);\n        break;\n    }\n    target = this._createAnimTargetForProperty(propertyComponent, path.propertyPath, targetPath);\n    this.targetCache[encodedPath] = target;\n    return target;\n  }\n  update(deltaTime) {\n    const activeNodes = this.activeNodes;\n    if (activeNodes) {\n      for (let i = 0; i < activeNodes.length; i++) {\n        activeNodes[i]._dirtifyLocal();\n      }\n    }\n  }\n  _getEntityFromHierarchy(entityHierarchy) {\n    if (!this.animComponent.entity.name === entityHierarchy[0]) {\n      return null;\n    }\n    const currEntity = this.animComponent.entity;\n    if (entityHierarchy.length === 1) {\n      return currEntity;\n    }\n    return currEntity._parent.findByPath(entityHierarchy);\n  }\n  _resolvePath(object, path, resolveLeaf) {\n    const steps = path.length - (resolveLeaf ? 0 : 1);\n    for (let i = 0; i < steps; i++) {\n      object = object[path[i]];\n    }\n    return object;\n  }\n  _setter(object, path, packFunc) {\n    const obj = this._resolvePath(object, path);\n    const key = path[path.length - 1];\n    const setterFuncName = 'set' + key.substring(0, 1).toUpperCase() + key.substring(1);\n    if (obj[setterFuncName]) {\n      const getterFunc = obj['get' + key.substring(0, 1).toUpperCase() + key.substring(1)].bind(obj);\n      let baseValues = getterFunc();\n      baseValues = [baseValues.x, baseValues.y, baseValues.z, baseValues.w];\n      const setterFunc = obj[setterFuncName].bind(obj);\n      return {\n        set: values => {\n          setterFunc(packFunc(values));\n        },\n        get: () => baseValues\n      };\n    }\n    const prop = obj[key];\n    if (typeof prop === 'object' && prop.hasOwnProperty('copy')) {\n      return function (values) {\n        prop.copy(packFunc(values));\n      };\n    }\n    if ([_core_math_vec2_js__WEBPACK_IMPORTED_MODULE_0__.Vec2, _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3, _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_2__.Vec4, _core_math_color_js__WEBPACK_IMPORTED_MODULE_3__.Color, _core_math_quat_js__WEBPACK_IMPORTED_MODULE_4__.Quat].indexOf(obj.constructor) !== -1 && path.length > 1) {\n      const parent = path.length > 2 ? this._resolvePath(object, path.slice(0, -1)) : object;\n      const objKey = path[path.length - 2];\n      return function (values) {\n        obj[key] = packFunc(values);\n        parent[objKey] = obj;\n      };\n    }\n    return function (values) {\n      obj[key] = packFunc(values);\n    };\n  }\n  _createAnimTargetForProperty(propertyComponent, propertyHierarchy, targetPath) {\n    if (this.handlers && propertyHierarchy[0].startsWith('weight.')) {\n      return this.handlers.weight(propertyComponent, propertyHierarchy[0].replace('weight.', ''));\n    } else if (this.handlers && propertyHierarchy[0] === 'material' && propertyHierarchy.length === 2) {\n      const materialPropertyName = propertyHierarchy[1];\n      if (materialPropertyName.endsWith('Map')) {\n        return this.handlers.materialTexture(propertyComponent, materialPropertyName);\n      }\n    }\n    const property = this._resolvePath(propertyComponent, propertyHierarchy, true);\n    if (typeof property === 'undefined') return null;\n    let setter;\n    let animDataType;\n    let animDataComponents;\n    if (typeof property === 'number') {\n      setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packFloat);\n      animDataType = 'vector';\n      animDataComponents = 1;\n    } else if (typeof property === 'boolean') {\n      setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packBoolean);\n      animDataType = 'vector';\n      animDataComponents = 1;\n    } else if (typeof property === 'object') {\n      switch (property.constructor) {\n        case _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_0__.Vec2:\n          setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec2);\n          animDataType = 'vector';\n          animDataComponents = 2;\n          break;\n        case _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3:\n          setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec3);\n          animDataType = 'vector';\n          animDataComponents = 3;\n          break;\n        case _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_2__.Vec4:\n          setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec4);\n          animDataType = 'vector';\n          animDataComponents = 4;\n          break;\n        case _core_math_color_js__WEBPACK_IMPORTED_MODULE_3__.Color:\n          setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packColor);\n          animDataType = 'vector';\n          animDataComponents = 4;\n          break;\n        case _core_math_quat_js__WEBPACK_IMPORTED_MODULE_4__.Quat:\n          setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packQuat);\n          animDataType = 'quaternion';\n          animDataComponents = 4;\n          break;\n        default:\n          return null;\n      }\n    }\n    if (propertyHierarchy.indexOf('material') !== -1) {\n      return new _anim_evaluator_anim_target_js__WEBPACK_IMPORTED_MODULE_7__.AnimTarget(function (values) {\n        setter(values);\n        propertyComponent.material.update();\n      }, animDataType, animDataComponents, targetPath);\n    }\n    return new _anim_evaluator_anim_target_js__WEBPACK_IMPORTED_MODULE_7__.AnimTarget(setter, animDataType, animDataComponents, targetPath);\n  }\n  rebind() {\n    this.targetCache = {};\n    if (this.animComponent.rootBone) {\n      this.graph = this.animComponent.rootBone;\n    } else {\n      this.graph = this.animComponent.entity;\n    }\n    const nodes = {};\n    const flatten = function flatten(node) {\n      nodes[node.name] = node;\n      for (let i = 0; i < node.children.length; ++i) {\n        flatten(node.children[i]);\n      }\n    };\n    flatten(this.graph);\n    this.nodes = nodes;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/anim/component-binder.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/anim/component-layer.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/anim/component-layer.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimComponentLayer\": () => (/* binding */ AnimComponentLayer)\n/* harmony export */ });\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _anim_evaluator_anim_track_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../anim/evaluator/anim-track.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-track.js\");\n/* harmony import */ var _anim_controller_anim_transition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../anim/controller/anim-transition.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-transition.js\");\n/* harmony import */ var _anim_controller_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../anim/controller/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/constants.js\");\n\n\n\n\n\n\nclass AnimComponentLayer {\n  constructor(name, controller, component, weight = 1, blendType = _anim_controller_constants_js__WEBPACK_IMPORTED_MODULE_0__.ANIM_LAYER_OVERWRITE, normalizedWeight = true) {\n    this._name = name;\n    this._controller = controller;\n    this._component = component;\n    this._weight = weight;\n    this._blendType = blendType;\n    this._normalizedWeight = normalizedWeight;\n    this._mask = null;\n    this._blendTime = 0;\n    this._blendTimeElapsed = 0;\n    this._startingWeight = 0;\n    this._targetWeight = 0;\n  }\n  get name() {\n    return this._name;\n  }\n  set playing(value) {\n    this._controller.playing = value;\n  }\n  get playing() {\n    return this._controller.playing;\n  }\n  get playable() {\n    return this._controller.playable;\n  }\n  get activeState() {\n    return this._controller.activeStateName;\n  }\n  get previousState() {\n    return this._controller.previousStateName;\n  }\n  get activeStateProgress() {\n    return this._controller.activeStateProgress;\n  }\n  get activeStateDuration() {\n    return this._controller.activeStateDuration;\n  }\n  set activeStateCurrentTime(time) {\n    const controller = this._controller;\n    const layerPlaying = controller.playing;\n    controller.playing = true;\n    controller.activeStateCurrentTime = time;\n    if (!layerPlaying) {\n      controller.update(0);\n    }\n    controller.playing = layerPlaying;\n  }\n  get activeStateCurrentTime() {\n    return this._controller.activeStateCurrentTime;\n  }\n  get transitioning() {\n    return this._controller.transitioning;\n  }\n  get transitionProgress() {\n    if (this.transitioning) {\n      return this._controller.transitionProgress;\n    }\n    return null;\n  }\n  get states() {\n    return this._controller.states;\n  }\n  set weight(value) {\n    this._weight = value;\n    this._component.dirtifyTargets();\n  }\n  get weight() {\n    return this._weight;\n  }\n  set blendType(value) {\n    if (value !== this._blendType) {\n      this._blendType = value;\n      if (this._controller.normalizeWeights) {\n        this._component.rebind();\n      }\n    }\n  }\n  get blendType() {\n    return this._blendType;\n  }\n  set mask(value) {\n    if (this._controller.assignMask(value)) {\n      this._component.rebind();\n    }\n    this._mask = value;\n  }\n  get mask() {\n    return this._mask;\n  }\n  play(name) {\n    this._controller.play(name);\n  }\n  pause() {\n    this._controller.pause();\n  }\n  reset() {\n    this._controller.reset();\n  }\n  rebind() {\n    this._controller.rebind();\n  }\n  update(dt) {\n    if (this._blendTime) {\n      if (this._blendTimeElapsed < this._blendTime) {\n        this.weight = _core_math_math_js__WEBPACK_IMPORTED_MODULE_1__.math.lerp(this._startingWeight, this._targetWeight, this._blendTimeElapsed / this._blendTime);\n        this._blendTimeElapsed += dt;\n      } else {\n        this.weight = this._targetWeight;\n        this._blendTime = 0;\n        this._blendTimeElapsed = 0;\n        this._startingWeight = 0;\n        this._targetWeight = 0;\n      }\n    }\n    this._controller.update(dt);\n  }\n  blendToWeight(weight, time) {\n    this._startingWeight = this.weight;\n    this._targetWeight = weight;\n    this._blendTime = Math.max(0, time);\n    this._blendTimeElapsed = 0;\n  }\n  assignMask(mask) {\n    if (this._controller.assignMask(mask)) {\n      this._component.rebind();\n    }\n    this._mask = mask;\n  }\n  assignAnimation(nodePath, animTrack, speed, loop) {\n    if (animTrack.constructor !== _anim_evaluator_anim_track_js__WEBPACK_IMPORTED_MODULE_2__.AnimTrack) {\n      return;\n    }\n    this._controller.assignAnimation(nodePath, animTrack, speed, loop);\n    if (this._controller._transitions.length === 0) {\n      this._controller._transitions.push(new _anim_controller_anim_transition_js__WEBPACK_IMPORTED_MODULE_3__.AnimTransition({\n        from: 'START',\n        to: nodePath\n      }));\n    }\n    if (this._component.activate && this._component.playable) {\n      this._component.playing = true;\n    }\n  }\n  removeNodeAnimations(nodeName) {\n    if (this._controller.removeNodeAnimations(nodeName)) {\n      this._component.playing = false;\n    }\n  }\n  getAnimationAsset(stateName) {\n    return this._component.animationAssets[`${this.name}:${stateName}`];\n  }\n  transition(to, time = 0, transitionOffset = null) {\n    this._controller.updateStateFromTransition(new _anim_controller_anim_transition_js__WEBPACK_IMPORTED_MODULE_3__.AnimTransition({\n      from: this._controller.activeStateName,\n      to,\n      time,\n      transitionOffset\n    }));\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/anim/component-layer.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/anim/component.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/anim/component.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimComponent\": () => (/* binding */ AnimComponent)\n/* harmony export */ });\n/* harmony import */ var _virtual_rollupPluginBabelHelpers_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../_virtual/_rollupPluginBabelHelpers.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/_virtual/_rollupPluginBabelHelpers.js\");\n/* harmony import */ var _asset_asset_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../asset/asset.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset.js\");\n/* harmony import */ var _anim_evaluator_anim_evaluator_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../anim/evaluator/anim-evaluator.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-evaluator.js\");\n/* harmony import */ var _anim_controller_anim_controller_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../anim/controller/anim-controller.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/anim-controller.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _anim_controller_constants_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../anim/controller/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/controller/constants.js\");\n/* harmony import */ var _component_binder_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./component-binder.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/anim/component-binder.js\");\n/* harmony import */ var _component_layer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./component-layer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/anim/component-layer.js\");\n/* harmony import */ var _anim_state_graph_anim_state_graph_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../anim/state-graph/anim-state-graph.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/state-graph/anim-state-graph.js\");\n/* harmony import */ var _entity_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../entity.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/entity.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nclass AnimComponent extends _component_js__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(system, entity) {\n    super(system, entity);\n    this._stateGraphAsset = null;\n    this._animationAssets = {};\n    this._speed = 1.0;\n    this._activate = true;\n    this._playing = false;\n    this._rootBone = null;\n    this._stateGraph = null;\n    this._layers = [];\n    this._layerIndices = {};\n    this._parameters = {};\n    this._targets = {};\n    this._consumedTriggers = new Set();\n    this._normalizeWeights = false;\n  }\n  set stateGraphAsset(value) {\n    if (value === null) {\n      this.removeStateGraph();\n      return;\n    }\n    if (this._stateGraphAsset) {\n      const stateGraphAsset = this.system.app.assets.get(this._stateGraphAsset);\n      stateGraphAsset.off('change', this._onStateGraphAssetChangeEvent, this);\n    }\n    let _id;\n    let _asset;\n    if (value instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_1__.Asset) {\n      _id = value.id;\n      _asset = this.system.app.assets.get(_id);\n      if (!_asset) {\n        this.system.app.assets.add(value);\n        _asset = this.system.app.assets.get(_id);\n      }\n    } else {\n      _id = value;\n      _asset = this.system.app.assets.get(_id);\n    }\n    if (!_asset || this._stateGraphAsset === _id) {\n      return;\n    }\n    if (_asset.resource) {\n      this._stateGraph = _asset.resource;\n      this.loadStateGraph(this._stateGraph);\n      _asset.on('change', this._onStateGraphAssetChangeEvent, this);\n    } else {\n      _asset.once('load', asset => {\n        this._stateGraph = asset.resource;\n        this.loadStateGraph(this._stateGraph);\n      });\n      _asset.on('change', this._onStateGraphAssetChangeEvent, this);\n      this.system.app.assets.load(_asset);\n    }\n    this._stateGraphAsset = _id;\n  }\n  get stateGraphAsset() {\n    return this._stateGraphAsset;\n  }\n  set normalizeWeights(value) {\n    this._normalizeWeights = value;\n    this.unbind();\n  }\n  get normalizeWeights() {\n    return this._normalizeWeights;\n  }\n  set animationAssets(value) {\n    this._animationAssets = value;\n    this.loadAnimationAssets();\n  }\n  get animationAssets() {\n    return this._animationAssets;\n  }\n  set speed(value) {\n    this._speed = value;\n  }\n  get speed() {\n    return this._speed;\n  }\n  set activate(value) {\n    this._activate = value;\n  }\n  get activate() {\n    return this._activate;\n  }\n  set playing(value) {\n    this._playing = value;\n  }\n  get playing() {\n    return this._playing;\n  }\n  set rootBone(value) {\n    if (typeof value === 'string') {\n      const entity = this.entity.root.findByGuid(value);\n      this._rootBone = entity;\n    } else if (value instanceof _entity_js__WEBPACK_IMPORTED_MODULE_2__.Entity) {\n      this._rootBone = value;\n    } else {\n      this._rootBone = null;\n    }\n    this.rebind();\n  }\n  get rootBone() {\n    return this._rootBone;\n  }\n  set stateGraph(value) {\n    this._stateGraph = value;\n  }\n  get stateGraph() {\n    return this._stateGraph;\n  }\n  get layers() {\n    return this._layers;\n  }\n  set layerIndices(value) {\n    this._layerIndices = value;\n  }\n  get layerIndices() {\n    return this._layerIndices;\n  }\n  set parameters(value) {\n    this._parameters = value;\n  }\n  get parameters() {\n    return this._parameters;\n  }\n  set targets(value) {\n    this._targets = value;\n  }\n  get targets() {\n    return this._targets;\n  }\n  get playable() {\n    for (let i = 0; i < this._layers.length; i++) {\n      if (!this._layers[i].playable) {\n        return false;\n      }\n    }\n    return true;\n  }\n  get baseLayer() {\n    if (this._layers.length > 0) {\n      return this._layers[0];\n    }\n    return null;\n  }\n  _onStateGraphAssetChangeEvent(asset) {\n    const prevAnimationAssets = this.animationAssets;\n    const prevMasks = this.layers.map(layer => layer.mask);\n    this.removeStateGraph();\n    this._stateGraph = new _anim_state_graph_anim_state_graph_js__WEBPACK_IMPORTED_MODULE_3__.AnimStateGraph(asset._data);\n    this.loadStateGraph(this._stateGraph);\n    this.animationAssets = prevAnimationAssets;\n    this.loadAnimationAssets();\n    this.layers.forEach((layer, i) => {\n      layer.mask = prevMasks[i];\n    });\n    this.rebind();\n  }\n  dirtifyTargets() {\n    const targets = Object.values(this._targets);\n    for (let i = 0; i < targets.length; i++) {\n      targets[i].dirty = true;\n    }\n  }\n  _addLayer({\n    name,\n    states,\n    transitions,\n    weight,\n    mask,\n    blendType\n  }) {\n    let graph;\n    if (this.rootBone) {\n      graph = this.rootBone;\n    } else {\n      graph = this.entity;\n    }\n    const layerIndex = this._layers.length;\n    const animBinder = new _component_binder_js__WEBPACK_IMPORTED_MODULE_4__.AnimComponentBinder(this, graph, name, mask, layerIndex);\n    const animEvaluator = new _anim_evaluator_anim_evaluator_js__WEBPACK_IMPORTED_MODULE_5__.AnimEvaluator(animBinder);\n    const controller = new _anim_controller_anim_controller_js__WEBPACK_IMPORTED_MODULE_6__.AnimController(animEvaluator, states, transitions, this._parameters, this._activate, this, this._consumedTriggers);\n    this._layers.push(new _component_layer_js__WEBPACK_IMPORTED_MODULE_7__.AnimComponentLayer(name, controller, this, weight, blendType));\n    this._layerIndices[name] = layerIndex;\n    return this._layers[layerIndex];\n  }\n  addLayer(name, weight, mask, blendType) {\n    const layer = this.findAnimationLayer(name);\n    if (layer) return layer;\n    const states = [{\n      'name': 'START',\n      'speed': 1\n    }];\n    const transitions = [];\n    return this._addLayer({\n      name,\n      states,\n      transitions,\n      weight,\n      mask,\n      blendType\n    });\n  }\n  loadStateGraph(stateGraph) {\n    this._stateGraph = stateGraph;\n    this._parameters = {};\n    const paramKeys = Object.keys(stateGraph.parameters);\n    for (let i = 0; i < paramKeys.length; i++) {\n      const paramKey = paramKeys[i];\n      this._parameters[paramKey] = {\n        type: stateGraph.parameters[paramKey].type,\n        value: stateGraph.parameters[paramKey].value\n      };\n    }\n    this._layers = [];\n    for (let i = 0; i < stateGraph.layers.length; i++) {\n      const layer = stateGraph.layers[i];\n      this._addLayer.bind(this)((0,_virtual_rollupPluginBabelHelpers_js__WEBPACK_IMPORTED_MODULE_8__[\"extends\"])({}, layer));\n    }\n    this.setupAnimationAssets();\n  }\n  setupAnimationAssets() {\n    for (let i = 0; i < this._layers.length; i++) {\n      const layer = this._layers[i];\n      const layerName = layer.name;\n      for (let j = 0; j < layer.states.length; j++) {\n        const stateName = layer.states[j];\n        if (_anim_controller_constants_js__WEBPACK_IMPORTED_MODULE_9__.ANIM_CONTROL_STATES.indexOf(stateName) === -1) {\n          const stateKey = layerName + ':' + stateName;\n          if (!this._animationAssets[stateKey]) {\n            this._animationAssets[stateKey] = {\n              asset: null\n            };\n          }\n        }\n      }\n    }\n    this.loadAnimationAssets();\n  }\n  loadAnimationAssets() {\n    for (let i = 0; i < this._layers.length; i++) {\n      const layer = this._layers[i];\n      for (let j = 0; j < layer.states.length; j++) {\n        const stateName = layer.states[j];\n        if (_anim_controller_constants_js__WEBPACK_IMPORTED_MODULE_9__.ANIM_CONTROL_STATES.indexOf(stateName) !== -1) continue;\n        const animationAsset = this._animationAssets[layer.name + ':' + stateName];\n        if (!animationAsset || !animationAsset.asset) {\n          this.removeNodeAnimations(stateName, layer.name);\n          continue;\n        }\n        const assetId = animationAsset.asset;\n        const asset = this.system.app.assets.get(assetId);\n        if (asset) {\n          if (asset.resource) {\n            this.onAnimationAssetLoaded(layer.name, stateName, asset);\n          } else {\n            asset.once('load', function (layerName, stateName) {\n              return function (asset) {\n                this.onAnimationAssetLoaded(layerName, stateName, asset);\n              }.bind(this);\n            }.bind(this)(layer.name, stateName));\n            this.system.app.assets.load(asset);\n          }\n        }\n      }\n    }\n  }\n  onAnimationAssetLoaded(layerName, stateName, asset) {\n    this.findAnimationLayer(layerName).assignAnimation(stateName, asset.resource);\n  }\n  removeStateGraph() {\n    this._stateGraph = null;\n    this._stateGraphAsset = null;\n    this._animationAssets = {};\n    this._layers = [];\n    this._layerIndices = {};\n    this._parameters = {};\n    this._playing = false;\n    this.unbind();\n    this._targets = {};\n  }\n  reset() {\n    this._parameters = Object.assign({}, this._stateGraph.parameters);\n    for (let i = 0; i < this._layers.length; i++) {\n      const layerPlaying = this._layers[i].playing;\n      this._layers[i].reset();\n      this._layers[i].playing = layerPlaying;\n    }\n  }\n  unbind() {\n    if (!this._normalizeWeights) {\n      Object.keys(this._targets).forEach(targetKey => {\n        this._targets[targetKey].unbind();\n      });\n    }\n  }\n  rebind() {\n    this._targets = {};\n    for (let i = 0; i < this._layers.length; i++) {\n      this._layers[i].rebind();\n    }\n  }\n  findAnimationLayer(name) {\n    const layerIndex = this._layerIndices[name];\n    return this._layers[layerIndex] || null;\n  }\n  addAnimationState(nodeName, animTrack, speed = 1, loop = true, layerName = 'Base') {\n    if (!this._stateGraph) {\n      this.loadStateGraph(new _anim_state_graph_anim_state_graph_js__WEBPACK_IMPORTED_MODULE_3__.AnimStateGraph({\n        'layers': [{\n          'name': layerName,\n          'states': [{\n            'name': 'START',\n            'speed': 1\n          }, {\n            'name': nodeName,\n            'speed': speed,\n            'loop': loop,\n            'defaultState': true\n          }],\n          'transitions': [{\n            'from': 'START',\n            'to': nodeName\n          }]\n        }],\n        'parameters': {}\n      }));\n    }\n    const layer = this.findAnimationLayer(layerName);\n    if (layer) {\n      layer.assignAnimation(nodeName, animTrack, speed, loop);\n    } else {\n      var _this$addLayer;\n      (_this$addLayer = this.addLayer(layerName)) == null ? void 0 : _this$addLayer.assignAnimation(nodeName, animTrack, speed, loop);\n    }\n  }\n  assignAnimation(nodePath, animTrack, layerName, speed = 1, loop = true) {\n    if (!this._stateGraph && nodePath.indexOf('.') === -1) {\n      this.loadStateGraph(new _anim_state_graph_anim_state_graph_js__WEBPACK_IMPORTED_MODULE_3__.AnimStateGraph({\n        'layers': [{\n          'name': 'Base',\n          'states': [{\n            'name': 'START',\n            'speed': 1\n          }, {\n            'name': nodePath,\n            'speed': speed,\n            'loop': loop,\n            'defaultState': true\n          }],\n          'transitions': [{\n            'from': 'START',\n            'to': nodePath\n          }]\n        }],\n        'parameters': {}\n      }));\n      this.baseLayer.assignAnimation(nodePath, animTrack);\n      return;\n    }\n    const layer = layerName ? this.findAnimationLayer(layerName) : this.baseLayer;\n    if (!layer) {\n      return;\n    }\n    layer.assignAnimation(nodePath, animTrack, speed, loop);\n  }\n  removeNodeAnimations(nodeName, layerName) {\n    const layer = layerName ? this.findAnimationLayer(layerName) : this.baseLayer;\n    if (!layer) {\n      return;\n    }\n    layer.removeNodeAnimations(nodeName);\n  }\n  getParameterValue(name, type) {\n    const param = this._parameters[name];\n    if (param && param.type === type) {\n      return param.value;\n    }\n    return undefined;\n  }\n  setParameterValue(name, type, value) {\n    const param = this._parameters[name];\n    if (param && param.type === type) {\n      param.value = value;\n      return;\n    }\n  }\n  getFloat(name) {\n    return this.getParameterValue(name, _anim_controller_constants_js__WEBPACK_IMPORTED_MODULE_9__.ANIM_PARAMETER_FLOAT);\n  }\n  setFloat(name, value) {\n    this.setParameterValue(name, _anim_controller_constants_js__WEBPACK_IMPORTED_MODULE_9__.ANIM_PARAMETER_FLOAT, value);\n  }\n  getInteger(name) {\n    return this.getParameterValue(name, _anim_controller_constants_js__WEBPACK_IMPORTED_MODULE_9__.ANIM_PARAMETER_INTEGER);\n  }\n  setInteger(name, value) {\n    if (typeof value === 'number' && value % 1 === 0) {\n      this.setParameterValue(name, _anim_controller_constants_js__WEBPACK_IMPORTED_MODULE_9__.ANIM_PARAMETER_INTEGER, value);\n    }\n  }\n  getBoolean(name) {\n    return this.getParameterValue(name, _anim_controller_constants_js__WEBPACK_IMPORTED_MODULE_9__.ANIM_PARAMETER_BOOLEAN);\n  }\n  setBoolean(name, value) {\n    this.setParameterValue(name, _anim_controller_constants_js__WEBPACK_IMPORTED_MODULE_9__.ANIM_PARAMETER_BOOLEAN, !!value);\n  }\n  getTrigger(name) {\n    return this.getParameterValue(name, _anim_controller_constants_js__WEBPACK_IMPORTED_MODULE_9__.ANIM_PARAMETER_TRIGGER);\n  }\n  setTrigger(name, singleFrame = false) {\n    this.setParameterValue(name, _anim_controller_constants_js__WEBPACK_IMPORTED_MODULE_9__.ANIM_PARAMETER_TRIGGER, true);\n    if (singleFrame) {\n      this._consumedTriggers.add(name);\n    }\n  }\n  resetTrigger(name) {\n    this.setParameterValue(name, _anim_controller_constants_js__WEBPACK_IMPORTED_MODULE_9__.ANIM_PARAMETER_TRIGGER, false);\n  }\n  onBeforeRemove() {\n    if (Number.isFinite(this._stateGraphAsset)) {\n      const stateGraphAsset = this.system.app.assets.get(this._stateGraphAsset);\n      stateGraphAsset.off('change', this._onStateGraphAssetChangeEvent, this);\n    }\n  }\n  update(dt) {\n    for (let i = 0; i < this.layers.length; i++) {\n      this.layers[i].update(dt * this.speed);\n    }\n    this._consumedTriggers.forEach(trigger => {\n      this.parameters[trigger].value = false;\n    });\n    this._consumedTriggers.clear();\n  }\n  resolveDuplicatedEntityReferenceProperties(oldAnim, duplicatedIdsMap) {\n    if (oldAnim.rootBone && duplicatedIdsMap[oldAnim.rootBone.getGuid()]) {\n      this.rootBone = duplicatedIdsMap[oldAnim.rootBone.getGuid()];\n    } else {\n      this.rebind();\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/anim/component.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/anim/data.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/anim/data.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimComponentData\": () => (/* binding */ AnimComponentData)\n/* harmony export */ });\nclass AnimComponentData {\n  constructor() {\n    this.enabled = true;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/anim/data.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/anim/system.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/anim/system.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimComponentSystem\": () => (/* binding */ AnimComponentSystem)\n/* harmony export */ });\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/system.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/anim/component.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/anim/data.js\");\n\n\n\n\n\nconst _schema = ['enabled'];\nclass AnimComponentSystem extends _system_js__WEBPACK_IMPORTED_MODULE_0__.ComponentSystem {\n  constructor(app) {\n    super(app);\n    this.id = 'anim';\n    this.ComponentType = _component_js__WEBPACK_IMPORTED_MODULE_1__.AnimComponent;\n    this.DataType = _data_js__WEBPACK_IMPORTED_MODULE_2__.AnimComponentData;\n    this.schema = _schema;\n    this.on('beforeremove', this.onBeforeRemove, this);\n    this.app.systems.on('animationUpdate', this.onAnimationUpdate, this);\n  }\n  initializeComponentData(component, data, properties) {\n    super.initializeComponentData(component, data, _schema);\n    const complexProperties = ['animationAssets', 'stateGraph', 'layers', 'masks'];\n    Object.keys(data).forEach(key => {\n      if (complexProperties.includes(key)) return;\n      component[key] = data[key];\n    });\n    if (data.stateGraph) {\n      component.stateGraph = data.stateGraph;\n      component.loadStateGraph(component.stateGraph);\n    }\n    if (data.layers) {\n      data.layers.forEach((layer, i) => {\n        layer._controller.states.forEach(stateKey => {\n          layer._controller._states[stateKey]._animationList.forEach(node => {\n            component.layers[i].assignAnimation(node.name, node.animTrack);\n          });\n        });\n      });\n    } else if (data.animationAssets) {\n      component.animationAssets = Object.assign(component.animationAssets, data.animationAssets);\n    }\n    if (data.masks) {\n      Object.keys(data.masks).forEach(key => {\n        if (component.layers[key]) {\n          const maskData = data.masks[key].mask;\n          const mask = {};\n          Object.keys(maskData).forEach(maskKey => {\n            mask[decodeURI(maskKey)] = maskData[maskKey];\n          });\n          component.layers[key].mask = mask;\n        }\n      });\n    }\n  }\n  onAnimationUpdate(dt) {\n    const components = this.store;\n    for (const id in components) {\n      if (components.hasOwnProperty(id)) {\n        const component = components[id].entity.anim;\n        const componentData = component.data;\n        if (componentData.enabled && component.entity.enabled && component.playing) {\n          component.update(dt);\n        }\n      }\n    }\n  }\n  cloneComponent(entity, clone) {\n    let masks;\n    if (!entity.anim.rootBone || entity.anim.rootBone === entity) {\n      masks = {};\n      entity.anim.layers.forEach((layer, i) => {\n        if (layer.mask) {\n          const mask = {};\n          Object.keys(layer.mask).forEach(path => {\n            const pathArr = path.split('/');\n            pathArr.shift();\n            const clonePath = [clone.name, ...pathArr].join('/');\n            mask[clonePath] = layer.mask[path];\n          });\n          masks[i] = {\n            mask\n          };\n        }\n      });\n    }\n    const data = {\n      stateGraphAsset: entity.anim.stateGraphAsset,\n      animationAssets: entity.anim.animationAssets,\n      speed: entity.anim.speed,\n      activate: entity.anim.activate,\n      playing: entity.anim.playing,\n      rootBone: entity.anim.rootBone,\n      stateGraph: entity.anim.stateGraph,\n      layers: entity.anim.layers,\n      layerIndices: entity.anim.layerIndices,\n      parameters: entity.anim.parameters,\n      normalizeWeights: entity.anim.normalizeWeights,\n      masks\n    };\n    return this.addComponent(clone, data);\n  }\n  onBeforeRemove(entity, component) {\n    component.onBeforeRemove();\n  }\n  destroy() {\n    super.destroy();\n    this.app.systems.off('animationUpdate', this.onAnimationUpdate, this);\n  }\n}\n_component_js__WEBPACK_IMPORTED_MODULE_3__.Component._buildAccessors(_component_js__WEBPACK_IMPORTED_MODULE_1__.AnimComponent.prototype, _schema);\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/anim/system.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/animation/component.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/animation/component.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimationComponent\": () => (/* binding */ AnimationComponent)\n/* harmony export */ });\n/* harmony import */ var _anim_evaluator_anim_clip_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../anim/evaluator/anim-clip.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-clip.js\");\n/* harmony import */ var _anim_evaluator_anim_evaluator_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../anim/evaluator/anim-evaluator.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-evaluator.js\");\n/* harmony import */ var _anim_evaluator_anim_track_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../anim/evaluator/anim-track.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-track.js\");\n/* harmony import */ var _anim_binder_default_anim_binder_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../anim/binder/default-anim-binder.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/binder/default-anim-binder.js\");\n/* harmony import */ var _scene_animation_skeleton_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../scene/animation/skeleton.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/animation/skeleton.js\");\n/* harmony import */ var _asset_asset_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../asset/asset.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n\n\n\n\n\n\n\n\n\nclass AnimationComponent extends _component_js__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(system, entity) {\n    super(system, entity);\n    this._animations = {};\n    this._assets = [];\n    this._loop = true;\n    this.animEvaluator = null;\n    this.model = null;\n    this.skeleton = null;\n    this.fromSkel = null;\n    this.toSkel = null;\n    this.animationsIndex = {};\n    this.prevAnim = null;\n    this.currAnim = null;\n    this.blend = 0;\n    this.blending = false;\n    this.blendSpeed = 0;\n    this.activate = true;\n    this.speed = 1;\n  }\n  set animations(value) {\n    this._animations = value;\n    this.onSetAnimations();\n  }\n  get animations() {\n    return this._animations;\n  }\n  set assets(value) {\n    const assets = this._assets;\n    if (assets && assets.length) {\n      for (let i = 0; i < assets.length; i++) {\n        if (assets[i]) {\n          const asset = this.system.app.assets.get(assets[i]);\n          if (asset) {\n            asset.off('change', this.onAssetChanged, this);\n            asset.off('remove', this.onAssetRemoved, this);\n            const animName = this.animationsIndex[asset.id];\n            if (this.currAnim === animName) this._stopCurrentAnimation();\n            delete this.animations[animName];\n            delete this.animationsIndex[asset.id];\n          }\n        }\n      }\n    }\n    this._assets = value;\n    const assetIds = value.map(value => {\n      return value instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_1__.Asset ? value.id : value;\n    });\n    this.loadAnimationAssets(assetIds);\n  }\n  get assets() {\n    return this._assets;\n  }\n  set currentTime(currentTime) {\n    if (this.skeleton) {\n      this.skeleton.currentTime = currentTime;\n      this.skeleton.addTime(0);\n      this.skeleton.updateGraph();\n    }\n    if (this.animEvaluator) {\n      const clips = this.animEvaluator.clips;\n      for (let i = 0; i < clips.length; ++i) {\n        clips[i].time = currentTime;\n      }\n    }\n  }\n  get currentTime() {\n    if (this.skeleton) {\n      return this.skeleton._time;\n    }\n    if (this.animEvaluator) {\n      const clips = this.animEvaluator.clips;\n      if (clips.length > 0) {\n        return clips[clips.length - 1].time;\n      }\n    }\n    return 0;\n  }\n  get duration() {\n    if (this.currAnim) {\n      return this.animations[this.currAnim].duration;\n    }\n    return 0;\n  }\n  set loop(value) {\n    this._loop = value;\n    if (this.skeleton) {\n      this.skeleton.looping = value;\n    }\n    if (this.animEvaluator) {\n      for (let i = 0; i < this.animEvaluator.clips.length; ++i) {\n        this.animEvaluator.clips[i].loop = value;\n      }\n    }\n  }\n  get loop() {\n    return this._loop;\n  }\n  play(name, blendTime = 0) {\n    if (!this.enabled || !this.entity.enabled) {\n      return;\n    }\n    if (!this.animations[name]) {\n      return;\n    }\n    this.prevAnim = this.currAnim;\n    this.currAnim = name;\n    if (this.model) {\n      if (!this.skeleton && !this.animEvaluator) {\n        this._createAnimationController();\n      }\n      const prevAnim = this.animations[this.prevAnim];\n      const currAnim = this.animations[this.currAnim];\n      this.blending = blendTime > 0 && !!this.prevAnim;\n      if (this.blending) {\n        this.blend = 0;\n        this.blendSpeed = 1 / blendTime;\n      }\n      if (this.skeleton) {\n        if (this.blending) {\n          this.fromSkel.animation = prevAnim;\n          this.fromSkel.addTime(this.skeleton._time);\n          this.toSkel.animation = currAnim;\n        } else {\n          this.skeleton.animation = currAnim;\n        }\n      }\n      if (this.animEvaluator) {\n        const animEvaluator = this.animEvaluator;\n        if (this.blending) {\n          while (animEvaluator.clips.length > 1) {\n            animEvaluator.removeClip(0);\n          }\n        } else {\n          this.animEvaluator.removeClips();\n        }\n        const clip = new _anim_evaluator_anim_clip_js__WEBPACK_IMPORTED_MODULE_2__.AnimClip(this.animations[this.currAnim], 0, 1.0, true, this.loop);\n        clip.name = this.currAnim;\n        clip.blendWeight = this.blending ? 0 : 1;\n        clip.reset();\n        this.animEvaluator.addClip(clip);\n      }\n    }\n    this.playing = true;\n  }\n  getAnimation(name) {\n    return this.animations[name];\n  }\n  setModel(model) {\n    if (model !== this.model) {\n      this._resetAnimationController();\n      this.model = model;\n      if (this.animations && this.currAnim && this.animations[this.currAnim]) {\n        this.play(this.currAnim);\n      }\n    }\n  }\n  onSetAnimations() {\n    const modelComponent = this.entity.model;\n    if (modelComponent) {\n      const m = modelComponent.model;\n      if (m && m !== this.model) {\n        this.setModel(m);\n      }\n    }\n    if (!this.currAnim && this.activate && this.enabled && this.entity.enabled) {\n      const animationNames = Object.keys(this._animations);\n      if (animationNames.length > 0) {\n        this.play(animationNames[0]);\n      }\n    }\n  }\n  _resetAnimationController() {\n    this.skeleton = null;\n    this.fromSkel = null;\n    this.toSkel = null;\n    this.animEvaluator = null;\n  }\n  _createAnimationController() {\n    const model = this.model;\n    const animations = this.animations;\n    let hasJson = false;\n    let hasGlb = false;\n    for (const animation in animations) {\n      if (animations.hasOwnProperty(animation)) {\n        const anim = animations[animation];\n        if (anim.constructor === _anim_evaluator_anim_track_js__WEBPACK_IMPORTED_MODULE_3__.AnimTrack) {\n          hasGlb = true;\n        } else {\n          hasJson = true;\n        }\n      }\n    }\n    const graph = model.getGraph();\n    if (hasJson) {\n      this.fromSkel = new _scene_animation_skeleton_js__WEBPACK_IMPORTED_MODULE_4__.Skeleton(graph);\n      this.toSkel = new _scene_animation_skeleton_js__WEBPACK_IMPORTED_MODULE_4__.Skeleton(graph);\n      this.skeleton = new _scene_animation_skeleton_js__WEBPACK_IMPORTED_MODULE_4__.Skeleton(graph);\n      this.skeleton.looping = this.loop;\n      this.skeleton.setGraph(graph);\n    } else if (hasGlb) {\n      this.animEvaluator = new _anim_evaluator_anim_evaluator_js__WEBPACK_IMPORTED_MODULE_5__.AnimEvaluator(new _anim_binder_default_anim_binder_js__WEBPACK_IMPORTED_MODULE_6__.DefaultAnimBinder(this.entity));\n    }\n  }\n  loadAnimationAssets(ids) {\n    if (!ids || !ids.length) return;\n    const assets = this.system.app.assets;\n    const onAssetReady = asset => {\n      if (asset.resources.length > 1) {\n        for (let i = 0; i < asset.resources.length; i++) {\n          this.animations[asset.resources[i].name] = asset.resources[i];\n          this.animationsIndex[asset.id] = asset.resources[i].name;\n        }\n      } else {\n        this.animations[asset.name] = asset.resource;\n        this.animationsIndex[asset.id] = asset.name;\n      }\n      this.animations = this.animations;\n    };\n    const onAssetAdd = asset => {\n      asset.off('change', this.onAssetChanged, this);\n      asset.on('change', this.onAssetChanged, this);\n      asset.off('remove', this.onAssetRemoved, this);\n      asset.on('remove', this.onAssetRemoved, this);\n      if (asset.resource) {\n        onAssetReady(asset);\n      } else {\n        asset.once('load', onAssetReady, this);\n        if (this.enabled && this.entity.enabled) assets.load(asset);\n      }\n    };\n    for (let i = 0, l = ids.length; i < l; i++) {\n      const asset = assets.get(ids[i]);\n      if (asset) {\n        onAssetAdd(asset);\n      } else {\n        assets.on('add:' + ids[i], onAssetAdd);\n      }\n    }\n  }\n  onAssetChanged(asset, attribute, newValue, oldValue) {\n    if (attribute === 'resource' || attribute === 'resources') {\n      if (attribute === 'resources' && newValue && newValue.length === 0) {\n        newValue = null;\n      }\n      if (newValue) {\n        let restarted = false;\n        if (newValue.length > 1) {\n          if (oldValue && oldValue.length > 1) {\n            for (let i = 0; i < oldValue.length; i++) {\n              delete this.animations[oldValue[i].name];\n            }\n          } else {\n            delete this.animations[asset.name];\n          }\n          restarted = false;\n          for (let i = 0; i < newValue.length; i++) {\n            this.animations[newValue[i].name] = newValue[i];\n            if (!restarted && this.currAnim === newValue[i].name) {\n              if (this.playing && this.enabled && this.entity.enabled) {\n                restarted = true;\n                this.play(newValue[i].name);\n              }\n            }\n          }\n          if (!restarted) {\n            this._stopCurrentAnimation();\n            this.onSetAnimations();\n          }\n        } else {\n          if (oldValue && oldValue.length > 1) {\n            for (let i = 0; i < oldValue.length; i++) {\n              delete this.animations[oldValue[i].name];\n            }\n          }\n          this.animations[asset.name] = newValue[0] || newValue;\n          restarted = false;\n          if (this.currAnim === asset.name) {\n            if (this.playing && this.enabled && this.entity.enabled) {\n              restarted = true;\n              this.play(asset.name);\n            }\n          }\n          if (!restarted) {\n            this._stopCurrentAnimation();\n            this.onSetAnimations();\n          }\n        }\n        this.animationsIndex[asset.id] = asset.name;\n      } else {\n        if (oldValue.length > 1) {\n          for (let i = 0; i < oldValue.length; i++) {\n            delete this.animations[oldValue[i].name];\n            if (this.currAnim === oldValue[i].name) {\n              this._stopCurrentAnimation();\n            }\n          }\n        } else {\n          delete this.animations[asset.name];\n          if (this.currAnim === asset.name) {\n            this._stopCurrentAnimation();\n          }\n        }\n        delete this.animationsIndex[asset.id];\n      }\n    }\n  }\n  onAssetRemoved(asset) {\n    asset.off('remove', this.onAssetRemoved, this);\n    if (this.animations) {\n      if (asset.resources.length > 1) {\n        for (let i = 0; i < asset.resources.length; i++) {\n          delete this.animations[asset.resources[i].name];\n          if (this.currAnim === asset.resources[i].name) this._stopCurrentAnimation();\n        }\n      } else {\n        delete this.animations[asset.name];\n        if (this.currAnim === asset.name) this._stopCurrentAnimation();\n      }\n      delete this.animationsIndex[asset.id];\n    }\n  }\n  _stopCurrentAnimation() {\n    this.currAnim = null;\n    this.playing = false;\n    if (this.skeleton) {\n      this.skeleton.currentTime = 0;\n      this.skeleton.animation = null;\n    }\n    if (this.animEvaluator) {\n      for (let i = 0; i < this.animEvaluator.clips.length; ++i) {\n        this.animEvaluator.clips[i].stop();\n      }\n      this.animEvaluator.update(0);\n      this.animEvaluator.removeClips();\n    }\n  }\n  onEnable() {\n    super.onEnable();\n    const assets = this.assets;\n    const registry = this.system.app.assets;\n    if (assets) {\n      for (let i = 0, len = assets.length; i < len; i++) {\n        let asset = assets[i];\n        if (!(asset instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_1__.Asset)) asset = registry.get(asset);\n        if (asset && !asset.resource) registry.load(asset);\n      }\n    }\n    if (this.activate && !this.currAnim) {\n      const animationNames = Object.keys(this.animations);\n      if (animationNames.length > 0) {\n        this.play(animationNames[0]);\n      }\n    }\n  }\n  onBeforeRemove() {\n    for (let i = 0; i < this.assets.length; i++) {\n      let asset = this.assets[i];\n      if (typeof asset === 'number') {\n        asset = this.system.app.assets.get(asset);\n      }\n      if (!asset) continue;\n      asset.off('change', this.onAssetChanged, this);\n      asset.off('remove', this.onAssetRemoved, this);\n    }\n    this.skeleton = null;\n    this.fromSkel = null;\n    this.toSkel = null;\n    this.animEvaluator = null;\n  }\n  update(dt) {\n    if (this.blending) {\n      this.blend += dt * this.blendSpeed;\n      if (this.blend >= 1) {\n        this.blend = 1;\n      }\n    }\n    if (this.playing) {\n      const skeleton = this.skeleton;\n      if (skeleton !== null && this.model !== null) {\n        if (this.blending) {\n          skeleton.blend(this.fromSkel, this.toSkel, this.blend);\n        } else {\n          const delta = dt * this.speed;\n          skeleton.addTime(delta);\n          if (this.speed > 0 && skeleton._time === skeleton.animation.duration && !this.loop) {\n            this.playing = false;\n          } else if (this.speed < 0 && skeleton._time === 0 && !this.loop) {\n            this.playing = false;\n          }\n        }\n        if (this.blending && this.blend === 1) {\n          skeleton.animation = this.toSkel.animation;\n        }\n        skeleton.updateGraph();\n      }\n    }\n    const animEvaluator = this.animEvaluator;\n    if (animEvaluator) {\n      for (let i = 0; i < animEvaluator.clips.length; ++i) {\n        const clip = animEvaluator.clips[i];\n        clip.speed = this.speed;\n        if (!this.playing) {\n          clip.pause();\n        } else {\n          clip.resume();\n        }\n      }\n      if (this.blending && animEvaluator.clips.length > 1) {\n        animEvaluator.clips[1].blendWeight = this.blend;\n      }\n      animEvaluator.update(dt);\n    }\n    if (this.blending && this.blend === 1) {\n      this.blending = false;\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/animation/component.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/animation/data.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/animation/data.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimationComponentData\": () => (/* binding */ AnimationComponentData)\n/* harmony export */ });\nclass AnimationComponentData {\n  constructor() {\n    this.enabled = true;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/animation/data.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/animation/system.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/animation/system.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimationComponentSystem\": () => (/* binding */ AnimationComponentSystem)\n/* harmony export */ });\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/system.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/animation/component.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/animation/data.js\");\n\n\n\n\n\nconst _schema = ['enabled'];\nclass AnimationComponentSystem extends _system_js__WEBPACK_IMPORTED_MODULE_0__.ComponentSystem {\n  constructor(app) {\n    super(app);\n    this.id = 'animation';\n    this.ComponentType = _component_js__WEBPACK_IMPORTED_MODULE_1__.AnimationComponent;\n    this.DataType = _data_js__WEBPACK_IMPORTED_MODULE_2__.AnimationComponentData;\n    this.schema = _schema;\n    this.on('beforeremove', this.onBeforeRemove, this);\n    this.app.systems.on('update', this.onUpdate, this);\n  }\n  initializeComponentData(component, data, properties) {\n    properties = ['activate', 'enabled', 'loop', 'speed', 'assets'];\n    for (const property of properties) {\n      if (data.hasOwnProperty(property)) {\n        component[property] = data[property];\n      }\n    }\n    super.initializeComponentData(component, data, _schema);\n  }\n  cloneComponent(entity, clone) {\n    this.addComponent(clone, {});\n    clone.animation.assets = entity.animation.assets.slice();\n    clone.animation.speed = entity.animation.speed;\n    clone.animation.loop = entity.animation.loop;\n    clone.animation.activate = entity.animation.activate;\n    clone.animation.enabled = entity.animation.enabled;\n    const clonedAnimations = {};\n    const animations = entity.animation.animations;\n    for (const key in animations) {\n      if (animations.hasOwnProperty(key)) {\n        clonedAnimations[key] = animations[key];\n      }\n    }\n    clone.animation.animations = clonedAnimations;\n    const clonedAnimationsIndex = {};\n    const animationsIndex = entity.animation.animationsIndex;\n    for (const key in animationsIndex) {\n      if (animationsIndex.hasOwnProperty(key)) {\n        clonedAnimationsIndex[key] = animationsIndex[key];\n      }\n    }\n    clone.animation.animationsIndex = clonedAnimationsIndex;\n    return clone.animation;\n  }\n  onBeforeRemove(entity, component) {\n    component.onBeforeRemove();\n  }\n  onUpdate(dt) {\n    const components = this.store;\n    for (const id in components) {\n      if (components.hasOwnProperty(id)) {\n        const component = components[id];\n        if (component.data.enabled && component.entity.enabled) {\n          component.entity.animation.update(dt);\n        }\n      }\n    }\n  }\n  destroy() {\n    super.destroy();\n    this.app.systems.off('update', this.onUpdate, this);\n  }\n}\n_component_js__WEBPACK_IMPORTED_MODULE_3__.Component._buildAccessors(_component_js__WEBPACK_IMPORTED_MODULE_1__.AnimationComponent.prototype, _schema);\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/animation/system.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/audio-listener/component.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/audio-listener/component.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AudioListenerComponent\": () => (/* binding */ AudioListenerComponent)\n/* harmony export */ });\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n\n\nclass AudioListenerComponent extends _component_js__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(system, entity) {\n    super(system, entity);\n  }\n  setCurrentListener() {\n    if (this.enabled && this.entity.audiolistener && this.entity.enabled) {\n      this.system.current = this.entity;\n      const position = this.system.current.getPosition();\n      this.system.manager.listener.setPosition(position);\n    }\n  }\n  onEnable() {\n    this.setCurrentListener();\n  }\n  onDisable() {\n    if (this.system.current === this.entity) {\n      this.system.current = null;\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/audio-listener/component.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/audio-listener/data.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/audio-listener/data.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AudioListenerComponentData\": () => (/* binding */ AudioListenerComponentData)\n/* harmony export */ });\nclass AudioListenerComponentData {\n  constructor() {\n    this.enabled = true;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/audio-listener/data.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/audio-listener/system.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/audio-listener/system.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AudioListenerComponentSystem\": () => (/* binding */ AudioListenerComponentSystem)\n/* harmony export */ });\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/system.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/audio-listener/component.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/audio-listener/data.js\");\n\n\n\n\n\n\nconst _schema = ['enabled'];\nclass AudioListenerComponentSystem extends _system_js__WEBPACK_IMPORTED_MODULE_0__.ComponentSystem {\n  constructor(app) {\n    super(app);\n    this.id = 'audiolistener';\n    this.ComponentType = _component_js__WEBPACK_IMPORTED_MODULE_1__.AudioListenerComponent;\n    this.DataType = _data_js__WEBPACK_IMPORTED_MODULE_2__.AudioListenerComponentData;\n    this.schema = _schema;\n    this.manager = app.soundManager;\n    this.current = null;\n    this.app.systems.on('update', this.onUpdate, this);\n  }\n  initializeComponentData(component, data, properties) {\n    properties = ['enabled'];\n    super.initializeComponentData(component, data, properties);\n  }\n  onUpdate(dt) {\n    if (this.current) {\n      const position = this.current.getPosition();\n      this.manager.listener.setPosition(position);\n      const wtm = this.current.getWorldTransform();\n      this.manager.listener.setOrientation(wtm);\n    }\n  }\n  destroy() {\n    super.destroy();\n    this.app.systems.off('update', this.onUpdate, this);\n  }\n}\n_component_js__WEBPACK_IMPORTED_MODULE_3__.Component._buildAccessors(_component_js__WEBPACK_IMPORTED_MODULE_1__.AudioListenerComponent.prototype, _schema);\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/audio-listener/system.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/audio-source/component.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/audio-source/component.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AudioSourceComponent\": () => (/* binding */ AudioSourceComponent)\n/* harmony export */ });\n/* harmony import */ var _asset_asset_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../asset/asset.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset.js\");\n/* harmony import */ var _platform_audio_channel3d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../platform/audio/channel3d.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/audio/channel3d.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n\n\n\n\nclass AudioSourceComponent extends _component_js__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(system, entity) {\n    super(system, entity);\n    this.on('set_assets', this.onSetAssets, this);\n    this.on('set_loop', this.onSetLoop, this);\n    this.on('set_volume', this.onSetVolume, this);\n    this.on('set_pitch', this.onSetPitch, this);\n    this.on('set_minDistance', this.onSetMinDistance, this);\n    this.on('set_maxDistance', this.onSetMaxDistance, this);\n    this.on('set_rollOffFactor', this.onSetRollOffFactor, this);\n    this.on('set_distanceModel', this.onSetDistanceModel, this);\n    this.on('set_3d', this.onSet3d, this);\n  }\n  play(name) {\n    if (!this.enabled || !this.entity.enabled) {\n      return;\n    }\n    if (this.channel) {\n      this.stop();\n    }\n    let channel;\n    const componentData = this.data;\n    if (componentData.sources[name]) {\n      if (!componentData['3d']) {\n        channel = this.system.manager.playSound(componentData.sources[name], componentData);\n        componentData.currentSource = name;\n        componentData.channel = channel;\n      } else {\n        const pos = this.entity.getPosition();\n        channel = this.system.manager.playSound3d(componentData.sources[name], pos, componentData);\n        componentData.currentSource = name;\n        componentData.channel = channel;\n      }\n    }\n  }\n  pause() {\n    if (this.channel) {\n      this.channel.pause();\n    }\n  }\n  unpause() {\n    if (this.channel && this.channel.paused) {\n      this.channel.unpause();\n    }\n  }\n  stop() {\n    if (this.channel) {\n      this.channel.stop();\n      this.channel = null;\n    }\n  }\n  onSetAssets(name, oldValue, newValue) {\n    const newAssets = [];\n    const len = newValue.length;\n    if (oldValue && oldValue.length) {\n      for (let i = 0; i < oldValue.length; i++) {\n        if (oldValue[i]) {\n          const asset = this.system.app.assets.get(oldValue[i]);\n          if (asset) {\n            asset.off('change', this.onAssetChanged, this);\n            asset.off('remove', this.onAssetRemoved, this);\n            if (this.currentSource === asset.name) {\n              this.stop();\n            }\n          }\n        }\n      }\n    }\n    if (len) {\n      for (let i = 0; i < len; i++) {\n        if (oldValue.indexOf(newValue[i]) < 0) {\n          if (newValue[i] instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_1__.Asset) {\n            newAssets.push(newValue[i].id);\n          } else {\n            newAssets.push(newValue[i]);\n          }\n        }\n      }\n    }\n    if (!this.system._inTools && newAssets.length) {\n      this.loadAudioSourceAssets(newAssets);\n    }\n  }\n  onAssetChanged(asset, attribute, newValue, oldValue) {\n    if (attribute === 'resource') {\n      const sources = this.data.sources;\n      if (sources) {\n        this.data.sources[asset.name] = newValue;\n        if (this.data.currentSource === asset.name) {\n          if (this.channel) {\n            if (this.channel.paused) {\n              this.play(asset.name);\n              this.pause();\n            } else {\n              this.play(asset.name);\n            }\n          }\n        }\n      }\n    }\n  }\n  onAssetRemoved(asset) {\n    asset.off('remove', this.onAssetRemoved, this);\n    if (this.data.sources[asset.name]) {\n      delete this.data.sources[asset.name];\n      if (this.data.currentSource === asset.name) {\n        this.stop();\n        this.data.currentSource = null;\n      }\n    }\n  }\n  onSetLoop(name, oldValue, newValue) {\n    if (oldValue !== newValue) {\n      if (this.channel) {\n        this.channel.setLoop(newValue);\n      }\n    }\n  }\n  onSetVolume(name, oldValue, newValue) {\n    if (oldValue !== newValue) {\n      if (this.channel) {\n        this.channel.setVolume(newValue);\n      }\n    }\n  }\n  onSetPitch(name, oldValue, newValue) {\n    if (oldValue !== newValue) {\n      if (this.channel) {\n        this.channel.setPitch(newValue);\n      }\n    }\n  }\n  onSetMaxDistance(name, oldValue, newValue) {\n    if (oldValue !== newValue) {\n      if (this.channel instanceof _platform_audio_channel3d_js__WEBPACK_IMPORTED_MODULE_2__.Channel3d) {\n        this.channel.setMaxDistance(newValue);\n      }\n    }\n  }\n  onSetMinDistance(name, oldValue, newValue) {\n    if (oldValue !== newValue) {\n      if (this.channel instanceof _platform_audio_channel3d_js__WEBPACK_IMPORTED_MODULE_2__.Channel3d) {\n        this.channel.setMinDistance(newValue);\n      }\n    }\n  }\n  onSetRollOffFactor(name, oldValue, newValue) {\n    if (oldValue !== newValue) {\n      if (this.channel instanceof _platform_audio_channel3d_js__WEBPACK_IMPORTED_MODULE_2__.Channel3d) {\n        this.channel.setRollOffFactor(newValue);\n      }\n    }\n  }\n  onSetDistanceModel(name, oldValue, newValue) {\n    if (oldValue !== newValue) {\n      if (this.channel instanceof _platform_audio_channel3d_js__WEBPACK_IMPORTED_MODULE_2__.Channel3d) {\n        this.channel.setDistanceModel(newValue);\n      }\n    }\n  }\n  onSet3d(name, oldValue, newValue) {\n    if (oldValue !== newValue) {\n      if (this.system.initialized && this.currentSource) {\n        let paused = false;\n        let suspended = false;\n        if (this.channel) {\n          paused = this.channel.paused;\n          suspended = this.channel.suspended;\n        }\n        this.play(this.currentSource);\n        if (this.channel) {\n          this.channel.paused = paused;\n          this.channel.suspended = suspended;\n        }\n      }\n    }\n  }\n  onEnable() {\n    const assets = this.data.assets;\n    if (assets) {\n      const registry = this.system.app.assets;\n      for (let i = 0, len = assets.length; i < len; i++) {\n        let asset = assets[i];\n        if (!(asset instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_1__.Asset)) asset = registry.get(asset);\n        if (asset && !asset.resource) {\n          registry.load(asset);\n        }\n      }\n    }\n    if (this.system.initialized) {\n      if (this.data.activate && !this.channel) {\n        this.play(this.currentSource);\n      } else {\n        this.unpause();\n      }\n    }\n  }\n  onDisable() {\n    this.pause();\n  }\n  loadAudioSourceAssets(ids) {\n    const assets = ids.map(id => {\n      return this.system.app.assets.get(id);\n    });\n    const sources = {};\n    let currentSource = null;\n    let count = assets.length;\n    const _error = e => {\n      count--;\n    };\n    const _done = () => {\n      this.data.sources = sources;\n      this.data.currentSource = currentSource;\n      if (this.enabled && this.activate && currentSource) {\n        this.onEnable();\n      }\n    };\n    assets.forEach((asset, index) => {\n      if (asset) {\n        currentSource = currentSource || asset.name;\n        asset.off('change', this.onAssetChanged, this);\n        asset.on('change', this.onAssetChanged, this);\n        asset.off('remove', this.onAssetRemoved, this);\n        asset.on('remove', this.onAssetRemoved, this);\n        asset.off('error', _error, this);\n        asset.on('error', _error, this);\n        asset.ready(asset => {\n          sources[asset.name] = asset.resource;\n          count--;\n          if (count === 0) {\n            _done();\n          }\n        });\n        if (!asset.resource && this.enabled && this.entity.enabled) this.system.app.assets.load(asset);\n      } else {\n        count--;\n        if (count === 0) {\n          _done();\n        }\n        this.system.app.assets.on('add:' + ids[index], asset => {\n          asset.ready(asset => {\n            this.data.sources[asset.name] = asset.resource;\n          });\n          if (!asset.resource) this.system.app.assets.load(asset);\n        });\n      }\n    });\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/audio-source/component.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/audio-source/data.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/audio-source/data.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AudioSourceComponentData\": () => (/* binding */ AudioSourceComponentData)\n/* harmony export */ });\n/* harmony import */ var _platform_audio_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/audio/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/audio/constants.js\");\n\n\nclass AudioSourceComponentData {\n  constructor() {\n    this.enabled = true;\n    this.assets = [];\n    this.activate = true;\n    this.volume = 1;\n    this.pitch = 1;\n    this.loop = false;\n    this['3d'] = true;\n    this.minDistance = 1;\n    this.maxDistance = 10000;\n    this.rollOffFactor = 1;\n    this.distanceModel = _platform_audio_constants_js__WEBPACK_IMPORTED_MODULE_0__.DISTANCE_INVERSE;\n    this.paused = true;\n    this.sources = {};\n    this.currentSource = null;\n    this.channel = null;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/audio-source/data.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/audio-source/system.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/audio-source/system.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AudioSourceComponentSystem\": () => (/* binding */ AudioSourceComponentSystem)\n/* harmony export */ });\n/* harmony import */ var _platform_audio_channel3d_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../platform/audio/channel3d.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/audio/channel3d.js\");\n/* harmony import */ var _entity_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../entity.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/entity.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/system.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/audio-source/component.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/audio-source/data.js\");\n\n\n\n\n\n\n\n\nconst _schema = ['enabled', 'assets', 'volume', 'pitch', 'loop', 'activate', '3d', 'minDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'sources', 'currentSource', 'channel'];\nclass AudioSourceComponentSystem extends _system_js__WEBPACK_IMPORTED_MODULE_0__.ComponentSystem {\n  constructor(app) {\n    super(app);\n    this.id = 'audiosource';\n    this.ComponentType = _component_js__WEBPACK_IMPORTED_MODULE_1__.AudioSourceComponent;\n    this.DataType = _data_js__WEBPACK_IMPORTED_MODULE_2__.AudioSourceComponentData;\n    this.schema = _schema;\n    this.manager = app.soundManager;\n    this.initialized = false;\n    this.app.systems.on('initialize', this.onInitialize, this);\n    this.app.systems.on('update', this.onUpdate, this);\n    this.on('remove', this.onRemove, this);\n  }\n  initializeComponentData(component, data, properties) {\n    properties = ['activate', 'volume', 'pitch', 'loop', '3d', 'minDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'enabled', 'assets'];\n    super.initializeComponentData(component, data, properties);\n    component.paused = !(component.enabled && component.activate);\n  }\n  onInitialize(root) {\n    if (root.audiosource && root.enabled && root.audiosource.enabled && root.audiosource.activate) {\n      root.audiosource.play(root.audiosource.currentSource);\n    }\n    const children = root._children;\n    for (let i = 0, len = children.length; i < len; i++) {\n      if (children[i] instanceof _entity_js__WEBPACK_IMPORTED_MODULE_3__.Entity) {\n        this.onInitialize(children[i]);\n      }\n    }\n    this.initialized = true;\n  }\n  onUpdate(dt) {\n    const components = this.store;\n    for (const id in components) {\n      if (components.hasOwnProperty(id)) {\n        const component = components[id];\n        const entity = component.entity;\n        const componentData = component.data;\n        if (componentData.enabled && entity.enabled && componentData.channel instanceof _platform_audio_channel3d_js__WEBPACK_IMPORTED_MODULE_4__.Channel3d) {\n          const pos = entity.getPosition();\n          componentData.channel.setPosition(pos);\n        }\n      }\n    }\n  }\n  onRemove(entity, data) {\n    if (data.channel) {\n      data.channel.stop();\n      data.channel = null;\n    }\n  }\n  setVolume(volume) {\n    this.manager.setVolume(volume);\n  }\n  destroy() {\n    super.destroy();\n    this.app.systems.off('initialize', this.onInitialize, this);\n    this.app.systems.off('update', this.onUpdate, this);\n  }\n}\n_component_js__WEBPACK_IMPORTED_MODULE_5__.Component._buildAccessors(_component_js__WEBPACK_IMPORTED_MODULE_1__.AudioSourceComponent.prototype, _schema);\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/audio-source/system.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/button/component.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/button/component.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ButtonComponent\": () => (/* binding */ ButtonComponent)\n/* harmony export */ });\n/* harmony import */ var _core_time_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/time.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/time.js\");\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _core_math_color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/math/color.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n/* harmony import */ var _utils_entity_reference_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/entity-reference.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/utils/entity-reference.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/button/constants.js\");\n/* harmony import */ var _element_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../element/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/constants.js\");\n\n\n\n\n\n\n\n\nconst VisualState = {\n  DEFAULT: 'DEFAULT',\n  HOVER: 'HOVER',\n  PRESSED: 'PRESSED',\n  INACTIVE: 'INACTIVE'\n};\nconst STATES_TO_TINT_NAMES = {};\nSTATES_TO_TINT_NAMES[VisualState.DEFAULT] = '_defaultTint';\nSTATES_TO_TINT_NAMES[VisualState.HOVER] = 'hoverTint';\nSTATES_TO_TINT_NAMES[VisualState.PRESSED] = 'pressedTint';\nSTATES_TO_TINT_NAMES[VisualState.INACTIVE] = 'inactiveTint';\nconst STATES_TO_SPRITE_ASSET_NAMES = {};\nSTATES_TO_SPRITE_ASSET_NAMES[VisualState.DEFAULT] = '_defaultSpriteAsset';\nSTATES_TO_SPRITE_ASSET_NAMES[VisualState.HOVER] = 'hoverSpriteAsset';\nSTATES_TO_SPRITE_ASSET_NAMES[VisualState.PRESSED] = 'pressedSpriteAsset';\nSTATES_TO_SPRITE_ASSET_NAMES[VisualState.INACTIVE] = 'inactiveSpriteAsset';\nconst STATES_TO_SPRITE_FRAME_NAMES = {};\nSTATES_TO_SPRITE_FRAME_NAMES[VisualState.DEFAULT] = '_defaultSpriteFrame';\nSTATES_TO_SPRITE_FRAME_NAMES[VisualState.HOVER] = 'hoverSpriteFrame';\nSTATES_TO_SPRITE_FRAME_NAMES[VisualState.PRESSED] = 'pressedSpriteFrame';\nSTATES_TO_SPRITE_FRAME_NAMES[VisualState.INACTIVE] = 'inactiveSpriteFrame';\nclass ButtonComponent extends _component_js__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(system, entity) {\n    super(system, entity);\n    this._visualState = VisualState.DEFAULT;\n    this._isHovering = false;\n    this._hoveringCounter = 0;\n    this._isPressed = false;\n    this._defaultTint = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_1__.Color(1, 1, 1, 1);\n    this._defaultSpriteAsset = null;\n    this._defaultSpriteFrame = 0;\n    this._imageReference = new _utils_entity_reference_js__WEBPACK_IMPORTED_MODULE_2__.EntityReference(this, 'imageEntity', {\n      'element#gain': this._onImageElementGain,\n      'element#lose': this._onImageElementLose,\n      'element#set:color': this._onSetColor,\n      'element#set:opacity': this._onSetOpacity,\n      'element#set:spriteAsset': this._onSetSpriteAsset,\n      'element#set:spriteFrame': this._onSetSpriteFrame\n    });\n    this._toggleLifecycleListeners('on', system);\n  }\n  _toggleLifecycleListeners(onOrOff, system) {\n    this[onOrOff]('set_active', this._onSetActive, this);\n    this[onOrOff]('set_transitionMode', this._onSetTransitionMode, this);\n    this[onOrOff]('set_hoverTint', this._onSetTransitionValue, this);\n    this[onOrOff]('set_pressedTint', this._onSetTransitionValue, this);\n    this[onOrOff]('set_inactiveTint', this._onSetTransitionValue, this);\n    this[onOrOff]('set_hoverSpriteAsset', this._onSetTransitionValue, this);\n    this[onOrOff]('set_hoverSpriteFrame', this._onSetTransitionValue, this);\n    this[onOrOff]('set_pressedSpriteAsset', this._onSetTransitionValue, this);\n    this[onOrOff]('set_pressedSpriteFrame', this._onSetTransitionValue, this);\n    this[onOrOff]('set_inactiveSpriteAsset', this._onSetTransitionValue, this);\n    this[onOrOff]('set_inactiveSpriteFrame', this._onSetTransitionValue, this);\n    system.app.systems.element[onOrOff]('add', this._onElementComponentAdd, this);\n    system.app.systems.element[onOrOff]('beforeremove', this._onElementComponentRemove, this);\n  }\n  _onSetActive(name, oldValue, newValue) {\n    if (oldValue !== newValue) {\n      this._updateVisualState();\n    }\n  }\n  _onSetTransitionMode(name, oldValue, newValue) {\n    if (oldValue !== newValue) {\n      this._cancelTween();\n      this._resetToDefaultVisualState(oldValue);\n      this._forceReapplyVisualState();\n    }\n  }\n  _onSetTransitionValue(name, oldValue, newValue) {\n    if (oldValue !== newValue) {\n      this._forceReapplyVisualState();\n    }\n  }\n  _onElementComponentRemove(entity) {\n    if (this.entity === entity) {\n      this._toggleHitElementListeners('off');\n    }\n  }\n  _onElementComponentAdd(entity) {\n    if (this.entity === entity) {\n      this._toggleHitElementListeners('on');\n    }\n  }\n  _onImageElementLose() {\n    this._cancelTween();\n    this._resetToDefaultVisualState(this.transitionMode);\n  }\n  _onImageElementGain() {\n    this._storeDefaultVisualState();\n    this._forceReapplyVisualState();\n  }\n  _toggleHitElementListeners(onOrOff) {\n    if (this.entity.element) {\n      const isAdding = onOrOff === 'on';\n      if (isAdding && this._hasHitElementListeners) {\n        return;\n      }\n      this.entity.element[onOrOff]('mouseenter', this._onMouseEnter, this);\n      this.entity.element[onOrOff]('mouseleave', this._onMouseLeave, this);\n      this.entity.element[onOrOff]('mousedown', this._onMouseDown, this);\n      this.entity.element[onOrOff]('mouseup', this._onMouseUp, this);\n      this.entity.element[onOrOff]('touchstart', this._onTouchStart, this);\n      this.entity.element[onOrOff]('touchend', this._onTouchEnd, this);\n      this.entity.element[onOrOff]('touchleave', this._onTouchLeave, this);\n      this.entity.element[onOrOff]('touchcancel', this._onTouchCancel, this);\n      this.entity.element[onOrOff]('selectstart', this._onSelectStart, this);\n      this.entity.element[onOrOff]('selectend', this._onSelectEnd, this);\n      this.entity.element[onOrOff]('selectenter', this._onSelectEnter, this);\n      this.entity.element[onOrOff]('selectleave', this._onSelectLeave, this);\n      this.entity.element[onOrOff]('click', this._onClick, this);\n      this._hasHitElementListeners = isAdding;\n    }\n  }\n  _storeDefaultVisualState() {\n    if (this._imageReference.hasComponent('element')) {\n      const element = this._imageReference.entity.element;\n      if (element.type !== _element_constants_js__WEBPACK_IMPORTED_MODULE_3__.ELEMENTTYPE_GROUP) {\n        this._storeDefaultColor(element.color);\n        this._storeDefaultOpacity(element.opacity);\n        this._storeDefaultSpriteAsset(element.spriteAsset);\n        this._storeDefaultSpriteFrame(element.spriteFrame);\n      }\n    }\n  }\n  _storeDefaultColor(color) {\n    this._defaultTint.r = color.r;\n    this._defaultTint.g = color.g;\n    this._defaultTint.b = color.b;\n  }\n  _storeDefaultOpacity(opacity) {\n    this._defaultTint.a = opacity;\n  }\n  _storeDefaultSpriteAsset(spriteAsset) {\n    this._defaultSpriteAsset = spriteAsset;\n  }\n  _storeDefaultSpriteFrame(spriteFrame) {\n    this._defaultSpriteFrame = spriteFrame;\n  }\n  _onSetColor(color) {\n    if (!this._isApplyingTint) {\n      this._storeDefaultColor(color);\n      this._forceReapplyVisualState();\n    }\n  }\n  _onSetOpacity(opacity) {\n    if (!this._isApplyingTint) {\n      this._storeDefaultOpacity(opacity);\n      this._forceReapplyVisualState();\n    }\n  }\n  _onSetSpriteAsset(spriteAsset) {\n    if (!this._isApplyingSprite) {\n      this._storeDefaultSpriteAsset(spriteAsset);\n      this._forceReapplyVisualState();\n    }\n  }\n  _onSetSpriteFrame(spriteFrame) {\n    if (!this._isApplyingSprite) {\n      this._storeDefaultSpriteFrame(spriteFrame);\n      this._forceReapplyVisualState();\n    }\n  }\n  _onMouseEnter(event) {\n    this._isHovering = true;\n    this._updateVisualState();\n    this._fireIfActive('mouseenter', event);\n  }\n  _onMouseLeave(event) {\n    this._isHovering = false;\n    this._isPressed = false;\n    this._updateVisualState();\n    this._fireIfActive('mouseleave', event);\n  }\n  _onMouseDown(event) {\n    this._isPressed = true;\n    this._updateVisualState();\n    this._fireIfActive('mousedown', event);\n  }\n  _onMouseUp(event) {\n    this._isPressed = false;\n    this._updateVisualState();\n    this._fireIfActive('mouseup', event);\n  }\n  _onTouchStart(event) {\n    this._isPressed = true;\n    this._updateVisualState();\n    this._fireIfActive('touchstart', event);\n  }\n  _onTouchEnd(event) {\n    event.event.preventDefault();\n    this._isPressed = false;\n    this._updateVisualState();\n    this._fireIfActive('touchend', event);\n  }\n  _onTouchLeave(event) {\n    this._isPressed = false;\n    this._updateVisualState();\n    this._fireIfActive('touchleave', event);\n  }\n  _onTouchCancel(event) {\n    this._isPressed = false;\n    this._updateVisualState();\n    this._fireIfActive('touchcancel', event);\n  }\n  _onSelectStart(event) {\n    this._isPressed = true;\n    this._updateVisualState();\n    this._fireIfActive('selectstart', event);\n  }\n  _onSelectEnd(event) {\n    this._isPressed = false;\n    this._updateVisualState();\n    this._fireIfActive('selectend', event);\n  }\n  _onSelectEnter(event) {\n    this._hoveringCounter++;\n    if (this._hoveringCounter === 1) {\n      this._isHovering = true;\n      this._updateVisualState();\n    }\n    this._fireIfActive('selectenter', event);\n  }\n  _onSelectLeave(event) {\n    this._hoveringCounter--;\n    if (this._hoveringCounter === 0) {\n      this._isHovering = false;\n      this._isPressed = false;\n      this._updateVisualState();\n    }\n    this._fireIfActive('selectleave', event);\n  }\n  _onClick(event) {\n    this._fireIfActive('click', event);\n  }\n  _fireIfActive(name, event) {\n    if (this.data.active) {\n      this.fire(name, event);\n    }\n  }\n  _updateVisualState(force) {\n    const oldVisualState = this._visualState;\n    const newVisualState = this._determineVisualState();\n    if ((oldVisualState !== newVisualState || force) && this.enabled) {\n      this._visualState = newVisualState;\n      if (oldVisualState === VisualState.HOVER) {\n        this._fireIfActive('hoverend');\n      }\n      if (oldVisualState === VisualState.PRESSED) {\n        this._fireIfActive('pressedend');\n      }\n      if (newVisualState === VisualState.HOVER) {\n        this._fireIfActive('hoverstart');\n      }\n      if (newVisualState === VisualState.PRESSED) {\n        this._fireIfActive('pressedstart');\n      }\n      switch (this.transitionMode) {\n        case _constants_js__WEBPACK_IMPORTED_MODULE_4__.BUTTON_TRANSITION_MODE_TINT:\n          {\n            const tintName = STATES_TO_TINT_NAMES[this._visualState];\n            const tintColor = this[tintName];\n            this._applyTint(tintColor);\n            break;\n          }\n        case _constants_js__WEBPACK_IMPORTED_MODULE_4__.BUTTON_TRANSITION_MODE_SPRITE_CHANGE:\n          {\n            const spriteAssetName = STATES_TO_SPRITE_ASSET_NAMES[this._visualState];\n            const spriteFrameName = STATES_TO_SPRITE_FRAME_NAMES[this._visualState];\n            const spriteAsset = this[spriteAssetName];\n            const spriteFrame = this[spriteFrameName];\n            this._applySprite(spriteAsset, spriteFrame);\n            break;\n          }\n      }\n    }\n  }\n  _forceReapplyVisualState() {\n    this._updateVisualState(true);\n  }\n  _resetToDefaultVisualState(transitionMode) {\n    if (this._imageReference.hasComponent('element')) {\n      switch (transitionMode) {\n        case _constants_js__WEBPACK_IMPORTED_MODULE_4__.BUTTON_TRANSITION_MODE_TINT:\n          this._cancelTween();\n          this._applyTintImmediately(this._defaultTint);\n          break;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_4__.BUTTON_TRANSITION_MODE_SPRITE_CHANGE:\n          this._applySprite(this._defaultSpriteAsset, this._defaultSpriteFrame);\n          break;\n      }\n    }\n  }\n  _determineVisualState() {\n    if (!this.active) {\n      return VisualState.INACTIVE;\n    } else if (this._isPressed) {\n      return VisualState.PRESSED;\n    } else if (this._isHovering) {\n      return VisualState.HOVER;\n    }\n    return VisualState.DEFAULT;\n  }\n  _applySprite(spriteAsset, spriteFrame) {\n    spriteFrame = spriteFrame || 0;\n    if (this._imageReference.hasComponent('element')) {\n      this._isApplyingSprite = true;\n      if (this._imageReference.entity.element.spriteAsset !== spriteAsset) {\n        this._imageReference.entity.element.spriteAsset = spriteAsset;\n      }\n      if (this._imageReference.entity.element.spriteFrame !== spriteFrame) {\n        this._imageReference.entity.element.spriteFrame = spriteFrame;\n      }\n      this._isApplyingSprite = false;\n    }\n  }\n  _applyTint(tintColor) {\n    this._cancelTween();\n    if (this.fadeDuration === 0) {\n      this._applyTintImmediately(tintColor);\n    } else {\n      this._applyTintWithTween(tintColor);\n    }\n  }\n  _applyTintImmediately(tintColor) {\n    if (!tintColor || !this._imageReference.hasComponent('element') || this._imageReference.entity.element.type === _element_constants_js__WEBPACK_IMPORTED_MODULE_3__.ELEMENTTYPE_GROUP) return;\n    const color3 = toColor3(tintColor);\n    this._isApplyingTint = true;\n    if (!color3.equals(this._imageReference.entity.element.color)) this._imageReference.entity.element.color = color3;\n    if (this._imageReference.entity.element.opacity !== tintColor.a) this._imageReference.entity.element.opacity = tintColor.a;\n    this._isApplyingTint = false;\n  }\n  _applyTintWithTween(tintColor) {\n    if (!tintColor || !this._imageReference.hasComponent('element') || this._imageReference.entity.element.type === _element_constants_js__WEBPACK_IMPORTED_MODULE_3__.ELEMENTTYPE_GROUP) return;\n    const color3 = toColor3(tintColor);\n    const color = this._imageReference.entity.element.color;\n    const opacity = this._imageReference.entity.element.opacity;\n    if (color3.equals(color) && tintColor.a === opacity) return;\n    this._tweenInfo = {\n      startTime: (0,_core_time_js__WEBPACK_IMPORTED_MODULE_5__.now)(),\n      from: new _core_math_color_js__WEBPACK_IMPORTED_MODULE_1__.Color(color.r, color.g, color.b, opacity),\n      to: tintColor.clone(),\n      lerpColor: new _core_math_color_js__WEBPACK_IMPORTED_MODULE_1__.Color()\n    };\n  }\n  _updateTintTween() {\n    const elapsedTime = (0,_core_time_js__WEBPACK_IMPORTED_MODULE_5__.now)() - this._tweenInfo.startTime;\n    let elapsedProportion = this.fadeDuration === 0 ? 1 : elapsedTime / this.fadeDuration;\n    elapsedProportion = _core_math_math_js__WEBPACK_IMPORTED_MODULE_6__.math.clamp(elapsedProportion, 0, 1);\n    if (Math.abs(elapsedProportion - 1) > 1e-5) {\n      const lerpColor = this._tweenInfo.lerpColor;\n      lerpColor.lerp(this._tweenInfo.from, this._tweenInfo.to, elapsedProportion);\n      this._applyTintImmediately(new _core_math_color_js__WEBPACK_IMPORTED_MODULE_1__.Color(lerpColor.r, lerpColor.g, lerpColor.b, lerpColor.a));\n    } else {\n      this._applyTintImmediately(this._tweenInfo.to);\n      this._cancelTween();\n    }\n  }\n  _cancelTween() {\n    delete this._tweenInfo;\n  }\n  onUpdate() {\n    if (this._tweenInfo) {\n      this._updateTintTween();\n    }\n  }\n  onEnable() {\n    this._isHovering = false;\n    this._hoveringCounter = 0;\n    this._isPressed = false;\n    this._imageReference.onParentComponentEnable();\n    this._toggleHitElementListeners('on');\n    this._forceReapplyVisualState();\n  }\n  onDisable() {\n    this._toggleHitElementListeners('off');\n    this._resetToDefaultVisualState(this.transitionMode);\n  }\n  onRemove() {\n    this._toggleLifecycleListeners('off', this.system);\n    this.onDisable();\n  }\n}\nfunction toColor3(color4) {\n  return new _core_math_color_js__WEBPACK_IMPORTED_MODULE_1__.Color(color4.r, color4.g, color4.b);\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/button/component.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/button/constants.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/button/constants.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BUTTON_TRANSITION_MODE_SPRITE_CHANGE\": () => (/* binding */ BUTTON_TRANSITION_MODE_SPRITE_CHANGE),\n/* harmony export */   \"BUTTON_TRANSITION_MODE_TINT\": () => (/* binding */ BUTTON_TRANSITION_MODE_TINT)\n/* harmony export */ });\nconst BUTTON_TRANSITION_MODE_TINT = 0;\nconst BUTTON_TRANSITION_MODE_SPRITE_CHANGE = 1;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/button/constants.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/button/data.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/button/data.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ButtonComponentData\": () => (/* binding */ ButtonComponentData)\n/* harmony export */ });\n/* harmony import */ var _core_math_color_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/math/color.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n/* harmony import */ var _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/math/vec4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec4.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/button/constants.js\");\n\n\n\n\nclass ButtonComponentData {\n  constructor() {\n    this.enabled = true;\n    this.active = true;\n    this.imageEntity = null;\n    this.hitPadding = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_0__.Vec4();\n    this.transitionMode = _constants_js__WEBPACK_IMPORTED_MODULE_1__.BUTTON_TRANSITION_MODE_TINT;\n    this.hoverTint = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_2__.Color(0.75, 0.75, 0.75);\n    this.pressedTint = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_2__.Color(0.5, 0.5, 0.5);\n    this.inactiveTint = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_2__.Color(0.25, 0.25, 0.25);\n    this.fadeDuration = 0;\n    this.hoverSpriteAsset = null;\n    this.hoverSpriteFrame = 0;\n    this.pressedSpriteAsset = null;\n    this.pressedSpriteFrame = 0;\n    this.inactiveSpriteAsset = null;\n    this.inactiveSpriteFrame = 0;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/button/data.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/button/system.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/button/system.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ButtonComponentSystem\": () => (/* binding */ ButtonComponentSystem)\n/* harmony export */ });\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/system.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/button/component.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/button/data.js\");\n\n\n\n\n\nconst _schema = ['enabled', 'active', {\n  name: 'imageEntity',\n  type: 'entity'\n}, {\n  name: 'hitPadding',\n  type: 'vec4'\n}, 'transitionMode', {\n  name: 'hoverTint',\n  type: 'rgba'\n}, {\n  name: 'pressedTint',\n  type: 'rgba'\n}, {\n  name: 'inactiveTint',\n  type: 'rgba'\n}, 'fadeDuration', 'hoverSpriteAsset', 'hoverSpriteFrame', 'pressedSpriteAsset', 'pressedSpriteFrame', 'inactiveSpriteAsset', 'inactiveSpriteFrame'];\nclass ButtonComponentSystem extends _system_js__WEBPACK_IMPORTED_MODULE_0__.ComponentSystem {\n  constructor(app) {\n    super(app);\n    this.id = 'button';\n    this.ComponentType = _component_js__WEBPACK_IMPORTED_MODULE_1__.ButtonComponent;\n    this.DataType = _data_js__WEBPACK_IMPORTED_MODULE_2__.ButtonComponentData;\n    this.schema = _schema;\n    this.on('beforeremove', this._onRemoveComponent, this);\n    this.app.systems.on('update', this.onUpdate, this);\n  }\n  initializeComponentData(component, data, properties) {\n    super.initializeComponentData(component, data, _schema);\n  }\n  onUpdate(dt) {\n    const components = this.store;\n    for (const id in components) {\n      const entity = components[id].entity;\n      const component = entity.button;\n      if (component.enabled && entity.enabled) {\n        component.onUpdate();\n      }\n    }\n  }\n  _onRemoveComponent(entity, component) {\n    component.onRemove();\n  }\n  destroy() {\n    super.destroy();\n    this.app.systems.off('update', this.onUpdate, this);\n  }\n}\n_component_js__WEBPACK_IMPORTED_MODULE_3__.Component._buildAccessors(_component_js__WEBPACK_IMPORTED_MODULE_1__.ButtonComponent.prototype, _schema);\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/button/system.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/camera/component.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/camera/component.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CameraComponent\": () => (/* binding */ CameraComponent)\n/* harmony export */ });\n/* harmony import */ var _scene_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../scene/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _scene_camera_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../scene/camera.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/camera.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _post_effect_queue_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./post-effect-queue.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/camera/post-effect-queue.js\");\n\n\n\n\n\n\nconst properties = [{\n  name: 'aspectRatio',\n  readonly: false\n}, {\n  name: 'aspectRatioMode',\n  readonly: false\n}, {\n  name: 'calculateProjection',\n  readonly: false\n}, {\n  name: 'calculateTransform',\n  readonly: false\n}, {\n  name: 'clearColor',\n  readonly: false\n}, {\n  name: 'cullFaces',\n  readonly: false\n}, {\n  name: 'farClip',\n  readonly: false\n}, {\n  name: 'flipFaces',\n  readonly: false\n}, {\n  name: 'fov',\n  readonly: false\n}, {\n  name: 'frustumCulling',\n  readonly: false\n}, {\n  name: 'horizontalFov',\n  readonly: false\n}, {\n  name: 'nearClip',\n  readonly: false\n}, {\n  name: 'orthoHeight',\n  readonly: false\n}, {\n  name: 'projection',\n  readonly: false\n}, {\n  name: 'scissorRect',\n  readonly: false\n}, {\n  name: 'aperture',\n  readonly: false\n}, {\n  name: 'shutter',\n  readonly: false\n}, {\n  name: 'sensitivity',\n  readonly: false\n}];\nclass CameraComponent extends _component_js__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(system, entity) {\n    super(system, entity);\n    this.onPostprocessing = null;\n    this.onPreRender = null;\n    this.onPostRender = null;\n    this._renderSceneDepthMap = 0;\n    this._renderSceneColorMap = 0;\n    this._camera = new _scene_camera_js__WEBPACK_IMPORTED_MODULE_1__.Camera();\n    this._camera.node = entity;\n    this._priority = 0;\n    this._disablePostEffectsLayer = _scene_constants_js__WEBPACK_IMPORTED_MODULE_2__.LAYERID_UI;\n    this._postEffects = new _post_effect_queue_js__WEBPACK_IMPORTED_MODULE_3__.PostEffectQueue(system.app, this);\n    this._sceneDepthMapRequested = false;\n    this._sceneColorMapRequested = false;\n  }\n  get camera() {\n    return this._camera;\n  }\n  set clearColorBuffer(value) {\n    this._camera.clearColorBuffer = value;\n    this.dirtyLayerCompositionCameras();\n  }\n  get clearColorBuffer() {\n    return this._camera.clearColorBuffer;\n  }\n  set clearDepthBuffer(value) {\n    this._camera.clearDepthBuffer = value;\n    this.dirtyLayerCompositionCameras();\n  }\n  get clearDepthBuffer() {\n    return this._camera.clearDepthBuffer;\n  }\n  set clearStencilBuffer(value) {\n    this._camera.clearStencilBuffer = value;\n    this.dirtyLayerCompositionCameras();\n  }\n  get clearStencilBuffer() {\n    return this._camera.clearStencilBuffer;\n  }\n  set disablePostEffectsLayer(layer) {\n    this._disablePostEffectsLayer = layer;\n    this.dirtyLayerCompositionCameras();\n  }\n  get disablePostEffectsLayer() {\n    return this._disablePostEffectsLayer;\n  }\n  _enableDepthLayer(value) {\n    const hasDepthLayer = this.layers.find(layerId => layerId === _scene_constants_js__WEBPACK_IMPORTED_MODULE_2__.LAYERID_DEPTH);\n    if (hasDepthLayer) {\n      const depthLayer = this.system.app.scene.layers.getLayerById(_scene_constants_js__WEBPACK_IMPORTED_MODULE_2__.LAYERID_DEPTH);\n      if (value) {\n        depthLayer == null ? void 0 : depthLayer.incrementCounter();\n      } else {\n        depthLayer == null ? void 0 : depthLayer.decrementCounter();\n      }\n    } else if (value) {\n      return false;\n    }\n    return true;\n  }\n  requestSceneColorMap(enabled) {\n    this._renderSceneColorMap += enabled ? 1 : -1;\n    this._enableDepthLayer(enabled);\n  }\n  set renderSceneColorMap(value) {\n    if (value && !this._sceneColorMapRequested) {\n      this.requestSceneColorMap(true);\n      this._sceneColorMapRequested = true;\n    } else if (this._sceneColorMapRequested) {\n      this.requestSceneColorMap(false);\n      this._sceneColorMapRequested = false;\n    }\n  }\n  get renderSceneColorMap() {\n    return this._renderSceneColorMap > 0;\n  }\n  requestSceneDepthMap(enabled) {\n    this._renderSceneDepthMap += enabled ? 1 : -1;\n    this._enableDepthLayer(enabled);\n  }\n  set renderSceneDepthMap(value) {\n    if (value && !this._sceneDepthMapRequested) {\n      this.requestSceneDepthMap(true);\n      this._sceneDepthMapRequested = true;\n    } else if (this._sceneDepthMapRequested) {\n      this.requestSceneDepthMap(false);\n      this._sceneDepthMapRequested = false;\n    }\n  }\n  get renderSceneDepthMap() {\n    return this._renderSceneDepthMap > 0;\n  }\n  get frustum() {\n    return this._camera.frustum;\n  }\n  set layers(newValue) {\n    const layers = this._camera.layers;\n    for (let i = 0; i < layers.length; i++) {\n      const layer = this.system.app.scene.layers.getLayerById(layers[i]);\n      if (!layer) continue;\n      layer.removeCamera(this);\n    }\n    this._camera.layers = newValue;\n    if (!this.enabled || !this.entity.enabled) return;\n    for (let i = 0; i < newValue.length; i++) {\n      const layer = this.system.app.scene.layers.getLayerById(newValue[i]);\n      if (!layer) continue;\n      layer.addCamera(this);\n    }\n  }\n  get layers() {\n    return this._camera.layers;\n  }\n  get layersSet() {\n    return this._camera.layersSet;\n  }\n  get postEffectsEnabled() {\n    return this._postEffects.enabled;\n  }\n  get postEffects() {\n    return this._postEffects;\n  }\n  set priority(newValue) {\n    this._priority = newValue;\n    this.dirtyLayerCompositionCameras();\n  }\n  get priority() {\n    return this._priority;\n  }\n  get projectionMatrix() {\n    return this._camera.projectionMatrix;\n  }\n  set aperture(newValue) {\n    this._camera.aperture = newValue;\n  }\n  get aperture() {\n    return this._camera.aperture;\n  }\n  set sensitivity(newValue) {\n    this._camera.sensitivity = newValue;\n  }\n  get sensitivity() {\n    return this._camera.sensitivity;\n  }\n  set shutter(newValue) {\n    this._camera.shutter = newValue;\n  }\n  get shutter() {\n    return this._camera.shutter;\n  }\n  set rect(value) {\n    this._camera.rect = value;\n    this.fire('set:rect', this._camera.rect);\n  }\n  get rect() {\n    return this._camera.rect;\n  }\n  set renderTarget(value) {\n    this._camera.renderTarget = value;\n    this.dirtyLayerCompositionCameras();\n  }\n  get renderTarget() {\n    return this._camera.renderTarget;\n  }\n  get viewMatrix() {\n    return this._camera.viewMatrix;\n  }\n  dirtyLayerCompositionCameras() {\n    const layerComp = this.system.app.scene.layers;\n    layerComp._dirtyCameras = true;\n  }\n  screenToWorld(screenx, screeny, cameraz, worldCoord) {\n    const device = this.system.app.graphicsDevice;\n    const w = device.clientRect.width;\n    const h = device.clientRect.height;\n    return this._camera.screenToWorld(screenx, screeny, cameraz, w, h, worldCoord);\n  }\n  worldToScreen(worldCoord, screenCoord) {\n    const device = this.system.app.graphicsDevice;\n    const w = device.clientRect.width;\n    const h = device.clientRect.height;\n    return this._camera.worldToScreen(worldCoord, w, h, screenCoord);\n  }\n  onAppPrerender() {\n    this._camera._viewMatDirty = true;\n    this._camera._viewProjMatDirty = true;\n  }\n  addCameraToLayers() {\n    const layers = this.layers;\n    for (let i = 0; i < layers.length; i++) {\n      const layer = this.system.app.scene.layers.getLayerById(layers[i]);\n      if (layer) {\n        layer.addCamera(this);\n      }\n    }\n  }\n  removeCameraFromLayers() {\n    const layers = this.layers;\n    for (let i = 0; i < layers.length; i++) {\n      const layer = this.system.app.scene.layers.getLayerById(layers[i]);\n      if (layer) {\n        layer.removeCamera(this);\n      }\n    }\n  }\n  onLayersChanged(oldComp, newComp) {\n    this.addCameraToLayers();\n    oldComp.off('add', this.onLayerAdded, this);\n    oldComp.off('remove', this.onLayerRemoved, this);\n    newComp.on('add', this.onLayerAdded, this);\n    newComp.on('remove', this.onLayerRemoved, this);\n  }\n  onLayerAdded(layer) {\n    const index = this.layers.indexOf(layer.id);\n    if (index < 0) return;\n    layer.addCamera(this);\n  }\n  onLayerRemoved(layer) {\n    const index = this.layers.indexOf(layer.id);\n    if (index < 0) return;\n    layer.removeCamera(this);\n  }\n  onEnable() {\n    const system = this.system;\n    const scene = system.app.scene;\n    const layers = scene.layers;\n    system.addCamera(this);\n    scene.on('set:layers', this.onLayersChanged, this);\n    if (layers) {\n      layers.on('add', this.onLayerAdded, this);\n      layers.on('remove', this.onLayerRemoved, this);\n    }\n    if (this.enabled && this.entity.enabled) {\n      this.addCameraToLayers();\n    }\n    this.postEffects.enable();\n  }\n  onDisable() {\n    const system = this.system;\n    const scene = system.app.scene;\n    const layers = scene.layers;\n    this.postEffects.disable();\n    this.removeCameraFromLayers();\n    scene.off('set:layers', this.onLayersChanged, this);\n    if (layers) {\n      layers.off('add', this.onLayerAdded, this);\n      layers.off('remove', this.onLayerRemoved, this);\n    }\n    system.removeCamera(this);\n  }\n  onRemove() {\n    this.onDisable();\n    this.off();\n  }\n  calculateAspectRatio(rt) {\n    const device = this.system.app.graphicsDevice;\n    const width = rt ? rt.width : device.width;\n    const height = rt ? rt.height : device.height;\n    return width * this.rect.z / (height * this.rect.w);\n  }\n  frameUpdate(rt) {\n    if (this.aspectRatioMode === _scene_constants_js__WEBPACK_IMPORTED_MODULE_2__.ASPECT_AUTO) {\n      this.aspectRatio = this.calculateAspectRatio(rt);\n    }\n  }\n  startXr(type, spaceType, options) {\n    this.system.app.xr.start(this, type, spaceType, options);\n  }\n  endXr(callback) {\n    if (!this._camera.xr) {\n      if (callback) callback(new Error('Camera is not in XR'));\n      return;\n    }\n    this._camera.xr.end(callback);\n  }\n  copy(source) {\n    properties.forEach(property => {\n      if (!property.readonly) {\n        const name = property.name;\n        this[name] = source[name];\n      }\n    });\n    this.clearColorBuffer = source.clearColorBuffer;\n    this.clearDepthBuffer = source.clearDepthBuffer;\n    this.clearStencilBuffer = source.clearStencilBuffer;\n    this.disablePostEffectsLayer = source.disablePostEffectsLayer;\n    this.layers = source.layers;\n    this.priority = source.priority;\n    this.renderTarget = source.renderTarget;\n    this.rect = source.rect;\n    this.aperture = source.aperture;\n    this.sensitivity = source.sensitivity;\n    this.shutter = source.shutter;\n  }\n}\nproperties.forEach(function (property) {\n  const name = property.name;\n  const options = {};\n  options.get = function () {\n    return this._camera[name];\n  };\n  if (!property.readonly) {\n    options.set = function (newValue) {\n      this._camera[name] = newValue;\n    };\n  }\n  Object.defineProperty(CameraComponent.prototype, name, options);\n});\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/camera/component.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/camera/data.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/camera/data.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CameraComponentData\": () => (/* binding */ CameraComponentData)\n/* harmony export */ });\nclass CameraComponentData {\n  constructor() {\n    this.enabled = true;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/camera/data.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/camera/post-effect-queue.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/camera/post-effect-queue.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PostEffectQueue\": () => (/* binding */ PostEffectQueue)\n/* harmony export */ });\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_render_target_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../platform/graphics/render-target.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/render-target.js\");\n/* harmony import */ var _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/graphics/texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js\");\n/* harmony import */ var _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../scene/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n\n\n\n\n\nclass PostEffect {\n  constructor(effect, inputTarget) {\n    this.effect = effect;\n    this.inputTarget = inputTarget;\n    this.outputTarget = null;\n    this.name = effect.constructor.name;\n  }\n}\nclass PostEffectQueue {\n  constructor(app, camera) {\n    this.app = app;\n    this.camera = camera;\n    this.destinationRenderTarget = null;\n    this.effects = [];\n    this.enabled = false;\n    this.depthTarget = null;\n    camera.on('set:rect', this.onCameraRectChanged, this);\n  }\n  _allocateColorBuffer(format, name) {\n    const rect = this.camera.rect;\n    const width = Math.floor(rect.z * this.app.graphicsDevice.width);\n    const height = Math.floor(rect.w * this.app.graphicsDevice.height);\n    const colorBuffer = new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_0__.Texture(this.app.graphicsDevice, {\n      name: name,\n      format: format,\n      width: width,\n      height: height,\n      mipmaps: false,\n      minFilter: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.FILTER_NEAREST,\n      magFilter: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.FILTER_NEAREST,\n      addressU: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.ADDRESS_CLAMP_TO_EDGE,\n      addressV: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.ADDRESS_CLAMP_TO_EDGE\n    });\n    return colorBuffer;\n  }\n  _createOffscreenTarget(useDepth, hdr) {\n    const device = this.app.graphicsDevice;\n    const format = hdr && device.getHdrFormat(false, true, false, false) || _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.PIXELFORMAT_RGBA8;\n    const name = this.camera.entity.name + '-posteffect-' + this.effects.length;\n    const colorBuffer = this._allocateColorBuffer(format, name);\n    return new _platform_graphics_render_target_js__WEBPACK_IMPORTED_MODULE_2__.RenderTarget({\n      colorBuffer: colorBuffer,\n      depth: useDepth,\n      stencil: useDepth && this.app.graphicsDevice.supportsStencil,\n      samples: useDepth ? device.samples : 1\n    });\n  }\n  _resizeOffscreenTarget(rt) {\n    const format = rt.colorBuffer.format;\n    const name = rt.colorBuffer.name;\n    rt.destroyFrameBuffers();\n    rt.destroyTextureBuffers();\n    rt._colorBuffer = this._allocateColorBuffer(format, name);\n  }\n  _destroyOffscreenTarget(rt) {\n    rt.destroyTextureBuffers();\n    rt.destroy();\n  }\n  addEffect(effect) {\n    const effects = this.effects;\n    const isFirstEffect = effects.length === 0;\n    const inputTarget = this._createOffscreenTarget(isFirstEffect, effect.hdr);\n    const newEntry = new PostEffect(effect, inputTarget);\n    effects.push(newEntry);\n    this._sourceTarget = newEntry.inputTarget;\n    if (effects.length > 1) {\n      effects[effects.length - 2].outputTarget = newEntry.inputTarget;\n    }\n    this._newPostEffect = effect;\n    if (effect.needsDepthBuffer) {\n      this._requestDepthMap();\n    }\n    this.enable();\n    this._newPostEffect = undefined;\n  }\n  removeEffect(effect) {\n    let index = -1;\n    for (let i = 0, len = this.effects.length; i < len; i++) {\n      if (this.effects[i].effect === effect) {\n        index = i;\n        break;\n      }\n    }\n    if (index >= 0) {\n      if (index > 0) {\n        this.effects[index - 1].outputTarget = index + 1 < this.effects.length ? this.effects[index + 1].inputTarget : null;\n      } else {\n        if (this.effects.length > 1) {\n          if (!this.effects[1].inputTarget._depth) {\n            this._destroyOffscreenTarget(this.effects[1].inputTarget);\n            this.effects[1].inputTarget = this._createOffscreenTarget(true, this.effects[1].hdr);\n            this._sourceTarget = this.effects[1].inputTarget;\n          }\n          this.camera.renderTarget = this.effects[1].inputTarget;\n        }\n      }\n      this._destroyOffscreenTarget(this.effects[index].inputTarget);\n      this.effects.splice(index, 1);\n    }\n    if (this.enabled) {\n      if (effect.needsDepthBuffer) {\n        this._releaseDepthMap();\n      }\n    }\n    if (this.effects.length === 0) {\n      this.disable();\n    }\n  }\n  _requestDepthMaps() {\n    for (let i = 0, len = this.effects.length; i < len; i++) {\n      const effect = this.effects[i].effect;\n      if (this._newPostEffect === effect) continue;\n      if (effect.needsDepthBuffer) {\n        this._requestDepthMap();\n      }\n    }\n  }\n  _releaseDepthMaps() {\n    for (let i = 0, len = this.effects.length; i < len; i++) {\n      const effect = this.effects[i].effect;\n      if (effect.needsDepthBuffer) {\n        this._releaseDepthMap();\n      }\n    }\n  }\n  _requestDepthMap() {\n    const depthLayer = this.app.scene.layers.getLayerById(_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.LAYERID_DEPTH);\n    if (depthLayer) {\n      depthLayer.incrementCounter();\n      this.camera.requestSceneDepthMap(true);\n    }\n  }\n  _releaseDepthMap() {\n    const depthLayer = this.app.scene.layers.getLayerById(_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.LAYERID_DEPTH);\n    if (depthLayer) {\n      depthLayer.decrementCounter();\n      this.camera.requestSceneDepthMap(false);\n    }\n  }\n  destroy() {\n    for (let i = 0, len = this.effects.length; i < len; i++) {\n      this.effects[i].inputTarget.destroy();\n    }\n    this.effects.length = 0;\n    this.disable();\n  }\n  enable() {\n    if (!this.enabled && this.effects.length) {\n      this.enabled = true;\n      this._requestDepthMaps();\n      this.app.graphicsDevice.on('resizecanvas', this._onCanvasResized, this);\n      this.destinationRenderTarget = this.camera.renderTarget;\n      this.camera.renderTarget = this.effects[0].inputTarget;\n      this.camera.onPostprocessing = () => {\n        if (this.enabled) {\n          let rect = null;\n          const len = this.effects.length;\n          if (len) {\n            for (let i = 0; i < len; i++) {\n              const fx = this.effects[i];\n              let destTarget = fx.outputTarget;\n              if (i === len - 1) {\n                rect = this.camera.rect;\n                if (this.destinationRenderTarget) {\n                  destTarget = this.destinationRenderTarget;\n                }\n              }\n              fx.effect.render(fx.inputTarget, destTarget, rect);\n            }\n          }\n        }\n      };\n    }\n  }\n  disable() {\n    if (this.enabled) {\n      this.enabled = false;\n      this.app.graphicsDevice.off('resizecanvas', this._onCanvasResized, this);\n      this._releaseDepthMaps();\n      this._destroyOffscreenTarget(this._sourceTarget);\n      this.camera.renderTarget = null;\n      this.camera.onPostprocessing = null;\n    }\n  }\n  _onCanvasResized(width, height) {\n    const rect = this.camera.rect;\n    const device = this.app.graphicsDevice;\n    this.camera.camera.aspectRatio = device.width * rect.z / (device.height * rect.w);\n    this.resizeRenderTargets();\n  }\n  resizeRenderTargets() {\n    const rect = this.camera.rect;\n    const desiredWidth = Math.floor(rect.z * this.app.graphicsDevice.width);\n    const desiredHeight = Math.floor(rect.w * this.app.graphicsDevice.height);\n    const effects = this.effects;\n    for (let i = 0, len = effects.length; i < len; i++) {\n      const fx = effects[i];\n      if (fx.inputTarget.width !== desiredWidth || fx.inputTarget.height !== desiredHeight) {\n        this._resizeOffscreenTarget(fx.inputTarget);\n      }\n    }\n  }\n  onCameraRectChanged(name, oldValue, newValue) {\n    if (this.enabled) {\n      this.resizeRenderTargets();\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/camera/post-effect-queue.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/camera/system.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/camera/system.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CameraComponentSystem\": () => (/* binding */ CameraComponentSystem)\n/* harmony export */ });\n/* harmony import */ var _core_sort_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/sort.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/sort.js\");\n/* harmony import */ var _core_math_color_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/math/color.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n/* harmony import */ var _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/math/vec4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec4.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/system.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/camera/component.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/camera/data.js\");\n\n\n\n\n\n\n\n\nconst _schema = ['enabled'];\nclass CameraComponentSystem extends _system_js__WEBPACK_IMPORTED_MODULE_0__.ComponentSystem {\n  constructor(app) {\n    super(app);\n    this.cameras = [];\n    this.id = 'camera';\n    this.ComponentType = _component_js__WEBPACK_IMPORTED_MODULE_1__.CameraComponent;\n    this.DataType = _data_js__WEBPACK_IMPORTED_MODULE_2__.CameraComponentData;\n    this.schema = _schema;\n    this.on('beforeremove', this.onBeforeRemove, this);\n    this.app.on('prerender', this.onAppPrerender, this);\n    this.app.systems.on('update', this.onUpdate, this);\n  }\n  initializeComponentData(component, data, properties) {\n    properties = ['aspectRatio', 'aspectRatioMode', 'calculateProjection', 'calculateTransform', 'clearColor', 'clearColorBuffer', 'clearDepthBuffer', 'clearStencilBuffer', 'renderSceneColorMap', 'renderSceneDepthMap', 'cullFaces', 'farClip', 'flipFaces', 'fov', 'frustumCulling', 'horizontalFov', 'layers', 'renderTarget', 'nearClip', 'orthoHeight', 'projection', 'priority', 'rect', 'scissorRect', 'aperture', 'shutter', 'sensitivity'];\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      if (data.hasOwnProperty(property)) {\n        const value = data[property];\n        switch (property) {\n          case 'rect':\n          case 'scissorRect':\n            if (Array.isArray(value)) {\n              component[property] = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_3__.Vec4(value[0], value[1], value[2], value[3]);\n            } else {\n              component[property] = value;\n            }\n            break;\n          case 'clearColor':\n            if (Array.isArray(value)) {\n              component[property] = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_4__.Color(value[0], value[1], value[2], value[3]);\n            } else {\n              component[property] = value;\n            }\n            break;\n          default:\n            component[property] = value;\n            break;\n        }\n      }\n    }\n    super.initializeComponentData(component, data, ['enabled']);\n  }\n  cloneComponent(entity, clone) {\n    const c = entity.camera;\n    return this.addComponent(clone, {\n      aspectRatio: c.aspectRatio,\n      aspectRatioMode: c.aspectRatioMode,\n      calculateProjection: c.calculateProjection,\n      calculateTransform: c.calculateTransform,\n      clearColor: c.clearColor,\n      clearColorBuffer: c.clearColorBuffer,\n      clearDepthBuffer: c.clearDepthBuffer,\n      clearStencilBuffer: c.clearStencilBuffer,\n      renderSceneDepthMap: c.renderSceneDepthMap,\n      renderSceneColorMap: c.renderSceneColorMap,\n      cullFaces: c.cullFaces,\n      enabled: c.enabled,\n      farClip: c.farClip,\n      flipFaces: c.flipFaces,\n      fov: c.fov,\n      frustumCulling: c.frustumCulling,\n      horizontalFov: c.horizontalFov,\n      layers: c.layers,\n      renderTarget: c.renderTarget,\n      nearClip: c.nearClip,\n      orthoHeight: c.orthoHeight,\n      projection: c.projection,\n      priority: c.priority,\n      rect: c.rect,\n      scissorRect: c.scissorRect,\n      aperture: c.aperture,\n      sensitivity: c.sensitivity,\n      shutter: c.shutter\n    });\n  }\n  onBeforeRemove(entity, component) {\n    this.removeCamera(component);\n  }\n  onUpdate(dt) {}\n  onAppPrerender() {\n    for (let i = 0, len = this.cameras.length; i < len; i++) {\n      this.cameras[i].onAppPrerender();\n    }\n  }\n  addCamera(camera) {\n    this.cameras.push(camera);\n    (0,_core_sort_js__WEBPACK_IMPORTED_MODULE_5__.sortPriority)(this.cameras);\n  }\n  removeCamera(camera) {\n    const index = this.cameras.indexOf(camera);\n    if (index >= 0) {\n      this.cameras.splice(index, 1);\n      (0,_core_sort_js__WEBPACK_IMPORTED_MODULE_5__.sortPriority)(this.cameras);\n    }\n  }\n  destroy() {\n    super.destroy();\n    this.app.systems.off('update', this.onUpdate, this);\n  }\n}\n_component_js__WEBPACK_IMPORTED_MODULE_6__.Component._buildAccessors(_component_js__WEBPACK_IMPORTED_MODULE_1__.CameraComponent.prototype, _schema);\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/camera/system.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/collision/component.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/collision/component.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CollisionComponent\": () => (/* binding */ CollisionComponent)\n/* harmony export */ });\n/* harmony import */ var _core_math_quat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/math/quat.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/quat.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _asset_asset_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../asset/asset.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n\n\n\n\n\nconst _vec3 = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst _quat = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_1__.Quat();\nclass CollisionComponent extends _component_js__WEBPACK_IMPORTED_MODULE_2__.Component {\n  constructor(system, entity) {\n    super(system, entity);\n    this._compoundParent = null;\n    this._hasOffset = false;\n    this.entity.on('insert', this._onInsert, this);\n    this.on('set_type', this.onSetType, this);\n    this.on('set_halfExtents', this.onSetHalfExtents, this);\n    this.on('set_linearOffset', this.onSetOffset, this);\n    this.on('set_angularOffset', this.onSetOffset, this);\n    this.on('set_radius', this.onSetRadius, this);\n    this.on('set_height', this.onSetHeight, this);\n    this.on('set_axis', this.onSetAxis, this);\n    this.on('set_asset', this.onSetAsset, this);\n    this.on('set_renderAsset', this.onSetRenderAsset, this);\n    this.on('set_model', this.onSetModel, this);\n    this.on('set_render', this.onSetRender, this);\n  }\n  onSetType(name, oldValue, newValue) {\n    if (oldValue !== newValue) {\n      this.system.changeType(this, oldValue, newValue);\n    }\n  }\n  onSetHalfExtents(name, oldValue, newValue) {\n    const t = this.data.type;\n    if (this.data.initialized && t === 'box') {\n      this.system.recreatePhysicalShapes(this);\n    }\n  }\n  onSetOffset(name, oldValue, newValue) {\n    this._hasOffset = !this.data.linearOffset.equals(_core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3.ZERO) || !this.data.angularOffset.equals(_core_math_quat_js__WEBPACK_IMPORTED_MODULE_1__.Quat.IDENTITY);\n    if (this.data.initialized) {\n      this.system.recreatePhysicalShapes(this);\n    }\n  }\n  onSetRadius(name, oldValue, newValue) {\n    const t = this.data.type;\n    if (this.data.initialized && (t === 'sphere' || t === 'capsule' || t === 'cylinder' || t === 'cone')) {\n      this.system.recreatePhysicalShapes(this);\n    }\n  }\n  onSetHeight(name, oldValue, newValue) {\n    const t = this.data.type;\n    if (this.data.initialized && (t === 'capsule' || t === 'cylinder' || t === 'cone')) {\n      this.system.recreatePhysicalShapes(this);\n    }\n  }\n  onSetAxis(name, oldValue, newValue) {\n    const t = this.data.type;\n    if (this.data.initialized && (t === 'capsule' || t === 'cylinder' || t === 'cone')) {\n      this.system.recreatePhysicalShapes(this);\n    }\n  }\n  onSetAsset(name, oldValue, newValue) {\n    const assets = this.system.app.assets;\n    if (oldValue) {\n      const asset = assets.get(oldValue);\n      if (asset) {\n        asset.off('remove', this.onAssetRemoved, this);\n      }\n    }\n    if (newValue) {\n      if (newValue instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_3__.Asset) {\n        this.data.asset = newValue.id;\n      }\n      const asset = assets.get(this.data.asset);\n      if (asset) {\n        asset.off('remove', this.onAssetRemoved, this);\n        asset.on('remove', this.onAssetRemoved, this);\n      }\n    }\n    if (this.data.initialized && this.data.type === 'mesh') {\n      if (!newValue) {\n        this.data.model = null;\n      }\n      this.system.recreatePhysicalShapes(this);\n    }\n  }\n  onSetRenderAsset(name, oldValue, newValue) {\n    const assets = this.system.app.assets;\n    if (oldValue) {\n      const asset = assets.get(oldValue);\n      if (asset) {\n        asset.off('remove', this.onRenderAssetRemoved, this);\n      }\n    }\n    if (newValue) {\n      if (newValue instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_3__.Asset) {\n        this.data.renderAsset = newValue.id;\n      }\n      const asset = assets.get(this.data.renderAsset);\n      if (asset) {\n        asset.off('remove', this.onRenderAssetRemoved, this);\n        asset.on('remove', this.onRenderAssetRemoved, this);\n      }\n    }\n    if (this.data.initialized && this.data.type === 'mesh') {\n      if (!newValue) {\n        this.data.render = null;\n      }\n      this.system.recreatePhysicalShapes(this);\n    }\n  }\n  onSetModel(name, oldValue, newValue) {\n    if (this.data.initialized && this.data.type === 'mesh') {\n      this.system.implementations.mesh.doRecreatePhysicalShape(this);\n    }\n  }\n  onSetRender(name, oldValue, newValue) {\n    this.onSetModel(name, oldValue, newValue);\n  }\n  onAssetRemoved(asset) {\n    asset.off('remove', this.onAssetRemoved, this);\n    if (this.data.asset === asset.id) {\n      this.asset = null;\n    }\n  }\n  onRenderAssetRemoved(asset) {\n    asset.off('remove', this.onRenderAssetRemoved, this);\n    if (this.data.renderAsset === asset.id) {\n      this.renderAsset = null;\n    }\n  }\n  _getCompoundChildShapeIndex(shape) {\n    const compound = this.data.shape;\n    const shapes = compound.getNumChildShapes();\n    for (let i = 0; i < shapes; i++) {\n      const childShape = compound.getChildShape(i);\n      if (childShape.ptr === shape.ptr) {\n        return i;\n      }\n    }\n    return null;\n  }\n  _onInsert(parent) {\n    if (typeof Ammo === 'undefined') return;\n    if (this._compoundParent) {\n      this.system.recreatePhysicalShapes(this);\n    } else if (!this.entity.rigidbody) {\n      let ancestor = this.entity.parent;\n      while (ancestor) {\n        if (ancestor.collision && ancestor.collision.type === 'compound') {\n          if (ancestor.collision.shape.getNumChildShapes() === 0) {\n            this.system.recreatePhysicalShapes(ancestor.collision);\n          } else {\n            this.system.recreatePhysicalShapes(this);\n          }\n          break;\n        }\n        ancestor = ancestor.parent;\n      }\n    }\n  }\n  _updateCompound() {\n    const entity = this.entity;\n    if (entity._dirtyWorld) {\n      let dirty = entity._dirtyLocal;\n      let parent = entity;\n      while (parent && !dirty) {\n        if (parent.collision && parent.collision === this._compoundParent) break;\n        if (parent._dirtyLocal) dirty = true;\n        parent = parent.parent;\n      }\n      if (dirty) {\n        entity.forEach(this.system.implementations.compound._updateEachDescendantTransform, entity);\n        const bodyComponent = this._compoundParent.entity.rigidbody;\n        if (bodyComponent) bodyComponent.activate();\n      }\n    }\n  }\n  getShapePosition() {\n    const pos = this.entity.getPosition();\n    if (this._hasOffset) {\n      const rot = this.entity.getRotation();\n      const lo = this.data.linearOffset;\n      _quat.copy(rot).transformVector(lo, _vec3);\n      return _vec3.add(pos);\n    }\n    return pos;\n  }\n  getShapeRotation() {\n    const rot = this.entity.getRotation();\n    if (this._hasOffset) {\n      return _quat.copy(rot).mul(this.data.angularOffset);\n    }\n    return rot;\n  }\n  onEnable() {\n    if (this.data.type === 'mesh' && (this.data.asset || this.data.renderAsset) && this.data.initialized) {\n      const asset = this.system.app.assets.get(this.data.asset || this.data.renderAsset);\n      if (asset && (!asset.resource || !this.data.shape)) {\n        this.system.recreatePhysicalShapes(this);\n        return;\n      }\n    }\n    if (this.entity.rigidbody) {\n      if (this.entity.rigidbody.enabled) {\n        this.entity.rigidbody.enableSimulation();\n      }\n    } else if (this._compoundParent && this !== this._compoundParent) {\n      if (this._compoundParent.shape.getNumChildShapes() === 0) {\n        this.system.recreatePhysicalShapes(this._compoundParent);\n      } else {\n        const transform = this.system._getNodeTransform(this.entity, this._compoundParent.entity);\n        this._compoundParent.shape.addChildShape(transform, this.data.shape);\n        Ammo.destroy(transform);\n        if (this._compoundParent.entity.rigidbody) this._compoundParent.entity.rigidbody.activate();\n      }\n    } else if (this.entity.trigger) {\n      this.entity.trigger.enable();\n    }\n  }\n  onDisable() {\n    if (this.entity.rigidbody) {\n      this.entity.rigidbody.disableSimulation();\n    } else if (this._compoundParent && this !== this._compoundParent) {\n      if (!this._compoundParent.entity._destroying) {\n        this.system._removeCompoundChild(this._compoundParent, this.data.shape);\n        if (this._compoundParent.entity.rigidbody) this._compoundParent.entity.rigidbody.activate();\n      }\n    } else if (this.entity.trigger) {\n      this.entity.trigger.disable();\n    }\n  }\n  onBeforeRemove() {\n    if (this.asset) {\n      this.asset = null;\n    }\n    if (this.renderAsset) {\n      this.renderAsset = null;\n    }\n    this.entity.off('insert', this._onInsert, this);\n    this.off();\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/collision/component.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/collision/data.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/collision/data.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CollisionComponentData\": () => (/* binding */ CollisionComponentData)\n/* harmony export */ });\n/* harmony import */ var _core_math_quat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/math/quat.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/quat.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n\n\n\nclass CollisionComponentData {\n  constructor() {\n    this.enabled = true;\n    this.type = 'box';\n    this.halfExtents = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(0.5, 0.5, 0.5);\n    this.linearOffset = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n    this.angularOffset = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_1__.Quat();\n    this.radius = 0.5;\n    this.axis = 1;\n    this.height = 2;\n    this.asset = null;\n    this.renderAsset = null;\n    this.shape = null;\n    this.model = null;\n    this.render = null;\n    this.initialized = false;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/collision/data.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/collision/system.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/collision/system.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CollisionComponentSystem\": () => (/* binding */ CollisionComponentSystem)\n/* harmony export */ });\n/* harmony import */ var _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/math/mat4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js\");\n/* harmony import */ var _core_math_quat_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/math/quat.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/quat.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _scene_graph_node_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../scene/graph-node.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/graph-node.js\");\n/* harmony import */ var _scene_model_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../scene/model.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/model.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/system.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/collision/component.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./data.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/collision/data.js\");\n/* harmony import */ var _trigger_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./trigger.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/collision/trigger.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst mat4 = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\nconst vec3 = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst quat = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_2__.Quat();\nconst tempGraphNode = new _scene_graph_node_js__WEBPACK_IMPORTED_MODULE_3__.GraphNode();\nconst _schema = ['enabled', 'type', 'halfExtents', 'linearOffset', 'angularOffset', 'radius', 'axis', 'height', 'asset', 'renderAsset', 'shape', 'model', 'render'];\nclass CollisionSystemImpl {\n  constructor(system) {\n    this.system = system;\n  }\n  beforeInitialize(component, data) {\n    data.shape = null;\n    data.model = new _scene_model_js__WEBPACK_IMPORTED_MODULE_4__.Model();\n    data.model.graph = new _scene_graph_node_js__WEBPACK_IMPORTED_MODULE_3__.GraphNode();\n  }\n  afterInitialize(component, data) {\n    this.recreatePhysicalShapes(component);\n    component.data.initialized = true;\n  }\n  reset(component, data) {\n    this.beforeInitialize(component, data);\n    this.afterInitialize(component, data);\n  }\n  recreatePhysicalShapes(component) {\n    const entity = component.entity;\n    const data = component.data;\n    if (typeof Ammo !== 'undefined') {\n      if (entity.trigger) {\n        entity.trigger.destroy();\n        delete entity.trigger;\n      }\n      if (data.shape) {\n        if (component._compoundParent) {\n          this.system._removeCompoundChild(component._compoundParent, data.shape);\n          if (component._compoundParent.entity.rigidbody) component._compoundParent.entity.rigidbody.activate();\n        }\n        Ammo.destroy(data.shape);\n        data.shape = null;\n      }\n      data.shape = this.createPhysicalShape(component.entity, data);\n      const firstCompoundChild = !component._compoundParent;\n      if (data.type === 'compound' && (!component._compoundParent || component === component._compoundParent)) {\n        component._compoundParent = component;\n        entity.forEach(this._addEachDescendant, component);\n      } else if (data.type !== 'compound') {\n        if (component._compoundParent && component === component._compoundParent) {\n          entity.forEach(this.system.implementations.compound._updateEachDescendant, component);\n        }\n        if (!component.rigidbody) {\n          component._compoundParent = null;\n          let parent = entity.parent;\n          while (parent) {\n            if (parent.collision && parent.collision.type === 'compound') {\n              component._compoundParent = parent.collision;\n              break;\n            }\n            parent = parent.parent;\n          }\n        }\n      }\n      if (component._compoundParent) {\n        if (component !== component._compoundParent) {\n          if (firstCompoundChild && component._compoundParent.shape.getNumChildShapes() === 0) {\n            this.system.recreatePhysicalShapes(component._compoundParent);\n          } else {\n            this.system.updateCompoundChildTransform(entity);\n            if (component._compoundParent.entity.rigidbody) component._compoundParent.entity.rigidbody.activate();\n          }\n        }\n      }\n      if (entity.rigidbody) {\n        entity.rigidbody.disableSimulation();\n        entity.rigidbody.createBody();\n        if (entity.enabled && entity.rigidbody.enabled) {\n          entity.rigidbody.enableSimulation();\n        }\n      } else if (!component._compoundParent) {\n        if (!entity.trigger) {\n          entity.trigger = new _trigger_js__WEBPACK_IMPORTED_MODULE_5__.Trigger(this.system.app, component, data);\n        } else {\n          entity.trigger.initialize(data);\n        }\n      }\n    }\n  }\n  createPhysicalShape(entity, data) {\n    return undefined;\n  }\n  updateTransform(component, position, rotation, scale) {\n    if (component.entity.trigger) {\n      component.entity.trigger.updateTransform();\n    }\n  }\n  beforeRemove(entity, component) {\n    if (component.data.shape) {\n      if (component._compoundParent && !component._compoundParent.entity._destroying) {\n        this.system._removeCompoundChild(component._compoundParent, component.data.shape);\n        if (component._compoundParent.entity.rigidbody) component._compoundParent.entity.rigidbody.activate();\n      }\n      component._compoundParent = null;\n      Ammo.destroy(component.data.shape);\n      component.data.shape = null;\n    }\n  }\n  remove(entity, data) {\n    if (entity.rigidbody && entity.rigidbody.body) {\n      entity.rigidbody.disableSimulation();\n    }\n    if (entity.trigger) {\n      entity.trigger.destroy();\n      delete entity.trigger;\n    }\n  }\n  clone(entity, clone) {\n    const src = this.system.store[entity.getGuid()];\n    const data = {\n      enabled: src.data.enabled,\n      type: src.data.type,\n      halfExtents: [src.data.halfExtents.x, src.data.halfExtents.y, src.data.halfExtents.z],\n      linearOffset: [src.data.linearOffset.x, src.data.linearOffset.y, src.data.linearOffset.z],\n      angularOffset: [src.data.angularOffset.x, src.data.angularOffset.y, src.data.angularOffset.z, src.data.angularOffset.w],\n      radius: src.data.radius,\n      axis: src.data.axis,\n      height: src.data.height,\n      asset: src.data.asset,\n      renderAsset: src.data.renderAsset,\n      model: src.data.model,\n      render: src.data.render\n    };\n    return this.system.addComponent(clone, data);\n  }\n}\nclass CollisionBoxSystemImpl extends CollisionSystemImpl {\n  createPhysicalShape(entity, data) {\n    if (typeof Ammo !== 'undefined') {\n      const he = data.halfExtents;\n      const ammoHe = new Ammo.btVector3(he ? he.x : 0.5, he ? he.y : 0.5, he ? he.z : 0.5);\n      const shape = new Ammo.btBoxShape(ammoHe);\n      Ammo.destroy(ammoHe);\n      return shape;\n    }\n    return undefined;\n  }\n}\nclass CollisionSphereSystemImpl extends CollisionSystemImpl {\n  createPhysicalShape(entity, data) {\n    if (typeof Ammo !== 'undefined') {\n      return new Ammo.btSphereShape(data.radius);\n    }\n    return undefined;\n  }\n}\nclass CollisionCapsuleSystemImpl extends CollisionSystemImpl {\n  createPhysicalShape(entity, data) {\n    const axis = data.axis !== undefined ? data.axis : 1;\n    const radius = data.radius || 0.5;\n    const height = Math.max((data.height || 2) - 2 * radius, 0);\n    let shape = null;\n    if (typeof Ammo !== 'undefined') {\n      switch (axis) {\n        case 0:\n          shape = new Ammo.btCapsuleShapeX(radius, height);\n          break;\n        case 1:\n          shape = new Ammo.btCapsuleShape(radius, height);\n          break;\n        case 2:\n          shape = new Ammo.btCapsuleShapeZ(radius, height);\n          break;\n      }\n    }\n    return shape;\n  }\n}\nclass CollisionCylinderSystemImpl extends CollisionSystemImpl {\n  createPhysicalShape(entity, data) {\n    const axis = data.axis !== undefined ? data.axis : 1;\n    const radius = data.radius !== undefined ? data.radius : 0.5;\n    const height = data.height !== undefined ? data.height : 1;\n    let halfExtents = null;\n    let shape = null;\n    if (typeof Ammo !== 'undefined') {\n      switch (axis) {\n        case 0:\n          halfExtents = new Ammo.btVector3(height * 0.5, radius, radius);\n          shape = new Ammo.btCylinderShapeX(halfExtents);\n          break;\n        case 1:\n          halfExtents = new Ammo.btVector3(radius, height * 0.5, radius);\n          shape = new Ammo.btCylinderShape(halfExtents);\n          break;\n        case 2:\n          halfExtents = new Ammo.btVector3(radius, radius, height * 0.5);\n          shape = new Ammo.btCylinderShapeZ(halfExtents);\n          break;\n      }\n    }\n    if (halfExtents) Ammo.destroy(halfExtents);\n    return shape;\n  }\n}\nclass CollisionConeSystemImpl extends CollisionSystemImpl {\n  createPhysicalShape(entity, data) {\n    const axis = data.axis !== undefined ? data.axis : 1;\n    const radius = data.radius !== undefined ? data.radius : 0.5;\n    const height = data.height !== undefined ? data.height : 1;\n    let shape = null;\n    if (typeof Ammo !== 'undefined') {\n      switch (axis) {\n        case 0:\n          shape = new Ammo.btConeShapeX(radius, height);\n          break;\n        case 1:\n          shape = new Ammo.btConeShape(radius, height);\n          break;\n        case 2:\n          shape = new Ammo.btConeShapeZ(radius, height);\n          break;\n      }\n    }\n    return shape;\n  }\n}\nclass CollisionMeshSystemImpl extends CollisionSystemImpl {\n  beforeInitialize(component, data) {}\n  createAmmoMesh(mesh, node, shape) {\n    let triMesh;\n    if (this.system._triMeshCache[mesh.id]) {\n      triMesh = this.system._triMeshCache[mesh.id];\n    } else {\n      const vb = mesh.vertexBuffer;\n      const format = vb.getFormat();\n      let stride;\n      let positions;\n      for (let i = 0; i < format.elements.length; i++) {\n        const element = format.elements[i];\n        if (element.name === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_6__.SEMANTIC_POSITION) {\n          positions = new Float32Array(vb.lock(), element.offset);\n          stride = element.stride / 4;\n          break;\n        }\n      }\n      const indices = [];\n      mesh.getIndices(indices);\n      const numTriangles = mesh.primitive[0].count / 3;\n      const v1 = new Ammo.btVector3();\n      const v2 = new Ammo.btVector3();\n      const v3 = new Ammo.btVector3();\n      let i1, i2, i3;\n      const base = mesh.primitive[0].base;\n      triMesh = new Ammo.btTriangleMesh();\n      this.system._triMeshCache[mesh.id] = triMesh;\n      for (let i = 0; i < numTriangles; i++) {\n        i1 = indices[base + i * 3] * stride;\n        i2 = indices[base + i * 3 + 1] * stride;\n        i3 = indices[base + i * 3 + 2] * stride;\n        v1.setValue(positions[i1], positions[i1 + 1], positions[i1 + 2]);\n        v2.setValue(positions[i2], positions[i2 + 1], positions[i2 + 2]);\n        v3.setValue(positions[i3], positions[i3 + 1], positions[i3 + 2]);\n        triMesh.addTriangle(v1, v2, v3, true);\n      }\n      Ammo.destroy(v1);\n      Ammo.destroy(v2);\n      Ammo.destroy(v3);\n    }\n    const useQuantizedAabbCompression = true;\n    const triMeshShape = new Ammo.btBvhTriangleMeshShape(triMesh, useQuantizedAabbCompression);\n    const scaling = this.system._getNodeScaling(node);\n    triMeshShape.setLocalScaling(scaling);\n    Ammo.destroy(scaling);\n    const transform = this.system._getNodeTransform(node);\n    shape.addChildShape(transform, triMeshShape);\n    Ammo.destroy(transform);\n  }\n  createPhysicalShape(entity, data) {\n    if (typeof Ammo === 'undefined') return undefined;\n    if (data.model || data.render) {\n      const shape = new Ammo.btCompoundShape();\n      if (data.model) {\n        const meshInstances = data.model.meshInstances;\n        for (let i = 0; i < meshInstances.length; i++) {\n          this.createAmmoMesh(meshInstances[i].mesh, meshInstances[i].node, shape);\n        }\n      } else if (data.render) {\n        const meshes = data.render.meshes;\n        for (let i = 0; i < meshes.length; i++) {\n          this.createAmmoMesh(meshes[i], tempGraphNode, shape);\n        }\n      }\n      const entityTransform = entity.getWorldTransform();\n      const scale = entityTransform.getScale();\n      const vec = new Ammo.btVector3(scale.x, scale.y, scale.z);\n      shape.setLocalScaling(vec);\n      Ammo.destroy(vec);\n      return shape;\n    }\n    return undefined;\n  }\n  recreatePhysicalShapes(component) {\n    const data = component.data;\n    if (data.renderAsset || data.asset) {\n      if (component.enabled && component.entity.enabled) {\n        this.loadAsset(component, data.renderAsset || data.asset, data.renderAsset ? 'render' : 'model');\n        return;\n      }\n    }\n    this.doRecreatePhysicalShape(component);\n  }\n  loadAsset(component, id, property) {\n    const data = component.data;\n    const assets = this.system.app.assets;\n    const asset = assets.get(id);\n    if (asset) {\n      asset.ready(asset => {\n        data[property] = asset.resource;\n        this.doRecreatePhysicalShape(component);\n      });\n      assets.load(asset);\n    } else {\n      assets.once('add:' + id, asset => {\n        asset.ready(asset => {\n          data[property] = asset.resource;\n          this.doRecreatePhysicalShape(component);\n        });\n        assets.load(asset);\n      });\n    }\n  }\n  doRecreatePhysicalShape(component) {\n    const entity = component.entity;\n    const data = component.data;\n    if (data.model || data.render) {\n      this.destroyShape(data);\n      data.shape = this.createPhysicalShape(entity, data);\n      if (entity.rigidbody) {\n        entity.rigidbody.disableSimulation();\n        entity.rigidbody.createBody();\n        if (entity.enabled && entity.rigidbody.enabled) {\n          entity.rigidbody.enableSimulation();\n        }\n      } else {\n        if (!entity.trigger) {\n          entity.trigger = new _trigger_js__WEBPACK_IMPORTED_MODULE_5__.Trigger(this.system.app, component, data);\n        } else {\n          entity.trigger.initialize(data);\n        }\n      }\n    } else {\n      this.beforeRemove(entity, component);\n      this.remove(entity, data);\n    }\n  }\n  updateTransform(component, position, rotation, scale) {\n    if (component.shape) {\n      const entityTransform = component.entity.getWorldTransform();\n      const worldScale = entityTransform.getScale();\n      const previousScale = component.shape.getLocalScaling();\n      if (worldScale.x !== previousScale.x() || worldScale.y !== previousScale.y() || worldScale.z !== previousScale.z()) {\n        this.doRecreatePhysicalShape(component);\n      }\n    }\n    super.updateTransform(component, position, rotation, scale);\n  }\n  destroyShape(data) {\n    if (!data.shape) return;\n    const numShapes = data.shape.getNumChildShapes();\n    for (let i = 0; i < numShapes; i++) {\n      const shape = data.shape.getChildShape(i);\n      Ammo.destroy(shape);\n    }\n    Ammo.destroy(data.shape);\n    data.shape = null;\n  }\n  remove(entity, data) {\n    this.destroyShape(data);\n    super.remove(entity, data);\n  }\n}\nclass CollisionCompoundSystemImpl extends CollisionSystemImpl {\n  createPhysicalShape(entity, data) {\n    if (typeof Ammo !== 'undefined') {\n      return new Ammo.btCompoundShape();\n    }\n    return undefined;\n  }\n  _addEachDescendant(entity) {\n    if (!entity.collision || entity.rigidbody) return;\n    entity.collision._compoundParent = this;\n    if (entity !== this.entity) {\n      entity.collision.system.recreatePhysicalShapes(entity.collision);\n    }\n  }\n  _updateEachDescendant(entity) {\n    if (!entity.collision) return;\n    if (entity.collision._compoundParent !== this) return;\n    entity.collision._compoundParent = null;\n    if (entity !== this.entity && !entity.rigidbody) {\n      entity.collision.system.recreatePhysicalShapes(entity.collision);\n    }\n  }\n  _updateEachDescendantTransform(entity) {\n    if (!entity.collision || entity.collision._compoundParent !== this.collision._compoundParent) return;\n    this.collision.system.updateCompoundChildTransform(entity);\n  }\n}\nclass CollisionComponentSystem extends _system_js__WEBPACK_IMPORTED_MODULE_7__.ComponentSystem {\n  constructor(app) {\n    super(app);\n    this.id = 'collision';\n    this.ComponentType = _component_js__WEBPACK_IMPORTED_MODULE_8__.CollisionComponent;\n    this.DataType = _data_js__WEBPACK_IMPORTED_MODULE_9__.CollisionComponentData;\n    this.schema = _schema;\n    this.implementations = {};\n    this._triMeshCache = {};\n    this.on('beforeremove', this.onBeforeRemove, this);\n    this.on('remove', this.onRemove, this);\n  }\n  initializeComponentData(component, _data, properties) {\n    properties = ['type', 'halfExtents', 'radius', 'axis', 'height', 'shape', 'model', 'asset', 'render', 'renderAsset', 'enabled', 'linearOffset', 'angularOffset'];\n    const data = {};\n    for (let i = 0, len = properties.length; i < len; i++) {\n      const property = properties[i];\n      data[property] = _data[property];\n    }\n    let idx;\n    if (_data.hasOwnProperty('asset')) {\n      idx = properties.indexOf('model');\n      if (idx !== -1) {\n        properties.splice(idx, 1);\n      }\n      idx = properties.indexOf('render');\n      if (idx !== -1) {\n        properties.splice(idx, 1);\n      }\n    } else if (_data.hasOwnProperty('model')) {\n      idx = properties.indexOf('asset');\n      if (idx !== -1) {\n        properties.splice(idx, 1);\n      }\n    }\n    if (!data.type) {\n      data.type = component.data.type;\n    }\n    component.data.type = data.type;\n    if (Array.isArray(data.halfExtents)) {\n      data.halfExtents = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3(data.halfExtents);\n    }\n    if (Array.isArray(data.linearOffset)) {\n      data.linearOffset = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3(data.linearOffset);\n    }\n    if (Array.isArray(data.angularOffset)) {\n      const values = data.angularOffset;\n      if (values.length === 3) {\n        data.angularOffset = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_2__.Quat().setFromEulerAngles(values[0], values[1], values[2]);\n      } else {\n        data.angularOffset = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_2__.Quat(data.angularOffset);\n      }\n    }\n    const impl = this._createImplementation(data.type);\n    impl.beforeInitialize(component, data);\n    super.initializeComponentData(component, data, properties);\n    impl.afterInitialize(component, data);\n  }\n  _createImplementation(type) {\n    if (this.implementations[type] === undefined) {\n      let impl;\n      switch (type) {\n        case 'box':\n          impl = new CollisionBoxSystemImpl(this);\n          break;\n        case 'sphere':\n          impl = new CollisionSphereSystemImpl(this);\n          break;\n        case 'capsule':\n          impl = new CollisionCapsuleSystemImpl(this);\n          break;\n        case 'cylinder':\n          impl = new CollisionCylinderSystemImpl(this);\n          break;\n        case 'cone':\n          impl = new CollisionConeSystemImpl(this);\n          break;\n        case 'mesh':\n          impl = new CollisionMeshSystemImpl(this);\n          break;\n        case 'compound':\n          impl = new CollisionCompoundSystemImpl(this);\n          break;\n      }\n      this.implementations[type] = impl;\n    }\n    return this.implementations[type];\n  }\n  _getImplementation(entity) {\n    return this.implementations[entity.collision.data.type];\n  }\n  cloneComponent(entity, clone) {\n    return this._getImplementation(entity).clone(entity, clone);\n  }\n  onBeforeRemove(entity, component) {\n    this.implementations[component.data.type].beforeRemove(entity, component);\n    component.onBeforeRemove();\n  }\n  onRemove(entity, data) {\n    this.implementations[data.type].remove(entity, data);\n  }\n  updateCompoundChildTransform(entity) {\n    this._removeCompoundChild(entity.collision._compoundParent, entity.collision.data.shape);\n    if (entity.enabled && entity.collision.enabled) {\n      const transform = this._getNodeTransform(entity, entity.collision._compoundParent.entity);\n      entity.collision._compoundParent.shape.addChildShape(transform, entity.collision.data.shape);\n      Ammo.destroy(transform);\n    }\n  }\n  _removeCompoundChild(collision, shape) {\n    if (collision.shape.removeChildShape) {\n      collision.shape.removeChildShape(shape);\n    } else {\n      const ind = collision._getCompoundChildShapeIndex(shape);\n      if (ind !== null) {\n        collision.shape.removeChildShapeByIndex(ind);\n      }\n    }\n  }\n  onTransformChanged(component, position, rotation, scale) {\n    this.implementations[component.data.type].updateTransform(component, position, rotation, scale);\n  }\n  changeType(component, previousType, newType) {\n    this.implementations[previousType].beforeRemove(component.entity, component);\n    this.implementations[previousType].remove(component.entity, component.data);\n    this._createImplementation(newType).reset(component, component.data);\n  }\n  recreatePhysicalShapes(component) {\n    this.implementations[component.data.type].recreatePhysicalShapes(component);\n  }\n  _calculateNodeRelativeTransform(node, relative) {\n    if (node === relative) {\n      const scale = node.getWorldTransform().getScale();\n      mat4.setScale(scale.x, scale.y, scale.z);\n    } else {\n      this._calculateNodeRelativeTransform(node.parent, relative);\n      mat4.mul(node.getLocalTransform());\n    }\n  }\n  _getNodeScaling(node) {\n    const wtm = node.getWorldTransform();\n    const scl = wtm.getScale();\n    return new Ammo.btVector3(scl.x, scl.y, scl.z);\n  }\n  _getNodeTransform(node, relative) {\n    let pos, rot;\n    if (relative) {\n      this._calculateNodeRelativeTransform(node, relative);\n      pos = vec3;\n      rot = quat;\n      mat4.getTranslation(pos);\n      rot.setFromMat4(mat4);\n    } else {\n      pos = node.getPosition();\n      rot = node.getRotation();\n    }\n    const ammoQuat = new Ammo.btQuaternion();\n    const transform = new Ammo.btTransform();\n    transform.setIdentity();\n    const origin = transform.getOrigin();\n    const component = node.collision;\n    if (component && component._hasOffset) {\n      const lo = component.data.linearOffset;\n      const ao = component.data.angularOffset;\n      quat.copy(rot).transformVector(lo, vec3);\n      vec3.add(pos);\n      quat.copy(rot).mul(ao);\n      origin.setValue(vec3.x, vec3.y, vec3.z);\n      ammoQuat.setValue(quat.x, quat.y, quat.z, quat.w);\n    } else {\n      origin.setValue(pos.x, pos.y, pos.z);\n      ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);\n    }\n    transform.setRotation(ammoQuat);\n    Ammo.destroy(ammoQuat);\n    Ammo.destroy(origin);\n    return transform;\n  }\n  destroy() {\n    for (const key in this._triMeshCache) {\n      Ammo.destroy(this._triMeshCache[key]);\n    }\n    this._triMeshCache = null;\n    super.destroy();\n  }\n}\n_component_js__WEBPACK_IMPORTED_MODULE_10__.Component._buildAccessors(_component_js__WEBPACK_IMPORTED_MODULE_8__.CollisionComponent.prototype, _schema);\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/collision/system.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/collision/trigger.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/collision/trigger.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Trigger\": () => (/* binding */ Trigger)\n/* harmony export */ });\n/* harmony import */ var _rigid_body_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../rigid-body/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/rigid-body/constants.js\");\n\n\nlet _ammoVec1, _ammoQuat, _ammoTransform;\nclass Trigger {\n  constructor(app, component, data) {\n    this.entity = component.entity;\n    this.component = component;\n    this.app = app;\n    if (typeof Ammo !== 'undefined' && !_ammoVec1) {\n      _ammoVec1 = new Ammo.btVector3();\n      _ammoQuat = new Ammo.btQuaternion();\n      _ammoTransform = new Ammo.btTransform();\n    }\n    this.initialize(data);\n  }\n  initialize(data) {\n    const entity = this.entity;\n    const shape = data.shape;\n    if (shape && typeof Ammo !== 'undefined') {\n      if (entity.trigger) {\n        entity.trigger.destroy();\n      }\n      const mass = 1;\n      const component = this.component;\n      if (component) {\n        const bodyPos = component.getShapePosition();\n        const bodyRot = component.getShapeRotation();\n        _ammoVec1.setValue(bodyPos.x, bodyPos.y, bodyPos.z);\n        _ammoQuat.setValue(bodyRot.x, bodyRot.y, bodyRot.z, bodyRot.w);\n      } else {\n        const pos = entity.getPosition();\n        const rot = entity.getRotation();\n        _ammoVec1.setValue(pos.x, pos.y, pos.z);\n        _ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);\n      }\n      _ammoTransform.setOrigin(_ammoVec1);\n      _ammoTransform.setRotation(_ammoQuat);\n      const body = this.app.systems.rigidbody.createBody(mass, shape, _ammoTransform);\n      body.setRestitution(0);\n      body.setFriction(0);\n      body.setDamping(0, 0);\n      _ammoVec1.setValue(0, 0, 0);\n      body.setLinearFactor(_ammoVec1);\n      body.setAngularFactor(_ammoVec1);\n      body.setCollisionFlags(body.getCollisionFlags() | _rigid_body_constants_js__WEBPACK_IMPORTED_MODULE_0__.BODYFLAG_NORESPONSE_OBJECT);\n      body.entity = entity;\n      this.body = body;\n      if (this.component.enabled && entity.enabled) {\n        this.enable();\n      }\n    }\n  }\n  destroy() {\n    const body = this.body;\n    if (!body) return;\n    this.disable();\n    this.app.systems.rigidbody.destroyBody(body);\n  }\n  _getEntityTransform(transform) {\n    const component = this.component;\n    if (component) {\n      const bodyPos = component.getShapePosition();\n      const bodyRot = component.getShapeRotation();\n      _ammoVec1.setValue(bodyPos.x, bodyPos.y, bodyPos.z);\n      _ammoQuat.setValue(bodyRot.x, bodyRot.y, bodyRot.z, bodyRot.w);\n    } else {\n      const pos = this.entity.getPosition();\n      const rot = this.entity.getRotation();\n      _ammoVec1.setValue(pos.x, pos.y, pos.z);\n      _ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);\n    }\n    transform.setOrigin(_ammoVec1);\n    transform.setRotation(_ammoQuat);\n  }\n  updateTransform() {\n    this._getEntityTransform(_ammoTransform);\n    const body = this.body;\n    body.setWorldTransform(_ammoTransform);\n    body.activate();\n  }\n  enable() {\n    const body = this.body;\n    if (!body) return;\n    const systems = this.app.systems;\n    systems.rigidbody.addBody(body, _rigid_body_constants_js__WEBPACK_IMPORTED_MODULE_0__.BODYGROUP_TRIGGER, _rigid_body_constants_js__WEBPACK_IMPORTED_MODULE_0__.BODYMASK_NOT_STATIC ^ _rigid_body_constants_js__WEBPACK_IMPORTED_MODULE_0__.BODYGROUP_TRIGGER);\n    systems.rigidbody._triggers.push(this);\n    body.forceActivationState(_rigid_body_constants_js__WEBPACK_IMPORTED_MODULE_0__.BODYSTATE_ACTIVE_TAG);\n    this.updateTransform();\n  }\n  disable() {\n    const body = this.body;\n    if (!body) return;\n    const systems = this.app.systems;\n    const idx = systems.rigidbody._triggers.indexOf(this);\n    if (idx > -1) {\n      systems.rigidbody._triggers.splice(idx, 1);\n    }\n    systems.rigidbody.removeBody(body);\n    body.forceActivationState(_rigid_body_constants_js__WEBPACK_IMPORTED_MODULE_0__.BODYSTATE_DISABLE_SIMULATION);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/collision/trigger.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Component\": () => (/* binding */ Component)\n/* harmony export */ });\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n\n\nclass Component extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor(system, entity) {\n    super();\n    this.system = void 0;\n    this.entity = void 0;\n    this.system = system;\n    this.entity = entity;\n    if (this.system.schema && !this._accessorsBuilt) {\n      this.buildAccessors(this.system.schema);\n    }\n    this.on('set', function (name, oldValue, newValue) {\n      this.fire('set_' + name, name, oldValue, newValue);\n    });\n    this.on('set_enabled', this.onSetEnabled, this);\n  }\n  static _buildAccessors(obj, schema) {\n    schema.forEach(function (descriptor) {\n      const name = typeof descriptor === 'object' ? descriptor.name : descriptor;\n      Object.defineProperty(obj, name, {\n        get: function () {\n          return this.data[name];\n        },\n        set: function (value) {\n          const data = this.data;\n          const oldValue = data[name];\n          data[name] = value;\n          this.fire('set', name, oldValue, value);\n        },\n        configurable: true\n      });\n    });\n    obj._accessorsBuilt = true;\n  }\n  buildAccessors(schema) {\n    Component._buildAccessors(this, schema);\n  }\n  onSetEnabled(name, oldValue, newValue) {\n    if (oldValue !== newValue) {\n      if (this.entity.enabled) {\n        if (newValue) {\n          this.onEnable();\n        } else {\n          this.onDisable();\n        }\n      }\n    }\n  }\n  onEnable() {}\n  onDisable() {}\n  onPostStateChange() {}\n  get data() {\n    const record = this.system.store[this.entity.getGuid()];\n    return record ? record.data : null;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/component.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/component.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ElementComponent\": () => (/* binding */ ElementComponent)\n/* harmony export */ });\n/* harmony import */ var _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/math/mat4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js\");\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/math/vec4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec4.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _scene_constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../scene/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _scene_batching_batch_group_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../scene/batching/batch-group.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/batching/batch-group.js\");\n/* harmony import */ var _scene_stencil_parameters_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../scene/stencil-parameters.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/stencil-parameters.js\");\n/* harmony import */ var _entity_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../entity.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/entity.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/constants.js\");\n/* harmony import */ var _image_element_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./image-element.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/image-element.js\");\n/* harmony import */ var _text_element_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./text-element.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/text-element.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst position = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst invParentWtm = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__.Mat4();\nconst vecA = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst vecB = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst matA = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__.Mat4();\nconst matB = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__.Mat4();\nconst matC = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__.Mat4();\nconst matD = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__.Mat4();\nclass ElementComponent extends _component_js__WEBPACK_IMPORTED_MODULE_2__.Component {\n  constructor(system, entity) {\n    super(system, entity);\n    this._beingInitialized = false;\n    this._anchor = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_3__.Vec4();\n    this._localAnchor = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_3__.Vec4();\n    this._pivot = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_4__.Vec2();\n    this._width = this._calculatedWidth = 32;\n    this._height = this._calculatedHeight = 32;\n    this._margin = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_3__.Vec4(0, 0, -32, -32);\n    this._modelTransform = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__.Mat4();\n    this._screenToWorld = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__.Mat4();\n    this._anchorTransform = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__.Mat4();\n    this._anchorDirty = true;\n    this._parentWorldTransform = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__.Mat4();\n    this._screenTransform = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__.Mat4();\n    this._screenCorners = [new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3()];\n    this._canvasCorners = [new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_4__.Vec2(), new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_4__.Vec2(), new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_4__.Vec2(), new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_4__.Vec2()];\n    this._worldCorners = [new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3()];\n    this._cornersDirty = true;\n    this._canvasCornersDirty = true;\n    this._worldCornersDirty = true;\n    this.entity.on('insert', this._onInsert, this);\n    this._patch();\n    this.screen = null;\n    this._type = _constants_js__WEBPACK_IMPORTED_MODULE_5__.ELEMENTTYPE_GROUP;\n    this._image = null;\n    this._text = null;\n    this._group = null;\n    this._drawOrder = 0;\n    this._fitMode = _constants_js__WEBPACK_IMPORTED_MODULE_5__.FITMODE_STRETCH;\n    this._useInput = false;\n    this._layers = [_scene_constants_js__WEBPACK_IMPORTED_MODULE_6__.LAYERID_UI];\n    this._addedModels = [];\n    this._batchGroupId = -1;\n    this._offsetReadAt = 0;\n    this._maskOffset = 0.5;\n    this._maskedBy = null;\n  }\n  get _absLeft() {\n    return this._localAnchor.x + this._margin.x;\n  }\n  get _absRight() {\n    return this._localAnchor.z - this._margin.z;\n  }\n  get _absTop() {\n    return this._localAnchor.w - this._margin.w;\n  }\n  get _absBottom() {\n    return this._localAnchor.y + this._margin.y;\n  }\n  get _hasSplitAnchorsX() {\n    return Math.abs(this._anchor.x - this._anchor.z) > 0.001;\n  }\n  get _hasSplitAnchorsY() {\n    return Math.abs(this._anchor.y - this._anchor.w) > 0.001;\n  }\n  get aabb() {\n    if (this._image) return this._image.aabb;\n    if (this._text) return this._text.aabb;\n    return null;\n  }\n  set anchor(value) {\n    if (value instanceof _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_3__.Vec4) {\n      this._anchor.copy(value);\n    } else {\n      this._anchor.set(...value);\n    }\n    if (!this.entity._parent && !this.screen) {\n      this._calculateLocalAnchors();\n    } else {\n      this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);\n    }\n    this._anchorDirty = true;\n    if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();\n    this.fire('set:anchor', this._anchor);\n  }\n  get anchor() {\n    return this._anchor;\n  }\n  set batchGroupId(value) {\n    if (this._batchGroupId === value) return;\n    if (this.entity.enabled && this._batchGroupId >= 0) {\n      var _this$system$app$batc;\n      (_this$system$app$batc = this.system.app.batcher) == null ? void 0 : _this$system$app$batc.remove(_scene_batching_batch_group_js__WEBPACK_IMPORTED_MODULE_7__.BatchGroup.ELEMENT, this.batchGroupId, this.entity);\n    }\n    if (this.entity.enabled && value >= 0) {\n      var _this$system$app$batc2;\n      (_this$system$app$batc2 = this.system.app.batcher) == null ? void 0 : _this$system$app$batc2.insert(_scene_batching_batch_group_js__WEBPACK_IMPORTED_MODULE_7__.BatchGroup.ELEMENT, value, this.entity);\n    }\n    if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {\n      if (this._image && this._image._renderable.model) {\n        this.addModelToLayers(this._image._renderable.model);\n      } else if (this._text && this._text._model) {\n        this.addModelToLayers(this._text._model);\n      }\n    }\n    this._batchGroupId = value;\n  }\n  get batchGroupId() {\n    return this._batchGroupId;\n  }\n  set bottom(value) {\n    this._margin.y = value;\n    const p = this.entity.getLocalPosition();\n    const wt = this._absTop;\n    const wb = this._localAnchor.y + value;\n    this._setHeight(wt - wb);\n    p.y = value + this._calculatedHeight * this._pivot.y;\n    this.entity.setLocalPosition(p);\n  }\n  get bottom() {\n    return this._margin.y;\n  }\n  set calculatedWidth(value) {\n    this._setCalculatedWidth(value, true);\n  }\n  get calculatedWidth() {\n    return this._calculatedWidth;\n  }\n  set calculatedHeight(value) {\n    this._setCalculatedHeight(value, true);\n  }\n  get calculatedHeight() {\n    return this._calculatedHeight;\n  }\n  get canvasCorners() {\n    if (!this._canvasCornersDirty || !this.screen || !this.screen.screen.screenSpace) return this._canvasCorners;\n    const device = this.system.app.graphicsDevice;\n    const screenCorners = this.screenCorners;\n    const sx = device.canvas.clientWidth / device.width;\n    const sy = device.canvas.clientHeight / device.height;\n    for (let i = 0; i < 4; i++) {\n      this._canvasCorners[i].set(screenCorners[i].x * sx, (device.height - screenCorners[i].y) * sy);\n    }\n    this._canvasCornersDirty = false;\n    return this._canvasCorners;\n  }\n  set drawOrder(value) {\n    let priority = 0;\n    if (this.screen) {\n      priority = this.screen.screen.priority;\n    }\n    if (value > 0xFFFFFF) {\n      value = 0xFFFFFF;\n    }\n    this._drawOrder = (priority << 24) + value;\n    this.fire('set:draworder', this._drawOrder);\n  }\n  get drawOrder() {\n    return this._drawOrder;\n  }\n  set height(value) {\n    this._height = value;\n    if (!this._hasSplitAnchorsY) {\n      this._setCalculatedHeight(value, true);\n    }\n    this.fire('set:height', this._height);\n  }\n  get height() {\n    return this._height;\n  }\n  set layers(value) {\n    if (this._addedModels.length) {\n      for (let i = 0; i < this._layers.length; i++) {\n        const layer = this.system.app.scene.layers.getLayerById(this._layers[i]);\n        if (layer) {\n          for (let j = 0; j < this._addedModels.length; j++) {\n            layer.removeMeshInstances(this._addedModels[j].meshInstances);\n          }\n        }\n      }\n    }\n    this._layers = value;\n    if (!this.enabled || !this.entity.enabled || !this._addedModels.length) return;\n    for (let i = 0; i < this._layers.length; i++) {\n      const layer = this.system.app.scene.layers.getLayerById(this._layers[i]);\n      if (layer) {\n        for (let j = 0; j < this._addedModels.length; j++) {\n          layer.addMeshInstances(this._addedModels[j].meshInstances);\n        }\n      }\n    }\n  }\n  get layers() {\n    return this._layers;\n  }\n  set left(value) {\n    this._margin.x = value;\n    const p = this.entity.getLocalPosition();\n    const wr = this._absRight;\n    const wl = this._localAnchor.x + value;\n    this._setWidth(wr - wl);\n    p.x = value + this._calculatedWidth * this._pivot.x;\n    this.entity.setLocalPosition(p);\n  }\n  get left() {\n    return this._margin.x;\n  }\n  set margin(value) {\n    this._margin.copy(value);\n    this._calculateSize(true, true);\n    this.fire('set:margin', this._margin);\n  }\n  get margin() {\n    return this._margin;\n  }\n  get maskedBy() {\n    return this._maskedBy;\n  }\n  set pivot(value) {\n    const {\n      pivot,\n      margin\n    } = this;\n    const prevX = pivot.x;\n    const prevY = pivot.y;\n    if (value instanceof _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_4__.Vec2) {\n      pivot.copy(value);\n    } else {\n      pivot.set(...value);\n    }\n    const mx = margin.x + margin.z;\n    const dx = pivot.x - prevX;\n    margin.x += mx * dx;\n    margin.z -= mx * dx;\n    const my = margin.y + margin.w;\n    const dy = pivot.y - prevY;\n    margin.y += my * dy;\n    margin.w -= my * dy;\n    this._anchorDirty = true;\n    this._cornersDirty = true;\n    this._worldCornersDirty = true;\n    this._calculateSize(false, false);\n    this._flagChildrenAsDirty();\n    this.fire('set:pivot', pivot);\n  }\n  get pivot() {\n    return this._pivot;\n  }\n  set right(value) {\n    this._margin.z = value;\n    const p = this.entity.getLocalPosition();\n    const wl = this._absLeft;\n    const wr = this._localAnchor.z - value;\n    this._setWidth(wr - wl);\n    p.x = this._localAnchor.z - this._localAnchor.x - value - this._calculatedWidth * (1 - this._pivot.x);\n    this.entity.setLocalPosition(p);\n  }\n  get right() {\n    return this._margin.z;\n  }\n  get screenCorners() {\n    if (!this._cornersDirty || !this.screen) return this._screenCorners;\n    const parentBottomLeft = this.entity.parent && this.entity.parent.element && this.entity.parent.element.screenCorners[0];\n    this._screenCorners[0].set(this._absLeft, this._absBottom, 0);\n    this._screenCorners[1].set(this._absRight, this._absBottom, 0);\n    this._screenCorners[2].set(this._absRight, this._absTop, 0);\n    this._screenCorners[3].set(this._absLeft, this._absTop, 0);\n    const screenSpace = this.screen.screen.screenSpace;\n    for (let i = 0; i < 4; i++) {\n      this._screenTransform.transformPoint(this._screenCorners[i], this._screenCorners[i]);\n      if (screenSpace) this._screenCorners[i].mulScalar(this.screen.screen.scale);\n      if (parentBottomLeft) {\n        this._screenCorners[i].add(parentBottomLeft);\n      }\n    }\n    this._cornersDirty = false;\n    this._canvasCornersDirty = true;\n    this._worldCornersDirty = true;\n    return this._screenCorners;\n  }\n  get textWidth() {\n    return this._text ? this._text.width : 0;\n  }\n  get textHeight() {\n    return this._text ? this._text.height : 0;\n  }\n  set top(value) {\n    this._margin.w = value;\n    const p = this.entity.getLocalPosition();\n    const wb = this._absBottom;\n    const wt = this._localAnchor.w - value;\n    this._setHeight(wt - wb);\n    p.y = this._localAnchor.w - this._localAnchor.y - value - this._calculatedHeight * (1 - this._pivot.y);\n    this.entity.setLocalPosition(p);\n  }\n  get top() {\n    return this._margin.w;\n  }\n  set type(value) {\n    if (value !== this._type) {\n      this._type = value;\n      if (this._image) {\n        this._image.destroy();\n        this._image = null;\n      }\n      if (this._text) {\n        this._text.destroy();\n        this._text = null;\n      }\n      if (value === _constants_js__WEBPACK_IMPORTED_MODULE_5__.ELEMENTTYPE_IMAGE) {\n        this._image = new _image_element_js__WEBPACK_IMPORTED_MODULE_8__.ImageElement(this);\n      } else if (value === _constants_js__WEBPACK_IMPORTED_MODULE_5__.ELEMENTTYPE_TEXT) {\n        this._text = new _text_element_js__WEBPACK_IMPORTED_MODULE_9__.TextElement(this);\n      }\n    }\n  }\n  get type() {\n    return this._type;\n  }\n  set useInput(value) {\n    if (this._useInput === value) return;\n    this._useInput = value;\n    if (this.system.app.elementInput) {\n      if (value) {\n        if (this.enabled && this.entity.enabled) {\n          this.system.app.elementInput.addElement(this);\n        }\n      } else {\n        this.system.app.elementInput.removeElement(this);\n      }\n    } else {\n      if (this._useInput === true) ;\n    }\n    this.fire('set:useInput', value);\n  }\n  get useInput() {\n    return this._useInput;\n  }\n  set fitMode(value) {\n    this._fitMode = value;\n    this._calculateSize(true, true);\n    if (this._image) {\n      this._image.refreshMesh();\n    }\n  }\n  get fitMode() {\n    return this._fitMode;\n  }\n  set width(value) {\n    this._width = value;\n    if (!this._hasSplitAnchorsX) {\n      this._setCalculatedWidth(value, true);\n    }\n    this.fire('set:width', this._width);\n  }\n  get width() {\n    return this._width;\n  }\n  get worldCorners() {\n    if (!this._worldCornersDirty) {\n      return this._worldCorners;\n    }\n    if (this.screen) {\n      const screenCorners = this.screenCorners;\n      if (!this.screen.screen.screenSpace) {\n        matA.copy(this.screen.screen._screenMatrix);\n        matA.data[13] = -matA.data[13];\n        matA.mul2(this.screen.getWorldTransform(), matA);\n        for (let i = 0; i < 4; i++) {\n          matA.transformPoint(screenCorners[i], this._worldCorners[i]);\n        }\n      }\n    } else {\n      const localPos = this.entity.getLocalPosition();\n      matA.setTranslate(-localPos.x, -localPos.y, -localPos.z);\n      matB.setTRS(_core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3.ZERO, this.entity.getLocalRotation(), this.entity.getLocalScale());\n      matC.setTranslate(localPos.x, localPos.y, localPos.z);\n      const entity = this.entity.parent ? this.entity.parent : this.entity;\n      matD.copy(entity.getWorldTransform());\n      matD.mul(matC).mul(matB).mul(matA);\n      vecA.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);\n      matD.transformPoint(vecA, this._worldCorners[0]);\n      vecA.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);\n      matD.transformPoint(vecA, this._worldCorners[1]);\n      vecA.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);\n      matD.transformPoint(vecA, this._worldCorners[2]);\n      vecA.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);\n      matD.transformPoint(vecA, this._worldCorners[3]);\n    }\n    this._worldCornersDirty = false;\n    return this._worldCorners;\n  }\n  _patch() {\n    this.entity._sync = this._sync;\n    this.entity.setPosition = this._setPosition;\n    this.entity.setLocalPosition = this._setLocalPosition;\n  }\n  _unpatch() {\n    this.entity._sync = _entity_js__WEBPACK_IMPORTED_MODULE_10__.Entity.prototype._sync;\n    this.entity.setPosition = _entity_js__WEBPACK_IMPORTED_MODULE_10__.Entity.prototype.setPosition;\n    this.entity.setLocalPosition = _entity_js__WEBPACK_IMPORTED_MODULE_10__.Entity.prototype.setLocalPosition;\n  }\n  _setPosition(x, y, z) {\n    if (!this.element.screen) {\n      _entity_js__WEBPACK_IMPORTED_MODULE_10__.Entity.prototype.setPosition.call(this, x, y, z);\n      return;\n    }\n    if (x instanceof _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3) {\n      position.copy(x);\n    } else {\n      position.set(x, y, z);\n    }\n    this.getWorldTransform();\n    invParentWtm.copy(this.element._screenToWorld).invert();\n    invParentWtm.transformPoint(position, this.localPosition);\n    if (!this._dirtyLocal) this._dirtifyLocal();\n  }\n  _setLocalPosition(x, y, z) {\n    if (x instanceof _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3) {\n      this.localPosition.copy(x);\n    } else {\n      this.localPosition.set(x, y, z);\n    }\n    const element = this.element;\n    const p = this.localPosition;\n    const pvt = element._pivot;\n    element._margin.x = p.x - element._calculatedWidth * pvt.x;\n    element._margin.z = element._localAnchor.z - element._localAnchor.x - element._calculatedWidth - element._margin.x;\n    element._margin.y = p.y - element._calculatedHeight * pvt.y;\n    element._margin.w = element._localAnchor.w - element._localAnchor.y - element._calculatedHeight - element._margin.y;\n    if (!this._dirtyLocal) this._dirtifyLocal();\n  }\n  _sync() {\n    const element = this.element;\n    const screen = element.screen;\n    if (screen) {\n      if (element._anchorDirty) {\n        let resx = 0;\n        let resy = 0;\n        let px = 0;\n        let py = 1;\n        if (this._parent && this._parent.element) {\n          resx = this._parent.element.calculatedWidth;\n          resy = this._parent.element.calculatedHeight;\n          px = this._parent.element.pivot.x;\n          py = this._parent.element.pivot.y;\n        } else {\n          const resolution = screen.screen.resolution;\n          resx = resolution.x / screen.screen.scale;\n          resy = resolution.y / screen.screen.scale;\n        }\n        element._anchorTransform.setTranslate(resx * (element.anchor.x - px), -(resy * (py - element.anchor.y)), 0);\n        element._anchorDirty = false;\n        element._calculateLocalAnchors();\n      }\n      if (element._sizeDirty) {\n        element._calculateSize(false, false);\n      }\n    }\n    if (this._dirtyLocal) {\n      this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);\n      const p = this.localPosition;\n      const pvt = element._pivot;\n      element._margin.x = p.x - element._calculatedWidth * pvt.x;\n      element._margin.z = element._localAnchor.z - element._localAnchor.x - element._calculatedWidth - element._margin.x;\n      element._margin.y = p.y - element._calculatedHeight * pvt.y;\n      element._margin.w = element._localAnchor.w - element._localAnchor.y - element._calculatedHeight - element._margin.y;\n      this._dirtyLocal = false;\n    }\n    if (!screen) {\n      if (this._dirtyWorld) {\n        element._cornersDirty = true;\n        element._canvasCornersDirty = true;\n        element._worldCornersDirty = true;\n      }\n      return _entity_js__WEBPACK_IMPORTED_MODULE_10__.Entity.prototype._sync.call(this);\n    }\n    if (this._dirtyWorld) {\n      if (this._parent === null) {\n        this.worldTransform.copy(this.localTransform);\n      } else {\n        if (this._parent.element) {\n          element._screenToWorld.mul2(this._parent.element._modelTransform, element._anchorTransform);\n        } else {\n          element._screenToWorld.copy(element._anchorTransform);\n        }\n        element._modelTransform.mul2(element._screenToWorld, this.localTransform);\n        if (screen) {\n          element._screenToWorld.mul2(screen.screen._screenMatrix, element._screenToWorld);\n          if (!screen.screen.screenSpace) {\n            element._screenToWorld.mul2(screen.worldTransform, element._screenToWorld);\n          }\n          this.worldTransform.mul2(element._screenToWorld, this.localTransform);\n          const parentWorldTransform = element._parentWorldTransform;\n          parentWorldTransform.setIdentity();\n          const parent = this._parent;\n          if (parent && parent.element && parent !== screen) {\n            matA.setTRS(_core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3.ZERO, parent.getLocalRotation(), parent.getLocalScale());\n            parentWorldTransform.mul2(parent.element._parentWorldTransform, matA);\n          }\n          const depthOffset = vecA;\n          depthOffset.set(0, 0, this.localPosition.z);\n          const pivotOffset = vecB;\n          pivotOffset.set(element._absLeft + element._pivot.x * element.calculatedWidth, element._absBottom + element._pivot.y * element.calculatedHeight, 0);\n          matA.setTranslate(-pivotOffset.x, -pivotOffset.y, -pivotOffset.z);\n          matB.setTRS(depthOffset, this.getLocalRotation(), this.getLocalScale());\n          matC.setTranslate(pivotOffset.x, pivotOffset.y, pivotOffset.z);\n          element._screenTransform.mul2(element._parentWorldTransform, matC).mul(matB).mul(matA);\n          element._cornersDirty = true;\n          element._canvasCornersDirty = true;\n          element._worldCornersDirty = true;\n        } else {\n          this.worldTransform.copy(element._modelTransform);\n        }\n      }\n      this._dirtyWorld = false;\n    }\n  }\n  _onInsert(parent) {\n    const result = this._parseUpToScreen();\n    this.entity._dirtifyWorld();\n    this._updateScreen(result.screen);\n    this._dirtifyMask();\n  }\n  _dirtifyMask() {\n    let current = this.entity;\n    while (current) {\n      const next = current.parent;\n      if ((next === null || next.screen) && current.element) {\n        if (!this.system._prerender || !this.system._prerender.length) {\n          this.system._prerender = [];\n          this.system.app.once('prerender', this._onPrerender, this);\n        }\n        const i = this.system._prerender.indexOf(this.entity);\n        if (i >= 0) {\n          this.system._prerender.splice(i, 1);\n        }\n        const j = this.system._prerender.indexOf(current);\n        if (j < 0) {\n          this.system._prerender.push(current);\n        }\n      }\n      current = next;\n    }\n  }\n  _onPrerender() {\n    for (let i = 0; i < this.system._prerender.length; i++) {\n      const mask = this.system._prerender[i];\n      if (mask.element) {\n        const depth = 1;\n        mask.element.syncMask(depth);\n      }\n    }\n    this.system._prerender.length = 0;\n  }\n  _bindScreen(screen) {\n    screen._bindElement(this);\n  }\n  _unbindScreen(screen) {\n    screen._unbindElement(this);\n  }\n  _updateScreen(screen) {\n    if (this.screen && this.screen !== screen) {\n      this._unbindScreen(this.screen.screen);\n    }\n    const previousScreen = this.screen;\n    this.screen = screen;\n    if (this.screen) {\n      this._bindScreen(this.screen.screen);\n    }\n    this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);\n    this.fire('set:screen', this.screen, previousScreen);\n    this._anchorDirty = true;\n    const children = this.entity.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      if (children[i].element) children[i].element._updateScreen(screen);\n    }\n    if (this.screen) this.screen.screen.syncDrawOrder();\n  }\n  syncMask(depth) {\n    const result = this._parseUpToScreen();\n    this._updateMask(result.mask, depth);\n  }\n  _setMaskedBy(mask) {\n    const renderableElement = this._image || this._text;\n    if (mask) {\n      const ref = mask.element._image._maskRef;\n      const sp = new _scene_stencil_parameters_js__WEBPACK_IMPORTED_MODULE_11__.StencilParameters({\n        ref: ref,\n        func: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_12__.FUNC_EQUAL\n      });\n      if (renderableElement && renderableElement._setStencil) {\n        renderableElement._setStencil(sp);\n      }\n      this._maskedBy = mask;\n    } else {\n      if (renderableElement && renderableElement._setStencil) {\n        renderableElement._setStencil(null);\n      }\n      this._maskedBy = null;\n    }\n  }\n  _updateMask(currentMask, depth) {\n    if (currentMask) {\n      this._setMaskedBy(currentMask);\n      if (this.mask) {\n        const ref = currentMask.element._image._maskRef;\n        const sp = new _scene_stencil_parameters_js__WEBPACK_IMPORTED_MODULE_11__.StencilParameters({\n          ref: ref,\n          func: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_12__.FUNC_EQUAL,\n          zpass: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_12__.STENCILOP_INCREMENT\n        });\n        this._image._setStencil(sp);\n        this._image._maskRef = depth;\n        depth++;\n        currentMask = this.entity;\n      }\n      const children = this.entity.children;\n      for (let i = 0, l = children.length; i < l; i++) {\n        if (children[i].element) {\n          children[i].element._updateMask(currentMask, depth);\n        }\n      }\n      if (this.mask) depth--;\n    } else {\n      this._setMaskedBy(null);\n      if (this.mask) {\n        const sp = new _scene_stencil_parameters_js__WEBPACK_IMPORTED_MODULE_11__.StencilParameters({\n          ref: depth,\n          func: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_12__.FUNC_ALWAYS,\n          zpass: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_12__.STENCILOP_REPLACE\n        });\n        this._image._setStencil(sp);\n        this._image._maskRef = depth;\n        depth++;\n        currentMask = this.entity;\n      }\n      const children = this.entity.children;\n      for (let i = 0, l = children.length; i < l; i++) {\n        if (children[i].element) {\n          children[i].element._updateMask(currentMask, depth);\n        }\n      }\n      if (this.mask) depth--;\n    }\n  }\n  _parseUpToScreen() {\n    const result = {\n      screen: null,\n      mask: null\n    };\n    let parent = this.entity._parent;\n    while (parent && !parent.screen) {\n      if (parent.element && parent.element.mask) {\n        if (!result.mask) result.mask = parent;\n      }\n      parent = parent.parent;\n    }\n    if (parent && parent.screen) result.screen = parent;\n    return result;\n  }\n  _onScreenResize(res) {\n    this._anchorDirty = true;\n    this._cornersDirty = true;\n    this._worldCornersDirty = true;\n    this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);\n    this.fire('screen:set:resolution', res);\n  }\n  _onScreenSpaceChange() {\n    this.fire('screen:set:screenspace', this.screen.screen.screenSpace);\n  }\n  _onScreenRemove() {\n    if (this.screen) {\n      if (this.screen._destroying) {\n        this.screen = null;\n      } else {\n        this._updateScreen(null);\n      }\n    }\n  }\n  _calculateLocalAnchors() {\n    let resx = 1000;\n    let resy = 1000;\n    const parent = this.entity._parent;\n    if (parent && parent.element) {\n      resx = parent.element.calculatedWidth;\n      resy = parent.element.calculatedHeight;\n    } else if (this.screen) {\n      const res = this.screen.screen.resolution;\n      const scale = this.screen.screen.scale;\n      resx = res.x / scale;\n      resy = res.y / scale;\n    }\n    this._localAnchor.set(this._anchor.x * resx, this._anchor.y * resy, this._anchor.z * resx, this._anchor.w * resy);\n  }\n  getOffsetPosition(x, y) {\n    const p = this.entity.getLocalPosition().clone();\n    p.x += x;\n    p.y += y;\n    this._screenToWorld.transformPoint(p, p);\n    return p;\n  }\n  onLayersChanged(oldComp, newComp) {\n    this.addModelToLayers(this._image ? this._image._renderable.model : this._text._model);\n    oldComp.off('add', this.onLayerAdded, this);\n    oldComp.off('remove', this.onLayerRemoved, this);\n    newComp.on('add', this.onLayerAdded, this);\n    newComp.on('remove', this.onLayerRemoved, this);\n  }\n  onLayerAdded(layer) {\n    const index = this.layers.indexOf(layer.id);\n    if (index < 0) return;\n    if (this._image) {\n      layer.addMeshInstances(this._image._renderable.model.meshInstances);\n    } else if (this._text) {\n      layer.addMeshInstances(this._text._model.meshInstances);\n    }\n  }\n  onLayerRemoved(layer) {\n    const index = this.layers.indexOf(layer.id);\n    if (index < 0) return;\n    if (this._image) {\n      layer.removeMeshInstances(this._image._renderable.model.meshInstances);\n    } else if (this._text) {\n      layer.removeMeshInstances(this._text._model.meshInstances);\n    }\n  }\n  onEnable() {\n    if (this._image) this._image.onEnable();\n    if (this._text) this._text.onEnable();\n    if (this._group) this._group.onEnable();\n    if (this.useInput && this.system.app.elementInput) {\n      this.system.app.elementInput.addElement(this);\n    }\n    this.system.app.scene.on('set:layers', this.onLayersChanged, this);\n    if (this.system.app.scene.layers) {\n      this.system.app.scene.layers.on('add', this.onLayerAdded, this);\n      this.system.app.scene.layers.on('remove', this.onLayerRemoved, this);\n    }\n    if (this._batchGroupId >= 0) {\n      var _this$system$app$batc3;\n      (_this$system$app$batc3 = this.system.app.batcher) == null ? void 0 : _this$system$app$batc3.insert(_scene_batching_batch_group_js__WEBPACK_IMPORTED_MODULE_7__.BatchGroup.ELEMENT, this.batchGroupId, this.entity);\n    }\n    this.fire('enableelement');\n  }\n  onDisable() {\n    this.system.app.scene.off('set:layers', this.onLayersChanged, this);\n    if (this.system.app.scene.layers) {\n      this.system.app.scene.layers.off('add', this.onLayerAdded, this);\n      this.system.app.scene.layers.off('remove', this.onLayerRemoved, this);\n    }\n    if (this._image) this._image.onDisable();\n    if (this._text) this._text.onDisable();\n    if (this._group) this._group.onDisable();\n    if (this.system.app.elementInput && this.useInput) {\n      this.system.app.elementInput.removeElement(this);\n    }\n    if (this._batchGroupId >= 0) {\n      var _this$system$app$batc4;\n      (_this$system$app$batc4 = this.system.app.batcher) == null ? void 0 : _this$system$app$batc4.remove(_scene_batching_batch_group_js__WEBPACK_IMPORTED_MODULE_7__.BatchGroup.ELEMENT, this.batchGroupId, this.entity);\n    }\n    this.fire('disableelement');\n  }\n  onRemove() {\n    this.entity.off('insert', this._onInsert, this);\n    this._unpatch();\n    if (this._image) this._image.destroy();\n    if (this._text) this._text.destroy();\n    if (this.system.app.elementInput && this.useInput) {\n      this.system.app.elementInput.removeElement(this);\n    }\n    if (this.screen && this.screen.screen) {\n      this._unbindScreen(this.screen.screen);\n      this.screen.screen.syncDrawOrder();\n    }\n    this.off();\n  }\n  _calculateSize(propagateCalculatedWidth, propagateCalculatedHeight) {\n    if (!this.entity._parent && !this.screen) return;\n    this._calculateLocalAnchors();\n    const newWidth = this._absRight - this._absLeft;\n    const newHeight = this._absTop - this._absBottom;\n    if (propagateCalculatedWidth) {\n      this._setWidth(newWidth);\n    } else {\n      this._setCalculatedWidth(newWidth, false);\n    }\n    if (propagateCalculatedHeight) {\n      this._setHeight(newHeight);\n    } else {\n      this._setCalculatedHeight(newHeight, false);\n    }\n    const p = this.entity.getLocalPosition();\n    p.x = this._margin.x + this._calculatedWidth * this._pivot.x;\n    p.y = this._margin.y + this._calculatedHeight * this._pivot.y;\n    this.entity.setLocalPosition(p);\n    this._sizeDirty = false;\n  }\n  _setWidth(w) {\n    this._width = w;\n    this._setCalculatedWidth(w, false);\n    this.fire('set:width', this._width);\n  }\n  _setHeight(h) {\n    this._height = h;\n    this._setCalculatedHeight(h, false);\n    this.fire('set:height', this._height);\n  }\n  _setCalculatedWidth(value, updateMargins) {\n    if (Math.abs(value - this._calculatedWidth) <= 1e-4) return;\n    this._calculatedWidth = value;\n    this.entity._dirtifyLocal();\n    if (updateMargins) {\n      const p = this.entity.getLocalPosition();\n      const pvt = this._pivot;\n      this._margin.x = p.x - this._calculatedWidth * pvt.x;\n      this._margin.z = this._localAnchor.z - this._localAnchor.x - this._calculatedWidth - this._margin.x;\n    }\n    this._flagChildrenAsDirty();\n    this.fire('set:calculatedWidth', this._calculatedWidth);\n    this.fire('resize', this._calculatedWidth, this._calculatedHeight);\n  }\n  _setCalculatedHeight(value, updateMargins) {\n    if (Math.abs(value - this._calculatedHeight) <= 1e-4) return;\n    this._calculatedHeight = value;\n    this.entity._dirtifyLocal();\n    if (updateMargins) {\n      const p = this.entity.getLocalPosition();\n      const pvt = this._pivot;\n      this._margin.y = p.y - this._calculatedHeight * pvt.y;\n      this._margin.w = this._localAnchor.w - this._localAnchor.y - this._calculatedHeight - this._margin.y;\n    }\n    this._flagChildrenAsDirty();\n    this.fire('set:calculatedHeight', this._calculatedHeight);\n    this.fire('resize', this._calculatedWidth, this._calculatedHeight);\n  }\n  _flagChildrenAsDirty() {\n    const c = this.entity._children;\n    for (let i = 0, l = c.length; i < l; i++) {\n      if (c[i].element) {\n        c[i].element._anchorDirty = true;\n        c[i].element._sizeDirty = true;\n      }\n    }\n  }\n  addModelToLayers(model) {\n    this._addedModels.push(model);\n    for (let i = 0; i < this.layers.length; i++) {\n      const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n      if (!layer) continue;\n      layer.addMeshInstances(model.meshInstances);\n    }\n  }\n  removeModelFromLayers(model) {\n    const idx = this._addedModels.indexOf(model);\n    if (idx >= 0) {\n      this._addedModels.splice(idx, 1);\n    }\n    for (let i = 0; i < this.layers.length; i++) {\n      const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n      if (!layer) continue;\n      layer.removeMeshInstances(model.meshInstances);\n    }\n  }\n  getMaskOffset() {\n    const frame = this.system.app.frame;\n    if (this._offsetReadAt !== frame) {\n      this._maskOffset = 0.5;\n      this._offsetReadAt = frame;\n    }\n    const mo = this._maskOffset;\n    this._maskOffset -= 0.001;\n    return mo;\n  }\n  isVisibleForCamera(camera) {\n    let clipL, clipR, clipT, clipB;\n    if (this.maskedBy) {\n      const corners = this.maskedBy.element.screenCorners;\n      clipL = Math.min(Math.min(corners[0].x, corners[1].x), Math.min(corners[2].x, corners[3].x));\n      clipR = Math.max(Math.max(corners[0].x, corners[1].x), Math.max(corners[2].x, corners[3].x));\n      clipB = Math.min(Math.min(corners[0].y, corners[1].y), Math.min(corners[2].y, corners[3].y));\n      clipT = Math.max(Math.max(corners[0].y, corners[1].y), Math.max(corners[2].y, corners[3].y));\n    } else {\n      const sw = this.system.app.graphicsDevice.width;\n      const sh = this.system.app.graphicsDevice.height;\n      const cameraWidth = camera._rect.z * sw;\n      const cameraHeight = camera._rect.w * sh;\n      clipL = camera._rect.x * sw;\n      clipR = clipL + cameraWidth;\n      clipT = (1 - camera._rect.y) * sh;\n      clipB = clipT - cameraHeight;\n    }\n    const hitCorners = this.screenCorners;\n    const left = Math.min(Math.min(hitCorners[0].x, hitCorners[1].x), Math.min(hitCorners[2].x, hitCorners[3].x));\n    const right = Math.max(Math.max(hitCorners[0].x, hitCorners[1].x), Math.max(hitCorners[2].x, hitCorners[3].x));\n    const bottom = Math.min(Math.min(hitCorners[0].y, hitCorners[1].y), Math.min(hitCorners[2].y, hitCorners[3].y));\n    const top = Math.max(Math.max(hitCorners[0].y, hitCorners[1].y), Math.max(hitCorners[2].y, hitCorners[3].y));\n    if (right < clipL || left > clipR || bottom > clipT || top < clipB) {\n      return false;\n    }\n    return true;\n  }\n  _isScreenSpace() {\n    if (this.screen && this.screen.screen) {\n      return this.screen.screen.screenSpace;\n    }\n    return false;\n  }\n  _isScreenCulled() {\n    if (this.screen && this.screen.screen) {\n      return this.screen.screen.cull;\n    }\n    return false;\n  }\n  _dirtyBatch() {\n    if (this.batchGroupId !== -1) {\n      var _this$system$app$batc5;\n      (_this$system$app$batc5 = this.system.app.batcher) == null ? void 0 : _this$system$app$batc5.markGroupDirty(this.batchGroupId);\n    }\n  }\n}\nfunction _define(name) {\n  Object.defineProperty(ElementComponent.prototype, name, {\n    get: function () {\n      if (this._text) {\n        return this._text[name];\n      } else if (this._image) {\n        return this._image[name];\n      }\n      return null;\n    },\n    set: function (value) {\n      if (this._text) {\n        if (this._text[name] !== value) {\n          this._dirtyBatch();\n        }\n        this._text[name] = value;\n      } else if (this._image) {\n        if (this._image[name] !== value) {\n          this._dirtyBatch();\n        }\n        this._image[name] = value;\n      }\n    }\n  });\n}\n_define('fontSize');\n_define('minFontSize');\n_define('maxFontSize');\n_define('maxLines');\n_define('autoFitWidth');\n_define('autoFitHeight');\n_define('color');\n_define('font');\n_define('fontAsset');\n_define('spacing');\n_define('lineHeight');\n_define('wrapLines');\n_define('lines');\n_define('alignment');\n_define('autoWidth');\n_define('autoHeight');\n_define('rtlReorder');\n_define('unicodeConverter');\n_define('text');\n_define('key');\n_define('texture');\n_define('textureAsset');\n_define('material');\n_define('materialAsset');\n_define('sprite');\n_define('spriteAsset');\n_define('spriteFrame');\n_define('pixelsPerUnit');\n_define('opacity');\n_define('rect');\n_define('mask');\n_define('outlineColor');\n_define('outlineThickness');\n_define('shadowColor');\n_define('shadowOffset');\n_define('enableMarkup');\n_define('rangeStart');\n_define('rangeEnd');\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/component.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/constants.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/constants.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ELEMENTTYPE_GROUP\": () => (/* binding */ ELEMENTTYPE_GROUP),\n/* harmony export */   \"ELEMENTTYPE_IMAGE\": () => (/* binding */ ELEMENTTYPE_IMAGE),\n/* harmony export */   \"ELEMENTTYPE_TEXT\": () => (/* binding */ ELEMENTTYPE_TEXT),\n/* harmony export */   \"FITMODE_CONTAIN\": () => (/* binding */ FITMODE_CONTAIN),\n/* harmony export */   \"FITMODE_COVER\": () => (/* binding */ FITMODE_COVER),\n/* harmony export */   \"FITMODE_STRETCH\": () => (/* binding */ FITMODE_STRETCH)\n/* harmony export */ });\nconst ELEMENTTYPE_GROUP = 'group';\nconst ELEMENTTYPE_IMAGE = 'image';\nconst ELEMENTTYPE_TEXT = 'text';\nconst FITMODE_STRETCH = 'stretch';\nconst FITMODE_CONTAIN = 'contain';\nconst FITMODE_COVER = 'cover';\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/constants.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/data.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/data.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ElementComponentData\": () => (/* binding */ ElementComponentData)\n/* harmony export */ });\nclass ElementComponentData {\n  constructor() {\n    this.enabled = true;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/data.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/element-drag-helper.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/element-drag-helper.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ElementDragHelper\": () => (/* binding */ ElementDragHelper)\n/* harmony export */ });\n/* harmony import */ var _core_platform_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../core/platform.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/platform.js\");\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _core_math_quat_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/math/quat.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/quat.js\");\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/component.js\");\n/* harmony import */ var _core_shape_ray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/shape/ray.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/shape/ray.js\");\n/* harmony import */ var _core_shape_plane_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/shape/plane.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/shape/plane.js\");\n\n\n\n\n\n\n\n\n\nconst _inputScreenPosition = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_0__.Vec2();\nconst _inputWorldPosition = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst _ray = new _core_shape_ray_js__WEBPACK_IMPORTED_MODULE_2__.Ray();\nconst _plane = new _core_shape_plane_js__WEBPACK_IMPORTED_MODULE_3__.Plane();\nconst _entityRotation = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_4__.Quat();\nconst OPPOSITE_AXIS = {\n  x: 'y',\n  y: 'x'\n};\nclass ElementDragHelper extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_5__.EventHandler {\n  constructor(element, axis) {\n    super();\n    if (!element || !(element instanceof _component_js__WEBPACK_IMPORTED_MODULE_6__.ElementComponent)) {\n      throw new Error('Element was null or not an ElementComponent');\n    }\n    if (axis && axis !== 'x' && axis !== 'y') {\n      throw new Error('Unrecognized axis: ' + axis);\n    }\n    this._element = element;\n    this._app = element.system.app;\n    this._axis = axis || null;\n    this._enabled = true;\n    this._dragScale = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n    this._dragStartMousePosition = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n    this._dragStartHandlePosition = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n    this._deltaMousePosition = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n    this._deltaHandlePosition = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n    this._isDragging = false;\n    this._toggleLifecycleListeners('on');\n  }\n  _toggleLifecycleListeners(onOrOff) {\n    this._element[onOrOff]('mousedown', this._onMouseDownOrTouchStart, this);\n    this._element[onOrOff]('touchstart', this._onMouseDownOrTouchStart, this);\n  }\n  _toggleDragListeners(onOrOff) {\n    const isOn = onOrOff === 'on';\n    if (this._hasDragListeners && isOn) {\n      return;\n    }\n    if (this._app.mouse) {\n      this._element[onOrOff]('mousemove', this._onMove, this);\n      this._element[onOrOff]('mouseup', this._onMouseUpOrTouchEnd, this);\n    }\n    if (_core_platform_js__WEBPACK_IMPORTED_MODULE_7__.platform.touch) {\n      this._element[onOrOff]('touchmove', this._onMove, this);\n      this._element[onOrOff]('touchend', this._onMouseUpOrTouchEnd, this);\n      this._element[onOrOff]('touchcancel', this._onMouseUpOrTouchEnd, this);\n    }\n    this._hasDragListeners = isOn;\n  }\n  _onMouseDownOrTouchStart(event) {\n    if (this._element && !this._isDragging && this.enabled) {\n      this._dragCamera = event.camera;\n      this._calculateDragScale();\n      const currentMousePosition = this._screenToLocal(event);\n      if (currentMousePosition) {\n        this._toggleDragListeners('on');\n        this._isDragging = true;\n        this._dragStartMousePosition.copy(currentMousePosition);\n        this._dragStartHandlePosition.copy(this._element.entity.getLocalPosition());\n        this.fire('drag:start');\n      }\n    }\n  }\n  _onMouseUpOrTouchEnd() {\n    if (this._isDragging) {\n      this._isDragging = false;\n      this._toggleDragListeners('off');\n      this.fire('drag:end');\n    }\n  }\n  _screenToLocal(event) {\n    this._determineInputPosition(event);\n    this._chooseRayOriginAndDirection();\n    _plane.point.copy(this._element.entity.getPosition());\n    _plane.normal.copy(this._element.entity.forward).mulScalar(-1);\n    const denominator = _plane.normal.dot(_ray.direction);\n    if (Math.abs(denominator) > 0) {\n      const rayOriginToPlaneOrigin = _plane.point.sub(_ray.origin);\n      const collisionDistance = rayOriginToPlaneOrigin.dot(_plane.normal) / denominator;\n      const position = _ray.origin.add(_ray.direction.mulScalar(collisionDistance));\n      _entityRotation.copy(this._element.entity.getRotation()).invert().transformVector(position, position);\n      position.mul(this._dragScale);\n      return position;\n    }\n    return null;\n  }\n  _determineInputPosition(event) {\n    const devicePixelRatio = this._app.graphicsDevice.maxPixelRatio;\n    if (typeof event.x !== 'undefined' && typeof event.y !== 'undefined') {\n      _inputScreenPosition.x = event.x * devicePixelRatio;\n      _inputScreenPosition.y = event.y * devicePixelRatio;\n    } else if (event.changedTouches) {\n      _inputScreenPosition.x = event.changedTouches[0].x * devicePixelRatio;\n      _inputScreenPosition.y = event.changedTouches[0].y * devicePixelRatio;\n    } else {\n      console.warn('Could not determine position from input event');\n    }\n  }\n  _chooseRayOriginAndDirection() {\n    if (this._element.screen && this._element.screen.screen.screenSpace) {\n      _ray.origin.set(_inputScreenPosition.x, -_inputScreenPosition.y, 0);\n      _ray.direction.copy(_core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3.FORWARD);\n    } else {\n      _inputWorldPosition.copy(this._dragCamera.screenToWorld(_inputScreenPosition.x, _inputScreenPosition.y, 1));\n      _ray.origin.copy(this._dragCamera.entity.getPosition());\n      _ray.direction.copy(_inputWorldPosition).sub(_ray.origin).normalize();\n    }\n  }\n  _calculateDragScale() {\n    let current = this._element.entity.parent;\n    const screen = this._element.screen && this._element.screen.screen;\n    const isWithin2DScreen = screen && screen.screenSpace;\n    const screenScale = isWithin2DScreen ? screen.scale : 1;\n    const dragScale = this._dragScale;\n    dragScale.set(screenScale, screenScale, screenScale);\n    while (current) {\n      dragScale.mul(current.getLocalScale());\n      current = current.parent;\n      if (isWithin2DScreen && current.screen) {\n        break;\n      }\n    }\n    dragScale.x = 1 / dragScale.x;\n    dragScale.y = 1 / dragScale.y;\n    dragScale.z = 0;\n  }\n  _onMove(event) {\n    const {\n      _element: element,\n      _deltaMousePosition: deltaMousePosition,\n      _deltaHandlePosition: deltaHandlePosition,\n      _axis: axis\n    } = this;\n    if (element && this._isDragging && this.enabled && element.enabled && element.entity.enabled) {\n      const currentMousePosition = this._screenToLocal(event);\n      if (currentMousePosition) {\n        deltaMousePosition.sub2(currentMousePosition, this._dragStartMousePosition);\n        deltaHandlePosition.add2(this._dragStartHandlePosition, deltaMousePosition);\n        if (axis) {\n          const currentPosition = element.entity.getLocalPosition();\n          const constrainedAxis = OPPOSITE_AXIS[axis];\n          deltaHandlePosition[constrainedAxis] = currentPosition[constrainedAxis];\n        }\n        element.entity.setLocalPosition(deltaHandlePosition);\n        this.fire('drag:move', deltaHandlePosition);\n      }\n    }\n  }\n  destroy() {\n    this._toggleLifecycleListeners('off');\n    this._toggleDragListeners('off');\n  }\n  set enabled(value) {\n    this._enabled = value;\n  }\n  get enabled() {\n    return this._enabled;\n  }\n  get isDragging() {\n    return this._isDragging;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/element-drag-helper.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/image-element.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/image-element.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ImageElement\": () => (/* binding */ ImageElement)\n/* harmony export */ });\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _core_math_color_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/math/color.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/math/vec4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec4.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_vertex_buffer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../platform/graphics/vertex-buffer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/vertex-buffer.js\");\n/* harmony import */ var _platform_graphics_vertex_format_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../platform/graphics/vertex-format.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/vertex-format.js\");\n/* harmony import */ var _scene_constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../scene/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _scene_graph_node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../scene/graph-node.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/graph-node.js\");\n/* harmony import */ var _scene_mesh_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../scene/mesh.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh.js\");\n/* harmony import */ var _scene_mesh_instance_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../scene/mesh-instance.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh-instance.js\");\n/* harmony import */ var _scene_model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../scene/model.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/model.js\");\n/* harmony import */ var _scene_stencil_parameters_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../../scene/stencil-parameters.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/stencil-parameters.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/constants.js\");\n/* harmony import */ var _asset_asset_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../asset/asset.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass ImageRenderable {\n  constructor(entity, mesh, material) {\n    this._entity = entity;\n    this._element = entity.element;\n    this.model = new _scene_model_js__WEBPACK_IMPORTED_MODULE_0__.Model();\n    this.node = new _scene_graph_node_js__WEBPACK_IMPORTED_MODULE_1__.GraphNode();\n    this.model.graph = this.node;\n    this.mesh = mesh;\n    this.meshInstance = new _scene_mesh_instance_js__WEBPACK_IMPORTED_MODULE_2__.MeshInstance(this.mesh, material, this.node);\n    this.meshInstance.name = 'ImageElement: ' + entity.name;\n    this.meshInstance.castShadow = false;\n    this.meshInstance.receiveShadow = false;\n    this._meshDirty = false;\n    this.model.meshInstances.push(this.meshInstance);\n    this._entity.addChild(this.model.graph);\n    this.model._entity = this._entity;\n    this.unmaskMeshInstance = null;\n  }\n  destroy() {\n    this.setMaterial(null);\n    this._element.removeModelFromLayers(this.model);\n    this.model.destroy();\n    this.model = null;\n    this.node = null;\n    this.mesh = null;\n    this.meshInstance = null;\n    this._entity = null;\n    this._element = null;\n  }\n  setMesh(mesh) {\n    if (!this.meshInstance) return;\n    this.mesh = mesh;\n    this.meshInstance.mesh = mesh;\n    this.meshInstance.visible = !!mesh;\n    if (this.unmaskMeshInstance) {\n      this.unmaskMeshInstance.mesh = mesh;\n    }\n    this.forceUpdateAabb();\n  }\n  setMask(mask) {\n    if (!this.meshInstance) return;\n    if (mask) {\n      this.unmaskMeshInstance = new _scene_mesh_instance_js__WEBPACK_IMPORTED_MODULE_2__.MeshInstance(this.mesh, this.meshInstance.material, this.node);\n      this.unmaskMeshInstance.name = 'Unmask: ' + this._entity.name;\n      this.unmaskMeshInstance.castShadow = false;\n      this.unmaskMeshInstance.receiveShadow = false;\n      this.unmaskMeshInstance.pick = false;\n      this.model.meshInstances.push(this.unmaskMeshInstance);\n      for (const name in this.meshInstance.parameters) {\n        this.unmaskMeshInstance.setParameter(name, this.meshInstance.parameters[name].data);\n      }\n    } else {\n      const idx = this.model.meshInstances.indexOf(this.unmaskMeshInstance);\n      if (idx >= 0) {\n        this.model.meshInstances.splice(idx, 1);\n      }\n      this.unmaskMeshInstance = null;\n    }\n    if (this._entity.enabled && this._element.enabled) {\n      this._element.removeModelFromLayers(this.model);\n      this._element.addModelToLayers(this.model);\n    }\n  }\n  setMaterial(material) {\n    if (!this.meshInstance) return;\n    this.meshInstance.material = material;\n    if (this.unmaskMeshInstance) {\n      this.unmaskMeshInstance.material = material;\n    }\n  }\n  setParameter(name, value) {\n    if (!this.meshInstance) return;\n    this.meshInstance.setParameter(name, value);\n    if (this.unmaskMeshInstance) {\n      this.unmaskMeshInstance.setParameter(name, value);\n    }\n  }\n  deleteParameter(name) {\n    if (!this.meshInstance) return;\n    this.meshInstance.deleteParameter(name);\n    if (this.unmaskMeshInstance) {\n      this.unmaskMeshInstance.deleteParameter(name);\n    }\n  }\n  setUnmaskDrawOrder() {\n    if (!this.meshInstance) return;\n    const getLastChild = function getLastChild(e) {\n      let last;\n      const c = e.children;\n      const l = c.length;\n      if (l) {\n        for (let i = 0; i < l; i++) {\n          if (c[i].element) {\n            last = c[i];\n          }\n        }\n        if (!last) return null;\n        const child = getLastChild(last);\n        if (child) {\n          return child;\n        }\n        return last;\n      }\n      return null;\n    };\n    if (this.unmaskMeshInstance) {\n      const lastChild = getLastChild(this._entity);\n      if (lastChild && lastChild.element) {\n        this.unmaskMeshInstance.drawOrder = lastChild.element.drawOrder + lastChild.element.getMaskOffset();\n      } else {\n        this.unmaskMeshInstance.drawOrder = this.meshInstance.drawOrder + this._element.getMaskOffset();\n      }\n    }\n  }\n  setDrawOrder(drawOrder) {\n    if (!this.meshInstance) return;\n    this.meshInstance.drawOrder = drawOrder;\n  }\n  setCull(cull) {\n    if (!this.meshInstance) return;\n    const element = this._element;\n    let visibleFn = null;\n    if (cull && element._isScreenSpace()) {\n      visibleFn = function (camera) {\n        return element.isVisibleForCamera(camera);\n      };\n    }\n    this.meshInstance.cull = cull;\n    this.meshInstance.isVisibleFunc = visibleFn;\n    if (this.unmaskMeshInstance) {\n      this.unmaskMeshInstance.cull = cull;\n      this.unmaskMeshInstance.isVisibleFunc = visibleFn;\n    }\n  }\n  setScreenSpace(screenSpace) {\n    if (!this.meshInstance) return;\n    this.meshInstance.screenSpace = screenSpace;\n    if (this.unmaskMeshInstance) {\n      this.unmaskMeshInstance.screenSpace = screenSpace;\n    }\n  }\n  setLayer(layer) {\n    if (!this.meshInstance) return;\n    this.meshInstance.layer = layer;\n    if (this.unmaskMeshInstance) {\n      this.unmaskMeshInstance.layer = layer;\n    }\n  }\n  forceUpdateAabb(mask) {\n    if (!this.meshInstance) return;\n    this.meshInstance._aabbVer = -1;\n    if (this.unmaskMeshInstance) {\n      this.unmaskMeshInstance._aabbVer = -1;\n    }\n  }\n  setAabbFunc(fn) {\n    if (!this.meshInstance) return;\n    this.meshInstance._updateAabbFunc = fn;\n    if (this.unmaskMeshInstance) {\n      this.unmaskMeshInstance._updateAabbFunc = fn;\n    }\n  }\n}\nclass ImageElement {\n  constructor(element) {\n    this._element = element;\n    this._entity = element.entity;\n    this._system = element.system;\n    this._textureAsset = null;\n    this._texture = null;\n    this._materialAsset = null;\n    this._material = null;\n    this._spriteAsset = null;\n    this._sprite = null;\n    this._spriteFrame = 0;\n    this._pixelsPerUnit = null;\n    this._targetAspectRatio = -1;\n    this._rect = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_3__.Vec4(0, 0, 1, 1);\n    this._mask = false;\n    this._maskRef = 0;\n    this._outerScale = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_4__.Vec2();\n    this._outerScaleUniform = new Float32Array(2);\n    this._innerOffset = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_3__.Vec4();\n    this._innerOffsetUniform = new Float32Array(4);\n    this._atlasRect = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_3__.Vec4();\n    this._atlasRectUniform = new Float32Array(4);\n    this._defaultMesh = this._createMesh();\n    this._renderable = new ImageRenderable(this._entity, this._defaultMesh, this._material);\n    this._color = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_5__.Color(1, 1, 1, 1);\n    this._colorUniform = new Float32Array([1, 1, 1]);\n    this._renderable.setParameter('material_emissive', this._colorUniform);\n    this._renderable.setParameter('material_opacity', 1);\n    this._updateAabbFunc = this._updateAabb.bind(this);\n    this._onScreenChange(this._element.screen);\n    this._element.on('resize', this._onParentResizeOrPivotChange, this);\n    this._element.on('set:pivot', this._onParentResizeOrPivotChange, this);\n    this._element.on('screen:set:screenspace', this._onScreenSpaceChange, this);\n    this._element.on('set:screen', this._onScreenChange, this);\n    this._element.on('set:draworder', this._onDrawOrderChange, this);\n    this._element.on('screen:set:resolution', this._onResolutionChange, this);\n  }\n  destroy() {\n    this.textureAsset = null;\n    this.spriteAsset = null;\n    this.materialAsset = null;\n    this._renderable.setMesh(this._defaultMesh);\n    this._renderable.destroy();\n    this._defaultMesh = null;\n    this._element.off('resize', this._onParentResizeOrPivotChange, this);\n    this._element.off('set:pivot', this._onParentResizeOrPivotChange, this);\n    this._element.off('screen:set:screenspace', this._onScreenSpaceChange, this);\n    this._element.off('set:screen', this._onScreenChange, this);\n    this._element.off('set:draworder', this._onDrawOrderChange, this);\n    this._element.off('screen:set:resolution', this._onResolutionChange, this);\n  }\n  _onResolutionChange(res) {}\n  _onParentResizeOrPivotChange() {\n    if (this._renderable.mesh) {\n      this._updateMesh(this._renderable.mesh);\n    }\n  }\n  _onScreenSpaceChange(value) {\n    this._updateMaterial(value);\n  }\n  _onScreenChange(screen, previous) {\n    if (screen) {\n      this._updateMaterial(screen.screen.screenSpace);\n    } else {\n      this._updateMaterial(false);\n    }\n  }\n  _onDrawOrderChange(order) {\n    this._renderable.setDrawOrder(order);\n    if (this.mask && this._element.screen) {\n      this._element.screen.screen.once('syncdraworder', function () {\n        this._renderable.setUnmaskDrawOrder();\n      }, this);\n    }\n  }\n  _hasUserMaterial() {\n    return !!this._materialAsset || !!this._material && this._system.defaultImageMaterials.indexOf(this._material) === -1;\n  }\n  _use9Slicing() {\n    return this.sprite && (this.sprite.renderMode === _scene_constants_js__WEBPACK_IMPORTED_MODULE_6__.SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === _scene_constants_js__WEBPACK_IMPORTED_MODULE_6__.SPRITE_RENDERMODE_TILED);\n  }\n  _updateMaterial(screenSpace) {\n    const mask = !!this._mask;\n    const nineSliced = !!(this.sprite && this.sprite.renderMode === _scene_constants_js__WEBPACK_IMPORTED_MODULE_6__.SPRITE_RENDERMODE_SLICED);\n    const nineTiled = !!(this.sprite && this.sprite.renderMode === _scene_constants_js__WEBPACK_IMPORTED_MODULE_6__.SPRITE_RENDERMODE_TILED);\n    if (!this._hasUserMaterial()) {\n      this._material = this._system.getImageElementMaterial(screenSpace, mask, nineSliced, nineTiled);\n    }\n    if (this._renderable) {\n      this._renderable.setCull(!this._element._isScreenSpace() || this._element._isScreenCulled());\n      this._renderable.setMaterial(this._material);\n      this._renderable.setScreenSpace(screenSpace);\n      this._renderable.setLayer(screenSpace ? _scene_constants_js__WEBPACK_IMPORTED_MODULE_6__.LAYER_HUD : _scene_constants_js__WEBPACK_IMPORTED_MODULE_6__.LAYER_WORLD);\n    }\n  }\n  _createMesh() {\n    const element = this._element;\n    const w = element.calculatedWidth;\n    const h = element.calculatedHeight;\n    const r = this._rect;\n    const vertexData = new ArrayBuffer(4 * 8 * 4);\n    const vertexDataF32 = new Float32Array(vertexData);\n    vertexDataF32[5] = 1;\n    vertexDataF32[6] = r.x;\n    vertexDataF32[7] = 1.0 - r.y;\n    vertexDataF32[8] = w;\n    vertexDataF32[13] = 1;\n    vertexDataF32[14] = r.x + r.z;\n    vertexDataF32[15] = 1.0 - r.y;\n    vertexDataF32[16] = w;\n    vertexDataF32[17] = h;\n    vertexDataF32[21] = 1;\n    vertexDataF32[22] = r.x + r.z;\n    vertexDataF32[23] = 1.0 - (r.y + r.w);\n    vertexDataF32[25] = h;\n    vertexDataF32[29] = 1;\n    vertexDataF32[30] = r.x;\n    vertexDataF32[31] = 1.0 - (r.y + r.w);\n    const vertexDesc = [{\n      semantic: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_7__.SEMANTIC_POSITION,\n      components: 3,\n      type: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_7__.TYPE_FLOAT32\n    }, {\n      semantic: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_7__.SEMANTIC_NORMAL,\n      components: 3,\n      type: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_7__.TYPE_FLOAT32\n    }, {\n      semantic: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_7__.SEMANTIC_TEXCOORD0,\n      components: 2,\n      type: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_7__.TYPE_FLOAT32\n    }];\n    const device = this._system.app.graphicsDevice;\n    const vertexFormat = new _platform_graphics_vertex_format_js__WEBPACK_IMPORTED_MODULE_8__.VertexFormat(device, vertexDesc);\n    const vertexBuffer = new _platform_graphics_vertex_buffer_js__WEBPACK_IMPORTED_MODULE_9__.VertexBuffer(device, vertexFormat, 4, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_7__.BUFFER_STATIC, vertexData);\n    const mesh = new _scene_mesh_js__WEBPACK_IMPORTED_MODULE_10__.Mesh(device);\n    mesh.vertexBuffer = vertexBuffer;\n    mesh.primitive[0].type = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_7__.PRIMITIVE_TRIFAN;\n    mesh.primitive[0].base = 0;\n    mesh.primitive[0].count = 4;\n    mesh.primitive[0].indexed = false;\n    mesh.aabb.setMinMax(_core_math_vec3_js__WEBPACK_IMPORTED_MODULE_11__.Vec3.ZERO, new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_11__.Vec3(w, h, 0));\n    this._updateMesh(mesh);\n    return mesh;\n  }\n  _updateMesh(mesh) {\n    const element = this._element;\n    let w = element.calculatedWidth;\n    let h = element.calculatedHeight;\n    if (element.fitMode !== _constants_js__WEBPACK_IMPORTED_MODULE_12__.FITMODE_STRETCH && this._targetAspectRatio > 0) {\n      const actualRatio = element.calculatedWidth / element.calculatedHeight;\n      if (element.fitMode === _constants_js__WEBPACK_IMPORTED_MODULE_12__.FITMODE_CONTAIN && actualRatio > this._targetAspectRatio || element.fitMode === _constants_js__WEBPACK_IMPORTED_MODULE_12__.FITMODE_COVER && actualRatio < this._targetAspectRatio) {\n        w = element.calculatedHeight * this._targetAspectRatio;\n      } else {\n        h = element.calculatedWidth / this._targetAspectRatio;\n      }\n    }\n    const screenSpace = element._isScreenSpace();\n    this._updateMaterial(screenSpace);\n    if (this._renderable) this._renderable.forceUpdateAabb();\n    if (this.sprite && (this.sprite.renderMode === _scene_constants_js__WEBPACK_IMPORTED_MODULE_6__.SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === _scene_constants_js__WEBPACK_IMPORTED_MODULE_6__.SPRITE_RENDERMODE_TILED)) {\n      const frameData = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];\n      const borderWidthScale = 2 / frameData.rect.z;\n      const borderHeightScale = 2 / frameData.rect.w;\n      this._innerOffset.set(frameData.border.x * borderWidthScale, frameData.border.y * borderHeightScale, frameData.border.z * borderWidthScale, frameData.border.w * borderHeightScale);\n      const tex = this.sprite.atlas.texture;\n      this._atlasRect.set(frameData.rect.x / tex.width, frameData.rect.y / tex.height, frameData.rect.z / tex.width, frameData.rect.w / tex.height);\n      const ppu = this._pixelsPerUnit !== null ? this._pixelsPerUnit : this.sprite.pixelsPerUnit;\n      const scaleMulX = frameData.rect.z / ppu;\n      const scaleMulY = frameData.rect.w / ppu;\n      this._outerScale.set(Math.max(w, this._innerOffset.x * scaleMulX), Math.max(h, this._innerOffset.y * scaleMulY));\n      let scaleX = scaleMulX;\n      let scaleY = scaleMulY;\n      this._outerScale.x /= scaleMulX;\n      this._outerScale.y /= scaleMulY;\n      scaleX *= _core_math_math_js__WEBPACK_IMPORTED_MODULE_13__.math.clamp(w / (this._innerOffset.x * scaleMulX), 0.0001, 1);\n      scaleY *= _core_math_math_js__WEBPACK_IMPORTED_MODULE_13__.math.clamp(h / (this._innerOffset.y * scaleMulY), 0.0001, 1);\n      if (this._renderable) {\n        this._innerOffsetUniform[0] = this._innerOffset.x;\n        this._innerOffsetUniform[1] = this._innerOffset.y;\n        this._innerOffsetUniform[2] = this._innerOffset.z;\n        this._innerOffsetUniform[3] = this._innerOffset.w;\n        this._renderable.setParameter('innerOffset', this._innerOffsetUniform);\n        this._atlasRectUniform[0] = this._atlasRect.x;\n        this._atlasRectUniform[1] = this._atlasRect.y;\n        this._atlasRectUniform[2] = this._atlasRect.z;\n        this._atlasRectUniform[3] = this._atlasRect.w;\n        this._renderable.setParameter('atlasRect', this._atlasRectUniform);\n        this._outerScaleUniform[0] = this._outerScale.x;\n        this._outerScaleUniform[1] = this._outerScale.y;\n        this._renderable.setParameter('outerScale', this._outerScaleUniform);\n        this._renderable.setAabbFunc(this._updateAabbFunc);\n        this._renderable.node.setLocalScale(scaleX, scaleY, 1);\n        this._renderable.node.setLocalPosition((0.5 - element.pivot.x) * w, (0.5 - element.pivot.y) * h, 0);\n      }\n    } else {\n      const vb = mesh.vertexBuffer;\n      const vertexDataF32 = new Float32Array(vb.lock());\n      const hp = element.pivot.x;\n      const vp = element.pivot.y;\n      vertexDataF32[0] = 0 - hp * w;\n      vertexDataF32[1] = 0 - vp * h;\n      vertexDataF32[8] = w - hp * w;\n      vertexDataF32[9] = 0 - vp * h;\n      vertexDataF32[16] = w - hp * w;\n      vertexDataF32[17] = h - vp * h;\n      vertexDataF32[24] = 0 - hp * w;\n      vertexDataF32[25] = h - vp * h;\n      let atlasTextureWidth = 1;\n      let atlasTextureHeight = 1;\n      let rect = this._rect;\n      if (this._sprite && this._sprite.frameKeys[this._spriteFrame] && this._sprite.atlas) {\n        const frame = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];\n        if (frame) {\n          rect = frame.rect;\n          atlasTextureWidth = this._sprite.atlas.texture.width;\n          atlasTextureHeight = this._sprite.atlas.texture.height;\n        }\n      }\n      vertexDataF32[6] = rect.x / atlasTextureWidth;\n      vertexDataF32[7] = 1.0 - rect.y / atlasTextureHeight;\n      vertexDataF32[14] = (rect.x + rect.z) / atlasTextureWidth;\n      vertexDataF32[15] = 1.0 - rect.y / atlasTextureHeight;\n      vertexDataF32[22] = (rect.x + rect.z) / atlasTextureWidth;\n      vertexDataF32[23] = 1.0 - (rect.y + rect.w) / atlasTextureHeight;\n      vertexDataF32[30] = rect.x / atlasTextureWidth;\n      vertexDataF32[31] = 1.0 - (rect.y + rect.w) / atlasTextureHeight;\n      vb.unlock();\n      const min = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_11__.Vec3(0 - hp * w, 0 - vp * h, 0);\n      const max = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_11__.Vec3(w - hp * w, h - vp * h, 0);\n      mesh.aabb.setMinMax(min, max);\n      if (this._renderable) {\n        this._renderable.node.setLocalScale(1, 1, 1);\n        this._renderable.node.setLocalPosition(0, 0, 0);\n        this._renderable.setAabbFunc(null);\n      }\n    }\n    this._meshDirty = false;\n  }\n  _updateSprite() {\n    let nineSlice = false;\n    let mesh = null;\n    this._targetAspectRatio = -1;\n    if (this._sprite && this._sprite.atlas) {\n      mesh = this._sprite.meshes[this.spriteFrame];\n      nineSlice = this._sprite.renderMode === _scene_constants_js__WEBPACK_IMPORTED_MODULE_6__.SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === _scene_constants_js__WEBPACK_IMPORTED_MODULE_6__.SPRITE_RENDERMODE_TILED;\n      const frameData = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];\n      if ((frameData == null ? void 0 : frameData.rect.w) > 0) {\n        this._targetAspectRatio = frameData.rect.z / frameData.rect.w;\n      }\n    }\n    this.mesh = nineSlice ? mesh : this._defaultMesh;\n    this.refreshMesh();\n  }\n  refreshMesh() {\n    if (this.mesh) {\n      if (!this._element._beingInitialized) {\n        this._updateMesh(this.mesh);\n      } else {\n        this._meshDirty = true;\n      }\n    }\n  }\n  _updateAabb(aabb) {\n    aabb.center.set(0, 0, 0);\n    aabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);\n    aabb.setFromTransformedAabb(aabb, this._renderable.node.getWorldTransform());\n    return aabb;\n  }\n  _toggleMask() {\n    this._element._dirtifyMask();\n    const screenSpace = this._element._isScreenSpace();\n    this._updateMaterial(screenSpace);\n    this._renderable.setMask(!!this._mask);\n  }\n  _onMaterialLoad(asset) {\n    this.material = asset.resource;\n  }\n  _onMaterialAdded(asset) {\n    this._system.app.assets.off('add:' + asset.id, this._onMaterialAdded, this);\n    if (this._materialAsset === asset.id) {\n      this._bindMaterialAsset(asset);\n    }\n  }\n  _bindMaterialAsset(asset) {\n    if (!this._entity.enabled) return;\n    asset.on('load', this._onMaterialLoad, this);\n    asset.on('change', this._onMaterialChange, this);\n    asset.on('remove', this._onMaterialRemove, this);\n    if (asset.resource) {\n      this._onMaterialLoad(asset);\n    } else {\n      this._system.app.assets.load(asset);\n    }\n  }\n  _unbindMaterialAsset(asset) {\n    asset.off('load', this._onMaterialLoad, this);\n    asset.off('change', this._onMaterialChange, this);\n    asset.off('remove', this._onMaterialRemove, this);\n  }\n  _onMaterialChange() {}\n  _onMaterialRemove() {}\n  _onTextureAdded(asset) {\n    this._system.app.assets.off('add:' + asset.id, this._onTextureAdded, this);\n    if (this._textureAsset === asset.id) {\n      this._bindTextureAsset(asset);\n    }\n  }\n  _bindTextureAsset(asset) {\n    if (!this._entity.enabled) return;\n    asset.on('load', this._onTextureLoad, this);\n    asset.on('change', this._onTextureChange, this);\n    asset.on('remove', this._onTextureRemove, this);\n    if (asset.resource) {\n      this._onTextureLoad(asset);\n    } else {\n      this._system.app.assets.load(asset);\n    }\n  }\n  _unbindTextureAsset(asset) {\n    asset.off('load', this._onTextureLoad, this);\n    asset.off('change', this._onTextureChange, this);\n    asset.off('remove', this._onTextureRemove, this);\n  }\n  _onTextureLoad(asset) {\n    this.texture = asset.resource;\n  }\n  _onTextureChange(asset) {}\n  _onTextureRemove(asset) {}\n  _onSpriteAssetAdded(asset) {\n    this._system.app.assets.off('add:' + asset.id, this._onSpriteAssetAdded, this);\n    if (this._spriteAsset === asset.id) {\n      this._bindSpriteAsset(asset);\n    }\n  }\n  _bindSpriteAsset(asset) {\n    if (!this._entity.enabled) return;\n    asset.on('load', this._onSpriteAssetLoad, this);\n    asset.on('change', this._onSpriteAssetChange, this);\n    asset.on('remove', this._onSpriteAssetRemove, this);\n    if (asset.resource) {\n      this._onSpriteAssetLoad(asset);\n    } else {\n      this._system.app.assets.load(asset);\n    }\n  }\n  _unbindSpriteAsset(asset) {\n    asset.off('load', this._onSpriteAssetLoad, this);\n    asset.off('change', this._onSpriteAssetChange, this);\n    asset.off('remove', this._onSpriteAssetRemove, this);\n    if (asset.data.textureAtlasAsset) {\n      this._system.app.assets.off('load:' + asset.data.textureAtlasAsset, this._onTextureAtlasLoad, this);\n    }\n  }\n  _onSpriteAssetLoad(asset) {\n    if (!asset || !asset.resource) {\n      this.sprite = null;\n    } else {\n      if (!asset.resource.atlas) {\n        const atlasAssetId = asset.data.textureAtlasAsset;\n        if (atlasAssetId) {\n          const assets = this._system.app.assets;\n          assets.off('load:' + atlasAssetId, this._onTextureAtlasLoad, this);\n          assets.once('load:' + atlasAssetId, this._onTextureAtlasLoad, this);\n        }\n      } else {\n        this.sprite = asset.resource;\n      }\n    }\n  }\n  _onSpriteAssetChange(asset) {\n    this._onSpriteAssetLoad(asset);\n  }\n  _onSpriteAssetRemove(asset) {}\n  _bindSprite(sprite) {\n    sprite.on('set:meshes', this._onSpriteMeshesChange, this);\n    sprite.on('set:pixelsPerUnit', this._onSpritePpuChange, this);\n    sprite.on('set:atlas', this._onAtlasTextureChange, this);\n    if (sprite.atlas) {\n      sprite.atlas.on('set:texture', this._onAtlasTextureChange, this);\n    }\n  }\n  _unbindSprite(sprite) {\n    sprite.off('set:meshes', this._onSpriteMeshesChange, this);\n    sprite.off('set:pixelsPerUnit', this._onSpritePpuChange, this);\n    sprite.off('set:atlas', this._onAtlasTextureChange, this);\n    if (sprite.atlas) {\n      sprite.atlas.off('set:texture', this._onAtlasTextureChange, this);\n    }\n  }\n  _onSpriteMeshesChange() {\n    if (this._sprite) {\n      this._spriteFrame = _core_math_math_js__WEBPACK_IMPORTED_MODULE_13__.math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);\n    }\n    this._updateSprite();\n  }\n  _onSpritePpuChange() {\n    if (this.sprite.renderMode !== _scene_constants_js__WEBPACK_IMPORTED_MODULE_6__.SPRITE_RENDERMODE_SIMPLE && this._pixelsPerUnit === null) {\n      this._updateSprite();\n    }\n  }\n  _onAtlasTextureChange() {\n    if (this.sprite && this.sprite.atlas && this.sprite.atlas.texture) {\n      this._renderable.setParameter('texture_emissiveMap', this._sprite.atlas.texture);\n      this._renderable.setParameter('texture_opacityMap', this._sprite.atlas.texture);\n    } else {\n      this._renderable.deleteParameter('texture_emissiveMap');\n      this._renderable.deleteParameter('texture_opacityMap');\n    }\n  }\n  _onTextureAtlasLoad(atlasAsset) {\n    const spriteAsset = this._spriteAsset;\n    if (spriteAsset instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_14__.Asset) {\n      this._onSpriteAssetLoad(spriteAsset);\n    } else {\n      this._onSpriteAssetLoad(this._system.app.assets.get(spriteAsset));\n    }\n  }\n  onEnable() {\n    if (this._materialAsset) {\n      const asset = this._system.app.assets.get(this._materialAsset);\n      if (asset && asset.resource !== this._material) {\n        this._bindMaterialAsset(asset);\n      }\n    }\n    if (this._textureAsset) {\n      const asset = this._system.app.assets.get(this._textureAsset);\n      if (asset && asset.resource !== this._texture) {\n        this._bindTextureAsset(asset);\n      }\n    }\n    if (this._spriteAsset) {\n      const asset = this._system.app.assets.get(this._spriteAsset);\n      if (asset && asset.resource !== this._sprite) {\n        this._bindSpriteAsset(asset);\n      }\n    }\n    this._element.addModelToLayers(this._renderable.model);\n  }\n  onDisable() {\n    this._element.removeModelFromLayers(this._renderable.model);\n  }\n  _setStencil(stencilParams) {\n    this._renderable.meshInstance.stencilFront = stencilParams;\n    this._renderable.meshInstance.stencilBack = stencilParams;\n    let ref = 0;\n    if (this._element.maskedBy) {\n      ref = this._element.maskedBy.element._image._maskRef;\n    }\n    if (this._renderable.unmaskMeshInstance) {\n      const sp = new _scene_stencil_parameters_js__WEBPACK_IMPORTED_MODULE_15__.StencilParameters({\n        ref: ref + 1,\n        func: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_7__.FUNC_EQUAL,\n        zpass: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_7__.STENCILOP_DECREMENT\n      });\n      this._renderable.unmaskMeshInstance.stencilFront = sp;\n      this._renderable.unmaskMeshInstance.stencilBack = sp;\n    }\n  }\n  set color(value) {\n    const r = value.r;\n    const g = value.g;\n    const b = value.b;\n    if (this._color.r !== r || this._color.g !== g || this._color.b !== b) {\n      this._color.r = r;\n      this._color.g = g;\n      this._color.b = b;\n      this._colorUniform[0] = r;\n      this._colorUniform[1] = g;\n      this._colorUniform[2] = b;\n      this._renderable.setParameter('material_emissive', this._colorUniform);\n    }\n    if (this._element) {\n      this._element.fire('set:color', this._color);\n    }\n  }\n  get color() {\n    return this._color;\n  }\n  set opacity(value) {\n    if (value !== this._color.a) {\n      this._color.a = value;\n      this._renderable.setParameter('material_opacity', value);\n    }\n    if (this._element) {\n      this._element.fire('set:opacity', value);\n    }\n  }\n  get opacity() {\n    return this._color.a;\n  }\n  set rect(value) {\n    let x, y, z, w;\n    if (value instanceof _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_3__.Vec4) {\n      x = value.x;\n      y = value.y;\n      z = value.z;\n      w = value.w;\n    } else {\n      x = value[0];\n      y = value[1];\n      z = value[2];\n      w = value[3];\n    }\n    if (x === this._rect.x && y === this._rect.y && z === this._rect.z && w === this._rect.w) {\n      return;\n    }\n    this._rect.set(x, y, z, w);\n    if (this._renderable.mesh) {\n      if (!this._element._beingInitialized) {\n        this._updateMesh(this._renderable.mesh);\n      } else {\n        this._meshDirty = true;\n      }\n    }\n  }\n  get rect() {\n    return this._rect;\n  }\n  set material(value) {\n    if (this._material === value) return;\n    if (!value) {\n      const screenSpace = this._element._isScreenSpace();\n      if (this.mask) {\n        value = screenSpace ? this._system.defaultScreenSpaceImageMaskMaterial : this._system.defaultImageMaskMaterial;\n      } else {\n        value = screenSpace ? this._system.defaultScreenSpaceImageMaterial : this._system.defaultImageMaterial;\n      }\n    }\n    this._material = value;\n    if (value) {\n      this._renderable.setMaterial(value);\n      if (this._hasUserMaterial()) {\n        this._renderable.deleteParameter('material_opacity');\n        this._renderable.deleteParameter('material_emissive');\n      } else {\n        this._colorUniform[0] = this._color.r;\n        this._colorUniform[1] = this._color.g;\n        this._colorUniform[2] = this._color.b;\n        this._renderable.setParameter('material_emissive', this._colorUniform);\n        this._renderable.setParameter('material_opacity', this._color.a);\n      }\n    }\n  }\n  get material() {\n    return this._material;\n  }\n  set materialAsset(value) {\n    const assets = this._system.app.assets;\n    let _id = value;\n    if (value instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_14__.Asset) {\n      _id = value.id;\n    }\n    if (this._materialAsset !== _id) {\n      if (this._materialAsset) {\n        assets.off('add:' + this._materialAsset, this._onMaterialAdded, this);\n        const _prev = assets.get(this._materialAsset);\n        if (_prev) {\n          _prev.off('load', this._onMaterialLoad, this);\n          _prev.off('change', this._onMaterialChange, this);\n          _prev.off('remove', this._onMaterialRemove, this);\n        }\n      }\n      this._materialAsset = _id;\n      if (this._materialAsset) {\n        const asset = assets.get(this._materialAsset);\n        if (!asset) {\n          this.material = null;\n          assets.on('add:' + this._materialAsset, this._onMaterialAdded, this);\n        } else {\n          this._bindMaterialAsset(asset);\n        }\n      } else {\n        this.material = null;\n      }\n    }\n  }\n  get materialAsset() {\n    return this._materialAsset;\n  }\n  set texture(value) {\n    if (this._texture === value) return;\n    if (this._textureAsset) {\n      const textureAsset = this._system.app.assets.get(this._textureAsset);\n      if (textureAsset && textureAsset.resource !== value) {\n        this.textureAsset = null;\n      }\n    }\n    this._texture = value;\n    if (value) {\n      if (this._spriteAsset) {\n        this.spriteAsset = null;\n      }\n      this._renderable.setParameter('texture_emissiveMap', this._texture);\n      this._renderable.setParameter('texture_opacityMap', this._texture);\n      this._colorUniform[0] = this._color.r;\n      this._colorUniform[1] = this._color.g;\n      this._colorUniform[2] = this._color.b;\n      this._renderable.setParameter('material_emissive', this._colorUniform);\n      this._renderable.setParameter('material_opacity', this._color.a);\n      const newAspectRatio = this._texture.width / this._texture.height;\n      if (newAspectRatio !== this._targetAspectRatio) {\n        this._targetAspectRatio = newAspectRatio;\n        if (this._element.fitMode !== _constants_js__WEBPACK_IMPORTED_MODULE_12__.FITMODE_STRETCH) {\n          this.refreshMesh();\n        }\n      }\n    } else {\n      this._renderable.deleteParameter('texture_emissiveMap');\n      this._renderable.deleteParameter('texture_opacityMap');\n      this._targetAspectRatio = -1;\n      if (this._element.fitMode !== _constants_js__WEBPACK_IMPORTED_MODULE_12__.FITMODE_STRETCH) {\n        this.refreshMesh();\n      }\n    }\n  }\n  get texture() {\n    return this._texture;\n  }\n  set textureAsset(value) {\n    const assets = this._system.app.assets;\n    let _id = value;\n    if (value instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_14__.Asset) {\n      _id = value.id;\n    }\n    if (this._textureAsset !== _id) {\n      if (this._textureAsset) {\n        assets.off('add:' + this._textureAsset, this._onTextureAdded, this);\n        const _prev = assets.get(this._textureAsset);\n        if (_prev) {\n          _prev.off('load', this._onTextureLoad, this);\n          _prev.off('change', this._onTextureChange, this);\n          _prev.off('remove', this._onTextureRemove, this);\n        }\n      }\n      this._textureAsset = _id;\n      if (this._textureAsset) {\n        const asset = assets.get(this._textureAsset);\n        if (!asset) {\n          this.texture = null;\n          assets.on('add:' + this._textureAsset, this._onTextureAdded, this);\n        } else {\n          this._bindTextureAsset(asset);\n        }\n      } else {\n        this.texture = null;\n      }\n    }\n  }\n  get textureAsset() {\n    return this._textureAsset;\n  }\n  set spriteAsset(value) {\n    const assets = this._system.app.assets;\n    let _id = value;\n    if (value instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_14__.Asset) {\n      _id = value.id;\n    }\n    if (this._spriteAsset !== _id) {\n      if (this._spriteAsset) {\n        assets.off('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);\n        const _prev = assets.get(this._spriteAsset);\n        if (_prev) {\n          this._unbindSpriteAsset(_prev);\n        }\n      }\n      this._spriteAsset = _id;\n      if (this._spriteAsset) {\n        const asset = assets.get(this._spriteAsset);\n        if (!asset) {\n          this.sprite = null;\n          assets.on('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);\n        } else {\n          this._bindSpriteAsset(asset);\n        }\n      } else {\n        this.sprite = null;\n      }\n    }\n    if (this._element) {\n      this._element.fire('set:spriteAsset', _id);\n    }\n  }\n  get spriteAsset() {\n    return this._spriteAsset;\n  }\n  set sprite(value) {\n    if (this._sprite === value) return;\n    if (this._sprite) {\n      this._unbindSprite(this._sprite);\n    }\n    if (this._spriteAsset) {\n      const spriteAsset = this._system.app.assets.get(this._spriteAsset);\n      if (spriteAsset && spriteAsset.resource !== value) {\n        this.spriteAsset = null;\n      }\n    }\n    this._sprite = value;\n    if (this._sprite) {\n      this._bindSprite(this._sprite);\n      if (this._textureAsset) {\n        this.textureAsset = null;\n      }\n    }\n    if (this._sprite && this._sprite.atlas && this._sprite.atlas.texture) {\n      this._renderable.setParameter('texture_emissiveMap', this._sprite.atlas.texture);\n      this._renderable.setParameter('texture_opacityMap', this._sprite.atlas.texture);\n    } else {\n      this._renderable.deleteParameter('texture_emissiveMap');\n      this._renderable.deleteParameter('texture_opacityMap');\n    }\n    if (this._sprite) {\n      this._spriteFrame = _core_math_math_js__WEBPACK_IMPORTED_MODULE_13__.math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);\n    }\n    this._updateSprite();\n  }\n  get sprite() {\n    return this._sprite;\n  }\n  set spriteFrame(value) {\n    const oldValue = this._spriteFrame;\n    if (this._sprite) {\n      this._spriteFrame = _core_math_math_js__WEBPACK_IMPORTED_MODULE_13__.math.clamp(value, 0, this._sprite.frameKeys.length - 1);\n    } else {\n      this._spriteFrame = value;\n    }\n    if (this._spriteFrame !== oldValue) {\n      this._updateSprite();\n    }\n    if (this._element) {\n      this._element.fire('set:spriteFrame', value);\n    }\n  }\n  get spriteFrame() {\n    return this._spriteFrame;\n  }\n  set mesh(value) {\n    this._renderable.setMesh(value);\n    if (this._defaultMesh === value) {\n      this._renderable.setAabbFunc(null);\n    } else {\n      this._renderable.setAabbFunc(this._updateAabbFunc);\n    }\n  }\n  get mesh() {\n    return this._renderable.mesh;\n  }\n  set mask(value) {\n    if (this._mask !== value) {\n      this._mask = value;\n      this._toggleMask();\n    }\n  }\n  get mask() {\n    return this._mask;\n  }\n  set pixelsPerUnit(value) {\n    if (this._pixelsPerUnit === value) return;\n    this._pixelsPerUnit = value;\n    if (this._sprite && (this._sprite.renderMode === _scene_constants_js__WEBPACK_IMPORTED_MODULE_6__.SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === _scene_constants_js__WEBPACK_IMPORTED_MODULE_6__.SPRITE_RENDERMODE_TILED)) {\n      this._updateSprite();\n    }\n  }\n  get pixelsPerUnit() {\n    return this._pixelsPerUnit;\n  }\n  get aabb() {\n    if (this._renderable.meshInstance) {\n      return this._renderable.meshInstance.aabb;\n    }\n    return null;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/image-element.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/markup.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/markup.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Markup\": () => (/* binding */ Markup)\n/* harmony export */ });\nconst EOF_TOKEN = 0;\nconst ERROR_TOKEN = 1;\nconst TEXT_TOKEN = 2;\nconst OPEN_BRACKET_TOKEN = 3;\nconst CLOSE_BRACKET_TOKEN = 4;\nconst EQUALS_TOKEN = 5;\nconst STRING_TOKEN = 6;\nconst IDENTIFIER_TOKEN = 7;\nconst WHITESPACE_TOKEN = 8;\nconst WHITESPACE_CHARS = ' \\t\\n\\r\\v\\f';\nconst IDENTIFIER_REGEX = /[A-Z|a-z|0-9|_|-|/]/;\nclass Scanner {\n  constructor(symbols) {\n    this._symbols = symbols;\n    this._index = 0;\n    this._last = 0;\n    this._cur = this._symbols.length > 0 ? this._symbols[0] : null;\n    this._buf = [];\n    this._mode = 'text';\n    this._error = null;\n  }\n  read() {\n    let token = this._read();\n    while (token === WHITESPACE_TOKEN) {\n      token = this._read();\n    }\n    if (token !== EOF_TOKEN && token !== ERROR_TOKEN) {\n      this._last = this._index;\n    }\n    return token;\n  }\n  buf() {\n    return this._buf;\n  }\n  last() {\n    return this._last;\n  }\n  error() {\n    return this._error;\n  }\n  debugPrint() {\n    const tokenStrings = ['EOF', 'ERROR', 'TEXT', 'OPEN_BRACKET', 'CLOSE_BRACKET', 'EQUALS', 'STRING', 'IDENTIFIER', 'WHITESPACE'];\n    let token = this.read();\n    let result = '';\n    while (true) {\n      result += (result.length > 0 ? '\\n' : '') + tokenStrings[token] + ' \\'' + this.buf().join('') + '\\'';\n      if (token === EOF_TOKEN || token === ERROR_TOKEN) {\n        break;\n      }\n      token = this.read();\n    }\n    return result;\n  }\n  _read() {\n    this._buf = [];\n    if (this._eof()) {\n      return EOF_TOKEN;\n    }\n    return this._mode === 'text' ? this._text() : this._tag();\n  }\n  _text() {\n    while (true) {\n      switch (this._cur) {\n        case null:\n          return this._buf.length > 0 ? TEXT_TOKEN : EOF_TOKEN;\n        case '[':\n          this._mode = 'tag';\n          return this._buf.length > 0 ? TEXT_TOKEN : this._tag();\n        case '\\\\':\n          this._next();\n          switch (this._cur) {\n            case '[':\n              this._store();\n              break;\n            default:\n              this._output('\\\\');\n              break;\n          }\n          break;\n        default:\n          this._store();\n          break;\n      }\n    }\n  }\n  _tag() {\n    switch (this._cur) {\n      case null:\n        this._error = 'unexpected end of input reading tag';\n        return ERROR_TOKEN;\n      case '[':\n        this._store();\n        return OPEN_BRACKET_TOKEN;\n      case ']':\n        this._store();\n        this._mode = 'text';\n        return CLOSE_BRACKET_TOKEN;\n      case '=':\n        this._store();\n        return EQUALS_TOKEN;\n      case ' ':\n      case '\\t':\n      case '\\n':\n      case '\\r':\n      case '\\v':\n      case '\\f':\n        return this._whitespace();\n      case '\"':\n        return this._string();\n      default:\n        if (!this._isIdentifierSymbol(this._cur)) {\n          this._error = 'unrecognized character';\n          return ERROR_TOKEN;\n        }\n        return this._identifier();\n    }\n  }\n  _whitespace() {\n    this._store();\n    while (WHITESPACE_CHARS.indexOf(this._cur) !== -1) {\n      this._store();\n    }\n    return WHITESPACE_TOKEN;\n  }\n  _string() {\n    this._next();\n    while (true) {\n      switch (this._cur) {\n        case null:\n          this._error = 'unexpected end of input reading string';\n          return ERROR_TOKEN;\n        case '\"':\n          this._next();\n          return STRING_TOKEN;\n        default:\n          this._store();\n          break;\n      }\n    }\n  }\n  _identifier() {\n    this._store();\n    while (this._cur !== null && this._isIdentifierSymbol(this._cur)) {\n      this._store();\n    }\n    return IDENTIFIER_TOKEN;\n  }\n  _isIdentifierSymbol(s) {\n    return s.length === 1 && s.match(IDENTIFIER_REGEX) !== null;\n  }\n  _eof() {\n    return this._cur === null;\n  }\n  _next() {\n    if (!this._eof()) {\n      this._index++;\n      this._cur = this._index < this._symbols.length ? this._symbols[this._index] : null;\n    }\n    return this._cur;\n  }\n  _store() {\n    this._buf.push(this._cur);\n    return this._next();\n  }\n  _output(c) {\n    this._buf.push(c);\n  }\n}\nclass Parser {\n  constructor(symbols) {\n    this._scanner = new Scanner(symbols);\n    this._error = null;\n  }\n  parse(symbols, tags) {\n    while (true) {\n      const token = this._scanner.read();\n      switch (token) {\n        case EOF_TOKEN:\n          return true;\n        case ERROR_TOKEN:\n          return false;\n        case TEXT_TOKEN:\n          Array.prototype.push.apply(symbols, this._scanner.buf());\n          break;\n        case OPEN_BRACKET_TOKEN:\n          if (!this._parseTag(symbols, tags)) {\n            return false;\n          }\n          break;\n        default:\n          return false;\n      }\n    }\n  }\n  error() {\n    return 'Error evaluating markup at #' + this._scanner.last().toString() + ' (' + (this._scanner.error() || this._error) + ')';\n  }\n  _parseTag(symbols, tags) {\n    let token = this._scanner.read();\n    if (token !== IDENTIFIER_TOKEN) {\n      this._error = 'expected identifier';\n      return false;\n    }\n    const name = this._scanner.buf().join('');\n    if (name[0] === '/') {\n      for (let index = tags.length - 1; index >= 0; --index) {\n        if (name === '/' + tags[index].name && tags[index].end === null) {\n          tags[index].end = symbols.length;\n          token = this._scanner.read();\n          if (token !== CLOSE_BRACKET_TOKEN) {\n            this._error = 'expected close bracket';\n            return false;\n          }\n          return true;\n        }\n      }\n      this._error = 'failed to find matching tag';\n      return false;\n    }\n    const tag = {\n      name: name,\n      value: null,\n      attributes: {},\n      start: symbols.length,\n      end: null\n    };\n    token = this._scanner.read();\n    if (token === EQUALS_TOKEN) {\n      token = this._scanner.read();\n      if (token !== STRING_TOKEN) {\n        this._error = 'expected string';\n        return false;\n      }\n      tag.value = this._scanner.buf().join('');\n      token = this._scanner.read();\n    }\n    while (true) {\n      switch (token) {\n        case CLOSE_BRACKET_TOKEN:\n          tags.push(tag);\n          return true;\n        case IDENTIFIER_TOKEN:\n          {\n            const identifier = this._scanner.buf().join('');\n            token = this._scanner.read();\n            if (token !== EQUALS_TOKEN) {\n              this._error = 'expected equals';\n              return false;\n            }\n            token = this._scanner.read();\n            if (token !== STRING_TOKEN) {\n              this._error = 'expected string';\n              return false;\n            }\n            const value = this._scanner.buf().join('');\n            tag.attributes[identifier] = value;\n            break;\n          }\n        default:\n          this._error = 'expected close bracket or identifier';\n          return false;\n      }\n      token = this._scanner.read();\n    }\n  }\n}\nfunction merge(target, source) {\n  for (const key in source) {\n    if (!source.hasOwnProperty(key)) {\n      continue;\n    }\n    const value = source[key];\n    if (value instanceof Object) {\n      if (!target.hasOwnProperty(key)) {\n        target[key] = {};\n      }\n      merge(target[key], source[key]);\n    } else {\n      target[key] = value;\n    }\n  }\n}\nfunction combineTags(tags) {\n  if (tags.length === 0) {\n    return null;\n  }\n  const result = {};\n  for (let index = 0; index < tags.length; ++index) {\n    const tag = tags[index];\n    const tmp = {};\n    tmp[tag.name] = {\n      value: tag.value,\n      attributes: tag.attributes\n    };\n    merge(result, tmp);\n  }\n  return result;\n}\nfunction resolveMarkupTags(tags, numSymbols) {\n  if (tags.length === 0) {\n    return null;\n  }\n  const edges = {};\n  for (let index = 0; index < tags.length; ++index) {\n    const tag = tags[index];\n    if (!edges.hasOwnProperty(tag.start)) {\n      edges[tag.start] = {\n        open: [tag],\n        close: null\n      };\n    } else {\n      if (edges[tag.start].open === null) {\n        edges[tag.start].open = [tag];\n      } else {\n        edges[tag.start].open.push(tag);\n      }\n    }\n    if (!edges.hasOwnProperty(tag.end)) {\n      edges[tag.end] = {\n        open: null,\n        close: [tag]\n      };\n    } else {\n      if (edges[tag.end].close === null) {\n        edges[tag.end].close = [tag];\n      } else {\n        edges[tag.end].close.push(tag);\n      }\n    }\n  }\n  let tagStack = [];\n  function removeTags(tags) {\n    tagStack = tagStack.filter(function (tag) {\n      return tags.find(function (t) {\n        return t === tag;\n      }) === undefined;\n    });\n  }\n  function addTags(tags) {\n    for (let index = 0; index < tags.length; ++index) {\n      tagStack.push(tags[index]);\n    }\n  }\n  const edgeKeys = Object.keys(edges).sort(function (a, b) {\n    return a - b;\n  });\n  const resolvedTags = [];\n  for (let index = 0; index < edgeKeys.length; ++index) {\n    const edge = edges[edgeKeys[index]];\n    if (edge.close !== null) {\n      removeTags(edge.close);\n    }\n    if (edge.open !== null) {\n      addTags(edge.open);\n    }\n    resolvedTags.push({\n      start: edgeKeys[index],\n      tags: combineTags(tagStack)\n    });\n  }\n  const result = [];\n  let prevTag = null;\n  for (let index = 0; index < resolvedTags.length; ++index) {\n    const resolvedTag = resolvedTags[index];\n    while (result.length < resolvedTag.start) {\n      result.push(prevTag ? prevTag.tags : null);\n    }\n    prevTag = resolvedTag;\n  }\n  while (result.length < numSymbols) {\n    result.push(null);\n  }\n  return result;\n}\nfunction evaluateMarkup(symbols) {\n  const parser = new Parser(symbols);\n  const stripped_symbols = [];\n  const tags = [];\n  if (!parser.parse(stripped_symbols, tags)) {\n    console.warn(parser.error());\n    return {\n      symbols: symbols,\n      tags: null\n    };\n  }\n  const invalidTag = tags.find(function (t) {\n    return t.end === null;\n  });\n  if (invalidTag) {\n    console.warn(`Markup error: found unclosed tag='${invalidTag.name}'`);\n    return {\n      symbols: symbols,\n      tags: null\n    };\n  }\n  const resolved_tags = resolveMarkupTags(tags, stripped_symbols.length);\n  return {\n    symbols: stripped_symbols,\n    tags: resolved_tags\n  };\n}\nclass Markup {\n  static evaluate(symbols) {\n    return evaluateMarkup(symbols);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/markup.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/system.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/system.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ElementComponentSystem\": () => (/* binding */ ElementComponentSystem)\n/* harmony export */ });\n/* harmony import */ var _core_math_color_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../core/math/color.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/math/vec4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec4.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../platform/graphics/texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js\");\n/* harmony import */ var _scene_constants_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../scene/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _scene_materials_standard_material_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../scene/materials/standard-material.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/system.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/constants.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/component.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/data.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst _schema = ['enabled'];\nclass ElementComponentSystem extends _system_js__WEBPACK_IMPORTED_MODULE_0__.ComponentSystem {\n  constructor(app) {\n    super(app);\n    this.id = 'element';\n    this.ComponentType = _component_js__WEBPACK_IMPORTED_MODULE_1__.ElementComponent;\n    this.DataType = _data_js__WEBPACK_IMPORTED_MODULE_2__.ElementComponentData;\n    this.schema = _schema;\n    this._unicodeConverter = null;\n    this._rtlReorder = null;\n    this._defaultTexture = new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_3__.Texture(app.graphicsDevice, {\n      width: 1,\n      height: 1,\n      format: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_4__.PIXELFORMAT_RGBA8,\n      name: 'element-system'\n    });\n    const pixels = this._defaultTexture.lock();\n    const pixelData = new Uint8Array(4);\n    pixelData[0] = 255.0;\n    pixelData[1] = 255.0;\n    pixelData[2] = 255.0;\n    pixelData[3] = 255.0;\n    pixels.set(pixelData);\n    this._defaultTexture.unlock();\n    this.defaultImageMaterial = null;\n    this.defaultImage9SlicedMaterial = null;\n    this.defaultImage9TiledMaterial = null;\n    this.defaultImageMaskMaterial = null;\n    this.defaultImage9SlicedMaskMaterial = null;\n    this.defaultImage9TiledMaskMaterial = null;\n    this.defaultScreenSpaceImageMaterial = null;\n    this.defaultScreenSpaceImage9SlicedMaterial = null;\n    this.defaultScreenSpaceImage9TiledMaterial = null;\n    this.defaultScreenSpaceImageMask9SlicedMaterial = null;\n    this.defaultScreenSpaceImageMask9TiledMaterial = null;\n    this.defaultScreenSpaceImageMaskMaterial = null;\n    this._defaultTextMaterials = {};\n    this.defaultImageMaterials = [];\n    this.on('beforeremove', this.onRemoveComponent, this);\n  }\n  destroy() {\n    super.destroy();\n    this._defaultTexture.destroy();\n  }\n  initializeComponentData(component, data, properties) {\n    component._beingInitialized = true;\n    if (data.anchor !== undefined) {\n      if (data.anchor instanceof _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_5__.Vec4) {\n        component.anchor.copy(data.anchor);\n      } else {\n        component.anchor.set(data.anchor[0], data.anchor[1], data.anchor[2], data.anchor[3]);\n      }\n    }\n    if (data.pivot !== undefined) {\n      if (data.pivot instanceof _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_6__.Vec2) {\n        component.pivot.copy(data.pivot);\n      } else {\n        component.pivot.set(data.pivot[0], data.pivot[1]);\n      }\n    }\n    const splitHorAnchors = Math.abs(component.anchor.x - component.anchor.z) > 0.001;\n    const splitVerAnchors = Math.abs(component.anchor.y - component.anchor.w) > 0.001;\n    let _marginChange = false;\n    let color;\n    if (data.margin !== undefined) {\n      if (data.margin instanceof _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_5__.Vec4) {\n        component.margin.copy(data.margin);\n      } else {\n        component._margin.set(data.margin[0], data.margin[1], data.margin[2], data.margin[3]);\n      }\n      _marginChange = true;\n    }\n    if (data.left !== undefined) {\n      component._margin.x = data.left;\n      _marginChange = true;\n    }\n    if (data.bottom !== undefined) {\n      component._margin.y = data.bottom;\n      _marginChange = true;\n    }\n    if (data.right !== undefined) {\n      component._margin.z = data.right;\n      _marginChange = true;\n    }\n    if (data.top !== undefined) {\n      component._margin.w = data.top;\n      _marginChange = true;\n    }\n    if (_marginChange) {\n      component.margin = component._margin;\n    }\n    let shouldForceSetAnchor = false;\n    if (data.width !== undefined && !splitHorAnchors) {\n      component.width = data.width;\n    } else if (splitHorAnchors) {\n      shouldForceSetAnchor = true;\n    }\n    if (data.height !== undefined && !splitVerAnchors) {\n      component.height = data.height;\n    } else if (splitVerAnchors) {\n      shouldForceSetAnchor = true;\n    }\n    if (shouldForceSetAnchor) {\n      component.anchor = component.anchor;\n    }\n    if (data.enabled !== undefined) {\n      component.enabled = data.enabled;\n    }\n    if (data.useInput !== undefined) {\n      component.useInput = data.useInput;\n    }\n    if (data.fitMode !== undefined) {\n      component.fitMode = data.fitMode;\n    }\n    component.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;\n    if (data.layers && Array.isArray(data.layers)) {\n      component.layers = data.layers.slice(0);\n    }\n    if (data.type !== undefined) {\n      component.type = data.type;\n    }\n    if (component.type === _constants_js__WEBPACK_IMPORTED_MODULE_7__.ELEMENTTYPE_IMAGE) {\n      if (data.rect !== undefined) {\n        component.rect = data.rect;\n      }\n      if (data.color !== undefined) {\n        color = data.color;\n        if (!(color instanceof _core_math_color_js__WEBPACK_IMPORTED_MODULE_8__.Color)) {\n          color = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_8__.Color(data.color[0], data.color[1], data.color[2]);\n        }\n        component.color = color;\n      }\n      if (data.opacity !== undefined) component.opacity = data.opacity;\n      if (data.textureAsset !== undefined) component.textureAsset = data.textureAsset;\n      if (data.texture) component.texture = data.texture;\n      if (data.spriteAsset !== undefined) component.spriteAsset = data.spriteAsset;\n      if (data.sprite) component.sprite = data.sprite;\n      if (data.spriteFrame !== undefined) component.spriteFrame = data.spriteFrame;\n      if (data.pixelsPerUnit !== undefined && data.pixelsPerUnit !== null) component.pixelsPerUnit = data.pixelsPerUnit;\n      if (data.materialAsset !== undefined) component.materialAsset = data.materialAsset;\n      if (data.material) component.material = data.material;\n      if (data.mask !== undefined) {\n        component.mask = data.mask;\n      }\n    } else if (component.type === _constants_js__WEBPACK_IMPORTED_MODULE_7__.ELEMENTTYPE_TEXT) {\n      if (data.autoWidth !== undefined) component.autoWidth = data.autoWidth;\n      if (data.autoHeight !== undefined) component.autoHeight = data.autoHeight;\n      if (data.rtlReorder !== undefined) component.rtlReorder = data.rtlReorder;\n      if (data.unicodeConverter !== undefined) component.unicodeConverter = data.unicodeConverter;\n      if (data.text !== null && data.text !== undefined) {\n        component.text = data.text;\n      } else if (data.key !== null && data.key !== undefined) {\n        component.key = data.key;\n      }\n      if (data.color !== undefined) {\n        color = data.color;\n        if (!(color instanceof _core_math_color_js__WEBPACK_IMPORTED_MODULE_8__.Color)) {\n          color = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_8__.Color(color[0], color[1], color[2]);\n        }\n        component.color = color;\n      }\n      if (data.opacity !== undefined) {\n        component.opacity = data.opacity;\n      }\n      if (data.spacing !== undefined) component.spacing = data.spacing;\n      if (data.fontSize !== undefined) {\n        component.fontSize = data.fontSize;\n        if (!data.lineHeight) component.lineHeight = data.fontSize;\n      }\n      if (data.lineHeight !== undefined) component.lineHeight = data.lineHeight;\n      if (data.maxLines !== undefined) component.maxLines = data.maxLines;\n      if (data.wrapLines !== undefined) component.wrapLines = data.wrapLines;\n      if (data.minFontSize !== undefined) component.minFontSize = data.minFontSize;\n      if (data.maxFontSize !== undefined) component.maxFontSize = data.maxFontSize;\n      if (data.autoFitWidth) component.autoFitWidth = data.autoFitWidth;\n      if (data.autoFitHeight) component.autoFitHeight = data.autoFitHeight;\n      if (data.fontAsset !== undefined) component.fontAsset = data.fontAsset;\n      if (data.font !== undefined) component.font = data.font;\n      if (data.alignment !== undefined) component.alignment = data.alignment;\n      if (data.outlineColor !== undefined) component.outlineColor = data.outlineColor;\n      if (data.outlineThickness !== undefined) component.outlineThickness = data.outlineThickness;\n      if (data.shadowColor !== undefined) component.shadowColor = data.shadowColor;\n      if (data.shadowOffset !== undefined) component.shadowOffset = data.shadowOffset;\n      if (data.enableMarkup !== undefined) component.enableMarkup = data.enableMarkup;\n    }\n    const result = component._parseUpToScreen();\n    if (result.screen) {\n      component._updateScreen(result.screen);\n    }\n    super.initializeComponentData(component, data, properties);\n    component._beingInitialized = false;\n    if (component.type === _constants_js__WEBPACK_IMPORTED_MODULE_7__.ELEMENTTYPE_IMAGE && component._image._meshDirty) {\n      component._image._updateMesh(component._image.mesh);\n    }\n  }\n  onRemoveComponent(entity, component) {\n    component.onRemove();\n  }\n  cloneComponent(entity, clone) {\n    const source = entity.element;\n    const data = {\n      enabled: source.enabled,\n      width: source.width,\n      height: source.height,\n      anchor: source.anchor.clone(),\n      pivot: source.pivot.clone(),\n      margin: source.margin.clone(),\n      alignment: source.alignment && source.alignment.clone() || source.alignment,\n      autoWidth: source.autoWidth,\n      autoHeight: source.autoHeight,\n      type: source.type,\n      rect: source.rect && source.rect.clone() || source.rect,\n      rtlReorder: source.rtlReorder,\n      unicodeConverter: source.unicodeConverter,\n      materialAsset: source.materialAsset,\n      material: source.material,\n      color: source.color && source.color.clone() || source.color,\n      opacity: source.opacity,\n      textureAsset: source.textureAsset,\n      texture: source.texture,\n      spriteAsset: source.spriteAsset,\n      sprite: source.sprite,\n      spriteFrame: source.spriteFrame,\n      pixelsPerUnit: source.pixelsPerUnit,\n      spacing: source.spacing,\n      lineHeight: source.lineHeight,\n      wrapLines: source.wrapLines,\n      layers: source.layers,\n      fontSize: source.fontSize,\n      minFontSize: source.minFontSize,\n      maxFontSize: source.maxFontSize,\n      autoFitWidth: source.autoFitWidth,\n      autoFitHeight: source.autoFitHeight,\n      maxLines: source.maxLines,\n      fontAsset: source.fontAsset,\n      font: source.font,\n      useInput: source.useInput,\n      fitMode: source.fitMode,\n      batchGroupId: source.batchGroupId,\n      mask: source.mask,\n      outlineColor: source.outlineColor && source.outlineColor.clone() || source.outlineColor,\n      outlineThickness: source.outlineThickness,\n      shadowColor: source.shadowColor && source.shadowColor.clone() || source.shadowColor,\n      shadowOffset: source.shadowOffset && source.shadowOffset.clone() || source.shadowOffset,\n      enableMarkup: source.enableMarkup\n    };\n    if (source.key !== undefined && source.key !== null) {\n      data.key = source.key;\n    } else {\n      data.text = source.text;\n    }\n    return this.addComponent(clone, data);\n  }\n  getTextElementMaterial(screenSpace, msdf, textAttibutes) {\n    const hash = (screenSpace && 1 << 0) | (msdf && 1 << 1) | (textAttibutes && 1 << 2);\n    let material = this._defaultTextMaterials[hash];\n    if (material) {\n      return material;\n    }\n    let name = \"TextMaterial\";\n    material = new _scene_materials_standard_material_js__WEBPACK_IMPORTED_MODULE_9__.StandardMaterial();\n    if (msdf) {\n      material.msdfMap = this._defaultTexture;\n      material.msdfTextAttribute = textAttibutes;\n      material.emissive.set(1, 1, 1);\n    } else {\n      name = \"Bitmap\" + name;\n      material.emissive.set(0.5, 0.5, 0.5);\n      material.emissiveMap = this._defaultTexture;\n      material.emissiveTint = true;\n      material.opacityMap = this._defaultTexture;\n      material.opacityMapChannel = 'a';\n    }\n    if (screenSpace) {\n      name = 'ScreenSpace' + name;\n      material.depthTest = false;\n    }\n    material.name = 'default' + name;\n    material.useLighting = false;\n    material.useGammaTonemap = false;\n    material.useFog = false;\n    material.useSkybox = false;\n    material.diffuse.set(0, 0, 0);\n    material.opacity = 0.5;\n    material.blendType = _scene_constants_js__WEBPACK_IMPORTED_MODULE_10__.BLEND_PREMULTIPLIED;\n    material.depthWrite = false;\n    material.emissiveVertexColor = true;\n    material.update();\n    this._defaultTextMaterials[hash] = material;\n    return material;\n  }\n  _createBaseImageMaterial() {\n    const material = new _scene_materials_standard_material_js__WEBPACK_IMPORTED_MODULE_9__.StandardMaterial();\n    material.diffuse.set(0, 0, 0);\n    material.emissive.set(0.5, 0.5, 0.5);\n    material.emissiveMap = this._defaultTexture;\n    material.emissiveTint = true;\n    material.opacityMap = this._defaultTexture;\n    material.opacityMapChannel = 'a';\n    material.opacityTint = true;\n    material.opacity = 0;\n    material.useLighting = false;\n    material.useGammaTonemap = false;\n    material.useFog = false;\n    material.useSkybox = false;\n    material.blendType = _scene_constants_js__WEBPACK_IMPORTED_MODULE_10__.BLEND_PREMULTIPLIED;\n    material.depthWrite = false;\n    return material;\n  }\n  getImageElementMaterial(screenSpace, mask, nineSliced, nineSliceTiled) {\n    if (screenSpace) {\n      if (mask) {\n        if (nineSliced) {\n          if (!this.defaultScreenSpaceImageMask9SlicedMaterial) {\n            this.defaultScreenSpaceImageMask9SlicedMaterial = this._createBaseImageMaterial();\n            this.defaultScreenSpaceImageMask9SlicedMaterial.name = 'defaultScreenSpaceImageMask9SlicedMaterial';\n            this.defaultScreenSpaceImageMask9SlicedMaterial.nineSlicedMode = _scene_constants_js__WEBPACK_IMPORTED_MODULE_10__.SPRITE_RENDERMODE_SLICED;\n            this.defaultScreenSpaceImageMask9SlicedMaterial.depthTest = false;\n            this.defaultScreenSpaceImageMask9SlicedMaterial.alphaTest = 1;\n            this.defaultScreenSpaceImageMask9SlicedMaterial.redWrite = false;\n            this.defaultScreenSpaceImageMask9SlicedMaterial.greenWrite = false;\n            this.defaultScreenSpaceImageMask9SlicedMaterial.blueWrite = false;\n            this.defaultScreenSpaceImageMask9SlicedMaterial.alphaWrite = false;\n            this.defaultScreenSpaceImageMask9SlicedMaterial.update();\n            this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9SlicedMaterial);\n          }\n          return this.defaultScreenSpaceImageMask9SlicedMaterial;\n        } else if (nineSliceTiled) {\n          if (!this.defaultScreenSpaceImageMask9TiledMaterial) {\n            this.defaultScreenSpaceImageMask9TiledMaterial = this.defaultScreenSpaceImage9TiledMaterial.clone();\n            this.defaultScreenSpaceImageMask9TiledMaterial.name = 'defaultScreenSpaceImageMask9TiledMaterial';\n            this.defaultScreenSpaceImageMask9TiledMaterial.nineSlicedMode = _scene_constants_js__WEBPACK_IMPORTED_MODULE_10__.SPRITE_RENDERMODE_TILED;\n            this.defaultScreenSpaceImageMask9TiledMaterial.depthTest = false;\n            this.defaultScreenSpaceImageMask9TiledMaterial.alphaTest = 1;\n            this.defaultScreenSpaceImageMask9TiledMaterial.redWrite = false;\n            this.defaultScreenSpaceImageMask9TiledMaterial.greenWrite = false;\n            this.defaultScreenSpaceImageMask9TiledMaterial.blueWrite = false;\n            this.defaultScreenSpaceImageMask9TiledMaterial.alphaWrite = false;\n            this.defaultScreenSpaceImageMask9TiledMaterial.update();\n            this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9TiledMaterial);\n          }\n          return this.defaultScreenSpaceImageMask9TiledMaterial;\n        } else {\n          if (!this.defaultScreenSpaceImageMaskMaterial) {\n            this.defaultScreenSpaceImageMaskMaterial = this._createBaseImageMaterial();\n            this.defaultScreenSpaceImageMaskMaterial.name = 'defaultScreenSpaceImageMaskMaterial';\n            this.defaultScreenSpaceImageMaskMaterial.depthTest = false;\n            this.defaultScreenSpaceImageMaskMaterial.alphaTest = 1;\n            this.defaultScreenSpaceImageMaskMaterial.redWrite = false;\n            this.defaultScreenSpaceImageMaskMaterial.greenWrite = false;\n            this.defaultScreenSpaceImageMaskMaterial.blueWrite = false;\n            this.defaultScreenSpaceImageMaskMaterial.alphaWrite = false;\n            this.defaultScreenSpaceImageMaskMaterial.update();\n            this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaskMaterial);\n          }\n          return this.defaultScreenSpaceImageMaskMaterial;\n        }\n      } else {\n        if (nineSliced) {\n          if (!this.defaultScreenSpaceImage9SlicedMaterial) {\n            this.defaultScreenSpaceImage9SlicedMaterial = this._createBaseImageMaterial();\n            this.defaultScreenSpaceImage9SlicedMaterial.name = 'defaultScreenSpaceImage9SlicedMaterial';\n            this.defaultScreenSpaceImage9SlicedMaterial.nineSlicedMode = _scene_constants_js__WEBPACK_IMPORTED_MODULE_10__.SPRITE_RENDERMODE_SLICED;\n            this.defaultScreenSpaceImage9SlicedMaterial.depthTest = false;\n            this.defaultScreenSpaceImage9SlicedMaterial.update();\n            this.defaultImageMaterials.push(this.defaultScreenSpaceImage9SlicedMaterial);\n          }\n          return this.defaultScreenSpaceImage9SlicedMaterial;\n        } else if (nineSliceTiled) {\n          if (!this.defaultScreenSpaceImage9TiledMaterial) {\n            this.defaultScreenSpaceImage9TiledMaterial = this._createBaseImageMaterial();\n            this.defaultScreenSpaceImage9TiledMaterial.name = 'defaultScreenSpaceImage9TiledMaterial';\n            this.defaultScreenSpaceImage9TiledMaterial.nineSlicedMode = _scene_constants_js__WEBPACK_IMPORTED_MODULE_10__.SPRITE_RENDERMODE_TILED;\n            this.defaultScreenSpaceImage9TiledMaterial.depthTest = false;\n            this.defaultScreenSpaceImage9TiledMaterial.update();\n            this.defaultImageMaterials.push(this.defaultScreenSpaceImage9TiledMaterial);\n          }\n          return this.defaultScreenSpaceImage9TiledMaterial;\n        } else {\n          if (!this.defaultScreenSpaceImageMaterial) {\n            this.defaultScreenSpaceImageMaterial = this._createBaseImageMaterial();\n            this.defaultScreenSpaceImageMaterial.name = 'defaultScreenSpaceImageMaterial';\n            this.defaultScreenSpaceImageMaterial.depthTest = false;\n            this.defaultScreenSpaceImageMaterial.update();\n            this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaterial);\n          }\n          return this.defaultScreenSpaceImageMaterial;\n        }\n      }\n    } else {\n      if (mask) {\n        if (nineSliced) {\n          if (!this.defaultImage9SlicedMaskMaterial) {\n            this.defaultImage9SlicedMaskMaterial = this._createBaseImageMaterial();\n            this.defaultImage9SlicedMaskMaterial.name = 'defaultImage9SlicedMaskMaterial';\n            this.defaultImage9SlicedMaskMaterial.nineSlicedMode = _scene_constants_js__WEBPACK_IMPORTED_MODULE_10__.SPRITE_RENDERMODE_SLICED;\n            this.defaultImage9SlicedMaskMaterial.alphaTest = 1;\n            this.defaultImage9SlicedMaskMaterial.redWrite = false;\n            this.defaultImage9SlicedMaskMaterial.greenWrite = false;\n            this.defaultImage9SlicedMaskMaterial.blueWrite = false;\n            this.defaultImage9SlicedMaskMaterial.alphaWrite = false;\n            this.defaultImage9SlicedMaskMaterial.update();\n            this.defaultImageMaterials.push(this.defaultImage9SlicedMaskMaterial);\n          }\n          return this.defaultImage9SlicedMaskMaterial;\n        } else if (nineSliceTiled) {\n          if (!this.defaultImage9TiledMaskMaterial) {\n            this.defaultImage9TiledMaskMaterial = this._createBaseImageMaterial();\n            this.defaultImage9TiledMaskMaterial.name = 'defaultImage9TiledMaskMaterial';\n            this.defaultImage9TiledMaskMaterial.nineSlicedMode = _scene_constants_js__WEBPACK_IMPORTED_MODULE_10__.SPRITE_RENDERMODE_TILED;\n            this.defaultImage9TiledMaskMaterial.alphaTest = 1;\n            this.defaultImage9TiledMaskMaterial.redWrite = false;\n            this.defaultImage9TiledMaskMaterial.greenWrite = false;\n            this.defaultImage9TiledMaskMaterial.blueWrite = false;\n            this.defaultImage9TiledMaskMaterial.alphaWrite = false;\n            this.defaultImage9TiledMaskMaterial.update();\n            this.defaultImageMaterials.push(this.defaultImage9TiledMaskMaterial);\n          }\n          return this.defaultImage9TiledMaskMaterial;\n        } else {\n          if (!this.defaultImageMaskMaterial) {\n            this.defaultImageMaskMaterial = this._createBaseImageMaterial();\n            this.defaultImageMaskMaterial.name = 'defaultImageMaskMaterial';\n            this.defaultImageMaskMaterial.alphaTest = 1;\n            this.defaultImageMaskMaterial.redWrite = false;\n            this.defaultImageMaskMaterial.greenWrite = false;\n            this.defaultImageMaskMaterial.blueWrite = false;\n            this.defaultImageMaskMaterial.alphaWrite = false;\n            this.defaultImageMaskMaterial.update();\n            this.defaultImageMaterials.push(this.defaultImageMaskMaterial);\n          }\n          return this.defaultImageMaskMaterial;\n        }\n      } else {\n        if (nineSliced) {\n          if (!this.defaultImage9SlicedMaterial) {\n            this.defaultImage9SlicedMaterial = this._createBaseImageMaterial();\n            this.defaultImage9SlicedMaterial.name = 'defaultImage9SlicedMaterial';\n            this.defaultImage9SlicedMaterial.nineSlicedMode = _scene_constants_js__WEBPACK_IMPORTED_MODULE_10__.SPRITE_RENDERMODE_SLICED;\n            this.defaultImage9SlicedMaterial.update();\n            this.defaultImageMaterials.push(this.defaultImage9SlicedMaterial);\n          }\n          return this.defaultImage9SlicedMaterial;\n        } else if (nineSliceTiled) {\n          if (!this.defaultImage9TiledMaterial) {\n            this.defaultImage9TiledMaterial = this._createBaseImageMaterial();\n            this.defaultImage9TiledMaterial.name = 'defaultImage9TiledMaterial';\n            this.defaultImage9TiledMaterial.nineSlicedMode = _scene_constants_js__WEBPACK_IMPORTED_MODULE_10__.SPRITE_RENDERMODE_TILED;\n            this.defaultImage9TiledMaterial.update();\n            this.defaultImageMaterials.push(this.defaultImage9TiledMaterial);\n          }\n          return this.defaultImage9TiledMaterial;\n        } else {\n          if (!this.defaultImageMaterial) {\n            this.defaultImageMaterial = this._createBaseImageMaterial();\n            this.defaultImageMaterial.name = 'defaultImageMaterial';\n            this.defaultImageMaterial.update();\n            this.defaultImageMaterials.push(this.defaultImageMaterial);\n          }\n          return this.defaultImageMaterial;\n        }\n      }\n    }\n  }\n  registerUnicodeConverter(func) {\n    this._unicodeConverter = func;\n  }\n  registerRtlReorder(func) {\n    this._rtlReorder = func;\n  }\n  getUnicodeConverter() {\n    return this._unicodeConverter;\n  }\n  getRtlReorder() {\n    return this._rtlReorder;\n  }\n}\n_component_js__WEBPACK_IMPORTED_MODULE_11__.Component._buildAccessors(_component_js__WEBPACK_IMPORTED_MODULE_1__.ElementComponent.prototype, _schema);\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/system.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/text-element.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/text-element.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TextElement\": () => (/* binding */ TextElement)\n/* harmony export */ });\n/* harmony import */ var _core_string_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../core/string.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/string.js\");\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _core_math_color_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/math/color.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../core/shape/bounding-box.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/shape/bounding-box.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_vertex_iterator_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../../platform/graphics/vertex-iterator.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/vertex-iterator.js\");\n/* harmony import */ var _scene_graph_node_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../scene/graph-node.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/graph-node.js\");\n/* harmony import */ var _scene_mesh_instance_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../scene/mesh-instance.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh-instance.js\");\n/* harmony import */ var _scene_model_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../scene/model.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/model.js\");\n/* harmony import */ var _scene_mesh_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../scene/mesh.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh.js\");\n/* harmony import */ var _asset_asset_localized_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../asset/asset-localized.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset-localized.js\");\n/* harmony import */ var _font_constants_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../font/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/font/constants.js\");\n/* harmony import */ var _markup_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./markup.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/markup.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass MeshInfo {\n  constructor() {\n    this.count = 0;\n    this.quad = 0;\n    this.lines = {};\n    this.positions = [];\n    this.normals = [];\n    this.uvs = [];\n    this.colors = [];\n    this.indices = [];\n    this.outlines = [];\n    this.shadows = [];\n    this.meshInstance = null;\n  }\n}\nfunction createTextMesh(device, meshInfo) {\n  const mesh = new _scene_mesh_js__WEBPACK_IMPORTED_MODULE_0__.Mesh(device);\n  mesh.setPositions(meshInfo.positions);\n  mesh.setNormals(meshInfo.normals);\n  mesh.setColors32(meshInfo.colors);\n  mesh.setUvs(0, meshInfo.uvs);\n  mesh.setIndices(meshInfo.indices);\n  mesh.setVertexStream(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.SEMANTIC_ATTR8, meshInfo.outlines, 3, undefined, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.TYPE_FLOAT32, false);\n  mesh.setVertexStream(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.SEMANTIC_ATTR9, meshInfo.shadows, 3, undefined, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.TYPE_FLOAT32, false);\n  mesh.update();\n  return mesh;\n}\nconst LINE_BREAK_CHAR = /^[\\r\\n]$/;\nconst WHITESPACE_CHAR = /^[ \\t]$/;\nconst WORD_BOUNDARY_CHAR = /^[ \\t\\-]|[\\u200b]$/;\nconst ALPHANUMERIC_CHAR = /^[a-z0-9]$/i;\nconst CJK_CHAR = /^[\\u1100-\\u11ff]|[\\u3000-\\u9fff]|[\\ua960-\\ua97f]|[\\uac00-\\ud7ff]$/;\nconst NO_LINE_BREAK_CJK_CHAR = /^[〕〉》」』】〙〗〟ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻]$/;\nconst CONTROL_CHARS = ['\\u200B', '\\u061C', '\\u200E', '\\u200F', '\\u202A', '\\u202B', '\\u202C', '\\u202D', '\\u202E', '\\u2066', '\\u2067', '\\u2068', '\\u2069'];\nconst CONTROL_GLYPH_DATA = {\n  width: 0,\n  height: 0,\n  xadvance: 0,\n  xoffset: 0,\n  yoffset: 0\n};\nconst colorTmp = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_2__.Color();\nconst vec2Tmp = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_3__.Vec2();\nclass TextElement {\n  constructor(element) {\n    this._element = element;\n    this._system = element.system;\n    this._entity = element.entity;\n    this._text = '';\n    this._symbols = [];\n    this._colorPalette = [];\n    this._outlinePalette = [];\n    this._shadowPalette = [];\n    this._symbolColors = null;\n    this._symbolOutlineParams = null;\n    this._symbolShadowParams = null;\n    this._i18nKey = null;\n    this._fontAsset = new _asset_asset_localized_js__WEBPACK_IMPORTED_MODULE_4__.LocalizedAsset(this._system.app);\n    this._fontAsset.disableLocalization = true;\n    this._fontAsset.on('load', this._onFontLoad, this);\n    this._fontAsset.on('change', this._onFontChange, this);\n    this._fontAsset.on('remove', this._onFontRemove, this);\n    this._font = null;\n    this._color = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_2__.Color(1, 1, 1, 1);\n    this._colorUniform = new Float32Array(3);\n    this._spacing = 1;\n    this._fontSize = 32;\n    this._fontMinY = 0;\n    this._fontMaxY = 0;\n    this._originalFontSize = 32;\n    this._maxFontSize = 32;\n    this._minFontSize = 8;\n    this._autoFitWidth = false;\n    this._autoFitHeight = false;\n    this._maxLines = -1;\n    this._lineHeight = 32;\n    this._scaledLineHeight = 32;\n    this._wrapLines = false;\n    this._drawOrder = 0;\n    this._alignment = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_3__.Vec2(0.5, 0.5);\n    this._autoWidth = true;\n    this._autoHeight = true;\n    this.width = 0;\n    this.height = 0;\n    this._node = new _scene_graph_node_js__WEBPACK_IMPORTED_MODULE_5__.GraphNode();\n    this._model = new _scene_model_js__WEBPACK_IMPORTED_MODULE_6__.Model();\n    this._model.graph = this._node;\n    this._entity.addChild(this._node);\n    this._meshInfo = [];\n    this._material = null;\n    this._aabbDirty = true;\n    this._aabb = new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_7__.BoundingBox();\n    this._noResize = false;\n    this._currentMaterialType = null;\n    this._maskedMaterialSrc = null;\n    this._rtlReorder = false;\n    this._unicodeConverter = false;\n    this._rtl = false;\n    this._outlineColor = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_2__.Color(0, 0, 0, 1);\n    this._outlineColorUniform = new Float32Array(4);\n    this._outlineThicknessScale = 0.2;\n    this._outlineThickness = 0.0;\n    this._shadowColor = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_2__.Color(0, 0, 0, 1);\n    this._shadowColorUniform = new Float32Array(4);\n    this._shadowOffsetScale = 0.005;\n    this._shadowOffset = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_3__.Vec2(0, 0);\n    this._shadowOffsetUniform = new Float32Array(2);\n    this._enableMarkup = false;\n    this._onScreenChange(this._element.screen);\n    element.on('resize', this._onParentResize, this);\n    element.on('set:screen', this._onScreenChange, this);\n    element.on('screen:set:screenspace', this._onScreenSpaceChange, this);\n    element.on('set:draworder', this._onDrawOrderChange, this);\n    element.on('set:pivot', this._onPivotChange, this);\n    this._system.app.i18n.on('set:locale', this._onLocaleSet, this);\n    this._system.app.i18n.on('data:add', this._onLocalizationData, this);\n    this._system.app.i18n.on('data:remove', this._onLocalizationData, this);\n    this._rangeStart = 0;\n    this._rangeEnd = 0;\n  }\n  destroy() {\n    this._setMaterial(null);\n    if (this._model) {\n      this._element.removeModelFromLayers(this._model);\n      this._model.destroy();\n      this._model = null;\n    }\n    this._fontAsset.destroy();\n    this.font = null;\n    this._element.off('resize', this._onParentResize, this);\n    this._element.off('set:screen', this._onScreenChange, this);\n    this._element.off('screen:set:screenspace', this._onScreenSpaceChange, this);\n    this._element.off('set:draworder', this._onDrawOrderChange, this);\n    this._element.off('set:pivot', this._onPivotChange, this);\n    this._system.app.i18n.off('set:locale', this._onLocaleSet, this);\n    this._system.app.i18n.off('data:add', this._onLocalizationData, this);\n    this._system.app.i18n.off('data:remove', this._onLocalizationData, this);\n  }\n  _onParentResize(width, height) {\n    if (this._noResize) return;\n    if (this._font) this._updateText();\n  }\n  _onScreenChange(screen) {\n    if (screen) {\n      this._updateMaterial(screen.screen.screenSpace);\n    } else {\n      this._updateMaterial(false);\n    }\n  }\n  _onScreenSpaceChange(value) {\n    this._updateMaterial(value);\n  }\n  _onDrawOrderChange(order) {\n    this._drawOrder = order;\n    if (this._model) {\n      for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n        this._model.meshInstances[i].drawOrder = order;\n      }\n    }\n  }\n  _onPivotChange(pivot) {\n    if (this._font) this._updateText();\n  }\n  _onLocaleSet(locale) {\n    if (!this._i18nKey) return;\n    if (this.fontAsset) {\n      const asset = this._system.app.assets.get(this.fontAsset);\n      if (!asset || !asset.resource || asset.resource !== this._font) {\n        this.font = null;\n      }\n    }\n    this._resetLocalizedText();\n  }\n  _onLocalizationData(locale, messages) {\n    if (this._i18nKey && messages[this._i18nKey]) {\n      this._resetLocalizedText();\n    }\n  }\n  _resetLocalizedText() {\n    this._setText(this._system.app.i18n.getText(this._i18nKey));\n  }\n  _setText(text) {\n    if (this.unicodeConverter) {\n      const unicodeConverterFunc = this._system.getUnicodeConverter();\n      if (unicodeConverterFunc) {\n        text = unicodeConverterFunc(text);\n      } else {\n        console.warn('Element created with unicodeConverter option but no unicodeConverter function registered');\n      }\n    }\n    if (this._text !== text) {\n      if (this._font) {\n        this._updateText(text);\n      }\n      this._text = text;\n    }\n  }\n  _updateText(text) {\n    let tags;\n    if (text === undefined) text = this._text;\n    this._symbols = _core_string_js__WEBPACK_IMPORTED_MODULE_8__.string.getSymbols(text.normalize ? text.normalize('NFC') : text);\n    if (this._symbols.length === 0) {\n      this._symbols = [' '];\n    }\n    if (this._enableMarkup) {\n      const results = _markup_js__WEBPACK_IMPORTED_MODULE_9__.Markup.evaluate(this._symbols);\n      this._symbols = results.symbols;\n      tags = results.tags || [];\n    }\n    if (this._rtlReorder) {\n      const rtlReorderFunc = this._system.app.systems.element.getRtlReorder();\n      if (rtlReorderFunc) {\n        const results = rtlReorderFunc(this._symbols);\n        this._rtl = results.rtl;\n        this._symbols = results.mapping.map(function (v) {\n          return this._symbols[v];\n        }, this);\n        if (tags) {\n          tags = results.mapping.map(function (v) {\n            return tags[v];\n          });\n        }\n      } else {\n        console.warn('Element created with rtlReorder option but no rtlReorder function registered');\n      }\n    } else {\n      this._rtl = false;\n    }\n    const getColorThicknessHash = (color, thickness) => {\n      return `${color.toString(true).toLowerCase()}:${thickness.toFixed(2)}`;\n    };\n    const getColorOffsetHash = (color, offset) => {\n      return `${color.toString(true).toLowerCase()}:${offset.x.toFixed(2)}:${offset.y.toFixed(2)}`;\n    };\n    if (tags) {\n      const paletteMap = {};\n      const outlinePaletteMap = {};\n      const shadowPaletteMap = {};\n      this._colorPalette = [Math.round(this._color.r * 255), Math.round(this._color.g * 255), Math.round(this._color.b * 255)];\n      this._outlinePalette = [Math.round(this._outlineColor.r * 255), Math.round(this._outlineColor.g * 255), Math.round(this._outlineColor.b * 255), Math.round(this._outlineColor.a * 255), Math.round(this._outlineThickness * 255)];\n      this._shadowPalette = [Math.round(this._shadowColor.r * 255), Math.round(this._shadowColor.g * 255), Math.round(this._shadowColor.b * 255), Math.round(this._shadowColor.a * 255), Math.round(this._shadowOffset.x * 127), Math.round(this._shadowOffset.y * 127)];\n      this._symbolColors = [];\n      this._symbolOutlineParams = [];\n      this._symbolShadowParams = [];\n      paletteMap[this._color.toString(false).toLowerCase()] = 0;\n      outlinePaletteMap[getColorThicknessHash(this._outlineColor, this._outlineThickness)] = 0;\n      shadowPaletteMap[getColorOffsetHash(this._shadowColor, this._shadowOffset)] = 0;\n      for (let i = 0, len = this._symbols.length; i < len; ++i) {\n        const tag = tags[i];\n        let color = 0;\n        if (tag && tag.color && tag.color.value) {\n          const c = tag.color.value;\n          if (c.length === 7 && c[0] === '#') {\n            const hex = c.substring(1).toLowerCase();\n            if (paletteMap.hasOwnProperty(hex)) {\n              color = paletteMap[hex];\n            } else {\n              if (/^([0-9a-f]{2}){3}$/.test(hex)) {\n                color = this._colorPalette.length / 3;\n                paletteMap[hex] = color;\n                this._colorPalette.push(parseInt(hex.substring(0, 2), 16));\n                this._colorPalette.push(parseInt(hex.substring(2, 4), 16));\n                this._colorPalette.push(parseInt(hex.substring(4, 6), 16));\n              }\n            }\n          }\n        }\n        this._symbolColors.push(color);\n        let outline = 0;\n        if (tag && tag.outline && (tag.outline.attributes.color || tag.outline.attributes.thickness)) {\n          let _color = tag.outline.attributes.color ? colorTmp.fromString(tag.outline.attributes.color) : this._outlineColor;\n          let thickness = Number(tag.outline.attributes.thickness);\n          if (Number.isNaN(_color.r) || Number.isNaN(_color.g) || Number.isNaN(_color.b) || Number.isNaN(_color.a)) {\n            _color = this._outlineColor;\n          }\n          if (Number.isNaN(thickness)) {\n            thickness = this._outlineThickness;\n          }\n          const outlineHash = getColorThicknessHash(_color, thickness);\n          if (outlinePaletteMap.hasOwnProperty(outlineHash)) {\n            outline = outlinePaletteMap[outlineHash];\n          } else {\n            outline = this._outlinePalette.length / 5;\n            outlinePaletteMap[outlineHash] = outline;\n            this._outlinePalette.push(Math.round(_color.r * 255), Math.round(_color.g * 255), Math.round(_color.b * 255), Math.round(_color.a * 255), Math.round(thickness * 255));\n          }\n        }\n        this._symbolOutlineParams.push(outline);\n        let shadow = 0;\n        if (tag && tag.shadow && (tag.shadow.attributes.color || tag.shadow.attributes.offset || tag.shadow.attributes.offsetX || tag.shadow.attributes.offsetY)) {\n          let _color2 = tag.shadow.attributes.color ? colorTmp.fromString(tag.shadow.attributes.color) : this._shadowColor;\n          const off = Number(tag.shadow.attributes.offset);\n          const offX = Number(tag.shadow.attributes.offsetX);\n          const offY = Number(tag.shadow.attributes.offsetY);\n          if (Number.isNaN(_color2.r) || Number.isNaN(_color2.g) || Number.isNaN(_color2.b) || Number.isNaN(_color2.a)) {\n            _color2 = this._shadowColor;\n          }\n          const offset = vec2Tmp.set(!Number.isNaN(offX) ? offX : !Number.isNaN(off) ? off : this._shadowOffset.x, !Number.isNaN(offY) ? offY : !Number.isNaN(off) ? off : this._shadowOffset.y);\n          const shadowHash = getColorOffsetHash(_color2, offset);\n          if (shadowPaletteMap.hasOwnProperty(shadowHash)) {\n            shadow = shadowPaletteMap[shadowHash];\n          } else {\n            shadow = this._shadowPalette.length / 6;\n            shadowPaletteMap[shadowHash] = shadow;\n            this._shadowPalette.push(Math.round(_color2.r * 255), Math.round(_color2.g * 255), Math.round(_color2.b * 255), Math.round(_color2.a * 255), Math.round(offset.x * 127), Math.round(offset.y * 127));\n          }\n        }\n        this._symbolShadowParams.push(shadow);\n      }\n    } else {\n      this._colorPalette = [];\n      this._symbolColors = null;\n      this._symbolOutlineParams = null;\n      this._symbolShadowParams = null;\n    }\n    this._updateMaterialEmissive();\n    this._updateMaterialOutline();\n    this._updateMaterialShadow();\n    const charactersPerTexture = this._calculateCharsPerTexture();\n    let removedModel = false;\n    const element = this._element;\n    const screenSpace = element._isScreenSpace();\n    const screenCulled = element._isScreenCulled();\n    const visibleFn = function visibleFn(camera) {\n      return element.isVisibleForCamera(camera);\n    };\n    for (let i = 0, len = this._meshInfo.length; i < len; i++) {\n      const l = charactersPerTexture[i] || 0;\n      const meshInfo = this._meshInfo[i];\n      if (meshInfo.count !== l) {\n        if (!removedModel) {\n          element.removeModelFromLayers(this._model);\n          removedModel = true;\n        }\n        meshInfo.count = l;\n        meshInfo.positions.length = meshInfo.normals.length = l * 3 * 4;\n        meshInfo.indices.length = l * 3 * 2;\n        meshInfo.uvs.length = l * 2 * 4;\n        meshInfo.colors.length = l * 4 * 4;\n        meshInfo.outlines.length = l * 4 * 3;\n        meshInfo.shadows.length = l * 4 * 3;\n        if (meshInfo.meshInstance) {\n          this._removeMeshInstance(meshInfo.meshInstance);\n        }\n        if (l === 0) {\n          meshInfo.meshInstance = null;\n          continue;\n        }\n        for (let v = 0; v < l; v++) {\n          meshInfo.indices[v * 3 * 2 + 0] = v * 4;\n          meshInfo.indices[v * 3 * 2 + 1] = v * 4 + 1;\n          meshInfo.indices[v * 3 * 2 + 2] = v * 4 + 3;\n          meshInfo.indices[v * 3 * 2 + 3] = v * 4 + 2;\n          meshInfo.indices[v * 3 * 2 + 4] = v * 4 + 3;\n          meshInfo.indices[v * 3 * 2 + 5] = v * 4 + 1;\n          meshInfo.normals[v * 4 * 3 + 0] = 0;\n          meshInfo.normals[v * 4 * 3 + 1] = 0;\n          meshInfo.normals[v * 4 * 3 + 2] = -1;\n          meshInfo.normals[v * 4 * 3 + 3] = 0;\n          meshInfo.normals[v * 4 * 3 + 4] = 0;\n          meshInfo.normals[v * 4 * 3 + 5] = -1;\n          meshInfo.normals[v * 4 * 3 + 6] = 0;\n          meshInfo.normals[v * 4 * 3 + 7] = 0;\n          meshInfo.normals[v * 4 * 3 + 8] = -1;\n          meshInfo.normals[v * 4 * 3 + 9] = 0;\n          meshInfo.normals[v * 4 * 3 + 10] = 0;\n          meshInfo.normals[v * 4 * 3 + 11] = -1;\n        }\n        const mesh = createTextMesh(this._system.app.graphicsDevice, meshInfo);\n        const mi = new _scene_mesh_instance_js__WEBPACK_IMPORTED_MODULE_10__.MeshInstance(mesh, this._material, this._node);\n        mi.name = 'Text Element: ' + this._entity.name;\n        mi.castShadow = false;\n        mi.receiveShadow = false;\n        mi.cull = !screenSpace;\n        mi.screenSpace = screenSpace;\n        mi.drawOrder = this._drawOrder;\n        if (screenCulled) {\n          mi.cull = true;\n          mi.isVisibleFunc = visibleFn;\n        }\n        this._setTextureParams(mi, this._font.textures[i]);\n        mi.setParameter('material_emissive', this._colorUniform);\n        mi.setParameter('material_opacity', this._color.a);\n        mi.setParameter('font_sdfIntensity', this._font.intensity);\n        mi.setParameter('font_pxrange', this._getPxRange(this._font));\n        mi.setParameter('font_textureWidth', this._font.data.info.maps[i].width);\n        mi.setParameter('outline_color', this._outlineColorUniform);\n        mi.setParameter('outline_thickness', this._outlineThicknessScale * this._outlineThickness);\n        mi.setParameter('shadow_color', this._shadowColorUniform);\n        if (this._symbolShadowParams) {\n          this._shadowOffsetUniform[0] = 0;\n          this._shadowOffsetUniform[1] = 0;\n        } else {\n          const ratio = -this._font.data.info.maps[i].width / this._font.data.info.maps[i].height;\n          this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;\n          this._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;\n        }\n        mi.setParameter('shadow_offset', this._shadowOffsetUniform);\n        meshInfo.meshInstance = mi;\n        this._model.meshInstances.push(mi);\n      }\n    }\n    if (this._element.maskedBy) {\n      this._element._setMaskedBy(this._element.maskedBy);\n    }\n    if (removedModel && this._element.enabled && this._entity.enabled) {\n      this._element.addModelToLayers(this._model);\n    }\n    this._updateMeshes();\n    this._rangeStart = 0;\n    this._rangeEnd = this._symbols.length;\n    this._updateRenderRange();\n  }\n  _removeMeshInstance(meshInstance) {\n    meshInstance.destroy();\n    const idx = this._model.meshInstances.indexOf(meshInstance);\n    if (idx !== -1) this._model.meshInstances.splice(idx, 1);\n  }\n  _setMaterial(material) {\n    this._material = material;\n    if (this._model) {\n      for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n        const mi = this._model.meshInstances[i];\n        mi.material = material;\n      }\n    }\n  }\n  _updateMaterial(screenSpace) {\n    const element = this._element;\n    const screenCulled = element._isScreenCulled();\n    const visibleFn = function visibleFn(camera) {\n      return element.isVisibleForCamera(camera);\n    };\n    const msdf = this._font && this._font.type === _font_constants_js__WEBPACK_IMPORTED_MODULE_11__.FONT_MSDF;\n    this._material = this._system.getTextElementMaterial(screenSpace, msdf, this._enableMarkup);\n    if (this._model) {\n      for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n        const mi = this._model.meshInstances[i];\n        mi.cull = !screenSpace;\n        mi.material = this._material;\n        mi.screenSpace = screenSpace;\n        if (screenCulled) {\n          mi.cull = true;\n          mi.isVisibleFunc = visibleFn;\n        } else {\n          mi.isVisibleFunc = null;\n        }\n      }\n    }\n  }\n  _updateMaterialEmissive() {\n    if (this._symbolColors) {\n      this._colorUniform[0] = 1;\n      this._colorUniform[1] = 1;\n      this._colorUniform[2] = 1;\n    } else {\n      this._colorUniform[0] = this._color.r;\n      this._colorUniform[1] = this._color.g;\n      this._colorUniform[2] = this._color.b;\n    }\n  }\n  _updateMaterialOutline() {\n    if (this._symbolOutlineParams) {\n      this._outlineColorUniform[0] = 0;\n      this._outlineColorUniform[1] = 0;\n      this._outlineColorUniform[2] = 0;\n      this._outlineColorUniform[3] = 1;\n    } else {\n      this._outlineColorUniform[0] = this._outlineColor.r;\n      this._outlineColorUniform[1] = this._outlineColor.g;\n      this._outlineColorUniform[2] = this._outlineColor.b;\n      this._outlineColorUniform[3] = this._outlineColor.a;\n    }\n  }\n  _updateMaterialShadow() {\n    if (this._symbolOutlineParams) {\n      this._shadowColorUniform[0] = 0;\n      this._shadowColorUniform[1] = 0;\n      this._shadowColorUniform[2] = 0;\n      this._shadowColorUniform[3] = 0;\n    } else {\n      this._shadowColorUniform[0] = this._shadowColor.r;\n      this._shadowColorUniform[1] = this._shadowColor.g;\n      this._shadowColorUniform[2] = this._shadowColor.b;\n      this._shadowColorUniform[3] = this._shadowColor.a;\n    }\n  }\n  _isWordBoundary(char) {\n    return WORD_BOUNDARY_CHAR.test(char);\n  }\n  _isValidNextChar(nextchar) {\n    return nextchar !== null && !NO_LINE_BREAK_CJK_CHAR.test(nextchar);\n  }\n  _isNextCJKBoundary(char, nextchar) {\n    return CJK_CHAR.test(char) && (WORD_BOUNDARY_CHAR.test(nextchar) || ALPHANUMERIC_CHAR.test(nextchar));\n  }\n  _isNextCJKWholeWord(nextchar) {\n    return CJK_CHAR.test(nextchar);\n  }\n  _updateMeshes() {\n    const json = this._font.data;\n    const self = this;\n    const minFont = Math.min(this._minFontSize, this._maxFontSize);\n    const maxFont = this._maxFontSize;\n    const autoFit = this._shouldAutoFit();\n    if (autoFit) {\n      this._fontSize = this._maxFontSize;\n    }\n    const MAGIC = 32;\n    const l = this._symbols.length;\n    let _x = 0;\n    let _y = 0;\n    let _z = 0;\n    let _xMinusTrailingWhitespace = 0;\n    let lines = 1;\n    let wordStartX = 0;\n    let wordStartIndex = 0;\n    let lineStartIndex = 0;\n    let numWordsThisLine = 0;\n    let numCharsThisLine = 0;\n    let numBreaksThisLine = 0;\n    const splitHorizontalAnchors = Math.abs(this._element.anchor.x - this._element.anchor.z) >= 0.0001;\n    let maxLineWidth = this._element.calculatedWidth;\n    if (this.autoWidth && !splitHorizontalAnchors || !this._wrapLines) {\n      maxLineWidth = Number.POSITIVE_INFINITY;\n    }\n    let fontMinY = 0;\n    let fontMaxY = 0;\n    let char, data, quad, nextchar;\n    function breakLine(symbols, lineBreakIndex, lineBreakX) {\n      self._lineWidths.push(Math.abs(lineBreakX));\n      const sliceStart = lineStartIndex > lineBreakIndex ? lineBreakIndex + 1 : lineStartIndex;\n      const sliceEnd = lineStartIndex > lineBreakIndex ? lineStartIndex + 1 : lineBreakIndex;\n      const chars = symbols.slice(sliceStart, sliceEnd);\n      if (numBreaksThisLine) {\n        let i = chars.length;\n        while (i-- && numBreaksThisLine > 0) {\n          if (LINE_BREAK_CHAR.test(chars[i])) {\n            chars.splice(i, 1);\n            numBreaksThisLine--;\n          }\n        }\n      }\n      self._lineContents.push(chars.join(''));\n      _x = 0;\n      _y -= self._scaledLineHeight;\n      lines++;\n      numWordsThisLine = 0;\n      numCharsThisLine = 0;\n      numBreaksThisLine = 0;\n      wordStartX = 0;\n      lineStartIndex = lineBreakIndex;\n    }\n    let retryUpdateMeshes = true;\n    while (retryUpdateMeshes) {\n      retryUpdateMeshes = false;\n      if (autoFit) {\n        this._scaledLineHeight = this._lineHeight * this._fontSize / (this._maxFontSize || 0.0001);\n      } else {\n        this._scaledLineHeight = this._lineHeight;\n      }\n      this.width = 0;\n      this.height = 0;\n      this._lineWidths = [];\n      this._lineContents = [];\n      _x = 0;\n      _y = 0;\n      _z = 0;\n      _xMinusTrailingWhitespace = 0;\n      lines = 1;\n      wordStartX = 0;\n      wordStartIndex = 0;\n      lineStartIndex = 0;\n      numWordsThisLine = 0;\n      numCharsThisLine = 0;\n      numBreaksThisLine = 0;\n      const scale = this._fontSize / MAGIC;\n      fontMinY = this._fontMinY * scale;\n      fontMaxY = this._fontMaxY * scale;\n      for (let i = 0; i < this._meshInfo.length; i++) {\n        this._meshInfo[i].quad = 0;\n        this._meshInfo[i].lines = {};\n      }\n      let color_r = 255;\n      let color_g = 255;\n      let color_b = 255;\n      let outline_color_rg = 255 + 255 * 256;\n      let outline_color_ba = 255 + 255 * 256;\n      let outline_thickness = 0;\n      let shadow_color_rg = 255 + 255 * 256;\n      let shadow_color_ba = 255 + 255 * 256;\n      let shadow_offset_xy = 127 + 127 * 256;\n      for (let i = 0; i < l; i++) {\n        char = this._symbols[i];\n        nextchar = i + 1 >= l ? null : this._symbols[i + 1];\n        const isLineBreak = LINE_BREAK_CHAR.test(char);\n        if (isLineBreak) {\n          numBreaksThisLine++;\n          if (!this._wrapLines || this._maxLines < 0 || lines < this._maxLines) {\n            breakLine(this._symbols, i, _xMinusTrailingWhitespace);\n            wordStartIndex = i + 1;\n            lineStartIndex = i + 1;\n          }\n          continue;\n        }\n        let x = 0;\n        let y = 0;\n        let advance = 0;\n        let quadsize = 1;\n        let dataScale, size;\n        data = json.chars[char];\n        if (!data) {\n          if (CONTROL_CHARS.indexOf(char) !== -1) {\n            data = CONTROL_GLYPH_DATA;\n          } else {\n            if (json.chars[' ']) {\n              data = json.chars[' '];\n            } else {\n              for (const key in json.chars) {\n                data = json.chars[key];\n                break;\n              }\n            }\n          }\n        }\n        if (data) {\n          let kerning = 0;\n          if (numCharsThisLine > 0) {\n            const kernTable = this._font.data.kerning;\n            if (kernTable) {\n              const kernLeft = kernTable[_core_string_js__WEBPACK_IMPORTED_MODULE_8__.string.getCodePoint(this._symbols[i - 1]) || 0];\n              if (kernLeft) {\n                kerning = kernLeft[_core_string_js__WEBPACK_IMPORTED_MODULE_8__.string.getCodePoint(this._symbols[i]) || 0] || 0;\n              }\n            }\n          }\n          dataScale = data.scale || 1;\n          size = (data.width + data.height) / 2;\n          quadsize = scale * size / dataScale;\n          advance = (data.xadvance + kerning) * scale;\n          x = (data.xoffset - kerning) * scale;\n          y = data.yoffset * scale;\n        } else {\n          console.error(`Couldn't substitute missing character: '${char}'`);\n        }\n        const isWhitespace = WHITESPACE_CHAR.test(char);\n        const meshInfoId = data && data.map || 0;\n        const ratio = -this._font.data.info.maps[meshInfoId].width / this._font.data.info.maps[meshInfoId].height;\n        const meshInfo = this._meshInfo[meshInfoId];\n        const candidateLineWidth = _x + this._spacing * advance;\n        if (candidateLineWidth > maxLineWidth && numCharsThisLine > 0 && !isWhitespace) {\n          if (this._maxLines < 0 || lines < this._maxLines) {\n            if (numWordsThisLine === 0) {\n              wordStartIndex = i;\n              breakLine(this._symbols, i, _xMinusTrailingWhitespace);\n            } else {\n              const backtrack = Math.max(i - wordStartIndex, 0);\n              if (this._meshInfo.length <= 1) {\n                meshInfo.lines[lines - 1] -= backtrack;\n                meshInfo.quad -= backtrack;\n              } else {\n                const backtrackStart = wordStartIndex;\n                const backtrackEnd = i;\n                for (let j = backtrackStart; j < backtrackEnd; j++) {\n                  const backChar = this._symbols[j];\n                  const backCharData = json.chars[backChar];\n                  const backMeshInfo = this._meshInfo[backCharData && backCharData.map || 0];\n                  backMeshInfo.lines[lines - 1] -= 1;\n                  backMeshInfo.quad -= 1;\n                }\n              }\n              i -= backtrack + 1;\n              breakLine(this._symbols, wordStartIndex, wordStartX);\n              continue;\n            }\n          }\n        }\n        quad = meshInfo.quad;\n        meshInfo.lines[lines - 1] = quad;\n        let left = _x - x;\n        let right = left + quadsize;\n        const bottom = _y - y;\n        const top = bottom + quadsize;\n        if (this._rtl) {\n          const shift = quadsize - x - this._spacing * advance - x;\n          left -= shift;\n          right -= shift;\n        }\n        meshInfo.positions[quad * 4 * 3 + 0] = left;\n        meshInfo.positions[quad * 4 * 3 + 1] = bottom;\n        meshInfo.positions[quad * 4 * 3 + 2] = _z;\n        meshInfo.positions[quad * 4 * 3 + 3] = right;\n        meshInfo.positions[quad * 4 * 3 + 4] = bottom;\n        meshInfo.positions[quad * 4 * 3 + 5] = _z;\n        meshInfo.positions[quad * 4 * 3 + 6] = right;\n        meshInfo.positions[quad * 4 * 3 + 7] = top;\n        meshInfo.positions[quad * 4 * 3 + 8] = _z;\n        meshInfo.positions[quad * 4 * 3 + 9] = left;\n        meshInfo.positions[quad * 4 * 3 + 10] = top;\n        meshInfo.positions[quad * 4 * 3 + 11] = _z;\n        this.width = Math.max(this.width, candidateLineWidth);\n        let fontSize;\n        if (this._shouldAutoFitWidth() && this.width > this._element.calculatedWidth) {\n          fontSize = Math.floor(this._element.fontSize * this._element.calculatedWidth / (this.width || 0.0001));\n          fontSize = _core_math_math_js__WEBPACK_IMPORTED_MODULE_12__.math.clamp(fontSize, minFont, maxFont);\n          if (fontSize !== this._element.fontSize) {\n            this._fontSize = fontSize;\n            retryUpdateMeshes = true;\n            break;\n          }\n        }\n        this.height = Math.max(this.height, fontMaxY - (_y + fontMinY));\n        if (this._shouldAutoFitHeight() && this.height > this._element.calculatedHeight) {\n          fontSize = _core_math_math_js__WEBPACK_IMPORTED_MODULE_12__.math.clamp(this._fontSize - 1, minFont, maxFont);\n          if (fontSize !== this._element.fontSize) {\n            this._fontSize = fontSize;\n            retryUpdateMeshes = true;\n            break;\n          }\n        }\n        _x += this._spacing * advance;\n        if (!isWhitespace) {\n          _xMinusTrailingWhitespace = _x;\n        }\n        if (this._isWordBoundary(char) || this._isValidNextChar(nextchar) && (this._isNextCJKBoundary(char, nextchar) || this._isNextCJKWholeWord(nextchar))) {\n          numWordsThisLine++;\n          wordStartX = _xMinusTrailingWhitespace;\n          wordStartIndex = i + 1;\n        }\n        numCharsThisLine++;\n        const uv = this._getUv(char);\n        meshInfo.uvs[quad * 4 * 2 + 0] = uv[0];\n        meshInfo.uvs[quad * 4 * 2 + 1] = 1.0 - uv[1];\n        meshInfo.uvs[quad * 4 * 2 + 2] = uv[2];\n        meshInfo.uvs[quad * 4 * 2 + 3] = 1.0 - uv[1];\n        meshInfo.uvs[quad * 4 * 2 + 4] = uv[2];\n        meshInfo.uvs[quad * 4 * 2 + 5] = 1.0 - uv[3];\n        meshInfo.uvs[quad * 4 * 2 + 6] = uv[0];\n        meshInfo.uvs[quad * 4 * 2 + 7] = 1.0 - uv[3];\n        if (this._symbolColors) {\n          const colorIdx = this._symbolColors[i] * 3;\n          color_r = this._colorPalette[colorIdx];\n          color_g = this._colorPalette[colorIdx + 1];\n          color_b = this._colorPalette[colorIdx + 2];\n        }\n        meshInfo.colors[quad * 4 * 4 + 0] = color_r;\n        meshInfo.colors[quad * 4 * 4 + 1] = color_g;\n        meshInfo.colors[quad * 4 * 4 + 2] = color_b;\n        meshInfo.colors[quad * 4 * 4 + 3] = 255;\n        meshInfo.colors[quad * 4 * 4 + 4] = color_r;\n        meshInfo.colors[quad * 4 * 4 + 5] = color_g;\n        meshInfo.colors[quad * 4 * 4 + 6] = color_b;\n        meshInfo.colors[quad * 4 * 4 + 7] = 255;\n        meshInfo.colors[quad * 4 * 4 + 8] = color_r;\n        meshInfo.colors[quad * 4 * 4 + 9] = color_g;\n        meshInfo.colors[quad * 4 * 4 + 10] = color_b;\n        meshInfo.colors[quad * 4 * 4 + 11] = 255;\n        meshInfo.colors[quad * 4 * 4 + 12] = color_r;\n        meshInfo.colors[quad * 4 * 4 + 13] = color_g;\n        meshInfo.colors[quad * 4 * 4 + 14] = color_b;\n        meshInfo.colors[quad * 4 * 4 + 15] = 255;\n        if (this._symbolOutlineParams) {\n          const outlineIdx = this._symbolOutlineParams[i] * 5;\n          outline_color_rg = this._outlinePalette[outlineIdx] + this._outlinePalette[outlineIdx + 1] * 256;\n          outline_color_ba = this._outlinePalette[outlineIdx + 2] + this._outlinePalette[outlineIdx + 3] * 256;\n          outline_thickness = this._outlinePalette[outlineIdx + 4];\n        }\n        meshInfo.outlines[quad * 4 * 3 + 0] = outline_color_rg;\n        meshInfo.outlines[quad * 4 * 3 + 1] = outline_color_ba;\n        meshInfo.outlines[quad * 4 * 3 + 2] = outline_thickness;\n        meshInfo.outlines[quad * 4 * 3 + 3] = outline_color_rg;\n        meshInfo.outlines[quad * 4 * 3 + 4] = outline_color_ba;\n        meshInfo.outlines[quad * 4 * 3 + 5] = outline_thickness;\n        meshInfo.outlines[quad * 4 * 3 + 6] = outline_color_rg;\n        meshInfo.outlines[quad * 4 * 3 + 7] = outline_color_ba;\n        meshInfo.outlines[quad * 4 * 3 + 8] = outline_thickness;\n        meshInfo.outlines[quad * 4 * 3 + 9] = outline_color_rg;\n        meshInfo.outlines[quad * 4 * 3 + 10] = outline_color_ba;\n        meshInfo.outlines[quad * 4 * 3 + 11] = outline_thickness;\n        if (this._symbolShadowParams) {\n          const shadowIdx = this._symbolShadowParams[i] * 6;\n          shadow_color_rg = this._shadowPalette[shadowIdx] + this._shadowPalette[shadowIdx + 1] * 256;\n          shadow_color_ba = this._shadowPalette[shadowIdx + 2] + this._shadowPalette[shadowIdx + 3] * 256;\n          shadow_offset_xy = this._shadowPalette[shadowIdx + 4] + 127 + Math.round(ratio * this._shadowPalette[shadowIdx + 5] + 127) * 256;\n        }\n        meshInfo.shadows[quad * 4 * 3 + 0] = shadow_color_rg;\n        meshInfo.shadows[quad * 4 * 3 + 1] = shadow_color_ba;\n        meshInfo.shadows[quad * 4 * 3 + 2] = shadow_offset_xy;\n        meshInfo.shadows[quad * 4 * 3 + 3] = shadow_color_rg;\n        meshInfo.shadows[quad * 4 * 3 + 4] = shadow_color_ba;\n        meshInfo.shadows[quad * 4 * 3 + 5] = shadow_offset_xy;\n        meshInfo.shadows[quad * 4 * 3 + 6] = shadow_color_rg;\n        meshInfo.shadows[quad * 4 * 3 + 7] = shadow_color_ba;\n        meshInfo.shadows[quad * 4 * 3 + 8] = shadow_offset_xy;\n        meshInfo.shadows[quad * 4 * 3 + 9] = shadow_color_rg;\n        meshInfo.shadows[quad * 4 * 3 + 10] = shadow_color_ba;\n        meshInfo.shadows[quad * 4 * 3 + 11] = shadow_offset_xy;\n        meshInfo.quad++;\n      }\n      if (retryUpdateMeshes) {\n        continue;\n      }\n      if (lineStartIndex < l) {\n        breakLine(this._symbols, l, _x);\n      }\n    }\n    this._noResize = true;\n    this.autoWidth = this._autoWidth;\n    this.autoHeight = this._autoHeight;\n    this._noResize = false;\n    const hp = this._element.pivot.x;\n    const vp = this._element.pivot.y;\n    const ha = this._alignment.x;\n    const va = this._alignment.y;\n    for (let i = 0; i < this._meshInfo.length; i++) {\n      if (this._meshInfo[i].count === 0) continue;\n      let prevQuad = 0;\n      for (const line in this._meshInfo[i].lines) {\n        const index = this._meshInfo[i].lines[line];\n        const lw = this._lineWidths[parseInt(line, 10)];\n        const hoffset = -hp * this._element.calculatedWidth + ha * (this._element.calculatedWidth - lw) * (this._rtl ? -1 : 1);\n        const voffset = (1 - vp) * this._element.calculatedHeight - fontMaxY - (1 - va) * (this._element.calculatedHeight - this.height);\n        for (let _quad = prevQuad; _quad <= index; _quad++) {\n          this._meshInfo[i].positions[_quad * 4 * 3] += hoffset;\n          this._meshInfo[i].positions[_quad * 4 * 3 + 3] += hoffset;\n          this._meshInfo[i].positions[_quad * 4 * 3 + 6] += hoffset;\n          this._meshInfo[i].positions[_quad * 4 * 3 + 9] += hoffset;\n          this._meshInfo[i].positions[_quad * 4 * 3 + 1] += voffset;\n          this._meshInfo[i].positions[_quad * 4 * 3 + 4] += voffset;\n          this._meshInfo[i].positions[_quad * 4 * 3 + 7] += voffset;\n          this._meshInfo[i].positions[_quad * 4 * 3 + 10] += voffset;\n        }\n        if (this._rtl) {\n          for (let _quad2 = prevQuad; _quad2 <= index; _quad2++) {\n            const idx = _quad2 * 4 * 3;\n            for (let vert = 0; vert < 4; ++vert) {\n              this._meshInfo[i].positions[idx + vert * 3] = this._element.calculatedWidth - this._meshInfo[i].positions[idx + vert * 3] + hoffset * 2;\n            }\n            const tmp0 = this._meshInfo[i].positions[idx + 3];\n            const tmp1 = this._meshInfo[i].positions[idx + 6];\n            this._meshInfo[i].positions[idx + 3] = this._meshInfo[i].positions[idx + 0];\n            this._meshInfo[i].positions[idx + 6] = this._meshInfo[i].positions[idx + 9];\n            this._meshInfo[i].positions[idx + 0] = tmp0;\n            this._meshInfo[i].positions[idx + 9] = tmp1;\n          }\n        }\n        prevQuad = index + 1;\n      }\n      const numVertices = this._meshInfo[i].count * 4;\n      const vertMax = this._meshInfo[i].quad * 4;\n      const it = new _platform_graphics_vertex_iterator_js__WEBPACK_IMPORTED_MODULE_13__.VertexIterator(this._meshInfo[i].meshInstance.mesh.vertexBuffer);\n      for (let v = 0; v < numVertices; v++) {\n        if (v >= vertMax) {\n          it.element[_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.SEMANTIC_POSITION].set(0, 0, 0);\n          it.element[_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.SEMANTIC_TEXCOORD0].set(0, 0);\n          it.element[_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.SEMANTIC_COLOR].set(0, 0, 0, 0);\n          it.element[_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.SEMANTIC_ATTR8].set(0, 0, 0, 0);\n          it.element[_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.SEMANTIC_ATTR9].set(0, 0, 0, 0);\n        } else {\n          it.element[_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.SEMANTIC_POSITION].set(this._meshInfo[i].positions[v * 3 + 0], this._meshInfo[i].positions[v * 3 + 1], this._meshInfo[i].positions[v * 3 + 2]);\n          it.element[_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.SEMANTIC_TEXCOORD0].set(this._meshInfo[i].uvs[v * 2 + 0], this._meshInfo[i].uvs[v * 2 + 1]);\n          it.element[_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.SEMANTIC_COLOR].set(this._meshInfo[i].colors[v * 4 + 0], this._meshInfo[i].colors[v * 4 + 1], this._meshInfo[i].colors[v * 4 + 2], this._meshInfo[i].colors[v * 4 + 3]);\n          it.element[_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.SEMANTIC_ATTR8].set(this._meshInfo[i].outlines[v * 3 + 0], this._meshInfo[i].outlines[v * 3 + 1], this._meshInfo[i].outlines[v * 3 + 2]);\n          it.element[_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.SEMANTIC_ATTR9].set(this._meshInfo[i].shadows[v * 3 + 0], this._meshInfo[i].shadows[v * 3 + 1], this._meshInfo[i].shadows[v * 3 + 2]);\n        }\n        it.next();\n      }\n      it.end();\n      this._meshInfo[i].meshInstance.mesh.aabb.compute(this._meshInfo[i].positions);\n      this._meshInfo[i].meshInstance._aabbVer = -1;\n    }\n    this._aabbDirty = true;\n  }\n  _onFontRender() {\n    this.font = this._font;\n  }\n  _onFontLoad(asset) {\n    if (this.font !== asset.resource) {\n      this.font = asset.resource;\n    }\n  }\n  _onFontChange(asset, name, _new, _old) {\n    if (name === 'data') {\n      this._font.data = _new;\n      const maps = this._font.data.info.maps.length;\n      for (let i = 0; i < maps; i++) {\n        if (!this._meshInfo[i]) continue;\n        const mi = this._meshInfo[i].meshInstance;\n        if (mi) {\n          mi.setParameter('font_sdfIntensity', this._font.intensity);\n          mi.setParameter('font_pxrange', this._getPxRange(this._font));\n          mi.setParameter('font_textureWidth', this._font.data.info.maps[i].width);\n        }\n      }\n    }\n  }\n  _onFontRemove(asset) {}\n  _setTextureParams(mi, texture) {\n    if (this._font) {\n      if (this._font.type === _font_constants_js__WEBPACK_IMPORTED_MODULE_11__.FONT_MSDF) {\n        mi.deleteParameter('texture_emissiveMap');\n        mi.deleteParameter('texture_opacityMap');\n        mi.setParameter('texture_msdfMap', texture);\n      } else if (this._font.type === _font_constants_js__WEBPACK_IMPORTED_MODULE_11__.FONT_BITMAP) {\n        mi.deleteParameter('texture_msdfMap');\n        mi.setParameter('texture_emissiveMap', texture);\n        mi.setParameter('texture_opacityMap', texture);\n      }\n    }\n  }\n  _getPxRange(font) {\n    const keys = Object.keys(this._font.data.chars);\n    for (let i = 0; i < keys.length; i++) {\n      const char = this._font.data.chars[keys[i]];\n      if (char.range) {\n        return (char.scale || 1) * char.range;\n      }\n    }\n    return 2;\n  }\n  _getUv(char) {\n    const data = this._font.data;\n    if (!data.chars[char]) {\n      const space = ' ';\n      if (data.chars[space]) {\n        return this._getUv(space);\n      }\n      return [0, 0, 0, 0];\n    }\n    const map = data.chars[char].map;\n    const width = data.info.maps[map].width;\n    const height = data.info.maps[map].height;\n    const x = data.chars[char].x;\n    const y = data.chars[char].y;\n    const x1 = x;\n    const y1 = y;\n    const x2 = x + data.chars[char].width;\n    const y2 = y - data.chars[char].height;\n    const edge = 1 - data.chars[char].height / height;\n    return [x1 / width, edge - y1 / height, x2 / width, edge - y2 / height];\n  }\n  onEnable() {\n    this._fontAsset.autoLoad = true;\n    if (this._model) {\n      this._element.addModelToLayers(this._model);\n    }\n  }\n  onDisable() {\n    this._fontAsset.autoLoad = false;\n    if (this._model) {\n      this._element.removeModelFromLayers(this._model);\n    }\n  }\n  _setStencil(stencilParams) {\n    if (this._model) {\n      const instances = this._model.meshInstances;\n      for (let i = 0; i < instances.length; i++) {\n        instances[i].stencilFront = stencilParams;\n        instances[i].stencilBack = stencilParams;\n      }\n    }\n  }\n  _shouldAutoFitWidth() {\n    return this._autoFitWidth && !this._autoWidth;\n  }\n  _shouldAutoFitHeight() {\n    return this._autoFitHeight && !this._autoHeight;\n  }\n  _shouldAutoFit() {\n    return this._autoFitWidth && !this._autoWidth || this._autoFitHeight && !this._autoHeight;\n  }\n  _calculateCharsPerTexture(symbolIndex) {\n    const charactersPerTexture = {};\n    if (symbolIndex === undefined) {\n      symbolIndex = this._symbols.length;\n    }\n    for (let i = 0, len = symbolIndex; i < len; i++) {\n      const char = this._symbols[i];\n      let info = this._font.data.chars[char];\n      if (!info) {\n        info = this._font.data.chars[' '];\n        if (!info) {\n          info = this._font.data.chars[Object.keys(this._font.data.chars)[0]];\n        }\n      }\n      const map = info.map;\n      if (!charactersPerTexture[map]) {\n        charactersPerTexture[map] = 1;\n      } else {\n        charactersPerTexture[map]++;\n      }\n    }\n    return charactersPerTexture;\n  }\n  _updateRenderRange() {\n    const startChars = this._rangeStart === 0 ? 0 : this._calculateCharsPerTexture(this._rangeStart);\n    const endChars = this._rangeEnd === 0 ? 0 : this._calculateCharsPerTexture(this._rangeEnd);\n    for (let i = 0, len = this._meshInfo.length; i < len; i++) {\n      const start = startChars[i] || 0;\n      const end = endChars[i] || 0;\n      const instance = this._meshInfo[i].meshInstance;\n      if (instance) {\n        const mesh = instance.mesh;\n        if (mesh) {\n          mesh.primitive[0].base = start * 3 * 2;\n          mesh.primitive[0].count = (end - start) * 3 * 2;\n        }\n      }\n    }\n  }\n  set text(value) {\n    this._i18nKey = null;\n    const str = value != null && value.toString() || '';\n    this._setText(str);\n  }\n  get text() {\n    return this._text;\n  }\n  set key(value) {\n    const str = value !== null ? value.toString() : null;\n    if (this._i18nKey === str) {\n      return;\n    }\n    this._i18nKey = str;\n    if (str) {\n      this._fontAsset.disableLocalization = false;\n      this._resetLocalizedText();\n    } else {\n      this._fontAsset.disableLocalization = true;\n    }\n  }\n  get key() {\n    return this._i18nKey;\n  }\n  set color(value) {\n    const r = value.r;\n    const g = value.g;\n    const b = value.b;\n    if (this._color.r === r && this._color.g === g && this._color.b === b) {\n      return;\n    }\n    this._color.r = r;\n    this._color.g = g;\n    this._color.b = b;\n    if (!this._model) {\n      return;\n    }\n    if (this._symbolColors) {\n      if (this._font) {\n        this._updateText();\n      }\n    } else {\n      this._colorUniform[0] = this._color.r;\n      this._colorUniform[1] = this._color.g;\n      this._colorUniform[2] = this._color.b;\n      for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n        const mi = this._model.meshInstances[i];\n        mi.setParameter('material_emissive', this._colorUniform);\n      }\n    }\n    if (this._element) {\n      this._element.fire('set:color', this._color);\n    }\n  }\n  get color() {\n    return this._color;\n  }\n  set opacity(value) {\n    if (this._color.a !== value) {\n      this._color.a = value;\n      if (this._model) {\n        for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n          const mi = this._model.meshInstances[i];\n          mi.setParameter('material_opacity', value);\n        }\n      }\n    }\n    if (this._element) {\n      this._element.fire('set:opacity', value);\n    }\n  }\n  get opacity() {\n    return this._color.a;\n  }\n  set lineHeight(value) {\n    const _prev = this._lineHeight;\n    this._lineHeight = value;\n    this._scaledLineHeight = value;\n    if (_prev !== value && this._font) {\n      this._updateText();\n    }\n  }\n  get lineHeight() {\n    return this._lineHeight;\n  }\n  set wrapLines(value) {\n    const _prev = this._wrapLines;\n    this._wrapLines = value;\n    if (_prev !== value && this._font) {\n      this._updateText();\n    }\n  }\n  get wrapLines() {\n    return this._wrapLines;\n  }\n  get lines() {\n    return this._lineContents;\n  }\n  set spacing(value) {\n    const _prev = this._spacing;\n    this._spacing = value;\n    if (_prev !== value && this._font) {\n      this._updateText();\n    }\n  }\n  get spacing() {\n    return this._spacing;\n  }\n  set fontSize(value) {\n    const _prev = this._fontSize;\n    this._fontSize = value;\n    this._originalFontSize = value;\n    if (_prev !== value && this._font) {\n      this._updateText();\n    }\n  }\n  get fontSize() {\n    return this._fontSize;\n  }\n  set fontAsset(value) {\n    this._fontAsset.defaultAsset = value;\n  }\n  get fontAsset() {\n    return this._fontAsset.localizedAsset;\n  }\n  set font(value) {\n    let previousFontType;\n    if (this._font) {\n      previousFontType = this._font.type;\n      if (this._font.off) this._font.off('render', this._onFontRender, this);\n    }\n    this._font = value;\n    this._fontMinY = 0;\n    this._fontMaxY = 0;\n    if (!value) return;\n    const json = this._font.data;\n    for (const charId in json.chars) {\n      const data = json.chars[charId];\n      if (data.bounds) {\n        this._fontMinY = Math.min(this._fontMinY, data.bounds[1]);\n        this._fontMaxY = Math.max(this._fontMaxY, data.bounds[3]);\n      }\n    }\n    if (this._font.on) this._font.on('render', this._onFontRender, this);\n    if (this._fontAsset.localizedAsset) {\n      const asset = this._system.app.assets.get(this._fontAsset.localizedAsset);\n      if (asset.resource !== this._font) {\n        this._fontAsset.defaultAsset = null;\n      }\n    }\n    if (value.type !== previousFontType) {\n      const screenSpace = this._element._isScreenSpace();\n      this._updateMaterial(screenSpace);\n    }\n    for (let i = 0, len = this._font.textures.length; i < len; i++) {\n      if (!this._meshInfo[i]) {\n        this._meshInfo[i] = new MeshInfo();\n      } else {\n        const mi = this._meshInfo[i].meshInstance;\n        if (mi) {\n          mi.setParameter('font_sdfIntensity', this._font.intensity);\n          mi.setParameter('font_pxrange', this._getPxRange(this._font));\n          mi.setParameter('font_textureWidth', this._font.data.info.maps[i].width);\n          this._setTextureParams(mi, this._font.textures[i]);\n        }\n      }\n    }\n    let removedModel = false;\n    for (let i = this._font.textures.length; i < this._meshInfo.length; i++) {\n      if (this._meshInfo[i].meshInstance) {\n        if (!removedModel) {\n          this._element.removeModelFromLayers(this._model);\n          removedModel = true;\n        }\n        this._removeMeshInstance(this._meshInfo[i].meshInstance);\n      }\n    }\n    if (this._meshInfo.length > this._font.textures.length) this._meshInfo.length = this._font.textures.length;\n    this._updateText();\n  }\n  get font() {\n    return this._font;\n  }\n  set alignment(value) {\n    if (value instanceof _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_3__.Vec2) {\n      this._alignment.set(value.x, value.y);\n    } else {\n      this._alignment.set(value[0], value[1]);\n    }\n    if (this._font) this._updateText();\n  }\n  get alignment() {\n    return this._alignment;\n  }\n  set autoWidth(value) {\n    const old = this._autoWidth;\n    this._autoWidth = value;\n    if (value && Math.abs(this._element.anchor.x - this._element.anchor.z) < 0.0001) {\n      this._element.width = this.width;\n    }\n    if (old !== value) {\n      const newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;\n      if (newFontSize !== this._fontSize) {\n        this._fontSize = newFontSize;\n        if (this._font) {\n          this._updateText();\n        }\n      }\n    }\n  }\n  get autoWidth() {\n    return this._autoWidth;\n  }\n  set autoHeight(value) {\n    const old = this._autoHeight;\n    this._autoHeight = value;\n    if (value && Math.abs(this._element.anchor.y - this._element.anchor.w) < 0.0001) {\n      this._element.height = this.height;\n    }\n    if (old !== value) {\n      const newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;\n      if (newFontSize !== this._fontSize) {\n        this._fontSize = newFontSize;\n        if (this._font) {\n          this._updateText();\n        }\n      }\n    }\n  }\n  get autoHeight() {\n    return this._autoHeight;\n  }\n  set rtlReorder(value) {\n    if (this._rtlReorder !== value) {\n      this._rtlReorder = value;\n      if (this._font) {\n        this._updateText();\n      }\n    }\n  }\n  get rtlReorder() {\n    return this._rtlReorder;\n  }\n  set unicodeConverter(value) {\n    if (this._unicodeConverter !== value) {\n      this._unicodeConverter = value;\n      this._setText(this._text);\n    }\n  }\n  get unicodeConverter() {\n    return this._unicodeConverter;\n  }\n  get aabb() {\n    if (this._aabbDirty) {\n      let initialized = false;\n      for (let i = 0; i < this._meshInfo.length; i++) {\n        if (!this._meshInfo[i].meshInstance) continue;\n        if (!initialized) {\n          this._aabb.copy(this._meshInfo[i].meshInstance.aabb);\n          initialized = true;\n        } else {\n          this._aabb.add(this._meshInfo[i].meshInstance.aabb);\n        }\n      }\n      this._aabbDirty = false;\n    }\n    return this._aabb;\n  }\n  set outlineColor(value) {\n    const r = value instanceof _core_math_color_js__WEBPACK_IMPORTED_MODULE_2__.Color ? value.r : value[0];\n    const g = value instanceof _core_math_color_js__WEBPACK_IMPORTED_MODULE_2__.Color ? value.g : value[1];\n    const b = value instanceof _core_math_color_js__WEBPACK_IMPORTED_MODULE_2__.Color ? value.b : value[2];\n    const a = value instanceof _core_math_color_js__WEBPACK_IMPORTED_MODULE_2__.Color ? value.a : value[3];\n    if (this._outlineColor.r === r && this._outlineColor.g === g && this._outlineColor.b === b && this._outlineColor.a === a) {\n      return;\n    }\n    this._outlineColor.r = r;\n    this._outlineColor.g = g;\n    this._outlineColor.b = b;\n    this._outlineColor.a = a;\n    if (!this._model) {\n      return;\n    }\n    if (this._symbolOutlineParams) {\n      if (this._font) {\n        this._updateText();\n      }\n    } else {\n      this._outlineColorUniform[0] = this._outlineColor.r;\n      this._outlineColorUniform[1] = this._outlineColor.g;\n      this._outlineColorUniform[2] = this._outlineColor.b;\n      this._outlineColorUniform[3] = this._outlineColor.a;\n      for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n        const mi = this._model.meshInstances[i];\n        mi.setParameter('outline_color', this._outlineColorUniform);\n      }\n    }\n    if (this._element) {\n      this._element.fire('set:outline', this._color);\n    }\n  }\n  get outlineColor() {\n    return this._outlineColor;\n  }\n  set outlineThickness(value) {\n    const _prev = this._outlineThickness;\n    this._outlineThickness = value;\n    if (_prev !== value && this._font) {\n      if (!this._model) {\n        return;\n      }\n      if (this._symbolOutlineParams) {\n        if (this._font) {\n          this._updateText();\n        }\n      } else {\n        for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n          const mi = this._model.meshInstances[i];\n          mi.setParameter('outline_thickness', this._outlineThicknessScale * this._outlineThickness);\n        }\n      }\n    }\n  }\n  get outlineThickness() {\n    return this._outlineThickness;\n  }\n  set shadowColor(value) {\n    const r = value instanceof _core_math_color_js__WEBPACK_IMPORTED_MODULE_2__.Color ? value.r : value[0];\n    const g = value instanceof _core_math_color_js__WEBPACK_IMPORTED_MODULE_2__.Color ? value.g : value[1];\n    const b = value instanceof _core_math_color_js__WEBPACK_IMPORTED_MODULE_2__.Color ? value.b : value[2];\n    const a = value instanceof _core_math_color_js__WEBPACK_IMPORTED_MODULE_2__.Color ? value.a : value[3];\n    if (this._shadowColor.r === r && this._shadowColor.g === g && this._shadowColor.b === b && this._shadowColor.a === a) {\n      return;\n    }\n    this._shadowColor.r = r;\n    this._shadowColor.g = g;\n    this._shadowColor.b = b;\n    this._shadowColor.a = a;\n    if (!this._model) {\n      return;\n    }\n    if (this._symbolShadowParams) {\n      if (this._font) {\n        this._updateText();\n      }\n    } else {\n      this._shadowColorUniform[0] = this._shadowColor.r;\n      this._shadowColorUniform[1] = this._shadowColor.g;\n      this._shadowColorUniform[2] = this._shadowColor.b;\n      this._shadowColorUniform[3] = this._shadowColor.a;\n      for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n        const mi = this._model.meshInstances[i];\n        mi.setParameter('shadow_color', this._shadowColorUniform);\n      }\n    }\n  }\n  get shadowColor() {\n    return this._shadowColor;\n  }\n  set shadowOffset(value) {\n    const x = value instanceof _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_3__.Vec2 ? value.x : value[0],\n      y = value instanceof _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_3__.Vec2 ? value.y : value[1];\n    if (this._shadowOffset.x === x && this._shadowOffset.y === y) {\n      return;\n    }\n    this._shadowOffset.set(x, y);\n    if (this._font && this._model) {\n      if (this._symbolShadowParams) {\n        this._updateText();\n      } else {\n        for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n          const ratio = -this._font.data.info.maps[i].width / this._font.data.info.maps[i].height;\n          this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;\n          this._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;\n          const mi = this._model.meshInstances[i];\n          mi.setParameter('shadow_offset', this._shadowOffsetUniform);\n        }\n      }\n    }\n  }\n  get shadowOffset() {\n    return this._shadowOffset;\n  }\n  set minFontSize(value) {\n    if (this._minFontSize === value) return;\n    this._minFontSize = value;\n    if (this.font && this._shouldAutoFit()) {\n      this._updateText();\n    }\n  }\n  get minFontSize() {\n    return this._minFontSize;\n  }\n  set maxFontSize(value) {\n    if (this._maxFontSize === value) return;\n    this._maxFontSize = value;\n    if (this.font && this._shouldAutoFit()) {\n      this._updateText();\n    }\n  }\n  get maxFontSize() {\n    return this._maxFontSize;\n  }\n  set autoFitWidth(value) {\n    if (this._autoFitWidth === value) return;\n    this._autoFitWidth = value;\n    this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;\n    if (this.font) {\n      this._updateText();\n    }\n  }\n  get autoFitWidth() {\n    return this._autoFitWidth;\n  }\n  set autoFitHeight(value) {\n    if (this._autoFitHeight === value) return;\n    this._autoFitHeight = value;\n    this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;\n    if (this.font) {\n      this._updateText();\n    }\n  }\n  get autoFitHeight() {\n    return this._autoFitHeight;\n  }\n  set maxLines(value) {\n    if (this._maxLines === value) return;\n    if (value === null && this._maxLines === -1) return;\n    this._maxLines = value === null ? -1 : value;\n    if (this.font && this._wrapLines) {\n      this._updateText();\n    }\n  }\n  get maxLines() {\n    return this._maxLines;\n  }\n  set enableMarkup(value) {\n    value = !!value;\n    if (this._enableMarkup === value) return;\n    this._enableMarkup = value;\n    if (this.font) {\n      this._updateText();\n    }\n    const screenSpace = this._element._isScreenSpace();\n    this._updateMaterial(screenSpace);\n  }\n  get enableMarkup() {\n    return this._enableMarkup;\n  }\n  get symbols() {\n    return this._symbols;\n  }\n  get symbolColors() {\n    if (this._symbolColors === null) {\n      return null;\n    }\n    return this._symbolColors.map(function (c) {\n      return this._colorPalette.slice(c * 3, c * 3 + 3);\n    }, this);\n  }\n  get symbolOutlineParams() {\n    if (this._symbolOutlineParams === null) {\n      return null;\n    }\n    return this._symbolOutlineParams.map(function (paramId) {\n      return this._outlinePalette.slice(paramId * 5, paramId * 5 + 5);\n    }, this);\n  }\n  get symbolShadowParams() {\n    if (this._symbolShadowParams === null) {\n      return null;\n    }\n    return this._symbolShadowParams.map(function (paramId) {\n      return this._shadowPalette.slice(paramId * 6, paramId * 6 + 6);\n    }, this);\n  }\n  get rtl() {\n    return this._rtl;\n  }\n  set rangeStart(rangeStart) {\n    rangeStart = Math.max(0, Math.min(rangeStart, this._symbols.length));\n    if (rangeStart !== this._rangeStart) {\n      this._rangeStart = rangeStart;\n      this._updateRenderRange();\n    }\n  }\n  get rangeStart() {\n    return this._rangeStart;\n  }\n  set rangeEnd(rangeEnd) {\n    rangeEnd = Math.max(this._rangeStart, Math.min(rangeEnd, this._symbols.length));\n    if (rangeEnd !== this._rangeEnd) {\n      this._rangeEnd = rangeEnd;\n      this._updateRenderRange();\n    }\n  }\n  get rangeEnd() {\n    return this._rangeEnd;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/text-element.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/joint/component.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/joint/component.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"JointComponent\": () => (/* binding */ JointComponent)\n/* harmony export */ });\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/math/mat4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js\");\n/* harmony import */ var _core_math_quat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/math/quat.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/quat.js\");\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/joint/constants.js\");\n\n\n\n\n\n\n\n\nconst properties = ['angularDampingX', 'angularDampingY', 'angularDampingZ', 'angularEquilibriumX', 'angularEquilibriumY', 'angularEquilibriumZ', 'angularLimitsX', 'angularLimitsY', 'angularLimitsZ', 'angularMotionX', 'angularMotionY', 'angularMotionZ', 'angularSpringX', 'angularSpringY', 'angularSpringZ', 'angularStiffnessX', 'angularStiffnessY', 'angularStiffnessZ', 'breakForce', 'enableCollision', 'enabled', 'entityA', 'entityB', 'linearDampingX', 'linearDampingY', 'linearDampingZ', 'linearEquilibriumX', 'linearEquilibriumY', 'linearEquilibriumZ', 'linearLimitsX', 'linearLimitsY', 'linearLimitsZ', 'linearMotionX', 'linearMotionY', 'linearMotionZ', 'linearSpringX', 'linearSpringY', 'linearSpringZ', 'linearStiffnessX', 'linearStiffnessY', 'linearStiffnessZ'];\nclass JointComponent extends _component_js__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(system, entity) {\n    super(system, entity);\n    this._constraint = null;\n    this._entityA = null;\n    this._entityB = null;\n    this._breakForce = 3.4e+38;\n    this._enableCollision = true;\n    this._linearMotionX = _constants_js__WEBPACK_IMPORTED_MODULE_1__.MOTION_LOCKED;\n    this._linearLimitsX = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_2__.Vec2(0, 0);\n    this._linearSpringX = false;\n    this._linearStiffnessX = 0;\n    this._linearDampingX = 1;\n    this._linearEquilibriumX = 0;\n    this._linearMotionY = _constants_js__WEBPACK_IMPORTED_MODULE_1__.MOTION_LOCKED;\n    this._linearLimitsY = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_2__.Vec2(0, 0);\n    this._linearSpringY = false;\n    this._linearStiffnessY = 0;\n    this._linearDampingY = 1;\n    this._linearEquilibriumY = 0;\n    this._linearMotionZ = _constants_js__WEBPACK_IMPORTED_MODULE_1__.MOTION_LOCKED;\n    this._linearLimitsZ = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_2__.Vec2(0, 0);\n    this._linearSpringZ = false;\n    this._linearStiffnessZ = 0;\n    this._linearDampingZ = 1;\n    this._linearEquilibriumZ = 0;\n    this._angularMotionX = _constants_js__WEBPACK_IMPORTED_MODULE_1__.MOTION_LOCKED;\n    this._angularLimitsX = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_2__.Vec2(0, 0);\n    this._angularSpringX = false;\n    this._angularStiffnessX = 0;\n    this._angularDampingX = 1;\n    this._angularEquilibriumX = 0;\n    this._angularMotionY = _constants_js__WEBPACK_IMPORTED_MODULE_1__.MOTION_LOCKED;\n    this._angularLimitsY = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_2__.Vec2(0, 0);\n    this._angularSpringY = false;\n    this._angularStiffnessY = 0;\n    this._angularDampingY = 1;\n    this._angularEquilibriumY = 0;\n    this._angularMotionZ = _constants_js__WEBPACK_IMPORTED_MODULE_1__.MOTION_LOCKED;\n    this._angularLimitsZ = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_2__.Vec2(0, 0);\n    this._angularSpringZ = false;\n    this._angularEquilibriumZ = 0;\n    this._angularDampingZ = 1;\n    this._angularStiffnessZ = 0;\n    this.on('set_enabled', this._onSetEnabled, this);\n  }\n  set entityA(body) {\n    this._destroyConstraint();\n    this._entityA = body;\n    this._createConstraint();\n  }\n  get entityA() {\n    return this._entityA;\n  }\n  set entityB(body) {\n    this._destroyConstraint();\n    this._entityB = body;\n    this._createConstraint();\n  }\n  get entityB() {\n    return this._entityB;\n  }\n  set breakForce(force) {\n    if (this._constraint && this._breakForce !== force) {\n      this._constraint.setBreakingImpulseThreshold(force);\n      this._breakForce = force;\n    }\n  }\n  get breakForce() {\n    return this._breakForce;\n  }\n  set enableCollision(enableCollision) {\n    this._destroyConstraint();\n    this._enableCollision = enableCollision;\n    this._createConstraint();\n  }\n  get enableCollision() {\n    return this._enableCollision;\n  }\n  set angularLimitsX(limits) {\n    if (!this._angularLimitsX.equals(limits)) {\n      this._angularLimitsX.copy(limits);\n      this._updateAngularLimits();\n    }\n  }\n  get angularLimitsX() {\n    return this._angularLimitsX;\n  }\n  set angularMotionX(value) {\n    if (this._angularMotionX !== value) {\n      this._angularMotionX = value;\n      this._updateAngularLimits();\n    }\n  }\n  get angularMotionX() {\n    return this._angularMotionX;\n  }\n  set angularLimitsY(limits) {\n    if (!this._angularLimitsY.equals(limits)) {\n      this._angularLimitsY.copy(limits);\n      this._updateAngularLimits();\n    }\n  }\n  get angularLimitsY() {\n    return this._angularLimitsY;\n  }\n  set angularMotionY(value) {\n    if (this._angularMotionY !== value) {\n      this._angularMotionY = value;\n      this._updateAngularLimits();\n    }\n  }\n  get angularMotionY() {\n    return this._angularMotionY;\n  }\n  set angularLimitsZ(limits) {\n    if (!this._angularLimitsZ.equals(limits)) {\n      this._angularLimitsZ.copy(limits);\n      this._updateAngularLimits();\n    }\n  }\n  get angularLimitsZ() {\n    return this._angularLimitsZ;\n  }\n  set angularMotionZ(value) {\n    if (this._angularMotionZ !== value) {\n      this._angularMotionZ = value;\n      this._updateAngularLimits();\n    }\n  }\n  get angularMotionZ() {\n    return this._angularMotionZ;\n  }\n  set linearLimitsX(limits) {\n    if (!this._linearLimitsX.equals(limits)) {\n      this._linearLimitsX.copy(limits);\n      this._updateLinearLimits();\n    }\n  }\n  get linearLimitsX() {\n    return this._linearLimitsX;\n  }\n  set linearMotionX(value) {\n    if (this._linearMotionX !== value) {\n      this._linearMotionX = value;\n      this._updateLinearLimits();\n    }\n  }\n  get linearMotionX() {\n    return this._linearMotionX;\n  }\n  set linearLimitsY(limits) {\n    if (!this._linearLimitsY.equals(limits)) {\n      this._linearLimitsY.copy(limits);\n      this._updateLinearLimits();\n    }\n  }\n  get linearLimitsY() {\n    return this._linearLimitsY;\n  }\n  set linearMotionY(value) {\n    if (this._linearMotionY !== value) {\n      this._linearMotionY = value;\n      this._updateLinearLimits();\n    }\n  }\n  get linearMotionY() {\n    return this._linearMotionY;\n  }\n  set linearLimitsZ(limits) {\n    if (!this._linearLimitsZ.equals(limits)) {\n      this._linearLimitsZ.copy(limits);\n      this._updateLinearLimits();\n    }\n  }\n  get linearLimitsZ() {\n    return this._linearLimitsZ;\n  }\n  set linearMotionZ(value) {\n    if (this._linearMotionZ !== value) {\n      this._linearMotionZ = value;\n      this._updateLinearLimits();\n    }\n  }\n  get linearMotionZ() {\n    return this._linearMotionZ;\n  }\n  _convertTransform(pcTransform, ammoTransform) {\n    const pos = pcTransform.getTranslation();\n    const rot = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_3__.Quat();\n    rot.setFromMat4(pcTransform);\n    const ammoVec = new Ammo.btVector3(pos.x, pos.y, pos.z);\n    const ammoQuat = new Ammo.btQuaternion(rot.x, rot.y, rot.z, rot.w);\n    ammoTransform.setOrigin(ammoVec);\n    ammoTransform.setRotation(ammoQuat);\n    Ammo.destroy(ammoVec);\n    Ammo.destroy(ammoQuat);\n  }\n  _updateAngularLimits() {\n    const constraint = this._constraint;\n    if (constraint) {\n      let lx, ly, lz, ux, uy, uz;\n      if (this._angularMotionX === _constants_js__WEBPACK_IMPORTED_MODULE_1__.MOTION_LIMITED) {\n        lx = this._angularLimitsX.x * _core_math_math_js__WEBPACK_IMPORTED_MODULE_4__.math.DEG_TO_RAD;\n        ux = this._angularLimitsX.y * _core_math_math_js__WEBPACK_IMPORTED_MODULE_4__.math.DEG_TO_RAD;\n      } else if (this._angularMotionX === _constants_js__WEBPACK_IMPORTED_MODULE_1__.MOTION_FREE) {\n        lx = 1;\n        ux = 0;\n      } else {\n        lx = ux = 0;\n      }\n      if (this._angularMotionY === _constants_js__WEBPACK_IMPORTED_MODULE_1__.MOTION_LIMITED) {\n        ly = this._angularLimitsY.x * _core_math_math_js__WEBPACK_IMPORTED_MODULE_4__.math.DEG_TO_RAD;\n        uy = this._angularLimitsY.y * _core_math_math_js__WEBPACK_IMPORTED_MODULE_4__.math.DEG_TO_RAD;\n      } else if (this._angularMotionY === _constants_js__WEBPACK_IMPORTED_MODULE_1__.MOTION_FREE) {\n        ly = 1;\n        uy = 0;\n      } else {\n        ly = uy = 0;\n      }\n      if (this._angularMotionZ === _constants_js__WEBPACK_IMPORTED_MODULE_1__.MOTION_LIMITED) {\n        lz = this._angularLimitsZ.x * _core_math_math_js__WEBPACK_IMPORTED_MODULE_4__.math.DEG_TO_RAD;\n        uz = this._angularLimitsZ.y * _core_math_math_js__WEBPACK_IMPORTED_MODULE_4__.math.DEG_TO_RAD;\n      } else if (this._angularMotionZ === _constants_js__WEBPACK_IMPORTED_MODULE_1__.MOTION_FREE) {\n        lz = 1;\n        uz = 0;\n      } else {\n        lz = uz = 0;\n      }\n      const limits = new Ammo.btVector3(lx, ly, lz);\n      constraint.setAngularLowerLimit(limits);\n      limits.setValue(ux, uy, uz);\n      constraint.setAngularUpperLimit(limits);\n      Ammo.destroy(limits);\n    }\n  }\n  _updateLinearLimits() {\n    const constraint = this._constraint;\n    if (constraint) {\n      let lx, ly, lz, ux, uy, uz;\n      if (this._linearMotionX === _constants_js__WEBPACK_IMPORTED_MODULE_1__.MOTION_LIMITED) {\n        lx = this._linearLimitsX.x;\n        ux = this._linearLimitsX.y;\n      } else if (this._linearMotionX === _constants_js__WEBPACK_IMPORTED_MODULE_1__.MOTION_FREE) {\n        lx = 1;\n        ux = 0;\n      } else {\n        lx = ux = 0;\n      }\n      if (this._linearMotionY === _constants_js__WEBPACK_IMPORTED_MODULE_1__.MOTION_LIMITED) {\n        ly = this._linearLimitsY.x;\n        uy = this._linearLimitsY.y;\n      } else if (this._linearMotionY === _constants_js__WEBPACK_IMPORTED_MODULE_1__.MOTION_FREE) {\n        ly = 1;\n        uy = 0;\n      } else {\n        ly = uy = 0;\n      }\n      if (this._linearMotionZ === _constants_js__WEBPACK_IMPORTED_MODULE_1__.MOTION_LIMITED) {\n        lz = this._linearLimitsZ.x;\n        uz = this._linearLimitsZ.y;\n      } else if (this._linearMotionZ === _constants_js__WEBPACK_IMPORTED_MODULE_1__.MOTION_FREE) {\n        lz = 1;\n        uz = 0;\n      } else {\n        lz = uz = 0;\n      }\n      const limits = new Ammo.btVector3(lx, ly, lz);\n      constraint.setLinearLowerLimit(limits);\n      limits.setValue(ux, uy, uz);\n      constraint.setLinearUpperLimit(limits);\n      Ammo.destroy(limits);\n    }\n  }\n  _createConstraint() {\n    if (this._entityA && this._entityA.rigidbody) {\n      this._destroyConstraint();\n      const mat = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_5__.Mat4();\n      const bodyA = this._entityA.rigidbody.body;\n      bodyA.activate();\n      const jointWtm = this.entity.getWorldTransform();\n      const entityAWtm = this._entityA.getWorldTransform();\n      const invEntityAWtm = entityAWtm.clone().invert();\n      mat.mul2(invEntityAWtm, jointWtm);\n      const frameA = new Ammo.btTransform();\n      this._convertTransform(mat, frameA);\n      if (this._entityB && this._entityB.rigidbody) {\n        const bodyB = this._entityB.rigidbody.body;\n        bodyB.activate();\n        const entityBWtm = this._entityB.getWorldTransform();\n        const invEntityBWtm = entityBWtm.clone().invert();\n        mat.mul2(invEntityBWtm, jointWtm);\n        const frameB = new Ammo.btTransform();\n        this._convertTransform(mat, frameB);\n        this._constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA, bodyB, frameA, frameB, !this._enableCollision);\n        Ammo.destroy(frameB);\n      } else {\n        this._constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA, frameA, !this._enableCollision);\n      }\n      Ammo.destroy(frameA);\n      const axis = ['X', 'Y', 'Z', 'X', 'Y', 'Z'];\n      for (let i = 0; i < 6; i++) {\n        const type = i < 3 ? '_linear' : '_angular';\n        this._constraint.enableSpring(i, this[type + 'Spring' + axis[i]]);\n        this._constraint.setDamping(i, this[type + 'Damping' + axis[i]]);\n        this._constraint.setEquilibriumPoint(i, this[type + 'Equilibrium' + axis[i]]);\n        this._constraint.setStiffness(i, this[type + 'Stiffness' + axis[i]]);\n      }\n      this._constraint.setBreakingImpulseThreshold(this._breakForce);\n      this._updateLinearLimits();\n      this._updateAngularLimits();\n      const app = this.system.app;\n      const dynamicsWorld = app.systems.rigidbody.dynamicsWorld;\n      dynamicsWorld.addConstraint(this._constraint, !this._enableCollision);\n    }\n  }\n  _destroyConstraint() {\n    if (this._constraint) {\n      const app = this.system.app;\n      const dynamicsWorld = app.systems.rigidbody.dynamicsWorld;\n      dynamicsWorld.removeConstraint(this._constraint);\n      Ammo.destroy(this._constraint);\n      this._constraint = null;\n    }\n  }\n  initFromData(data) {\n    for (const prop of properties) {\n      if (data.hasOwnProperty(prop)) {\n        if (data[prop] instanceof _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_2__.Vec2) {\n          this['_' + prop].copy(data[prop]);\n        } else {\n          this['_' + prop] = data[prop];\n        }\n      }\n    }\n    this._createConstraint();\n  }\n  onEnable() {\n    this._createConstraint();\n  }\n  onDisable() {\n    this._destroyConstraint();\n  }\n  _onSetEnabled(prop, old, value) {}\n  _onBeforeRemove() {\n    this.fire('remove');\n  }\n}\nconst functionMap = {\n  Damping: 'setDamping',\n  Equilibrium: 'setEquilibriumPoint',\n  Spring: 'enableSpring',\n  Stiffness: 'setStiffness'\n};\n['linear', 'angular'].forEach(type => {\n  ['Damping', 'Equilibrium', 'Spring', 'Stiffness'].forEach(name => {\n    ['X', 'Y', 'Z'].forEach(axis => {\n      const prop = type + name + axis;\n      const propInternal = '_' + prop;\n      let index = type === 'linear' ? 0 : 3;\n      if (axis === 'Y') index += 1;\n      if (axis === 'Z') index += 2;\n      Object.defineProperty(JointComponent.prototype, prop, {\n        get: function () {\n          return this[propInternal];\n        },\n        set: function (value) {\n          if (this[propInternal] !== value) {\n            this[propInternal] = value;\n            this._constraint[functionMap[name]](index, value);\n          }\n        }\n      });\n    });\n  });\n});\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/joint/component.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/joint/constants.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/joint/constants.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MOTION_FREE\": () => (/* binding */ MOTION_FREE),\n/* harmony export */   \"MOTION_LIMITED\": () => (/* binding */ MOTION_LIMITED),\n/* harmony export */   \"MOTION_LOCKED\": () => (/* binding */ MOTION_LOCKED)\n/* harmony export */ });\nconst MOTION_FREE = 'free';\nconst MOTION_LIMITED = 'limited';\nconst MOTION_LOCKED = 'locked';\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/joint/constants.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/joint/data.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/joint/data.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"JointComponentData\": () => (/* binding */ JointComponentData)\n/* harmony export */ });\nclass JointComponentData {\n  constructor() {\n    this.enabled = true;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/joint/data.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/joint/system.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/joint/system.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"JointComponentSystem\": () => (/* binding */ JointComponentSystem)\n/* harmony export */ });\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/system.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/joint/component.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/joint/data.js\");\n\n\n\n\n\nconst _schema = ['enabled'];\nclass JointComponentSystem extends _system_js__WEBPACK_IMPORTED_MODULE_0__.ComponentSystem {\n  constructor(app) {\n    super(app);\n    this.id = 'joint';\n    this.app = app;\n    this.ComponentType = _component_js__WEBPACK_IMPORTED_MODULE_1__.JointComponent;\n    this.DataType = _data_js__WEBPACK_IMPORTED_MODULE_2__.JointComponentData;\n    this.schema = _schema;\n  }\n  initializeComponentData(component, data, properties) {\n    component.initFromData(data);\n  }\n}\n_component_js__WEBPACK_IMPORTED_MODULE_3__.Component._buildAccessors(_component_js__WEBPACK_IMPORTED_MODULE_1__.JointComponent.prototype, _schema);\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/joint/system.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-child/component.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-child/component.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LayoutChildComponent\": () => (/* binding */ LayoutChildComponent)\n/* harmony export */ });\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n\n\nclass LayoutChildComponent extends _component_js__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(system, entity) {\n    super(system, entity);\n    this._minWidth = 0;\n    this._minHeight = 0;\n    this._maxWidth = null;\n    this._maxHeight = null;\n    this._fitWidthProportion = 0;\n    this._fitHeightProportion = 0;\n    this._excludeFromLayout = false;\n  }\n  set minWidth(value) {\n    if (value !== this._minWidth) {\n      this._minWidth = value;\n      this.fire('resize');\n    }\n  }\n  get minWidth() {\n    return this._minWidth;\n  }\n  set minHeight(value) {\n    if (value !== this._minHeight) {\n      this._minHeight = value;\n      this.fire('resize');\n    }\n  }\n  get minHeight() {\n    return this._minHeight;\n  }\n  set maxWidth(value) {\n    if (value !== this._maxWidth) {\n      this._maxWidth = value;\n      this.fire('resize');\n    }\n  }\n  get maxWidth() {\n    return this._maxWidth;\n  }\n  set maxHeight(value) {\n    if (value !== this._maxHeight) {\n      this._maxHeight = value;\n      this.fire('resize');\n    }\n  }\n  get maxHeight() {\n    return this._maxHeight;\n  }\n  set fitWidthProportion(value) {\n    if (value !== this._fitWidthProportion) {\n      this._fitWidthProportion = value;\n      this.fire('resize');\n    }\n  }\n  get fitWidthProportion() {\n    return this._fitWidthProportion;\n  }\n  set fitHeightProportion(value) {\n    if (value !== this._fitHeightProportion) {\n      this._fitHeightProportion = value;\n      this.fire('resize');\n    }\n  }\n  get fitHeightProportion() {\n    return this._fitHeightProportion;\n  }\n  set excludeFromLayout(value) {\n    if (value !== this._excludeFromLayout) {\n      this._excludeFromLayout = value;\n      this.fire('resize');\n    }\n  }\n  get excludeFromLayout() {\n    return this._excludeFromLayout;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-child/component.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-child/data.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-child/data.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LayoutChildComponentData\": () => (/* binding */ LayoutChildComponentData)\n/* harmony export */ });\nclass LayoutChildComponentData {\n  constructor() {\n    this.enabled = true;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-child/data.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-child/system.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-child/system.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LayoutChildComponentSystem\": () => (/* binding */ LayoutChildComponentSystem)\n/* harmony export */ });\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/system.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-child/component.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-child/data.js\");\n\n\n\n\n\nconst _schema = ['enabled'];\nclass LayoutChildComponentSystem extends _system_js__WEBPACK_IMPORTED_MODULE_0__.ComponentSystem {\n  constructor(app) {\n    super(app);\n    this.id = 'layoutchild';\n    this.ComponentType = _component_js__WEBPACK_IMPORTED_MODULE_1__.LayoutChildComponent;\n    this.DataType = _data_js__WEBPACK_IMPORTED_MODULE_2__.LayoutChildComponentData;\n    this.schema = _schema;\n  }\n  initializeComponentData(component, data, properties) {\n    if (data.enabled !== undefined) component.enabled = data.enabled;\n    if (data.minWidth !== undefined) component.minWidth = data.minWidth;\n    if (data.minHeight !== undefined) component.minHeight = data.minHeight;\n    if (data.maxWidth !== undefined) component.maxWidth = data.maxWidth;\n    if (data.maxHeight !== undefined) component.maxHeight = data.maxHeight;\n    if (data.fitWidthProportion !== undefined) component.fitWidthProportion = data.fitWidthProportion;\n    if (data.fitHeightProportion !== undefined) component.fitHeightProportion = data.fitHeightProportion;\n    if (data.excludeFromLayout !== undefined) component.excludeFromLayout = data.excludeFromLayout;\n    super.initializeComponentData(component, data, properties);\n  }\n  cloneComponent(entity, clone) {\n    const layoutChild = entity.layoutchild;\n    return this.addComponent(clone, {\n      enabled: layoutChild.enabled,\n      minWidth: layoutChild.minWidth,\n      minHeight: layoutChild.minHeight,\n      maxWidth: layoutChild.maxWidth,\n      maxHeight: layoutChild.maxHeight,\n      fitWidthProportion: layoutChild.fitWidthProportion,\n      fitHeightProportion: layoutChild.fitHeightProportion,\n      excludeFromLayout: layoutChild.excludeFromLayout\n    });\n  }\n}\n_component_js__WEBPACK_IMPORTED_MODULE_3__.Component._buildAccessors(_component_js__WEBPACK_IMPORTED_MODULE_1__.LayoutChildComponent.prototype, _schema);\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-child/system.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-group/component.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-group/component.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LayoutGroupComponent\": () => (/* binding */ LayoutGroupComponent)\n/* harmony export */ });\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/math/vec4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec4.js\");\n/* harmony import */ var _scene_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../scene/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-group/constants.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _layout_calculator_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./layout-calculator.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-group/layout-calculator.js\");\n\n\n\n\n\n\n\nfunction getElement(entity) {\n  return entity.element;\n}\nfunction isEnabledAndHasEnabledElement(entity) {\n  return entity.enabled && entity.element && entity.element.enabled;\n}\nclass LayoutGroupComponent extends _component_js__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(system, entity) {\n    super(system, entity);\n    this._orientation = _scene_constants_js__WEBPACK_IMPORTED_MODULE_1__.ORIENTATION_HORIZONTAL;\n    this._reverseX = false;\n    this._reverseY = true;\n    this._alignment = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_2__.Vec2(0, 1);\n    this._padding = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_3__.Vec4();\n    this._spacing = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_2__.Vec2();\n    this._widthFitting = _constants_js__WEBPACK_IMPORTED_MODULE_4__.FITTING_NONE;\n    this._heightFitting = _constants_js__WEBPACK_IMPORTED_MODULE_4__.FITTING_NONE;\n    this._wrap = false;\n    this._layoutCalculator = new _layout_calculator_js__WEBPACK_IMPORTED_MODULE_5__.LayoutCalculator();\n    this._listenForReflowEvents(this.entity, 'on');\n    this.entity.children.forEach(child => {\n      this._listenForReflowEvents(child, 'on');\n    });\n    this.entity.on('childinsert', this._onChildInsert, this);\n    this.entity.on('childremove', this._onChildRemove, this);\n    system.app.systems.element.on('add', this._onElementOrLayoutComponentAdd, this);\n    system.app.systems.element.on('beforeremove', this._onElementOrLayoutComponentRemove, this);\n    system.app.systems.layoutchild.on('add', this._onElementOrLayoutComponentAdd, this);\n    system.app.systems.layoutchild.on('beforeremove', this._onElementOrLayoutComponentRemove, this);\n  }\n  set orientation(value) {\n    if (value !== this._orientation) {\n      this._orientation = value;\n      this._scheduleReflow();\n    }\n  }\n  get orientation() {\n    return this._orientation;\n  }\n  set reverseX(value) {\n    if (value !== this._reverseX) {\n      this._reverseX = value;\n      this._scheduleReflow();\n    }\n  }\n  get reverseX() {\n    return this._reverseX;\n  }\n  set reverseY(value) {\n    if (value !== this._reverseY) {\n      this._reverseY = value;\n      this._scheduleReflow();\n    }\n  }\n  get reverseY() {\n    return this._reverseY;\n  }\n  set alignment(value) {\n    if (!value.equals(this._alignment)) {\n      this._alignment.copy(value);\n      this._scheduleReflow();\n    }\n  }\n  get alignment() {\n    return this._alignment;\n  }\n  set padding(value) {\n    if (!value.equals(this._padding)) {\n      this._padding.copy(value);\n      this._scheduleReflow();\n    }\n  }\n  get padding() {\n    return this._padding;\n  }\n  set spacing(value) {\n    if (!value.equals(this._spacing)) {\n      this._spacing.copy(value);\n      this._scheduleReflow();\n    }\n  }\n  get spacing() {\n    return this._spacing;\n  }\n  set widthFitting(value) {\n    if (value !== this._widthFitting) {\n      this._widthFitting = value;\n      this._scheduleReflow();\n    }\n  }\n  get widthFitting() {\n    return this._widthFitting;\n  }\n  set heightFitting(value) {\n    if (value !== this._heightFitting) {\n      this._heightFitting = value;\n      this._scheduleReflow();\n    }\n  }\n  get heightFitting() {\n    return this._heightFitting;\n  }\n  set wrap(value) {\n    if (value !== this._wrap) {\n      this._wrap = value;\n      this._scheduleReflow();\n    }\n  }\n  get wrap() {\n    return this._wrap;\n  }\n  _isSelfOrChild(entity) {\n    return entity === this.entity || this.entity.children.indexOf(entity) !== -1;\n  }\n  _listenForReflowEvents(target, onOff) {\n    if (target.element) {\n      target.element[onOff]('enableelement', this._scheduleReflow, this);\n      target.element[onOff]('disableelement', this._scheduleReflow, this);\n      target.element[onOff]('resize', this._scheduleReflow, this);\n      target.element[onOff]('set:pivot', this._scheduleReflow, this);\n    }\n    if (target.layoutchild) {\n      target.layoutchild[onOff]('set_enabled', this._scheduleReflow, this);\n      target.layoutchild[onOff]('resize', this._scheduleReflow, this);\n    }\n  }\n  _onElementOrLayoutComponentAdd(entity) {\n    if (this._isSelfOrChild(entity)) {\n      this._listenForReflowEvents(entity, 'on');\n      this._scheduleReflow();\n    }\n  }\n  _onElementOrLayoutComponentRemove(entity) {\n    if (this._isSelfOrChild(entity)) {\n      this._listenForReflowEvents(entity, 'off');\n      this._scheduleReflow();\n    }\n  }\n  _onChildInsert(child) {\n    this._listenForReflowEvents(child, 'on');\n    this._scheduleReflow();\n  }\n  _onChildRemove(child) {\n    this._listenForReflowEvents(child, 'off');\n    this._scheduleReflow();\n  }\n  _scheduleReflow() {\n    if (this.enabled && this.entity && this.entity.enabled && !this._isPerformingReflow) {\n      this.system.scheduleReflow(this);\n    }\n  }\n  reflow() {\n    const container = getElement(this.entity);\n    const elements = this.entity.children.filter(isEnabledAndHasEnabledElement).map(getElement);\n    if (!container || elements.length === 0) {\n      return;\n    }\n    const containerWidth = Math.max(container.calculatedWidth, 0);\n    const containerHeight = Math.max(container.calculatedHeight, 0);\n    const options = {\n      orientation: this._orientation,\n      reverseX: this._reverseX,\n      reverseY: this._reverseY,\n      alignment: this._alignment,\n      padding: this._padding,\n      spacing: this._spacing,\n      widthFitting: this._widthFitting,\n      heightFitting: this._heightFitting,\n      wrap: this._wrap,\n      containerSize: new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_2__.Vec2(containerWidth, containerHeight)\n    };\n    this._isPerformingReflow = true;\n    const layoutInfo = this._layoutCalculator.calculateLayout(elements, options);\n    this._isPerformingReflow = false;\n    this.fire('reflow', layoutInfo);\n  }\n  onEnable() {\n    this._scheduleReflow();\n  }\n  onRemove() {\n    this.entity.off('childinsert', this._onChildInsert, this);\n    this.entity.off('childremove', this._onChildRemove, this);\n    this._listenForReflowEvents(this.entity, 'off');\n    this.entity.children.forEach(child => {\n      this._listenForReflowEvents(child, 'off');\n    });\n    this.system.app.systems.element.off('add', this._onElementOrLayoutComponentAdd, this);\n    this.system.app.systems.element.off('beforeremove', this._onElementOrLayoutComponentRemove, this);\n    this.system.app.systems.layoutchild.off('add', this._onElementOrLayoutComponentAdd, this);\n    this.system.app.systems.layoutchild.off('beforeremove', this._onElementOrLayoutComponentRemove, this);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-group/component.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-group/constants.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-group/constants.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FITTING_BOTH\": () => (/* binding */ FITTING_BOTH),\n/* harmony export */   \"FITTING_NONE\": () => (/* binding */ FITTING_NONE),\n/* harmony export */   \"FITTING_SHRINK\": () => (/* binding */ FITTING_SHRINK),\n/* harmony export */   \"FITTING_STRETCH\": () => (/* binding */ FITTING_STRETCH)\n/* harmony export */ });\nconst FITTING_NONE = 0;\nconst FITTING_STRETCH = 1;\nconst FITTING_SHRINK = 2;\nconst FITTING_BOTH = 3;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-group/constants.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-group/data.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-group/data.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LayoutGroupComponentData\": () => (/* binding */ LayoutGroupComponentData)\n/* harmony export */ });\nclass LayoutGroupComponentData {\n  constructor() {\n    this.enabled = true;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-group/data.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-group/layout-calculator.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-group/layout-calculator.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LayoutCalculator\": () => (/* binding */ LayoutCalculator)\n/* harmony export */ });\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/math/vec4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec4.js\");\n/* harmony import */ var _scene_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../scene/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-group/constants.js\");\n\n\n\n\n\nconst AXIS_MAPPINGS = {};\nAXIS_MAPPINGS[_scene_constants_js__WEBPACK_IMPORTED_MODULE_0__.ORIENTATION_HORIZONTAL] = {\n  axis: 'x',\n  size: 'width',\n  calculatedSize: 'calculatedWidth',\n  minSize: 'minWidth',\n  maxSize: 'maxWidth',\n  fitting: 'widthFitting',\n  fittingProportion: 'fitWidthProportion'\n};\nAXIS_MAPPINGS[_scene_constants_js__WEBPACK_IMPORTED_MODULE_0__.ORIENTATION_VERTICAL] = {\n  axis: 'y',\n  size: 'height',\n  calculatedSize: 'calculatedHeight',\n  minSize: 'minHeight',\n  maxSize: 'maxHeight',\n  fitting: 'heightFitting',\n  fittingProportion: 'fitHeightProportion'\n};\nconst OPPOSITE_ORIENTATION = {};\nOPPOSITE_ORIENTATION[_scene_constants_js__WEBPACK_IMPORTED_MODULE_0__.ORIENTATION_HORIZONTAL] = _scene_constants_js__WEBPACK_IMPORTED_MODULE_0__.ORIENTATION_VERTICAL;\nOPPOSITE_ORIENTATION[_scene_constants_js__WEBPACK_IMPORTED_MODULE_0__.ORIENTATION_VERTICAL] = _scene_constants_js__WEBPACK_IMPORTED_MODULE_0__.ORIENTATION_HORIZONTAL;\nconst PROPERTY_DEFAULTS = {\n  minWidth: 0,\n  minHeight: 0,\n  maxWidth: Number.POSITIVE_INFINITY,\n  maxHeight: Number.POSITIVE_INFINITY,\n  width: null,\n  height: null,\n  fitWidthProportion: 0,\n  fitHeightProportion: 0\n};\nconst FITTING_ACTION = {\n  NONE: 'NONE',\n  APPLY_STRETCHING: 'APPLY_STRETCHING',\n  APPLY_SHRINKING: 'APPLY_SHRINKING'\n};\nconst availableSpace = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_1__.Vec2();\nfunction createCalculator(orientation) {\n  let options;\n  const a = AXIS_MAPPINGS[orientation];\n  const b = AXIS_MAPPINGS[OPPOSITE_ORIENTATION[orientation]];\n  function minExtentA(element, size) {\n    return -size[a.size] * element.pivot[a.axis];\n  }\n  function minExtentB(element, size) {\n    return -size[b.size] * element.pivot[b.axis];\n  }\n  function maxExtentA(element, size) {\n    return size[a.size] * (1 - element.pivot[a.axis]);\n  }\n  function calculateAll(allElements, layoutOptions) {\n    allElements = allElements.filter(shouldIncludeInLayout);\n    options = layoutOptions;\n    availableSpace.x = options.containerSize.x - options.padding.x - options.padding.z;\n    availableSpace.y = options.containerSize.y - options.padding.y - options.padding.w;\n    resetAnchors(allElements);\n    const lines = reverseLinesIfRequired(splitLines(allElements));\n    const sizes = calculateSizesOnAxisB(lines, calculateSizesOnAxisA(lines));\n    const positions = calculateBasePositions(lines, sizes);\n    applyAlignmentAndPadding(lines, sizes, positions);\n    applySizesAndPositions(lines, sizes, positions);\n    return createLayoutInfo(lines);\n  }\n  function shouldIncludeInLayout(element) {\n    const layoutChildComponent = element.entity.layoutchild;\n    return !layoutChildComponent || !layoutChildComponent.enabled || !layoutChildComponent.excludeFromLayout;\n  }\n  function resetAnchors(allElements) {\n    for (let i = 0; i < allElements.length; ++i) {\n      const element = allElements[i];\n      const anchor = element.anchor;\n      if (anchor.x !== 0 || anchor.y !== 0 || anchor.z !== 0 || anchor.w !== 0) {\n        element.anchor = _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_2__.Vec4.ZERO;\n      }\n    }\n  }\n  function splitLines(allElements) {\n    if (!options.wrap) {\n      return [allElements];\n    }\n    const lines = [[]];\n    const sizes = getElementSizeProperties(allElements);\n    let runningSize = 0;\n    const allowOverrun = options[a.fitting] === _constants_js__WEBPACK_IMPORTED_MODULE_3__.FITTING_SHRINK;\n    for (let i = 0; i < allElements.length; ++i) {\n      if (lines[lines.length - 1].length > 0) {\n        runningSize += options.spacing[a.axis];\n      }\n      const idealElementSize = sizes[i][a.size];\n      runningSize += idealElementSize;\n      if (!allowOverrun && runningSize > availableSpace[a.axis] && lines[lines.length - 1].length !== 0) {\n        runningSize = idealElementSize;\n        lines.push([]);\n      }\n      lines[lines.length - 1].push(allElements[i]);\n      if (allowOverrun && runningSize > availableSpace[a.axis] && i !== allElements.length - 1) {\n        runningSize = 0;\n        lines.push([]);\n      }\n    }\n    return lines;\n  }\n  function reverseLinesIfRequired(lines) {\n    const reverseAxisA = options.orientation === _scene_constants_js__WEBPACK_IMPORTED_MODULE_0__.ORIENTATION_HORIZONTAL && options.reverseX || options.orientation === _scene_constants_js__WEBPACK_IMPORTED_MODULE_0__.ORIENTATION_VERTICAL && options.reverseY;\n    const reverseAxisB = options.orientation === _scene_constants_js__WEBPACK_IMPORTED_MODULE_0__.ORIENTATION_HORIZONTAL && options.reverseY || options.orientation === _scene_constants_js__WEBPACK_IMPORTED_MODULE_0__.ORIENTATION_VERTICAL && options.reverseX;\n    if (reverseAxisA) {\n      for (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {\n        if (reverseAxisA) {\n          lines[lineIndex].reverse();\n        }\n      }\n    }\n    if (reverseAxisB) {\n      lines.reverse();\n    }\n    return lines;\n  }\n  function calculateSizesOnAxisA(lines) {\n    const sizesAllLines = [];\n    for (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {\n      const line = lines[lineIndex];\n      const sizesThisLine = getElementSizeProperties(line);\n      const idealRequiredSpace = calculateTotalSpace(sizesThisLine, a);\n      const fittingAction = determineFittingAction(options[a.fitting], idealRequiredSpace, availableSpace[a.axis]);\n      if (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {\n        stretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);\n      } else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {\n        shrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);\n      }\n      sizesAllLines.push(sizesThisLine);\n    }\n    return sizesAllLines;\n  }\n  function calculateSizesOnAxisB(lines, sizesAllLines) {\n    const largestElementsForEachLine = [];\n    const largestSizesForEachLine = [];\n    for (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {\n      const line = lines[lineIndex];\n      line.largestElement = null;\n      line.largestSize = {\n        width: Number.NEGATIVE_INFINITY,\n        height: Number.NEGATIVE_INFINITY\n      };\n      for (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {\n        const sizesThisElement = sizesAllLines[lineIndex][elementIndex];\n        if (sizesThisElement[b.size] > line.largestSize[b.size]) {\n          line.largestElement = line[elementIndex];\n          line.largestSize = sizesThisElement;\n        }\n      }\n      largestElementsForEachLine.push(line.largestElement);\n      largestSizesForEachLine.push(line.largestSize);\n    }\n    const idealRequiredSpace = calculateTotalSpace(largestSizesForEachLine, b);\n    const fittingAction = determineFittingAction(options[b.fitting], idealRequiredSpace, availableSpace[b.axis]);\n    if (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {\n      stretchSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);\n    } else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {\n      shrinkSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);\n    }\n    for (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {\n      const line = lines[lineIndex];\n      for (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {\n        const sizesForThisElement = sizesAllLines[lineIndex][elementIndex];\n        const currentSize = sizesForThisElement[b.size];\n        const availableSize = lines.length === 1 ? availableSpace[b.axis] : line.largestSize[b.size];\n        const elementFittingAction = determineFittingAction(options[b.fitting], currentSize, availableSize);\n        if (elementFittingAction === FITTING_ACTION.APPLY_STRETCHING) {\n          sizesForThisElement[b.size] = Math.min(availableSize, sizesForThisElement[b.maxSize]);\n        } else if (elementFittingAction === FITTING_ACTION.APPLY_SHRINKING) {\n          sizesForThisElement[b.size] = Math.max(availableSize, sizesForThisElement[b.minSize]);\n        }\n      }\n    }\n    return sizesAllLines;\n  }\n  function determineFittingAction(fittingMode, currentSize, availableSize) {\n    switch (fittingMode) {\n      case _constants_js__WEBPACK_IMPORTED_MODULE_3__.FITTING_NONE:\n        return FITTING_ACTION.NONE;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_3__.FITTING_STRETCH:\n        if (currentSize < availableSize) {\n          return FITTING_ACTION.APPLY_STRETCHING;\n        }\n        return FITTING_ACTION.NONE;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_3__.FITTING_SHRINK:\n        if (currentSize >= availableSize) {\n          return FITTING_ACTION.APPLY_SHRINKING;\n        }\n        return FITTING_ACTION.NONE;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_3__.FITTING_BOTH:\n        if (currentSize < availableSize) {\n          return FITTING_ACTION.APPLY_STRETCHING;\n        }\n        return FITTING_ACTION.APPLY_SHRINKING;\n      default:\n        throw new Error(`Unrecognized fitting mode: ${fittingMode}`);\n    }\n  }\n  function calculateTotalSpace(sizes, axis) {\n    const totalSizes = sumValues(sizes, axis.size);\n    const totalSpacing = (sizes.length - 1) * options.spacing[axis.axis];\n    return totalSizes + totalSpacing;\n  }\n  function stretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {\n    const ascendingMaxSizeOrder = getTraversalOrder(sizesThisLine, axis.maxSize);\n    const fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);\n    const fittingProportionSums = createSumArray(fittingProportions, ascendingMaxSizeOrder);\n    let remainingUndershoot = availableSpace[axis.axis] - idealRequiredSpace;\n    for (let i = 0; i < sizesThisLine.length; ++i) {\n      const index = ascendingMaxSizeOrder[i];\n      const targetIncrease = calculateAdjustment(index, remainingUndershoot, fittingProportions, fittingProportionSums);\n      const targetSize = sizesThisLine[index][axis.size] + targetIncrease;\n      const maxSize = sizesThisLine[index][axis.maxSize];\n      const actualSize = Math.min(targetSize, maxSize);\n      sizesThisLine[index][axis.size] = actualSize;\n      const actualIncrease = Math.max(targetSize - actualSize, 0);\n      const appliedIncrease = targetIncrease - actualIncrease;\n      remainingUndershoot -= appliedIncrease;\n    }\n  }\n  function shrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {\n    const descendingMinSizeOrder = getTraversalOrder(sizesThisLine, axis.minSize, true);\n    const fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);\n    const inverseFittingProportions = invertNormalizedValues(fittingProportions);\n    const inverseFittingProportionSums = createSumArray(inverseFittingProportions, descendingMinSizeOrder);\n    let remainingOvershoot = idealRequiredSpace - availableSpace[axis.axis];\n    for (let i = 0; i < sizesThisLine.length; ++i) {\n      const index = descendingMinSizeOrder[i];\n      const targetReduction = calculateAdjustment(index, remainingOvershoot, inverseFittingProportions, inverseFittingProportionSums);\n      const targetSize = sizesThisLine[index][axis.size] - targetReduction;\n      const minSize = sizesThisLine[index][axis.minSize];\n      const actualSize = Math.max(targetSize, minSize);\n      sizesThisLine[index][axis.size] = actualSize;\n      const actualReduction = Math.max(actualSize - targetSize, 0);\n      const appliedReduction = targetReduction - actualReduction;\n      remainingOvershoot -= appliedReduction;\n    }\n  }\n  function calculateAdjustment(index, remainingAdjustment, fittingProportions, fittingProportionSums) {\n    const proportion = fittingProportions[index];\n    const sumOfRemainingProportions = fittingProportionSums[index];\n    if (Math.abs(proportion) < 1e-5 && Math.abs(sumOfRemainingProportions) < 1e-5) {\n      return remainingAdjustment;\n    }\n    return remainingAdjustment * proportion / sumOfRemainingProportions;\n  }\n  function calculateBasePositions(lines, sizes) {\n    const cursor = {};\n    cursor[a.axis] = 0;\n    cursor[b.axis] = 0;\n    lines[a.size] = Number.NEGATIVE_INFINITY;\n    const positionsAllLines = [];\n    for (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {\n      const line = lines[lineIndex];\n      if (line.length === 0) {\n        positionsAllLines.push([]);\n        continue;\n      }\n      const positionsThisLine = [];\n      const sizesThisLine = sizes[lineIndex];\n      for (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {\n        const element = line[elementIndex];\n        const sizesThisElement = sizesThisLine[elementIndex];\n        cursor[b.axis] -= minExtentB(element, sizesThisElement);\n        cursor[a.axis] -= minExtentA(element, sizesThisElement);\n        positionsThisLine[elementIndex] = {};\n        positionsThisLine[elementIndex][a.axis] = cursor[a.axis];\n        positionsThisLine[elementIndex][b.axis] = cursor[b.axis];\n        cursor[b.axis] += minExtentB(element, sizesThisElement);\n        cursor[a.axis] += maxExtentA(element, sizesThisElement) + options.spacing[a.axis];\n      }\n      line[a.size] = cursor[a.axis] - options.spacing[a.axis];\n      line[b.size] = line.largestSize[b.size];\n      lines[a.size] = Math.max(lines[a.size], line[a.size]);\n      cursor[a.axis] = 0;\n      cursor[b.axis] += line[b.size] + options.spacing[b.axis];\n      positionsAllLines.push(positionsThisLine);\n    }\n    lines[b.size] = cursor[b.axis] - options.spacing[b.axis];\n    return positionsAllLines;\n  }\n  function applyAlignmentAndPadding(lines, sizes, positions) {\n    const alignmentA = options.alignment[a.axis];\n    const alignmentB = options.alignment[b.axis];\n    const paddingA = options.padding[a.axis];\n    const paddingB = options.padding[b.axis];\n    for (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {\n      const line = lines[lineIndex];\n      const sizesThisLine = sizes[lineIndex];\n      const positionsThisLine = positions[lineIndex];\n      const axisAOffset = (availableSpace[a.axis] - line[a.size]) * alignmentA + paddingA;\n      const axisBOffset = (availableSpace[b.axis] - lines[b.size]) * alignmentB + paddingB;\n      for (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {\n        const withinLineAxisBOffset = (line[b.size] - sizesThisLine[elementIndex][b.size]) * options.alignment[b.axis];\n        positionsThisLine[elementIndex][a.axis] += axisAOffset;\n        positionsThisLine[elementIndex][b.axis] += axisBOffset + withinLineAxisBOffset;\n      }\n    }\n  }\n  function applySizesAndPositions(lines, sizes, positions) {\n    for (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {\n      const line = lines[lineIndex];\n      const sizesThisLine = sizes[lineIndex];\n      const positionsThisLine = positions[lineIndex];\n      for (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {\n        const element = line[elementIndex];\n        element[a.calculatedSize] = sizesThisLine[elementIndex][a.size];\n        element[b.calculatedSize] = sizesThisLine[elementIndex][b.size];\n        if (options.orientation === _scene_constants_js__WEBPACK_IMPORTED_MODULE_0__.ORIENTATION_HORIZONTAL) {\n          element.entity.setLocalPosition(positionsThisLine[elementIndex][a.axis], positionsThisLine[elementIndex][b.axis], element.entity.getLocalPosition().z);\n        } else {\n          element.entity.setLocalPosition(positionsThisLine[elementIndex][b.axis], positionsThisLine[elementIndex][a.axis], element.entity.getLocalPosition().z);\n        }\n      }\n    }\n  }\n  function createLayoutInfo(lines) {\n    const layoutWidth = lines.width;\n    const layoutHeight = lines.height;\n    const xOffset = (availableSpace.x - layoutWidth) * options.alignment.x + options.padding.x;\n    const yOffset = (availableSpace.y - layoutHeight) * options.alignment.y + options.padding.y;\n    return {\n      bounds: new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_2__.Vec4(xOffset, yOffset, layoutWidth, layoutHeight)\n    };\n  }\n  function getElementSizeProperties(elements) {\n    const sizeProperties = [];\n    for (let i = 0; i < elements.length; ++i) {\n      const element = elements[i];\n      const minWidth = Math.max(getProperty(element, 'minWidth'), 0);\n      const minHeight = Math.max(getProperty(element, 'minHeight'), 0);\n      const maxWidth = Math.max(getProperty(element, 'maxWidth'), minWidth);\n      const maxHeight = Math.max(getProperty(element, 'maxHeight'), minHeight);\n      const width = clamp(getProperty(element, 'width'), minWidth, maxWidth);\n      const height = clamp(getProperty(element, 'height'), minHeight, maxHeight);\n      const fitWidthProportion = getProperty(element, 'fitWidthProportion');\n      const fitHeightProportion = getProperty(element, 'fitHeightProportion');\n      sizeProperties.push({\n        minWidth: minWidth,\n        minHeight: minHeight,\n        maxWidth: maxWidth,\n        maxHeight: maxHeight,\n        width: width,\n        height: height,\n        fitWidthProportion: fitWidthProportion,\n        fitHeightProportion: fitHeightProportion\n      });\n    }\n    return sizeProperties;\n  }\n  function getProperty(element, propertyName) {\n    const layoutChildComponent = element.entity.layoutchild;\n    if (layoutChildComponent && layoutChildComponent.enabled && layoutChildComponent[propertyName] !== undefined && layoutChildComponent[propertyName] !== null) {\n      return layoutChildComponent[propertyName];\n    } else if (element[propertyName] !== undefined) {\n      return element[propertyName];\n    }\n    return PROPERTY_DEFAULTS[propertyName];\n  }\n  function clamp(value, min, max) {\n    return Math.min(Math.max(value, min), max);\n  }\n  function sumValues(items, propertyName) {\n    return items.reduce(function (accumulator, current) {\n      return accumulator + current[propertyName];\n    }, 0);\n  }\n  function getNormalizedValues(items, propertyName) {\n    const sum = sumValues(items, propertyName);\n    const normalizedValues = [];\n    const numItems = items.length;\n    if (sum === 0) {\n      for (let i = 0; i < numItems; ++i) {\n        normalizedValues.push(1 / numItems);\n      }\n    } else {\n      for (let i = 0; i < numItems; ++i) {\n        normalizedValues.push(items[i][propertyName] / sum);\n      }\n    }\n    return normalizedValues;\n  }\n  function invertNormalizedValues(values) {\n    if (values.length === 1) {\n      return [1];\n    }\n    const invertedValues = [];\n    const numValues = values.length;\n    for (let i = 0; i < numValues; ++i) {\n      invertedValues.push((1 - values[i]) / (numValues - 1));\n    }\n    return invertedValues;\n  }\n  function getTraversalOrder(items, orderBy, descending) {\n    items.forEach(assignIndex);\n    return items.slice().sort(function (itemA, itemB) {\n      return descending ? itemB[orderBy] - itemA[orderBy] : itemA[orderBy] - itemB[orderBy];\n    }).map(getIndex);\n  }\n  function assignIndex(item, index) {\n    item.index = index;\n  }\n  function getIndex(item) {\n    return item.index;\n  }\n  function createSumArray(values, order) {\n    const sumArray = [];\n    sumArray[order[values.length - 1]] = values[order[values.length - 1]];\n    for (let i = values.length - 2; i >= 0; --i) {\n      sumArray[order[i]] = sumArray[order[i + 1]] + values[order[i]];\n    }\n    return sumArray;\n  }\n  return calculateAll;\n}\nconst CALCULATE_FNS = {};\nCALCULATE_FNS[_scene_constants_js__WEBPACK_IMPORTED_MODULE_0__.ORIENTATION_HORIZONTAL] = createCalculator(_scene_constants_js__WEBPACK_IMPORTED_MODULE_0__.ORIENTATION_HORIZONTAL);\nCALCULATE_FNS[_scene_constants_js__WEBPACK_IMPORTED_MODULE_0__.ORIENTATION_VERTICAL] = createCalculator(_scene_constants_js__WEBPACK_IMPORTED_MODULE_0__.ORIENTATION_VERTICAL);\nclass LayoutCalculator {\n  calculateLayout(elements, options) {\n    const calculateFn = CALCULATE_FNS[options.orientation];\n    if (!calculateFn) {\n      throw new Error('Unrecognized orientation value: ' + options.orientation);\n    } else {\n      return calculateFn(elements, options);\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-group/layout-calculator.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-group/system.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-group/system.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LayoutGroupComponentSystem\": () => (/* binding */ LayoutGroupComponentSystem)\n/* harmony export */ });\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/math/vec4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec4.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/system.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-group/component.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-group/data.js\");\n\n\n\n\n\n\n\nconst _schema = ['enabled'];\nconst MAX_ITERATIONS = 100;\nclass LayoutGroupComponentSystem extends _system_js__WEBPACK_IMPORTED_MODULE_0__.ComponentSystem {\n  constructor(app) {\n    super(app);\n    this.id = 'layoutgroup';\n    this.ComponentType = _component_js__WEBPACK_IMPORTED_MODULE_1__.LayoutGroupComponent;\n    this.DataType = _data_js__WEBPACK_IMPORTED_MODULE_2__.LayoutGroupComponentData;\n    this.schema = _schema;\n    this._reflowQueue = [];\n    this.on('beforeremove', this._onRemoveComponent, this);\n    this.app.systems.on('postUpdate', this._onPostUpdate, this);\n  }\n  initializeComponentData(component, data, properties) {\n    if (data.enabled !== undefined) component.enabled = data.enabled;\n    if (data.orientation !== undefined) component.orientation = data.orientation;\n    if (data.reverseX !== undefined) component.reverseX = data.reverseX;\n    if (data.reverseY !== undefined) component.reverseY = data.reverseY;\n    if (data.alignment !== undefined) {\n      component.alignment = Array.isArray(data.alignment) ? new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_3__.Vec2(data.alignment) : data.alignment;\n    }\n    if (data.padding !== undefined) {\n      component.padding = Array.isArray(data.padding) ? new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_4__.Vec4(data.padding) : data.padding;\n    }\n    if (data.spacing !== undefined) {\n      component.spacing = Array.isArray(data.spacing) ? new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_3__.Vec2(data.spacing) : data.spacing;\n    }\n    if (data.widthFitting !== undefined) component.widthFitting = data.widthFitting;\n    if (data.heightFitting !== undefined) component.heightFitting = data.heightFitting;\n    if (data.wrap !== undefined) component.wrap = data.wrap;\n    super.initializeComponentData(component, data, properties);\n  }\n  cloneComponent(entity, clone) {\n    const layoutGroup = entity.layoutgroup;\n    return this.addComponent(clone, {\n      enabled: layoutGroup.enabled,\n      orientation: layoutGroup.orientation,\n      reverseX: layoutGroup.reverseX,\n      reverseY: layoutGroup.reverseY,\n      alignment: layoutGroup.alignment,\n      padding: layoutGroup.padding,\n      spacing: layoutGroup.spacing,\n      widthFitting: layoutGroup.widthFitting,\n      heightFitting: layoutGroup.heightFitting,\n      wrap: layoutGroup.wrap\n    });\n  }\n  scheduleReflow(component) {\n    if (this._reflowQueue.indexOf(component) === -1) {\n      this._reflowQueue.push(component);\n    }\n  }\n  _onPostUpdate() {\n    this._processReflowQueue();\n  }\n  _processReflowQueue() {\n    if (this._reflowQueue.length === 0) {\n      return;\n    }\n    let iterationCount = 0;\n    while (this._reflowQueue.length > 0) {\n      const queue = this._reflowQueue.slice();\n      this._reflowQueue.length = 0;\n      queue.sort(function (componentA, componentB) {\n        return componentA.entity.graphDepth - componentB.entity.graphDepth;\n      });\n      for (let i = 0; i < queue.length; ++i) {\n        queue[i].reflow();\n      }\n      if (++iterationCount >= MAX_ITERATIONS) {\n        console.warn('Max reflow iterations limit reached, bailing.');\n        break;\n      }\n    }\n  }\n  _onRemoveComponent(entity, component) {\n    component.onRemove();\n  }\n  destroy() {\n    super.destroy();\n    this.app.systems.off('postUpdate', this._onPostUpdate, this);\n  }\n}\n_component_js__WEBPACK_IMPORTED_MODULE_5__.Component._buildAccessors(_component_js__WEBPACK_IMPORTED_MODULE_1__.LayoutGroupComponent.prototype, _schema);\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/layout-group/system.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/light/component.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/light/component.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LightComponent\": () => (/* binding */ LightComponent),\n/* harmony export */   \"_lightProps\": () => (/* binding */ _lightProps),\n/* harmony export */   \"_lightPropsDefault\": () => (/* binding */ _lightPropsDefault)\n/* harmony export */ });\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _core_math_color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/math/color.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n/* harmony import */ var _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/math/vec4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec4.js\");\n/* harmony import */ var _scene_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../scene/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _asset_asset_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../asset/asset.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n\n\n\n\n\n\n\nconst _lightProps = [];\nconst _lightPropsDefault = [];\nclass LightComponent extends _component_js__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(system, entity) {\n    super(system, entity);\n    this._cookieAsset = null;\n    this._cookieAssetId = null;\n    this._cookieAssetAdd = false;\n    this._cookieMatrix = null;\n  }\n  addLightToLayers() {\n    for (let i = 0; i < this.layers.length; i++) {\n      const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n      if (layer) {\n        layer.addLight(this);\n      }\n    }\n  }\n  removeLightFromLayers() {\n    for (let i = 0; i < this.layers.length; i++) {\n      const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n      if (layer) {\n        layer.removeLight(this);\n      }\n    }\n  }\n  onLayersChanged(oldComp, newComp) {\n    if (this.enabled && this.entity.enabled) {\n      this.addLightToLayers();\n    }\n    oldComp.off('add', this.onLayerAdded, this);\n    oldComp.off('remove', this.onLayerRemoved, this);\n    newComp.on('add', this.onLayerAdded, this);\n    newComp.on('remove', this.onLayerRemoved, this);\n  }\n  onLayerAdded(layer) {\n    const index = this.layers.indexOf(layer.id);\n    if (index >= 0 && this.enabled && this.entity.enabled) {\n      layer.addLight(this);\n    }\n  }\n  onLayerRemoved(layer) {\n    const index = this.layers.indexOf(layer.id);\n    if (index >= 0) {\n      layer.removeLight(this);\n    }\n  }\n  refreshProperties() {\n    for (let i = 0; i < _lightProps.length; i++) {\n      const name = _lightProps[i];\n      this[name] = this[name];\n    }\n    if (this.enabled && this.entity.enabled) this.onEnable();\n  }\n  onCookieAssetSet() {\n    let forceLoad = false;\n    if (this._cookieAsset.type === 'cubemap' && !this._cookieAsset.loadFaces) {\n      this._cookieAsset.loadFaces = true;\n      forceLoad = true;\n    }\n    if (!this._cookieAsset.resource || forceLoad) this.system.app.assets.load(this._cookieAsset);\n    if (this._cookieAsset.resource) this.onCookieAssetLoad();\n  }\n  onCookieAssetAdd(asset) {\n    if (this._cookieAssetId !== asset.id) return;\n    this._cookieAsset = asset;\n    if (this.light.enabled) this.onCookieAssetSet();\n    this._cookieAsset.on('load', this.onCookieAssetLoad, this);\n    this._cookieAsset.on('remove', this.onCookieAssetRemove, this);\n  }\n  onCookieAssetLoad() {\n    if (!this._cookieAsset || !this._cookieAsset.resource) return;\n    this.cookie = this._cookieAsset.resource;\n  }\n  onCookieAssetRemove() {\n    if (!this._cookieAssetId) return;\n    if (this._cookieAssetAdd) {\n      this.system.app.assets.off('add:' + this._cookieAssetId, this.onCookieAssetAdd, this);\n      this._cookieAssetAdd = false;\n    }\n    if (this._cookieAsset) {\n      this._cookieAsset.off('load', this.onCookieAssetLoad, this);\n      this._cookieAsset.off('remove', this.onCookieAssetRemove, this);\n      this._cookieAsset = null;\n    }\n    this.cookie = null;\n  }\n  onEnable() {\n    this.light.enabled = true;\n    this.system.app.scene.on('set:layers', this.onLayersChanged, this);\n    if (this.system.app.scene.layers) {\n      this.system.app.scene.layers.on('add', this.onLayerAdded, this);\n      this.system.app.scene.layers.on('remove', this.onLayerRemoved, this);\n    }\n    if (this.enabled && this.entity.enabled) {\n      this.addLightToLayers();\n    }\n    if (this._cookieAsset && !this.cookie) this.onCookieAssetSet();\n  }\n  onDisable() {\n    this.light.enabled = false;\n    this.system.app.scene.off('set:layers', this.onLayersChanged, this);\n    if (this.system.app.scene.layers) {\n      this.system.app.scene.layers.off('add', this.onLayerAdded, this);\n      this.system.app.scene.layers.off('remove', this.onLayerRemoved, this);\n    }\n    this.removeLightFromLayers();\n  }\n  onRemove() {\n    this.onDisable();\n    this.light.destroy();\n    this.cookieAsset = null;\n  }\n  set shadowUpdateOverrides(values) {\n    this.light.shadowUpdateOverrides = values;\n  }\n  get shadowUpdateOverrides() {\n    return this.light.shadowUpdateOverrides;\n  }\n}\nfunction _defineProperty(name, defaultValue, setFunc, skipEqualsCheck) {\n  const c = LightComponent.prototype;\n  _lightProps.push(name);\n  _lightPropsDefault.push(defaultValue);\n  Object.defineProperty(c, name, {\n    get: function () {\n      return this.data[name];\n    },\n    set: function (value) {\n      const data = this.data;\n      const oldValue = data[name];\n      if (!skipEqualsCheck && oldValue === value) return;\n      data[name] = value;\n      if (setFunc) setFunc.call(this, value, oldValue);\n    },\n    configurable: true\n  });\n}\nfunction _defineProps() {\n  _defineProperty('enabled', true, function (newValue, oldValue) {\n    this.onSetEnabled(null, oldValue, newValue);\n  });\n  _defineProperty('light', null);\n  _defineProperty('type', 'directional', function (newValue, oldValue) {\n    this.system.changeType(this, oldValue, newValue);\n    this.refreshProperties();\n  });\n  _defineProperty('color', new _core_math_color_js__WEBPACK_IMPORTED_MODULE_1__.Color(1, 1, 1), function (newValue, oldValue) {\n    this.light.setColor(newValue);\n  }, true);\n  _defineProperty('intensity', 1, function (newValue, oldValue) {\n    this.light.intensity = newValue;\n  });\n  _defineProperty('luminance', 0, function (newValue, oldValue) {\n    this.light.luminance = newValue;\n  });\n  _defineProperty('shape', _scene_constants_js__WEBPACK_IMPORTED_MODULE_2__.LIGHTSHAPE_PUNCTUAL, function (newValue, oldValue) {\n    this.light.shape = newValue;\n  });\n  _defineProperty('castShadows', false, function (newValue, oldValue) {\n    this.light.castShadows = newValue;\n  });\n  _defineProperty('shadowDistance', 40, function (newValue, oldValue) {\n    this.light.shadowDistance = newValue;\n  });\n  _defineProperty('shadowIntensity', 1, function (newValue, oldValue) {\n    this.light.shadowIntensity = newValue;\n  });\n  _defineProperty('shadowResolution', 1024, function (newValue, oldValue) {\n    this.light.shadowResolution = newValue;\n  });\n  _defineProperty('shadowBias', 0.05, function (newValue, oldValue) {\n    this.light.shadowBias = -0.01 * _core_math_math_js__WEBPACK_IMPORTED_MODULE_3__.math.clamp(newValue, 0, 1);\n  });\n  _defineProperty('numCascades', 1, function (newValue, oldValue) {\n    this.light.numCascades = _core_math_math_js__WEBPACK_IMPORTED_MODULE_3__.math.clamp(Math.floor(newValue), 1, 4);\n  });\n  _defineProperty('bakeNumSamples', 1, function (newValue, oldValue) {\n    this.light.bakeNumSamples = _core_math_math_js__WEBPACK_IMPORTED_MODULE_3__.math.clamp(Math.floor(newValue), 1, 255);\n  });\n  _defineProperty('bakeArea', 0, function (newValue, oldValue) {\n    this.light.bakeArea = _core_math_math_js__WEBPACK_IMPORTED_MODULE_3__.math.clamp(newValue, 0, 180);\n  });\n  _defineProperty('cascadeDistribution', 0.5, function (newValue, oldValue) {\n    this.light.cascadeDistribution = _core_math_math_js__WEBPACK_IMPORTED_MODULE_3__.math.clamp(newValue, 0, 1);\n  });\n  _defineProperty('normalOffsetBias', 0, function (newValue, oldValue) {\n    this.light.normalOffsetBias = _core_math_math_js__WEBPACK_IMPORTED_MODULE_3__.math.clamp(newValue, 0, 1);\n  });\n  _defineProperty('range', 10, function (newValue, oldValue) {\n    this.light.attenuationEnd = newValue;\n  });\n  _defineProperty('innerConeAngle', 40, function (newValue, oldValue) {\n    this.light.innerConeAngle = newValue;\n  });\n  _defineProperty('outerConeAngle', 45, function (newValue, oldValue) {\n    this.light.outerConeAngle = newValue;\n  });\n  _defineProperty('falloffMode', _scene_constants_js__WEBPACK_IMPORTED_MODULE_2__.LIGHTFALLOFF_LINEAR, function (newValue, oldValue) {\n    this.light.falloffMode = newValue;\n  });\n  _defineProperty('shadowType', _scene_constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADOW_PCF3, function (newValue, oldValue) {\n    this.light.shadowType = newValue;\n  });\n  _defineProperty('vsmBlurSize', 11, function (newValue, oldValue) {\n    this.light.vsmBlurSize = newValue;\n  });\n  _defineProperty('vsmBlurMode', _scene_constants_js__WEBPACK_IMPORTED_MODULE_2__.BLUR_GAUSSIAN, function (newValue, oldValue) {\n    this.light.vsmBlurMode = newValue;\n  });\n  _defineProperty('vsmBias', 0.01 * 0.25, function (newValue, oldValue) {\n    this.light.vsmBias = _core_math_math_js__WEBPACK_IMPORTED_MODULE_3__.math.clamp(newValue, 0, 1);\n  });\n  _defineProperty('cookieAsset', null, function (newValue, oldValue) {\n    if (this._cookieAssetId && (newValue instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_4__.Asset && newValue.id === this._cookieAssetId || newValue === this._cookieAssetId)) return;\n    this.onCookieAssetRemove();\n    this._cookieAssetId = null;\n    if (newValue instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_4__.Asset) {\n      this.data.cookieAsset = newValue.id;\n      this._cookieAssetId = newValue.id;\n      this.onCookieAssetAdd(newValue);\n    } else if (typeof newValue === 'number') {\n      this._cookieAssetId = newValue;\n      const asset = this.system.app.assets.get(newValue);\n      if (asset) {\n        this.onCookieAssetAdd(asset);\n      } else {\n        this._cookieAssetAdd = true;\n        this.system.app.assets.on('add:' + this._cookieAssetId, this.onCookieAssetAdd, this);\n      }\n    }\n  });\n  _defineProperty('cookie', null, function (newValue, oldValue) {\n    this.light.cookie = newValue;\n  });\n  _defineProperty('cookieIntensity', 1, function (newValue, oldValue) {\n    this.light.cookieIntensity = _core_math_math_js__WEBPACK_IMPORTED_MODULE_3__.math.clamp(newValue, 0, 1);\n  });\n  _defineProperty('cookieFalloff', true, function (newValue, oldValue) {\n    this.light.cookieFalloff = newValue;\n  });\n  _defineProperty('cookieChannel', 'rgb', function (newValue, oldValue) {\n    this.light.cookieChannel = newValue;\n  });\n  _defineProperty('cookieAngle', 0, function (newValue, oldValue) {\n    if (newValue !== 0 || this.cookieScale !== null) {\n      if (!this._cookieMatrix) this._cookieMatrix = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_5__.Vec4();\n      let scx = 1;\n      let scy = 1;\n      if (this.cookieScale) {\n        scx = this.cookieScale.x;\n        scy = this.cookieScale.y;\n      }\n      const c = Math.cos(newValue * _core_math_math_js__WEBPACK_IMPORTED_MODULE_3__.math.DEG_TO_RAD);\n      const s = Math.sin(newValue * _core_math_math_js__WEBPACK_IMPORTED_MODULE_3__.math.DEG_TO_RAD);\n      this._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);\n      this.light.cookieTransform = this._cookieMatrix;\n    } else {\n      this.light.cookieTransform = null;\n    }\n  });\n  _defineProperty('cookieScale', null, function (newValue, oldValue) {\n    if (newValue !== null || this.cookieAngle !== 0) {\n      if (!this._cookieMatrix) this._cookieMatrix = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_5__.Vec4();\n      const scx = newValue.x;\n      const scy = newValue.y;\n      const c = Math.cos(this.cookieAngle * _core_math_math_js__WEBPACK_IMPORTED_MODULE_3__.math.DEG_TO_RAD);\n      const s = Math.sin(this.cookieAngle * _core_math_math_js__WEBPACK_IMPORTED_MODULE_3__.math.DEG_TO_RAD);\n      this._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);\n      this.light.cookieTransform = this._cookieMatrix;\n    } else {\n      this.light.cookieTransform = null;\n    }\n  }, true);\n  _defineProperty('cookieOffset', null, function (newValue, oldValue) {\n    this.light.cookieOffset = newValue;\n  }, true);\n  _defineProperty('shadowUpdateMode', _scene_constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADOWUPDATE_REALTIME, function (newValue, oldValue) {\n    this.light.shadowUpdateMode = newValue;\n  }, true);\n  _defineProperty('mask', 1, function (newValue, oldValue) {\n    this.light.mask = newValue;\n  });\n  _defineProperty('affectDynamic', true, function (newValue, oldValue) {\n    if (newValue) {\n      this.light.mask |= _scene_constants_js__WEBPACK_IMPORTED_MODULE_2__.MASK_AFFECT_DYNAMIC;\n    } else {\n      this.light.mask &= ~_scene_constants_js__WEBPACK_IMPORTED_MODULE_2__.MASK_AFFECT_DYNAMIC;\n    }\n    this.light.layersDirty();\n  });\n  _defineProperty('affectLightmapped', false, function (newValue, oldValue) {\n    if (newValue) {\n      this.light.mask |= _scene_constants_js__WEBPACK_IMPORTED_MODULE_2__.MASK_AFFECT_LIGHTMAPPED;\n      if (this.bake) this.light.mask &= ~_scene_constants_js__WEBPACK_IMPORTED_MODULE_2__.MASK_BAKE;\n    } else {\n      this.light.mask &= ~_scene_constants_js__WEBPACK_IMPORTED_MODULE_2__.MASK_AFFECT_LIGHTMAPPED;\n      if (this.bake) this.light.mask |= _scene_constants_js__WEBPACK_IMPORTED_MODULE_2__.MASK_BAKE;\n    }\n  });\n  _defineProperty('bake', false, function (newValue, oldValue) {\n    if (newValue) {\n      this.light.mask |= _scene_constants_js__WEBPACK_IMPORTED_MODULE_2__.MASK_BAKE;\n      if (this.affectLightmapped) this.light.mask &= ~_scene_constants_js__WEBPACK_IMPORTED_MODULE_2__.MASK_AFFECT_LIGHTMAPPED;\n    } else {\n      this.light.mask &= ~_scene_constants_js__WEBPACK_IMPORTED_MODULE_2__.MASK_BAKE;\n      if (this.affectLightmapped) this.light.mask |= _scene_constants_js__WEBPACK_IMPORTED_MODULE_2__.MASK_AFFECT_LIGHTMAPPED;\n    }\n    this.light.layersDirty();\n  });\n  _defineProperty('bakeDir', true, function (newValue, oldValue) {\n    this.light.bakeDir = newValue;\n  });\n  _defineProperty('isStatic', false, function (newValue, oldValue) {\n    this.light.isStatic = newValue;\n  });\n  _defineProperty('layers', [_scene_constants_js__WEBPACK_IMPORTED_MODULE_2__.LAYERID_WORLD], function (newValue, oldValue) {\n    for (let i = 0; i < oldValue.length; i++) {\n      const layer = this.system.app.scene.layers.getLayerById(oldValue[i]);\n      if (!layer) continue;\n      layer.removeLight(this);\n    }\n    for (let i = 0; i < newValue.length; i++) {\n      const layer = this.system.app.scene.layers.getLayerById(newValue[i]);\n      if (!layer) continue;\n      if (this.enabled && this.entity.enabled) {\n        layer.addLight(this);\n      }\n    }\n  });\n}\n_defineProps();\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/light/component.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/light/data.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/light/data.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LightComponentData\": () => (/* binding */ LightComponentData)\n/* harmony export */ });\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/light/component.js\");\n\n\nclass LightComponentData {\n  constructor() {\n    const _props = _component_js__WEBPACK_IMPORTED_MODULE_0__._lightProps;\n    const _propsDefault = _component_js__WEBPACK_IMPORTED_MODULE_0__._lightPropsDefault;\n    for (let i = 0; i < _props.length; i++) {\n      const value = _propsDefault[i];\n      if (value && value.clone) {\n        this[_props[i]] = value.clone();\n      } else {\n        this[_props[i]] = value;\n      }\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/light/data.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/light/system.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/light/system.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LightComponentSystem\": () => (/* binding */ LightComponentSystem)\n/* harmony export */ });\n/* harmony import */ var _core_math_color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/math/color.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _scene_constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../scene/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _scene_light_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../scene/light.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/light.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/system.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/light/component.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/light/data.js\");\n\n\n\n\n\n\n\n\nclass LightComponentSystem extends _system_js__WEBPACK_IMPORTED_MODULE_0__.ComponentSystem {\n  constructor(app) {\n    super(app);\n    this.id = 'light';\n    this.ComponentType = _component_js__WEBPACK_IMPORTED_MODULE_1__.LightComponent;\n    this.DataType = _data_js__WEBPACK_IMPORTED_MODULE_2__.LightComponentData;\n    this.on('beforeremove', this._onRemoveComponent, this);\n  }\n  initializeComponentData(component, _data) {\n    const properties = _component_js__WEBPACK_IMPORTED_MODULE_1__._lightProps;\n    const data = {};\n    for (let i = 0, len = properties.length; i < len; i++) {\n      const property = properties[i];\n      data[property] = _data[property];\n    }\n    if (!data.type) data.type = component.data.type;\n    component.data.type = data.type;\n    if (data.layers && Array.isArray(data.layers)) {\n      data.layers = data.layers.slice(0);\n    }\n    if (data.color && Array.isArray(data.color)) data.color = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_3__.Color(data.color[0], data.color[1], data.color[2]);\n    if (data.cookieOffset && data.cookieOffset instanceof Array) data.cookieOffset = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_4__.Vec2(data.cookieOffset[0], data.cookieOffset[1]);\n    if (data.cookieScale && data.cookieScale instanceof Array) data.cookieScale = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_4__.Vec2(data.cookieScale[0], data.cookieScale[1]);\n    if (data.enable) {\n      console.warn('WARNING: enable: Property is deprecated. Set enabled property instead.');\n      data.enabled = data.enable;\n    }\n    if (!data.shape) {\n      data.shape = _scene_constants_js__WEBPACK_IMPORTED_MODULE_5__.LIGHTSHAPE_PUNCTUAL;\n    }\n    const light = new _scene_light_js__WEBPACK_IMPORTED_MODULE_6__.Light(this.app.graphicsDevice);\n    light.type = _scene_light_js__WEBPACK_IMPORTED_MODULE_6__.lightTypes[data.type];\n    light._node = component.entity;\n    light._scene = this.app.scene;\n    component.data.light = light;\n    super.initializeComponentData(component, data, properties);\n  }\n  _onRemoveComponent(entity, component) {\n    component.onRemove();\n  }\n  cloneComponent(entity, clone) {\n    const light = entity.light;\n    const data = [];\n    let name;\n    const _props = _component_js__WEBPACK_IMPORTED_MODULE_1__._lightProps;\n    for (let i = 0; i < _props.length; i++) {\n      name = _props[i];\n      if (name === 'light') continue;\n      if (light[name] && light[name].clone) {\n        data[name] = light[name].clone();\n      } else {\n        data[name] = light[name];\n      }\n    }\n    return this.addComponent(clone, data);\n  }\n  changeType(component, oldValue, newValue) {\n    if (oldValue !== newValue) {\n      component.light.type = _scene_light_js__WEBPACK_IMPORTED_MODULE_6__.lightTypes[newValue];\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/light/system.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/model/component.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/model/component.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ModelComponent\": () => (/* binding */ ModelComponent)\n/* harmony export */ });\n/* harmony import */ var _scene_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../scene/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _scene_batching_batch_group_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../scene/batching/batch-group.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/batching/batch-group.js\");\n/* harmony import */ var _scene_graph_node_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../scene/graph-node.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/graph-node.js\");\n/* harmony import */ var _scene_mesh_instance_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../scene/mesh-instance.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh-instance.js\");\n/* harmony import */ var _scene_model_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../scene/model.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/model.js\");\n/* harmony import */ var _scene_procedural_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../scene/procedural.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/procedural.js\");\n/* harmony import */ var _asset_asset_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../asset/asset.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n\n\n\n\n\n\n\n\n\n\nclass ModelComponent extends _component_js__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(system, entity) {\n    super(system, entity);\n    this._type = 'asset';\n    this._asset = null;\n    this._model = null;\n    this._mapping = {};\n    this._castShadows = true;\n    this._receiveShadows = true;\n    this._materialAsset = null;\n    this._material = void 0;\n    this._castShadowsLightmap = true;\n    this._lightmapped = false;\n    this._lightmapSizeMultiplier = 1;\n    this._isStatic = false;\n    this._layers = [_scene_constants_js__WEBPACK_IMPORTED_MODULE_1__.LAYERID_WORLD];\n    this._batchGroupId = -1;\n    this._customAabb = null;\n    this._area = null;\n    this._materialEvents = null;\n    this._clonedModel = false;\n    this._material = system.defaultMaterial;\n    entity.on('remove', this.onRemoveChild, this);\n    entity.on('removehierarchy', this.onRemoveChild, this);\n    entity.on('insert', this.onInsertChild, this);\n    entity.on('inserthierarchy', this.onInsertChild, this);\n  }\n  set meshInstances(value) {\n    if (!this._model) return;\n    this._model.meshInstances = value;\n  }\n  get meshInstances() {\n    if (!this._model) return null;\n    return this._model.meshInstances;\n  }\n  set customAabb(value) {\n    this._customAabb = value;\n    if (this._model) {\n      const mi = this._model.meshInstances;\n      if (mi) {\n        for (let i = 0; i < mi.length; i++) {\n          mi[i].setCustomAabb(this._customAabb);\n        }\n      }\n    }\n  }\n  get customAabb() {\n    return this._customAabb;\n  }\n  set type(value) {\n    if (this._type === value) return;\n    this._area = null;\n    this._type = value;\n    if (value === 'asset') {\n      if (this._asset !== null) {\n        this._bindModelAsset(this._asset);\n      } else {\n        this.model = null;\n      }\n    } else {\n      const primData = (0,_scene_procedural_js__WEBPACK_IMPORTED_MODULE_2__.getShapePrimitive)(this.system.app.graphicsDevice, value);\n      this._area = primData.area;\n      const mesh = primData.mesh;\n      const node = new _scene_graph_node_js__WEBPACK_IMPORTED_MODULE_3__.GraphNode();\n      const model = new _scene_model_js__WEBPACK_IMPORTED_MODULE_4__.Model();\n      model.graph = node;\n      model.meshInstances = [new _scene_mesh_instance_js__WEBPACK_IMPORTED_MODULE_5__.MeshInstance(mesh, this._material, node)];\n      this.model = model;\n      this._asset = null;\n    }\n  }\n  get type() {\n    return this._type;\n  }\n  set asset(value) {\n    const assets = this.system.app.assets;\n    let _id = value;\n    if (value instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_6__.Asset) {\n      _id = value.id;\n    }\n    if (this._asset !== _id) {\n      if (this._asset) {\n        assets.off('add:' + this._asset, this._onModelAssetAdded, this);\n        const _prev = assets.get(this._asset);\n        if (_prev) {\n          this._unbindModelAsset(_prev);\n        }\n      }\n      this._asset = _id;\n      if (this._asset) {\n        const asset = assets.get(this._asset);\n        if (!asset) {\n          this.model = null;\n          assets.on('add:' + this._asset, this._onModelAssetAdded, this);\n        } else {\n          this._bindModelAsset(asset);\n        }\n      } else {\n        this.model = null;\n      }\n    }\n  }\n  get asset() {\n    return this._asset;\n  }\n  set model(value) {\n    if (this._model === value) return;\n    if (value && value._immutable) {\n      return;\n    }\n    if (this._model) {\n      this._model._immutable = false;\n      this.removeModelFromLayers();\n      this.entity.removeChild(this._model.getGraph());\n      delete this._model._entity;\n      if (this._clonedModel) {\n        this._model.destroy();\n        this._clonedModel = false;\n      }\n    }\n    this._model = value;\n    if (this._model) {\n      this._model._immutable = true;\n      const meshInstances = this._model.meshInstances;\n      for (let i = 0; i < meshInstances.length; i++) {\n        meshInstances[i].castShadow = this._castShadows;\n        meshInstances[i].receiveShadow = this._receiveShadows;\n        meshInstances[i].isStatic = this._isStatic;\n        meshInstances[i].setCustomAabb(this._customAabb);\n      }\n      this.lightmapped = this._lightmapped;\n      this.entity.addChild(this._model.graph);\n      if (this.enabled && this.entity.enabled) {\n        this.addModelToLayers();\n      }\n      this._model._entity = this.entity;\n      if (this.entity.animation) this.entity.animation.setModel(this._model);\n      if (this.entity.anim) {\n        this.entity.anim.rebind();\n      }\n      if (this.type === 'asset') {\n        this.mapping = this._mapping;\n      } else {\n        this._unsetMaterialEvents();\n      }\n    }\n  }\n  get model() {\n    return this._model;\n  }\n  set lightmapped(value) {\n    if (value !== this._lightmapped) {\n      this._lightmapped = value;\n      if (this._model) {\n        const mi = this._model.meshInstances;\n        for (let i = 0; i < mi.length; i++) {\n          mi[i].setLightmapped(value);\n        }\n      }\n    }\n  }\n  get lightmapped() {\n    return this._lightmapped;\n  }\n  set castShadows(value) {\n    if (this._castShadows === value) return;\n    const model = this._model;\n    if (model) {\n      const layers = this.layers;\n      const scene = this.system.app.scene;\n      if (this._castShadows && !value) {\n        for (let i = 0; i < layers.length; i++) {\n          const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n          if (!layer) continue;\n          layer.removeShadowCasters(model.meshInstances);\n        }\n      }\n      const meshInstances = model.meshInstances;\n      for (let i = 0; i < meshInstances.length; i++) {\n        meshInstances[i].castShadow = value;\n      }\n      if (!this._castShadows && value) {\n        for (let i = 0; i < layers.length; i++) {\n          const layer = scene.layers.getLayerById(layers[i]);\n          if (!layer) continue;\n          layer.addShadowCasters(model.meshInstances);\n        }\n      }\n    }\n    this._castShadows = value;\n  }\n  get castShadows() {\n    return this._castShadows;\n  }\n  set receiveShadows(value) {\n    if (this._receiveShadows === value) return;\n    this._receiveShadows = value;\n    if (this._model) {\n      const meshInstances = this._model.meshInstances;\n      for (let i = 0, len = meshInstances.length; i < len; i++) {\n        meshInstances[i].receiveShadow = value;\n      }\n    }\n  }\n  get receiveShadows() {\n    return this._receiveShadows;\n  }\n  set castShadowsLightmap(value) {\n    this._castShadowsLightmap = value;\n  }\n  get castShadowsLightmap() {\n    return this._castShadowsLightmap;\n  }\n  set lightmapSizeMultiplier(value) {\n    this._lightmapSizeMultiplier = value;\n  }\n  get lightmapSizeMultiplier() {\n    return this._lightmapSizeMultiplier;\n  }\n  set isStatic(value) {\n    if (this._isStatic === value) return;\n    this._isStatic = value;\n    if (this._model) {\n      const rcv = this._model.meshInstances;\n      for (let i = 0; i < rcv.length; i++) {\n        const m = rcv[i];\n        m.isStatic = value;\n      }\n    }\n  }\n  get isStatic() {\n    return this._isStatic;\n  }\n  set layers(value) {\n    const layers = this.system.app.scene.layers;\n    if (this.meshInstances) {\n      for (let i = 0; i < this._layers.length; i++) {\n        const layer = layers.getLayerById(this._layers[i]);\n        if (!layer) continue;\n        layer.removeMeshInstances(this.meshInstances);\n      }\n    }\n    this._layers.length = 0;\n    for (let i = 0; i < value.length; i++) {\n      this._layers[i] = value[i];\n    }\n    if (!this.enabled || !this.entity.enabled || !this.meshInstances) return;\n    for (let i = 0; i < this._layers.length; i++) {\n      const layer = layers.getLayerById(this._layers[i]);\n      if (!layer) continue;\n      layer.addMeshInstances(this.meshInstances);\n    }\n  }\n  get layers() {\n    return this._layers;\n  }\n  set batchGroupId(value) {\n    if (this._batchGroupId === value) return;\n    if (this.entity.enabled && this._batchGroupId >= 0) {\n      var _this$system$app$batc;\n      (_this$system$app$batc = this.system.app.batcher) == null ? void 0 : _this$system$app$batc.remove(_scene_batching_batch_group_js__WEBPACK_IMPORTED_MODULE_7__.BatchGroup.MODEL, this.batchGroupId, this.entity);\n    }\n    if (this.entity.enabled && value >= 0) {\n      var _this$system$app$batc2;\n      (_this$system$app$batc2 = this.system.app.batcher) == null ? void 0 : _this$system$app$batc2.insert(_scene_batching_batch_group_js__WEBPACK_IMPORTED_MODULE_7__.BatchGroup.MODEL, value, this.entity);\n    }\n    if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {\n      this.addModelToLayers();\n    }\n    this._batchGroupId = value;\n  }\n  get batchGroupId() {\n    return this._batchGroupId;\n  }\n  set materialAsset(value) {\n    let _id = value;\n    if (value instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_6__.Asset) {\n      _id = value.id;\n    }\n    const assets = this.system.app.assets;\n    if (_id !== this._materialAsset) {\n      if (this._materialAsset) {\n        assets.off('add:' + this._materialAsset, this._onMaterialAssetAdd, this);\n        const _prev = assets.get(this._materialAsset);\n        if (_prev) {\n          this._unbindMaterialAsset(_prev);\n        }\n      }\n      this._materialAsset = _id;\n      if (this._materialAsset) {\n        const asset = assets.get(this._materialAsset);\n        if (!asset) {\n          this._setMaterial(this.system.defaultMaterial);\n          assets.on('add:' + this._materialAsset, this._onMaterialAssetAdd, this);\n        } else {\n          this._bindMaterialAsset(asset);\n        }\n      } else {\n        this._setMaterial(this.system.defaultMaterial);\n      }\n    }\n  }\n  get materialAsset() {\n    return this._materialAsset;\n  }\n  set material(value) {\n    if (this._material === value) return;\n    this.materialAsset = null;\n    this._setMaterial(value);\n  }\n  get material() {\n    return this._material;\n  }\n  set mapping(value) {\n    if (this._type !== 'asset') return;\n    this._unsetMaterialEvents();\n    if (!value) value = {};\n    this._mapping = value;\n    if (!this._model) return;\n    const meshInstances = this._model.meshInstances;\n    const modelAsset = this.asset ? this.system.app.assets.get(this.asset) : null;\n    const assetMapping = modelAsset ? modelAsset.data.mapping : null;\n    let asset = null;\n    for (let i = 0, len = meshInstances.length; i < len; i++) {\n      if (value[i] !== undefined) {\n        if (value[i]) {\n          asset = this.system.app.assets.get(value[i]);\n          this._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);\n        } else {\n          meshInstances[i].material = this.system.defaultMaterial;\n        }\n      } else if (assetMapping) {\n        if (assetMapping[i] && (assetMapping[i].material || assetMapping[i].path)) {\n          if (assetMapping[i].material !== undefined) {\n            asset = this.system.app.assets.get(assetMapping[i].material);\n          } else if (assetMapping[i].path !== undefined) {\n            const url = this._getMaterialAssetUrl(assetMapping[i].path);\n            if (url) {\n              asset = this.system.app.assets.getByUrl(url);\n            }\n          }\n          this._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);\n        } else {\n          meshInstances[i].material = this.system.defaultMaterial;\n        }\n      }\n    }\n  }\n  get mapping() {\n    return this._mapping;\n  }\n  addModelToLayers() {\n    const layers = this.system.app.scene.layers;\n    for (let i = 0; i < this._layers.length; i++) {\n      const layer = layers.getLayerById(this._layers[i]);\n      if (layer) {\n        layer.addMeshInstances(this.meshInstances);\n      }\n    }\n  }\n  removeModelFromLayers() {\n    const layers = this.system.app.scene.layers;\n    for (let i = 0; i < this._layers.length; i++) {\n      const layer = layers.getLayerById(this._layers[i]);\n      if (!layer) continue;\n      layer.removeMeshInstances(this.meshInstances);\n    }\n  }\n  onRemoveChild() {\n    if (this._model) this.removeModelFromLayers();\n  }\n  onInsertChild() {\n    if (this._model && this.enabled && this.entity.enabled) this.addModelToLayers();\n  }\n  onRemove() {\n    this.asset = null;\n    this.model = null;\n    this.materialAsset = null;\n    this._unsetMaterialEvents();\n    this.entity.off('remove', this.onRemoveChild, this);\n    this.entity.off('insert', this.onInsertChild, this);\n  }\n  onLayersChanged(oldComp, newComp) {\n    this.addModelToLayers();\n    oldComp.off('add', this.onLayerAdded, this);\n    oldComp.off('remove', this.onLayerRemoved, this);\n    newComp.on('add', this.onLayerAdded, this);\n    newComp.on('remove', this.onLayerRemoved, this);\n  }\n  onLayerAdded(layer) {\n    const index = this.layers.indexOf(layer.id);\n    if (index < 0) return;\n    layer.addMeshInstances(this.meshInstances);\n  }\n  onLayerRemoved(layer) {\n    const index = this.layers.indexOf(layer.id);\n    if (index < 0) return;\n    layer.removeMeshInstances(this.meshInstances);\n  }\n  _setMaterialEvent(index, event, id, handler) {\n    const evt = event + ':' + id;\n    this.system.app.assets.on(evt, handler, this);\n    if (!this._materialEvents) this._materialEvents = [];\n    if (!this._materialEvents[index]) this._materialEvents[index] = {};\n    this._materialEvents[index][evt] = {\n      id: id,\n      handler: handler\n    };\n  }\n  _unsetMaterialEvents() {\n    const assets = this.system.app.assets;\n    const events = this._materialEvents;\n    if (!events) return;\n    for (let i = 0, len = events.length; i < len; i++) {\n      if (!events[i]) continue;\n      const evt = events[i];\n      for (const key in evt) {\n        assets.off(key, evt[key].handler, this);\n      }\n    }\n    this._materialEvents = null;\n  }\n  _getAssetByIdOrPath(idOrPath) {\n    let asset = null;\n    const isPath = isNaN(parseInt(idOrPath, 10));\n    if (!isPath) {\n      asset = this.system.app.assets.get(idOrPath);\n    } else if (this.asset) {\n      const url = this._getMaterialAssetUrl(idOrPath);\n      if (url) asset = this.system.app.assets.getByUrl(url);\n    }\n    return asset;\n  }\n  _getMaterialAssetUrl(path) {\n    if (!this.asset) return null;\n    const modelAsset = this.system.app.assets.get(this.asset);\n    return modelAsset ? modelAsset.getAbsoluteUrl(path) : null;\n  }\n  _loadAndSetMeshInstanceMaterial(materialAsset, meshInstance, index) {\n    const assets = this.system.app.assets;\n    if (!materialAsset) return;\n    if (materialAsset.resource) {\n      meshInstance.material = materialAsset.resource;\n      this._setMaterialEvent(index, 'remove', materialAsset.id, function () {\n        meshInstance.material = this.system.defaultMaterial;\n      });\n    } else {\n      this._setMaterialEvent(index, 'load', materialAsset.id, function (asset) {\n        meshInstance.material = asset.resource;\n        this._setMaterialEvent(index, 'remove', materialAsset.id, function () {\n          meshInstance.material = this.system.defaultMaterial;\n        });\n      });\n      if (this.enabled && this.entity.enabled) assets.load(materialAsset);\n    }\n  }\n  onEnable() {\n    const app = this.system.app;\n    const scene = app.scene;\n    scene.on('set:layers', this.onLayersChanged, this);\n    if (scene.layers) {\n      scene.layers.on('add', this.onLayerAdded, this);\n      scene.layers.on('remove', this.onLayerRemoved, this);\n    }\n    const isAsset = this._type === 'asset';\n    let asset;\n    if (this._model) {\n      this.addModelToLayers();\n    } else if (isAsset && this._asset) {\n      asset = app.assets.get(this._asset);\n      if (asset && asset.resource !== this._model) {\n        this._bindModelAsset(asset);\n      }\n    }\n    if (this._materialAsset) {\n      asset = app.assets.get(this._materialAsset);\n      if (asset && asset.resource !== this._material) {\n        this._bindMaterialAsset(asset);\n      }\n    }\n    if (isAsset) {\n      if (this._mapping) {\n        for (const index in this._mapping) {\n          if (this._mapping[index]) {\n            asset = this._getAssetByIdOrPath(this._mapping[index]);\n            if (asset && !asset.resource) {\n              app.assets.load(asset);\n            }\n          }\n        }\n      }\n    }\n    if (this._batchGroupId >= 0) {\n      var _app$batcher;\n      (_app$batcher = app.batcher) == null ? void 0 : _app$batcher.insert(_scene_batching_batch_group_js__WEBPACK_IMPORTED_MODULE_7__.BatchGroup.MODEL, this.batchGroupId, this.entity);\n    }\n  }\n  onDisable() {\n    const app = this.system.app;\n    const scene = app.scene;\n    scene.off('set:layers', this.onLayersChanged, this);\n    if (scene.layers) {\n      scene.layers.off('add', this.onLayerAdded, this);\n      scene.layers.off('remove', this.onLayerRemoved, this);\n    }\n    if (this._batchGroupId >= 0) {\n      var _app$batcher2;\n      (_app$batcher2 = app.batcher) == null ? void 0 : _app$batcher2.remove(_scene_batching_batch_group_js__WEBPACK_IMPORTED_MODULE_7__.BatchGroup.MODEL, this.batchGroupId, this.entity);\n    }\n    if (this._model) {\n      this.removeModelFromLayers();\n    }\n  }\n  hide() {\n    if (this._model) {\n      const instances = this._model.meshInstances;\n      for (let i = 0, l = instances.length; i < l; i++) {\n        instances[i].visible = false;\n      }\n    }\n  }\n  show() {\n    if (this._model) {\n      const instances = this._model.meshInstances;\n      for (let i = 0, l = instances.length; i < l; i++) {\n        instances[i].visible = true;\n      }\n    }\n  }\n  _bindMaterialAsset(asset) {\n    asset.on('load', this._onMaterialAssetLoad, this);\n    asset.on('unload', this._onMaterialAssetUnload, this);\n    asset.on('remove', this._onMaterialAssetRemove, this);\n    asset.on('change', this._onMaterialAssetChange, this);\n    if (asset.resource) {\n      this._onMaterialAssetLoad(asset);\n    } else {\n      if (!this.enabled || !this.entity.enabled) return;\n      this.system.app.assets.load(asset);\n    }\n  }\n  _unbindMaterialAsset(asset) {\n    asset.off('load', this._onMaterialAssetLoad, this);\n    asset.off('unload', this._onMaterialAssetUnload, this);\n    asset.off('remove', this._onMaterialAssetRemove, this);\n    asset.off('change', this._onMaterialAssetChange, this);\n  }\n  _onMaterialAssetAdd(asset) {\n    this.system.app.assets.off('add:' + asset.id, this._onMaterialAssetAdd, this);\n    if (this._materialAsset === asset.id) {\n      this._bindMaterialAsset(asset);\n    }\n  }\n  _onMaterialAssetLoad(asset) {\n    this._setMaterial(asset.resource);\n  }\n  _onMaterialAssetUnload(asset) {\n    this._setMaterial(this.system.defaultMaterial);\n  }\n  _onMaterialAssetRemove(asset) {\n    this._onMaterialAssetUnload(asset);\n  }\n  _onMaterialAssetChange(asset) {}\n  _bindModelAsset(asset) {\n    this._unbindModelAsset(asset);\n    asset.on('load', this._onModelAssetLoad, this);\n    asset.on('unload', this._onModelAssetUnload, this);\n    asset.on('change', this._onModelAssetChange, this);\n    asset.on('remove', this._onModelAssetRemove, this);\n    if (asset.resource) {\n      this._onModelAssetLoad(asset);\n    } else {\n      if (!this.enabled || !this.entity.enabled) return;\n      this.system.app.assets.load(asset);\n    }\n  }\n  _unbindModelAsset(asset) {\n    asset.off('load', this._onModelAssetLoad, this);\n    asset.off('unload', this._onModelAssetUnload, this);\n    asset.off('change', this._onModelAssetChange, this);\n    asset.off('remove', this._onModelAssetRemove, this);\n  }\n  _onModelAssetAdded(asset) {\n    this.system.app.assets.off('add:' + asset.id, this._onModelAssetAdded, this);\n    if (asset.id === this._asset) {\n      this._bindModelAsset(asset);\n    }\n  }\n  _onModelAssetLoad(asset) {\n    this.model = asset.resource.clone();\n    this._clonedModel = true;\n  }\n  _onModelAssetUnload(asset) {\n    this.model = null;\n  }\n  _onModelAssetChange(asset, attr, _new, _old) {\n    if (attr === 'data') {\n      this.mapping = this._mapping;\n    }\n  }\n  _onModelAssetRemove(asset) {\n    this.model = null;\n  }\n  _setMaterial(material) {\n    if (this._material === material) return;\n    this._material = material;\n    const model = this._model;\n    if (model && this._type !== 'asset') {\n      const meshInstances = model.meshInstances;\n      for (let i = 0, len = meshInstances.length; i < len; i++) {\n        meshInstances[i].material = material;\n      }\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/model/component.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/model/data.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/model/data.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ModelComponentData\": () => (/* binding */ ModelComponentData)\n/* harmony export */ });\nclass ModelComponentData {\n  constructor() {\n    this.enabled = true;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/model/data.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/model/system.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/model/system.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ModelComponentSystem\": () => (/* binding */ ModelComponentSystem)\n/* harmony export */ });\n/* harmony import */ var _core_core_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../core/core.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/core.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/shape/bounding-box.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/shape/bounding-box.js\");\n/* harmony import */ var _scene_materials_default_material_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../scene/materials/default-material.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/default-material.js\");\n/* harmony import */ var _asset_asset_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../asset/asset.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/system.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/model/component.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/model/data.js\");\n\n\n\n\n\n\n\n\n\n\nconst _schema = ['enabled'];\nclass ModelComponentSystem extends _system_js__WEBPACK_IMPORTED_MODULE_0__.ComponentSystem {\n  constructor(app) {\n    super(app);\n    this.id = 'model';\n    this.ComponentType = _component_js__WEBPACK_IMPORTED_MODULE_1__.ModelComponent;\n    this.DataType = _data_js__WEBPACK_IMPORTED_MODULE_2__.ModelComponentData;\n    this.schema = _schema;\n    this.defaultMaterial = (0,_scene_materials_default_material_js__WEBPACK_IMPORTED_MODULE_3__.getDefaultMaterial)(app.graphicsDevice);\n    this.on('beforeremove', this.onRemove, this);\n  }\n  initializeComponentData(component, _data, properties) {\n    properties = ['material', 'materialAsset', 'asset', 'castShadows', 'receiveShadows', 'castShadowsLightmap', 'lightmapped', 'lightmapSizeMultiplier', 'type', 'mapping', 'layers', 'isStatic', 'batchGroupId'];\n    if (_data.batchGroupId === null || _data.batchGroupId === undefined) {\n      _data.batchGroupId = -1;\n    }\n    if (_data.layers && _data.layers.length) {\n      _data.layers = _data.layers.slice(0);\n    }\n    for (let i = 0; i < properties.length; i++) {\n      if (_data.hasOwnProperty(properties[i])) {\n        component[properties[i]] = _data[properties[i]];\n      }\n    }\n    if (_data.aabbCenter && _data.aabbHalfExtents) {\n      component.customAabb = new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_4__.BoundingBox(new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3(_data.aabbCenter), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3(_data.aabbHalfExtents));\n    }\n    super.initializeComponentData(component, _data, ['enabled']);\n  }\n  cloneComponent(entity, clone) {\n    const data = {\n      type: entity.model.type,\n      asset: entity.model.asset,\n      castShadows: entity.model.castShadows,\n      receiveShadows: entity.model.receiveShadows,\n      castShadowsLightmap: entity.model.castShadowsLightmap,\n      lightmapped: entity.model.lightmapped,\n      lightmapSizeMultiplier: entity.model.lightmapSizeMultiplier,\n      isStatic: entity.model.isStatic,\n      enabled: entity.model.enabled,\n      layers: entity.model.layers,\n      batchGroupId: entity.model.batchGroupId,\n      mapping: (0,_core_core_js__WEBPACK_IMPORTED_MODULE_6__.extend)({}, entity.model.mapping)\n    };\n    let materialAsset = entity.model.materialAsset;\n    if (!(materialAsset instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_7__.Asset) && materialAsset != null) {\n      materialAsset = this.app.assets.get(materialAsset);\n    }\n    const material = entity.model.material;\n    if (!material || material === this.defaultMaterial || !materialAsset || material === materialAsset.resource) {\n      data.materialAsset = materialAsset;\n    }\n    const component = this.addComponent(clone, data);\n    if (entity.model.model && entity.model.type === 'asset' && !entity.model.asset) {\n      component.model = entity.model.model.clone();\n      component._clonedModel = true;\n    }\n    if (!data.materialAsset) component.material = material;\n    if (entity.model.model) {\n      const meshInstances = entity.model.model.meshInstances;\n      const meshInstancesClone = component.model.meshInstances;\n      for (let i = 0; i < meshInstances.length; i++) {\n        meshInstancesClone[i].mask = meshInstances[i].mask;\n        meshInstancesClone[i].material = meshInstances[i].material;\n        meshInstancesClone[i].layer = meshInstances[i].layer;\n        meshInstancesClone[i].receiveShadow = meshInstances[i].receiveShadow;\n      }\n    }\n    if (entity.model.customAabb) {\n      component.customAabb = entity.model.customAabb.clone();\n    }\n    return component;\n  }\n  onRemove(entity, component) {\n    component.onRemove();\n  }\n}\n_component_js__WEBPACK_IMPORTED_MODULE_8__.Component._buildAccessors(_component_js__WEBPACK_IMPORTED_MODULE_1__.ModelComponent.prototype, _schema);\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/model/system.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/particle-system/component.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/particle-system/component.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ParticleSystemComponent\": () => (/* binding */ ParticleSystemComponent)\n/* harmony export */ });\n/* harmony import */ var _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../scene/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _scene_mesh_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../scene/mesh.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh.js\");\n/* harmony import */ var _scene_particle_system_particle_emitter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../scene/particle-system/particle-emitter.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/particle-system/particle-emitter.js\");\n/* harmony import */ var _asset_asset_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../asset/asset.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n\n\n\n\n\n\nconst SIMPLE_PROPERTIES = ['emitterExtents', 'emitterRadius', 'emitterExtentsInner', 'emitterRadiusInner', 'loop', 'initialVelocity', 'animSpeed', 'normalMap', 'particleNormal'];\nconst COMPLEX_PROPERTIES = ['numParticles', 'lifetime', 'rate', 'rate2', 'startAngle', 'startAngle2', 'lighting', 'halfLambert', 'intensity', 'wrap', 'wrapBounds', 'depthWrite', 'noFog', 'sort', 'stretch', 'alignToMotion', 'preWarm', 'emitterShape', 'animTilesX', 'animTilesY', 'animStartFrame', 'animNumFrames', 'animNumAnimations', 'animIndex', 'randomizeAnimIndex', 'animLoop', 'colorMap', 'localSpace', 'screenSpace', 'orientation'];\nconst GRAPH_PROPERTIES = ['scaleGraph', 'scaleGraph2', 'colorGraph', 'colorGraph2', 'alphaGraph', 'alphaGraph2', 'velocityGraph', 'velocityGraph2', 'localVelocityGraph', 'localVelocityGraph2', 'rotationSpeedGraph', 'rotationSpeedGraph2', 'radialSpeedGraph', 'radialSpeedGraph2'];\nconst ASSET_PROPERTIES = ['colorMapAsset', 'normalMapAsset', 'meshAsset', 'renderAsset'];\nlet depthLayer;\nclass ParticleSystemComponent extends _component_js__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(system, entity) {\n    super(system, entity);\n    this._requestedDepth = false;\n    this._drawOrder = 0;\n    this.on('set_colorMapAsset', this.onSetColorMapAsset, this);\n    this.on('set_normalMapAsset', this.onSetNormalMapAsset, this);\n    this.on('set_meshAsset', this.onSetMeshAsset, this);\n    this.on('set_mesh', this.onSetMesh, this);\n    this.on('set_renderAsset', this.onSetRenderAsset, this);\n    this.on('set_loop', this.onSetLoop, this);\n    this.on('set_blendType', this.onSetBlendType, this);\n    this.on('set_depthSoftening', this.onSetDepthSoftening, this);\n    this.on('set_layers', this.onSetLayers, this);\n    SIMPLE_PROPERTIES.forEach(prop => {\n      this.on(`set_${prop}`, this.onSetSimpleProperty, this);\n    });\n    COMPLEX_PROPERTIES.forEach(prop => {\n      this.on(`set_${prop}`, this.onSetComplexProperty, this);\n    });\n    GRAPH_PROPERTIES.forEach(prop => {\n      this.on(`set_${prop}`, this.onSetGraphProperty, this);\n    });\n  }\n  set drawOrder(drawOrder) {\n    this._drawOrder = drawOrder;\n    if (this.emitter) {\n      this.emitter.drawOrder = drawOrder;\n    }\n  }\n  get drawOrder() {\n    return this._drawOrder;\n  }\n  addMeshInstanceToLayers() {\n    if (!this.emitter) return;\n    for (let i = 0; i < this.layers.length; i++) {\n      const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n      if (!layer) continue;\n      layer.addMeshInstances([this.emitter.meshInstance]);\n      this.emitter._layer = layer;\n    }\n  }\n  removeMeshInstanceFromLayers() {\n    if (!this.emitter) return;\n    for (let i = 0; i < this.layers.length; i++) {\n      const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n      if (!layer) continue;\n      layer.removeMeshInstances([this.emitter.meshInstance]);\n    }\n  }\n  onSetLayers(name, oldValue, newValue) {\n    if (!this.emitter) return;\n    for (let i = 0; i < oldValue.length; i++) {\n      const layer = this.system.app.scene.layers.getLayerById(oldValue[i]);\n      if (!layer) continue;\n      layer.removeMeshInstances([this.emitter.meshInstance]);\n    }\n    if (!this.enabled || !this.entity.enabled) return;\n    for (let i = 0; i < newValue.length; i++) {\n      const layer = this.system.app.scene.layers.getLayerById(newValue[i]);\n      if (!layer) continue;\n      layer.addMeshInstances([this.emitter.meshInstance]);\n    }\n  }\n  onLayersChanged(oldComp, newComp) {\n    this.addMeshInstanceToLayers();\n    oldComp.off('add', this.onLayerAdded, this);\n    oldComp.off('remove', this.onLayerRemoved, this);\n    newComp.on('add', this.onLayerAdded, this);\n    newComp.on('remove', this.onLayerRemoved, this);\n  }\n  onLayerAdded(layer) {\n    if (!this.emitter) return;\n    const index = this.layers.indexOf(layer.id);\n    if (index < 0) return;\n    layer.addMeshInstances([this.emitter.meshInstance]);\n  }\n  onLayerRemoved(layer) {\n    if (!this.emitter) return;\n    const index = this.layers.indexOf(layer.id);\n    if (index < 0) return;\n    layer.removeMeshInstances([this.emitter.meshInstance]);\n  }\n  _bindColorMapAsset(asset) {\n    asset.on('load', this._onColorMapAssetLoad, this);\n    asset.on('unload', this._onColorMapAssetUnload, this);\n    asset.on('remove', this._onColorMapAssetRemove, this);\n    asset.on('change', this._onColorMapAssetChange, this);\n    if (asset.resource) {\n      this._onColorMapAssetLoad(asset);\n    } else {\n      if (!this.enabled || !this.entity.enabled) return;\n      this.system.app.assets.load(asset);\n    }\n  }\n  _unbindColorMapAsset(asset) {\n    asset.off('load', this._onColorMapAssetLoad, this);\n    asset.off('unload', this._onColorMapAssetUnload, this);\n    asset.off('remove', this._onColorMapAssetRemove, this);\n    asset.off('change', this._onColorMapAssetChange, this);\n  }\n  _onColorMapAssetLoad(asset) {\n    this.colorMap = asset.resource;\n  }\n  _onColorMapAssetUnload(asset) {\n    this.colorMap = null;\n  }\n  _onColorMapAssetRemove(asset) {\n    this._onColorMapAssetUnload(asset);\n  }\n  _onColorMapAssetChange(asset) {}\n  onSetColorMapAsset(name, oldValue, newValue) {\n    const assets = this.system.app.assets;\n    if (oldValue) {\n      const asset = assets.get(oldValue);\n      if (asset) {\n        this._unbindColorMapAsset(asset);\n      }\n    }\n    if (newValue) {\n      if (newValue instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_1__.Asset) {\n        this.data.colorMapAsset = newValue.id;\n        newValue = newValue.id;\n      }\n      const asset = assets.get(newValue);\n      if (asset) {\n        this._bindColorMapAsset(asset);\n      } else {\n        assets.once('add:' + newValue, asset => {\n          this._bindColorMapAsset(asset);\n        });\n      }\n    } else {\n      this.colorMap = null;\n    }\n  }\n  _bindNormalMapAsset(asset) {\n    asset.on('load', this._onNormalMapAssetLoad, this);\n    asset.on('unload', this._onNormalMapAssetUnload, this);\n    asset.on('remove', this._onNormalMapAssetRemove, this);\n    asset.on('change', this._onNormalMapAssetChange, this);\n    if (asset.resource) {\n      this._onNormalMapAssetLoad(asset);\n    } else {\n      if (!this.enabled || !this.entity.enabled) return;\n      this.system.app.assets.load(asset);\n    }\n  }\n  _unbindNormalMapAsset(asset) {\n    asset.off('load', this._onNormalMapAssetLoad, this);\n    asset.off('unload', this._onNormalMapAssetUnload, this);\n    asset.off('remove', this._onNormalMapAssetRemove, this);\n    asset.off('change', this._onNormalMapAssetChange, this);\n  }\n  _onNormalMapAssetLoad(asset) {\n    this.normalMap = asset.resource;\n  }\n  _onNormalMapAssetUnload(asset) {\n    this.normalMap = null;\n  }\n  _onNormalMapAssetRemove(asset) {\n    this._onNormalMapAssetUnload(asset);\n  }\n  _onNormalMapAssetChange(asset) {}\n  onSetNormalMapAsset(name, oldValue, newValue) {\n    const assets = this.system.app.assets;\n    if (oldValue) {\n      const asset = assets.get(oldValue);\n      if (asset) {\n        this._unbindNormalMapAsset(asset);\n      }\n    }\n    if (newValue) {\n      if (newValue instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_1__.Asset) {\n        this.data.normalMapAsset = newValue.id;\n        newValue = newValue.id;\n      }\n      const asset = assets.get(newValue);\n      if (asset) {\n        this._bindNormalMapAsset(asset);\n      } else {\n        assets.once('add:' + newValue, asset => {\n          this._bindNormalMapAsset(asset);\n        });\n      }\n    } else {\n      this.normalMap = null;\n    }\n  }\n  _bindMeshAsset(asset) {\n    asset.on('load', this._onMeshAssetLoad, this);\n    asset.on('unload', this._onMeshAssetUnload, this);\n    asset.on('remove', this._onMeshAssetRemove, this);\n    asset.on('change', this._onMeshAssetChange, this);\n    if (asset.resource) {\n      this._onMeshAssetLoad(asset);\n    } else {\n      if (!this.enabled || !this.entity.enabled) return;\n      this.system.app.assets.load(asset);\n    }\n  }\n  _unbindMeshAsset(asset) {\n    asset.off('load', this._onMeshAssetLoad, this);\n    asset.off('unload', this._onMeshAssetUnload, this);\n    asset.off('remove', this._onMeshAssetRemove, this);\n    asset.off('change', this._onMeshAssetChange, this);\n  }\n  _onMeshAssetLoad(asset) {\n    this._onMeshChanged(asset.resource);\n  }\n  _onMeshAssetUnload(asset) {\n    this.mesh = null;\n  }\n  _onMeshAssetRemove(asset) {\n    this._onMeshAssetUnload(asset);\n  }\n  _onMeshAssetChange(asset) {}\n  onSetMeshAsset(name, oldValue, newValue) {\n    const assets = this.system.app.assets;\n    if (oldValue) {\n      const asset = assets.get(oldValue);\n      if (asset) {\n        this._unbindMeshAsset(asset);\n      }\n    }\n    if (newValue) {\n      if (newValue instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_1__.Asset) {\n        this.data.meshAsset = newValue.id;\n        newValue = newValue.id;\n      }\n      const asset = assets.get(newValue);\n      if (asset) {\n        this._bindMeshAsset(asset);\n      }\n    } else {\n      this._onMeshChanged(null);\n    }\n  }\n  onSetMesh(name, oldValue, newValue) {\n    if (!newValue || newValue instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_1__.Asset || typeof newValue === 'number') {\n      this.meshAsset = newValue;\n    } else {\n      this._onMeshChanged(newValue);\n    }\n  }\n  _onMeshChanged(mesh) {\n    if (mesh && !(mesh instanceof _scene_mesh_js__WEBPACK_IMPORTED_MODULE_2__.Mesh)) {\n      if (mesh.meshInstances[0]) {\n        mesh = mesh.meshInstances[0].mesh;\n      } else {\n        mesh = null;\n      }\n    }\n    this.data.mesh = mesh;\n    if (this.emitter) {\n      this.emitter.mesh = mesh;\n      this.emitter.resetMaterial();\n      this.rebuild();\n    }\n  }\n  onSetRenderAsset(name, oldValue, newValue) {\n    const assets = this.system.app.assets;\n    if (oldValue) {\n      const asset = assets.get(oldValue);\n      if (asset) {\n        this._unbindRenderAsset(asset);\n      }\n    }\n    if (newValue) {\n      if (newValue instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_1__.Asset) {\n        this.data.renderAsset = newValue.id;\n        newValue = newValue.id;\n      }\n      const asset = assets.get(newValue);\n      if (asset) {\n        this._bindRenderAsset(asset);\n      }\n    } else {\n      this._onRenderChanged(null);\n    }\n  }\n  _bindRenderAsset(asset) {\n    asset.on('load', this._onRenderAssetLoad, this);\n    asset.on('unload', this._onRenderAssetUnload, this);\n    asset.on('remove', this._onRenderAssetRemove, this);\n    if (asset.resource) {\n      this._onRenderAssetLoad(asset);\n    } else {\n      if (!this.enabled || !this.entity.enabled) return;\n      this.system.app.assets.load(asset);\n    }\n  }\n  _unbindRenderAsset(asset) {\n    asset.off('load', this._onRenderAssetLoad, this);\n    asset.off('unload', this._onRenderAssetUnload, this);\n    asset.off('remove', this._onRenderAssetRemove, this);\n    if (asset.resource) {\n      asset.resource.off('set:meshes', this._onRenderSetMeshes, this);\n    }\n  }\n  _onRenderAssetLoad(asset) {\n    this._onRenderChanged(asset.resource);\n  }\n  _onRenderAssetUnload(asset) {\n    this._onRenderChanged(null);\n  }\n  _onRenderAssetRemove(asset) {\n    this._onRenderAssetUnload(asset);\n  }\n  _onRenderChanged(render) {\n    if (!render) {\n      this._onMeshChanged(null);\n      return;\n    }\n    render.off('set:meshes', this._onRenderSetMeshes, this);\n    render.on('set:meshes', this._onRenderSetMeshes, this);\n    if (render.meshes) {\n      this._onRenderSetMeshes(render.meshes);\n    }\n  }\n  _onRenderSetMeshes(meshes) {\n    this._onMeshChanged(meshes && meshes[0]);\n  }\n  onSetLoop(name, oldValue, newValue) {\n    if (this.emitter) {\n      this.emitter[name] = newValue;\n      this.emitter.resetTime();\n    }\n  }\n  onSetBlendType(name, oldValue, newValue) {\n    if (this.emitter) {\n      this.emitter[name] = newValue;\n      this.emitter.material.blendType = newValue;\n      this.emitter.resetMaterial();\n      this.rebuild();\n    }\n  }\n  _requestDepth() {\n    if (this._requestedDepth) return;\n    if (!depthLayer) depthLayer = this.system.app.scene.layers.getLayerById(_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.LAYERID_DEPTH);\n    if (depthLayer) {\n      depthLayer.incrementCounter();\n      this._requestedDepth = true;\n    }\n  }\n  _releaseDepth() {\n    if (!this._requestedDepth) return;\n    if (depthLayer) {\n      depthLayer.decrementCounter();\n      this._requestedDepth = false;\n    }\n  }\n  onSetDepthSoftening(name, oldValue, newValue) {\n    if (oldValue !== newValue) {\n      if (newValue) {\n        if (this.enabled && this.entity.enabled) this._requestDepth();\n        if (this.emitter) this.emitter[name] = newValue;\n      } else {\n        if (this.enabled && this.entity.enabled) this._releaseDepth();\n        if (this.emitter) this.emitter[name] = newValue;\n      }\n      if (this.emitter) {\n        this.reset();\n        this.emitter.resetMaterial();\n        this.rebuild();\n      }\n    }\n  }\n  onSetSimpleProperty(name, oldValue, newValue) {\n    if (this.emitter) {\n      this.emitter[name] = newValue;\n      this.emitter.resetMaterial();\n    }\n  }\n  onSetComplexProperty(name, oldValue, newValue) {\n    if (this.emitter) {\n      this.emitter[name] = newValue;\n      this.emitter.resetMaterial();\n      this.rebuild();\n      this.reset();\n    }\n  }\n  onSetGraphProperty(name, oldValue, newValue) {\n    if (this.emitter) {\n      this.emitter[name] = newValue;\n      this.emitter.rebuildGraphs();\n      this.emitter.resetMaterial();\n    }\n  }\n  onEnable() {\n    const data = this.data;\n    for (let i = 0, len = ASSET_PROPERTIES.length; i < len; i++) {\n      let asset = data[ASSET_PROPERTIES[i]];\n      if (asset) {\n        if (!(asset instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_1__.Asset)) {\n          const id = parseInt(asset, 10);\n          if (id >= 0) {\n            asset = this.system.app.assets.get(asset);\n          } else {\n            continue;\n          }\n        }\n        if (asset && !asset.resource) {\n          this.system.app.assets.load(asset);\n        }\n      }\n    }\n    if (!this.emitter) {\n      let mesh = data.mesh;\n      if (!(mesh instanceof _scene_mesh_js__WEBPACK_IMPORTED_MODULE_2__.Mesh)) mesh = null;\n      this.emitter = new _scene_particle_system_particle_emitter_js__WEBPACK_IMPORTED_MODULE_4__.ParticleEmitter(this.system.app.graphicsDevice, {\n        numParticles: data.numParticles,\n        emitterExtents: data.emitterExtents,\n        emitterExtentsInner: data.emitterExtentsInner,\n        emitterRadius: data.emitterRadius,\n        emitterRadiusInner: data.emitterRadiusInner,\n        emitterShape: data.emitterShape,\n        initialVelocity: data.initialVelocity,\n        wrap: data.wrap,\n        localSpace: data.localSpace,\n        screenSpace: data.screenSpace,\n        wrapBounds: data.wrapBounds,\n        lifetime: data.lifetime,\n        rate: data.rate,\n        rate2: data.rate2,\n        orientation: data.orientation,\n        particleNormal: data.particleNormal,\n        animTilesX: data.animTilesX,\n        animTilesY: data.animTilesY,\n        animStartFrame: data.animStartFrame,\n        animNumFrames: data.animNumFrames,\n        animNumAnimations: data.animNumAnimations,\n        animIndex: data.animIndex,\n        randomizeAnimIndex: data.randomizeAnimIndex,\n        animSpeed: data.animSpeed,\n        animLoop: data.animLoop,\n        startAngle: data.startAngle,\n        startAngle2: data.startAngle2,\n        scaleGraph: data.scaleGraph,\n        scaleGraph2: data.scaleGraph2,\n        colorGraph: data.colorGraph,\n        colorGraph2: data.colorGraph2,\n        alphaGraph: data.alphaGraph,\n        alphaGraph2: data.alphaGraph2,\n        localVelocityGraph: data.localVelocityGraph,\n        localVelocityGraph2: data.localVelocityGraph2,\n        velocityGraph: data.velocityGraph,\n        velocityGraph2: data.velocityGraph2,\n        rotationSpeedGraph: data.rotationSpeedGraph,\n        rotationSpeedGraph2: data.rotationSpeedGraph2,\n        radialSpeedGraph: data.radialSpeedGraph,\n        radialSpeedGraph2: data.radialSpeedGraph2,\n        colorMap: data.colorMap,\n        normalMap: data.normalMap,\n        loop: data.loop,\n        preWarm: data.preWarm,\n        sort: data.sort,\n        stretch: data.stretch,\n        alignToMotion: data.alignToMotion,\n        lighting: data.lighting,\n        halfLambert: data.halfLambert,\n        intensity: data.intensity,\n        depthSoftening: data.depthSoftening,\n        scene: this.system.app.scene,\n        mesh: mesh,\n        depthWrite: data.depthWrite,\n        noFog: data.noFog,\n        node: this.entity,\n        blendType: data.blendType\n      });\n      this.emitter.meshInstance.node = this.entity;\n      this.emitter.drawOrder = this.drawOrder;\n      if (!data.autoPlay) {\n        this.pause();\n        this.emitter.meshInstance.visible = false;\n      }\n    }\n    if (this.emitter.colorMap) {\n      this.addMeshInstanceToLayers();\n    }\n    this.system.app.scene.on('set:layers', this.onLayersChanged, this);\n    if (this.system.app.scene.layers) {\n      this.system.app.scene.layers.on('add', this.onLayerAdded, this);\n      this.system.app.scene.layers.on('remove', this.onLayerRemoved, this);\n    }\n    if (this.enabled && this.entity.enabled && data.depthSoftening) {\n      this._requestDepth();\n    }\n  }\n  onDisable() {\n    this.system.app.scene.off('set:layers', this.onLayersChanged, this);\n    if (this.system.app.scene.layers) {\n      this.system.app.scene.layers.off('add', this.onLayerAdded, this);\n      this.system.app.scene.layers.off('remove', this.onLayerRemoved, this);\n    }\n    if (this.emitter) {\n      this.removeMeshInstanceFromLayers();\n      if (this.data.depthSoftening) this._releaseDepth();\n      this.emitter.camera = null;\n    }\n  }\n  onBeforeRemove() {\n    if (this.enabled) {\n      this.enabled = false;\n    }\n    if (this.emitter) {\n      this.emitter.destroy();\n      this.emitter = null;\n    }\n    for (let i = 0; i < ASSET_PROPERTIES.length; i++) {\n      const prop = ASSET_PROPERTIES[i];\n      if (this.data[prop]) {\n        this[prop] = null;\n      }\n    }\n    this.off();\n  }\n  reset() {\n    if (this.emitter) {\n      this.emitter.reset();\n    }\n  }\n  stop() {\n    if (this.emitter) {\n      this.emitter.loop = false;\n      this.emitter.resetTime();\n      this.emitter.addTime(0, true);\n    }\n  }\n  pause() {\n    this.data.paused = true;\n  }\n  unpause() {\n    this.data.paused = false;\n  }\n  play() {\n    this.data.paused = false;\n    if (this.emitter) {\n      this.emitter.meshInstance.visible = true;\n      this.emitter.loop = this.data.loop;\n      this.emitter.resetTime();\n    }\n  }\n  isPlaying() {\n    if (this.data.paused) {\n      return false;\n    }\n    if (this.emitter && this.emitter.loop) {\n      return true;\n    }\n    return Date.now() <= this.emitter.endTime;\n  }\n  rebuild() {\n    const enabled = this.enabled;\n    this.enabled = false;\n    if (this.emitter) {\n      this.emitter.rebuild();\n      this.emitter.meshInstance.node = this.entity;\n    }\n    this.enabled = enabled;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/particle-system/component.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/particle-system/data.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/particle-system/data.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ParticleSystemComponentData\": () => (/* binding */ ParticleSystemComponentData)\n/* harmony export */ });\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _scene_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../scene/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n\n\n\nclass ParticleSystemComponentData {\n  constructor() {\n    this.numParticles = 1;\n    this.rate = 1;\n    this.rate2 = null;\n    this.startAngle = 0;\n    this.startAngle2 = null;\n    this.lifetime = 50;\n    this.emitterExtents = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n    this.emitterExtentsInner = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n    this.emitterRadius = 0;\n    this.emitterRadiusInner = 0;\n    this.emitterShape = _scene_constants_js__WEBPACK_IMPORTED_MODULE_1__.EMITTERSHAPE_BOX;\n    this.initialVelocity = 0;\n    this.wrapBounds = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n    this.localSpace = false;\n    this.screenSpace = false;\n    this.colorMap = null;\n    this.colorMapAsset = null;\n    this.normalMap = null;\n    this.normalMapAsset = null;\n    this.loop = true;\n    this.preWarm = false;\n    this.sort = 0;\n    this.mode = _scene_constants_js__WEBPACK_IMPORTED_MODULE_1__.PARTICLEMODE_GPU;\n    this.scene = null;\n    this.lighting = false;\n    this.halfLambert = false;\n    this.intensity = 1;\n    this.stretch = 0.0;\n    this.alignToMotion = false;\n    this.depthSoftening = 0;\n    this.meshAsset = null;\n    this.mesh = null;\n    this.depthWrite = false;\n    this.noFog = false;\n    this.orientation = _scene_constants_js__WEBPACK_IMPORTED_MODULE_1__.PARTICLEORIENTATION_SCREEN;\n    this.particleNormal = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(0, 1, 0);\n    this.animTilesX = 1;\n    this.animTilesY = 1;\n    this.animStartFrame = 0;\n    this.animNumFrames = 1;\n    this.animNumAnimations = 1;\n    this.animIndex = 0;\n    this.randomizeAnimIndex = false;\n    this.animSpeed = 1;\n    this.animLoop = true;\n    this.scaleGraph = null;\n    this.scaleGraph2 = null;\n    this.colorGraph = null;\n    this.colorGraph2 = null;\n    this.alphaGraph = null;\n    this.alphaGraph2 = null;\n    this.localVelocityGraph = null;\n    this.localVelocityGraph2 = null;\n    this.velocityGraph = null;\n    this.velocityGraph2 = null;\n    this.rotationSpeedGraph = null;\n    this.rotationSpeedGraph2 = null;\n    this.radialSpeedGraph = null;\n    this.radialSpeedGraph2 = null;\n    this.blendType = _scene_constants_js__WEBPACK_IMPORTED_MODULE_1__.BLEND_NORMAL;\n    this.enabled = true;\n    this.paused = false;\n    this.autoPlay = true;\n    this.layers = [_scene_constants_js__WEBPACK_IMPORTED_MODULE_1__.LAYERID_WORLD];\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/particle-system/data.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/particle-system/system.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/particle-system/system.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ParticleSystemComponentSystem\": () => (/* binding */ ParticleSystemComponentSystem)\n/* harmony export */ });\n/* harmony import */ var _core_math_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/math/curve.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/curve.js\");\n/* harmony import */ var _core_math_curve_set_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../core/math/curve-set.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/curve-set.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _scene_constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../scene/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _asset_asset_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../asset/asset.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/system.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/particle-system/component.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/particle-system/data.js\");\n\n\n\n\n\n\n\n\n\n\nconst _schema = ['enabled', 'autoPlay', 'numParticles', 'lifetime', 'rate', 'rate2', 'startAngle', 'startAngle2', 'loop', 'preWarm', 'lighting', 'halfLambert', 'intensity', 'depthWrite', 'noFog', 'depthSoftening', 'sort', 'blendType', 'stretch', 'alignToMotion', 'emitterShape', 'emitterExtents', 'emitterExtentsInner', 'emitterRadius', 'emitterRadiusInner', 'initialVelocity', 'wrap', 'wrapBounds', 'localSpace', 'screenSpace', 'colorMapAsset', 'normalMapAsset', 'mesh', 'meshAsset', 'renderAsset', 'orientation', 'particleNormal', 'localVelocityGraph', 'localVelocityGraph2', 'velocityGraph', 'velocityGraph2', 'rotationSpeedGraph', 'rotationSpeedGraph2', 'radialSpeedGraph', 'radialSpeedGraph2', 'scaleGraph', 'scaleGraph2', 'colorGraph', 'colorGraph2', 'alphaGraph', 'alphaGraph2', 'colorMap', 'normalMap', 'animTilesX', 'animTilesY', 'animStartFrame', 'animNumFrames', 'animNumAnimations', 'animIndex', 'randomizeAnimIndex', 'animSpeed', 'animLoop', 'layers'];\nclass ParticleSystemComponentSystem extends _system_js__WEBPACK_IMPORTED_MODULE_0__.ComponentSystem {\n  constructor(app) {\n    super(app);\n    this.id = 'particlesystem';\n    this.ComponentType = _component_js__WEBPACK_IMPORTED_MODULE_1__.ParticleSystemComponent;\n    this.DataType = _data_js__WEBPACK_IMPORTED_MODULE_2__.ParticleSystemComponentData;\n    this.schema = _schema;\n    this.propertyTypes = {\n      emitterExtents: 'vec3',\n      emitterExtentsInner: 'vec3',\n      particleNormal: 'vec3',\n      wrapBounds: 'vec3',\n      localVelocityGraph: 'curveset',\n      localVelocityGraph2: 'curveset',\n      velocityGraph: 'curveset',\n      velocityGraph2: 'curveset',\n      colorGraph: 'curveset',\n      colorGraph2: 'curveset',\n      alphaGraph: 'curve',\n      alphaGraph2: 'curve',\n      rotationSpeedGraph: 'curve',\n      rotationSpeedGraph2: 'curve',\n      radialSpeedGraph: 'curve',\n      radialSpeedGraph2: 'curve',\n      scaleGraph: 'curve',\n      scaleGraph2: 'curve'\n    };\n    this.on('beforeremove', this.onBeforeRemove, this);\n    this.app.systems.on('update', this.onUpdate, this);\n  }\n  initializeComponentData(component, _data, properties) {\n    const data = {};\n    properties = [];\n    const types = this.propertyTypes;\n    if (_data.mesh instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_3__.Asset || typeof _data.mesh === 'number') {\n      _data.meshAsset = _data.mesh;\n      delete _data.mesh;\n    }\n    for (const prop in _data) {\n      if (_data.hasOwnProperty(prop)) {\n        properties.push(prop);\n        data[prop] = _data[prop];\n      }\n      if (types[prop] === 'vec3') {\n        if (Array.isArray(data[prop])) {\n          data[prop] = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_4__.Vec3(data[prop][0], data[prop][1], data[prop][2]);\n        }\n      } else if (types[prop] === 'curve') {\n        if (!(data[prop] instanceof _core_math_curve_js__WEBPACK_IMPORTED_MODULE_5__.Curve)) {\n          const t = data[prop].type;\n          data[prop] = new _core_math_curve_js__WEBPACK_IMPORTED_MODULE_5__.Curve(data[prop].keys);\n          data[prop].type = t;\n        }\n      } else if (types[prop] === 'curveset') {\n        if (!(data[prop] instanceof _core_math_curve_set_js__WEBPACK_IMPORTED_MODULE_6__.CurveSet)) {\n          const t = data[prop].type;\n          data[prop] = new _core_math_curve_set_js__WEBPACK_IMPORTED_MODULE_6__.CurveSet(data[prop].keys);\n          data[prop].type = t;\n        }\n      }\n      if (data.layers && Array.isArray(data.layers)) {\n        data.layers = data.layers.slice(0);\n      }\n    }\n    super.initializeComponentData(component, data, properties);\n  }\n  cloneComponent(entity, clone) {\n    const source = entity.particlesystem.data;\n    const schema = this.schema;\n    const data = {};\n    for (let i = 0, len = schema.length; i < len; i++) {\n      const prop = schema[i];\n      let sourceProp = source[prop];\n      if (sourceProp instanceof _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_4__.Vec3 || sourceProp instanceof _core_math_curve_js__WEBPACK_IMPORTED_MODULE_5__.Curve || sourceProp instanceof _core_math_curve_set_js__WEBPACK_IMPORTED_MODULE_6__.CurveSet) {\n        sourceProp = sourceProp.clone();\n        data[prop] = sourceProp;\n      } else if (prop === 'layers') {\n        data.layers = source.layers.slice(0);\n      } else {\n        if (sourceProp !== null && sourceProp !== undefined) {\n          data[prop] = sourceProp;\n        }\n      }\n    }\n    return this.addComponent(clone, data);\n  }\n  onUpdate(dt) {\n    const components = this.store;\n    let numSteps;\n    const stats = this.app.stats.particles;\n    for (const id in components) {\n      if (components.hasOwnProperty(id)) {\n        const component = components[id];\n        const entity = component.entity;\n        const data = component.data;\n        if (data.enabled && entity.enabled) {\n          const emitter = entity.particlesystem.emitter;\n          if (!emitter.meshInstance.visible) continue;\n          if (emitter.lighting) {\n            const layers = data.layers;\n            let lightCube;\n            for (let i = 0; i < layers.length; i++) {\n              const layer = this.app.scene.layers.getLayerById(layers[i]);\n              if (!layer) continue;\n              if (!layer._lightCube) {\n                layer._lightCube = new Float32Array(6 * 3);\n              }\n              lightCube = layer._lightCube;\n              for (let j = 0; j < 6; j++) {\n                lightCube[j * 3] = this.app.scene.ambientLight.r;\n                lightCube[j * 3 + 1] = this.app.scene.ambientLight.g;\n                lightCube[j * 3 + 2] = this.app.scene.ambientLight.b;\n              }\n              const dirs = layer._splitLights[_scene_constants_js__WEBPACK_IMPORTED_MODULE_7__.LIGHTTYPE_DIRECTIONAL];\n              for (let j = 0; j < dirs.length; j++) {\n                for (let c = 0; c < 6; c++) {\n                  const weight = Math.max(emitter.lightCubeDir[c].dot(dirs[j]._direction), 0) * dirs[j]._intensity;\n                  lightCube[c * 3] += dirs[j]._color.r * weight;\n                  lightCube[c * 3 + 1] += dirs[j]._color.g * weight;\n                  lightCube[c * 3 + 2] += dirs[j]._color.b * weight;\n                }\n              }\n            }\n            emitter.constantLightCube.setValue(lightCube);\n          }\n          if (!data.paused) {\n            emitter.simTime += dt;\n            if (emitter.simTime > emitter.fixedTimeStep) {\n              numSteps = Math.floor(emitter.simTime / emitter.fixedTimeStep);\n              emitter.simTime -= numSteps * emitter.fixedTimeStep;\n            }\n            if (numSteps) {\n              numSteps = Math.min(numSteps, emitter.maxSubSteps);\n              for (let i = 0; i < numSteps; i++) {\n                emitter.addTime(emitter.fixedTimeStep, false);\n              }\n              stats._updatesPerFrame += numSteps;\n              stats._frameTime += emitter._addTimeTime;\n              emitter._addTimeTime = 0;\n            }\n            emitter.finishFrame();\n          }\n        }\n      }\n    }\n  }\n  onBeforeRemove(entity, component) {\n    component.onBeforeRemove();\n  }\n  destroy() {\n    super.destroy();\n    this.app.systems.off('update', this.onUpdate, this);\n  }\n}\n_component_js__WEBPACK_IMPORTED_MODULE_8__.Component._buildAccessors(_component_js__WEBPACK_IMPORTED_MODULE_1__.ParticleSystemComponent.prototype, _schema);\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/particle-system/system.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/registry.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/registry.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ComponentSystemRegistry\": () => (/* binding */ ComponentSystemRegistry)\n/* harmony export */ });\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n\n\nclass ComponentSystemRegistry extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor() {\n    super();\n    this.anim = void 0;\n    this.animation = void 0;\n    this.audiolistener = void 0;\n    this.audiosource = void 0;\n    this.button = void 0;\n    this.camera = void 0;\n    this.collision = void 0;\n    this.element = void 0;\n    this.joint = void 0;\n    this.layoutchild = void 0;\n    this.layoutgroup = void 0;\n    this.light = void 0;\n    this.model = void 0;\n    this.particlesystem = void 0;\n    this.render = void 0;\n    this.rigidbody = void 0;\n    this.screen = void 0;\n    this.script = void 0;\n    this.scrollbar = void 0;\n    this.scrollview = void 0;\n    this.sound = void 0;\n    this.sprite = void 0;\n    this.zone = void 0;\n    this.list = [];\n  }\n  add(system) {\n    const id = system.id;\n    if (this[id]) {\n      throw new Error(`ComponentSystem name '${id}' already registered or not allowed`);\n    }\n    this[id] = system;\n    this.list.push(system);\n  }\n  remove(system) {\n    const id = system.id;\n    if (!this[id]) {\n      throw new Error(`No ComponentSystem named '${id}' registered`);\n    }\n    delete this[id];\n    const index = this.list.indexOf(this[id]);\n    if (index !== -1) {\n      this.list.splice(index, 1);\n    }\n  }\n  destroy() {\n    this.off();\n    for (let i = 0; i < this.list.length; i++) {\n      this.list[i].destroy();\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/registry.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/render/component.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/render/component.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RenderComponent\": () => (/* binding */ RenderComponent)\n/* harmony export */ });\n/* harmony import */ var _scene_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../scene/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _scene_batching_batch_group_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../scene/batching/batch-group.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/batching/batch-group.js\");\n/* harmony import */ var _scene_mesh_instance_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../scene/mesh-instance.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh-instance.js\");\n/* harmony import */ var _scene_morph_instance_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../scene/morph-instance.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/morph-instance.js\");\n/* harmony import */ var _scene_procedural_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../scene/procedural.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/procedural.js\");\n/* harmony import */ var _scene_graph_node_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../scene/graph-node.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/graph-node.js\");\n/* harmony import */ var _scene_skin_instance_cache_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../scene/skin-instance-cache.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/skin-instance-cache.js\");\n/* harmony import */ var _asset_asset_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../asset/asset.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset.js\");\n/* harmony import */ var _asset_asset_reference_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../asset/asset-reference.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset-reference.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _utils_entity_reference_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/entity-reference.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/utils/entity-reference.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nclass RenderComponent extends _component_js__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(system, entity) {\n    super(system, entity);\n    this._type = 'asset';\n    this._castShadows = true;\n    this._receiveShadows = true;\n    this._castShadowsLightmap = true;\n    this._lightmapped = false;\n    this._lightmapSizeMultiplier = 1;\n    this._isStatic = false;\n    this._batchGroupId = -1;\n    this._layers = [_scene_constants_js__WEBPACK_IMPORTED_MODULE_1__.LAYERID_WORLD];\n    this._renderStyle = _scene_constants_js__WEBPACK_IMPORTED_MODULE_1__.RENDERSTYLE_SOLID;\n    this._meshInstances = [];\n    this._customAabb = null;\n    this._area = null;\n    this._assetReference = [];\n    this._materialReferences = [];\n    this._material = void 0;\n    this._rootBone = void 0;\n    this._rootBone = new _utils_entity_reference_js__WEBPACK_IMPORTED_MODULE_2__.EntityReference(this, 'rootBone');\n    this._rootBone.on('set:entity', this._onSetRootBone, this);\n    this._assetReference = new _asset_asset_reference_js__WEBPACK_IMPORTED_MODULE_3__.AssetReference('asset', this, system.app.assets, {\n      add: this._onRenderAssetAdded,\n      load: this._onRenderAssetLoad,\n      remove: this._onRenderAssetRemove,\n      unload: this._onRenderAssetUnload\n    }, this);\n    this._material = system.defaultMaterial;\n    entity.on('remove', this.onRemoveChild, this);\n    entity.on('removehierarchy', this.onRemoveChild, this);\n    entity.on('insert', this.onInsertChild, this);\n    entity.on('inserthierarchy', this.onInsertChild, this);\n  }\n  set renderStyle(renderStyle) {\n    if (this._renderStyle !== renderStyle) {\n      this._renderStyle = renderStyle;\n      _scene_mesh_instance_js__WEBPACK_IMPORTED_MODULE_4__.MeshInstance._prepareRenderStyleForArray(this._meshInstances, renderStyle);\n    }\n  }\n  get renderStyle() {\n    return this._renderStyle;\n  }\n  set customAabb(value) {\n    this._customAabb = value;\n    const mi = this._meshInstances;\n    if (mi) {\n      for (let i = 0; i < mi.length; i++) {\n        mi[i].setCustomAabb(this._customAabb);\n      }\n    }\n  }\n  get customAabb() {\n    return this._customAabb;\n  }\n  set type(value) {\n    if (this._type !== value) {\n      this._area = null;\n      this._type = value;\n      this.destroyMeshInstances();\n      if (value !== 'asset') {\n        let material = this._material;\n        if (!material || material === this.system.defaultMaterial) {\n          material = this._materialReferences[0] && this._materialReferences[0].asset && this._materialReferences[0].asset.resource;\n        }\n        const primData = (0,_scene_procedural_js__WEBPACK_IMPORTED_MODULE_5__.getShapePrimitive)(this.system.app.graphicsDevice, value);\n        this._area = primData.area;\n        this.meshInstances = [new _scene_mesh_instance_js__WEBPACK_IMPORTED_MODULE_4__.MeshInstance(primData.mesh, material || this.system.defaultMaterial, this.entity)];\n      }\n    }\n  }\n  get type() {\n    return this._type;\n  }\n  set meshInstances(value) {\n    this.destroyMeshInstances();\n    this._meshInstances = value;\n    if (this._meshInstances) {\n      const mi = this._meshInstances;\n      for (let i = 0; i < mi.length; i++) {\n        if (!mi[i].node) {\n          mi[i].node = this.entity;\n        }\n        mi[i].castShadow = this._castShadows;\n        mi[i].receiveShadow = this._receiveShadows;\n        mi[i].isStatic = this._isStatic;\n        mi[i].renderStyle = this._renderStyle;\n        mi[i].setLightmapped(this._lightmapped);\n        mi[i].setCustomAabb(this._customAabb);\n      }\n      if (this.enabled && this.entity.enabled) {\n        this.addToLayers();\n      }\n    }\n  }\n  get meshInstances() {\n    return this._meshInstances;\n  }\n  set lightmapped(value) {\n    if (value !== this._lightmapped) {\n      this._lightmapped = value;\n      const mi = this._meshInstances;\n      if (mi) {\n        for (let i = 0; i < mi.length; i++) {\n          mi[i].setLightmapped(value);\n        }\n      }\n    }\n  }\n  get lightmapped() {\n    return this._lightmapped;\n  }\n  set castShadows(value) {\n    if (this._castShadows !== value) {\n      const mi = this._meshInstances;\n      if (mi) {\n        const layers = this.layers;\n        const scene = this.system.app.scene;\n        if (this._castShadows && !value) {\n          for (let i = 0; i < layers.length; i++) {\n            const layer = scene.layers.getLayerById(this.layers[i]);\n            if (layer) {\n              layer.removeShadowCasters(mi);\n            }\n          }\n        }\n        for (let i = 0; i < mi.length; i++) {\n          mi[i].castShadow = value;\n        }\n        if (!this._castShadows && value) {\n          for (let i = 0; i < layers.length; i++) {\n            const layer = scene.layers.getLayerById(layers[i]);\n            if (layer) {\n              layer.addShadowCasters(mi);\n            }\n          }\n        }\n      }\n      this._castShadows = value;\n    }\n  }\n  get castShadows() {\n    return this._castShadows;\n  }\n  set receiveShadows(value) {\n    if (this._receiveShadows !== value) {\n      this._receiveShadows = value;\n      const mi = this._meshInstances;\n      if (mi) {\n        for (let i = 0; i < mi.length; i++) {\n          mi[i].receiveShadow = value;\n        }\n      }\n    }\n  }\n  get receiveShadows() {\n    return this._receiveShadows;\n  }\n  set castShadowsLightmap(value) {\n    this._castShadowsLightmap = value;\n  }\n  get castShadowsLightmap() {\n    return this._castShadowsLightmap;\n  }\n  set lightmapSizeMultiplier(value) {\n    this._lightmapSizeMultiplier = value;\n  }\n  get lightmapSizeMultiplier() {\n    return this._lightmapSizeMultiplier;\n  }\n  set isStatic(value) {\n    if (this._isStatic !== value) {\n      this._isStatic = value;\n      const mi = this._meshInstances;\n      if (mi) {\n        for (let i = 0; i < mi.length; i++) {\n          mi[i].isStatic = value;\n        }\n      }\n    }\n  }\n  get isStatic() {\n    return this._isStatic;\n  }\n  set layers(value) {\n    const layers = this.system.app.scene.layers;\n    let layer;\n    if (this._meshInstances) {\n      for (let i = 0; i < this._layers.length; i++) {\n        layer = layers.getLayerById(this._layers[i]);\n        if (layer) {\n          layer.removeMeshInstances(this._meshInstances);\n        }\n      }\n    }\n    this._layers.length = 0;\n    for (let i = 0; i < value.length; i++) {\n      this._layers[i] = value[i];\n    }\n    if (!this.enabled || !this.entity.enabled || !this._meshInstances) return;\n    for (let i = 0; i < this._layers.length; i++) {\n      layer = layers.getLayerById(this._layers[i]);\n      if (layer) {\n        layer.addMeshInstances(this._meshInstances);\n      }\n    }\n  }\n  get layers() {\n    return this._layers;\n  }\n  set batchGroupId(value) {\n    if (this._batchGroupId !== value) {\n      if (this.entity.enabled && this._batchGroupId >= 0) {\n        var _this$system$app$batc;\n        (_this$system$app$batc = this.system.app.batcher) == null ? void 0 : _this$system$app$batc.remove(_scene_batching_batch_group_js__WEBPACK_IMPORTED_MODULE_6__.BatchGroup.RENDER, this.batchGroupId, this.entity);\n      }\n      if (this.entity.enabled && value >= 0) {\n        var _this$system$app$batc2;\n        (_this$system$app$batc2 = this.system.app.batcher) == null ? void 0 : _this$system$app$batc2.insert(_scene_batching_batch_group_js__WEBPACK_IMPORTED_MODULE_6__.BatchGroup.RENDER, value, this.entity);\n      }\n      if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {\n        this.addToLayers();\n      }\n      this._batchGroupId = value;\n    }\n  }\n  get batchGroupId() {\n    return this._batchGroupId;\n  }\n  set material(value) {\n    if (this._material !== value) {\n      this._material = value;\n      if (this._meshInstances && this._type !== 'asset') {\n        for (let i = 0; i < this._meshInstances.length; i++) {\n          this._meshInstances[i].material = value;\n        }\n      }\n    }\n  }\n  get material() {\n    return this._material;\n  }\n  set materialAssets(value = []) {\n    if (this._materialReferences.length > value.length) {\n      for (let i = value.length; i < this._materialReferences.length; i++) {\n        this._materialReferences[i].id = null;\n      }\n      this._materialReferences.length = value.length;\n    }\n    for (let i = 0; i < value.length; i++) {\n      if (!this._materialReferences[i]) {\n        this._materialReferences.push(new _asset_asset_reference_js__WEBPACK_IMPORTED_MODULE_3__.AssetReference(i, this, this.system.app.assets, {\n          add: this._onMaterialAdded,\n          load: this._onMaterialLoad,\n          remove: this._onMaterialRemove,\n          unload: this._onMaterialUnload\n        }, this));\n      }\n      if (value[i]) {\n        const id = value[i] instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_7__.Asset ? value[i].id : value[i];\n        if (this._materialReferences[i].id !== id) {\n          this._materialReferences[i].id = id;\n        }\n        if (this._materialReferences[i].asset) {\n          this._onMaterialAdded(i, this, this._materialReferences[i].asset);\n        }\n      } else {\n        this._materialReferences[i].id = null;\n        if (this._meshInstances[i]) {\n          this._meshInstances[i].material = this.system.defaultMaterial;\n        }\n      }\n    }\n  }\n  get materialAssets() {\n    return this._materialReferences.map(function (ref) {\n      return ref.id;\n    });\n  }\n  set asset(value) {\n    const id = value instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_7__.Asset ? value.id : value;\n    if (this._assetReference.id === id) return;\n    if (this._assetReference.asset && this._assetReference.asset.resource) {\n      this._onRenderAssetRemove();\n    }\n    this._assetReference.id = id;\n    if (this._assetReference.asset) {\n      this._onRenderAssetAdded();\n    }\n  }\n  get asset() {\n    return this._assetReference.id;\n  }\n  assignAsset(asset) {\n    const id = asset instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_7__.Asset ? asset.id : asset;\n    this._assetReference.id = id;\n  }\n  _onSetRootBone(entity) {\n    if (entity) {\n      this._onRootBoneChanged();\n    }\n  }\n  _onRootBoneChanged() {\n    this._clearSkinInstances();\n    if (this.enabled && this.entity.enabled) {\n      this._cloneSkinInstances();\n    }\n  }\n  destroyMeshInstances() {\n    const meshInstances = this._meshInstances;\n    if (meshInstances) {\n      this.removeFromLayers();\n      this._clearSkinInstances();\n      for (let i = 0; i < meshInstances.length; i++) {\n        meshInstances[i].destroy();\n      }\n      this._meshInstances.length = 0;\n    }\n  }\n  addToLayers() {\n    const layers = this.system.app.scene.layers;\n    for (let i = 0; i < this._layers.length; i++) {\n      const layer = layers.getLayerById(this._layers[i]);\n      if (layer) {\n        layer.addMeshInstances(this._meshInstances);\n      }\n    }\n  }\n  removeFromLayers() {\n    if (this._meshInstances && this._meshInstances.length) {\n      const layers = this.system.app.scene.layers;\n      for (let i = 0; i < this._layers.length; i++) {\n        const layer = layers.getLayerById(this._layers[i]);\n        if (layer) {\n          layer.removeMeshInstances(this._meshInstances);\n        }\n      }\n    }\n  }\n  onRemoveChild() {\n    this.removeFromLayers();\n  }\n  onInsertChild() {\n    if (this._meshInstances && this.enabled && this.entity.enabled) {\n      this.addToLayers();\n    }\n  }\n  onRemove() {\n    this.destroyMeshInstances();\n    this.asset = null;\n    this.materialAsset = null;\n    this._assetReference.id = null;\n    for (let i = 0; i < this._materialReferences.length; i++) {\n      this._materialReferences[i].id = null;\n    }\n    this.entity.off('remove', this.onRemoveChild, this);\n    this.entity.off('insert', this.onInsertChild, this);\n  }\n  onLayersChanged(oldComp, newComp) {\n    this.addToLayers();\n    oldComp.off('add', this.onLayerAdded, this);\n    oldComp.off('remove', this.onLayerRemoved, this);\n    newComp.on('add', this.onLayerAdded, this);\n    newComp.on('remove', this.onLayerRemoved, this);\n  }\n  onLayerAdded(layer) {\n    const index = this.layers.indexOf(layer.id);\n    if (index < 0) return;\n    layer.addMeshInstances(this._meshInstances);\n  }\n  onLayerRemoved(layer) {\n    const index = this.layers.indexOf(layer.id);\n    if (index < 0) return;\n    layer.removeMeshInstances(this._meshInstances);\n  }\n  onEnable() {\n    const app = this.system.app;\n    const scene = app.scene;\n    this._rootBone.onParentComponentEnable();\n    this._cloneSkinInstances();\n    scene.on('set:layers', this.onLayersChanged, this);\n    if (scene.layers) {\n      scene.layers.on('add', this.onLayerAdded, this);\n      scene.layers.on('remove', this.onLayerRemoved, this);\n    }\n    const isAsset = this._type === 'asset';\n    if (this._meshInstances && this._meshInstances.length) {\n      this.addToLayers();\n    } else if (isAsset && this.asset) {\n      this._onRenderAssetAdded();\n    }\n    for (let i = 0; i < this._materialReferences.length; i++) {\n      if (this._materialReferences[i].asset) {\n        this.system.app.assets.load(this._materialReferences[i].asset);\n      }\n    }\n    if (this._batchGroupId >= 0) {\n      var _app$batcher;\n      (_app$batcher = app.batcher) == null ? void 0 : _app$batcher.insert(_scene_batching_batch_group_js__WEBPACK_IMPORTED_MODULE_6__.BatchGroup.RENDER, this.batchGroupId, this.entity);\n    }\n  }\n  onDisable() {\n    const app = this.system.app;\n    const scene = app.scene;\n    scene.off('set:layers', this.onLayersChanged, this);\n    if (scene.layers) {\n      scene.layers.off('add', this.onLayerAdded, this);\n      scene.layers.off('remove', this.onLayerRemoved, this);\n    }\n    if (this._batchGroupId >= 0) {\n      var _app$batcher2;\n      (_app$batcher2 = app.batcher) == null ? void 0 : _app$batcher2.remove(_scene_batching_batch_group_js__WEBPACK_IMPORTED_MODULE_6__.BatchGroup.RENDER, this.batchGroupId, this.entity);\n    }\n    this.removeFromLayers();\n  }\n  hide() {\n    if (this._meshInstances) {\n      for (let i = 0; i < this._meshInstances.length; i++) {\n        this._meshInstances[i].visible = false;\n      }\n    }\n  }\n  show() {\n    if (this._meshInstances) {\n      for (let i = 0; i < this._meshInstances.length; i++) {\n        this._meshInstances[i].visible = true;\n      }\n    }\n  }\n  _onRenderAssetAdded() {\n    if (!this._assetReference.asset) return;\n    if (this._assetReference.asset.resource) {\n      this._onRenderAssetLoad();\n    } else if (this.enabled && this.entity.enabled) {\n      this.system.app.assets.load(this._assetReference.asset);\n    }\n  }\n  _onRenderAssetLoad() {\n    this.destroyMeshInstances();\n    if (this._assetReference.asset) {\n      const render = this._assetReference.asset.resource;\n      render.off('set:meshes', this._onSetMeshes, this);\n      render.on('set:meshes', this._onSetMeshes, this);\n      if (render.meshes) {\n        this._onSetMeshes(render.meshes);\n      }\n    }\n  }\n  _onSetMeshes(meshes) {\n    this._cloneMeshes(meshes);\n  }\n  _clearSkinInstances() {\n    for (let i = 0; i < this._meshInstances.length; i++) {\n      const meshInstance = this._meshInstances[i];\n      _scene_skin_instance_cache_js__WEBPACK_IMPORTED_MODULE_8__.SkinInstanceCache.removeCachedSkinInstance(meshInstance.skinInstance);\n      meshInstance.skinInstance = null;\n    }\n  }\n  _cloneSkinInstances() {\n    if (this._meshInstances.length && this._rootBone.entity instanceof _scene_graph_node_js__WEBPACK_IMPORTED_MODULE_9__.GraphNode) {\n      for (let i = 0; i < this._meshInstances.length; i++) {\n        const meshInstance = this._meshInstances[i];\n        const mesh = meshInstance.mesh;\n        if (mesh.skin && !meshInstance.skinInstance) {\n          meshInstance.skinInstance = _scene_skin_instance_cache_js__WEBPACK_IMPORTED_MODULE_8__.SkinInstanceCache.createCachedSkinInstance(mesh.skin, this._rootBone.entity, this.entity);\n        }\n      }\n    }\n  }\n  _cloneMeshes(meshes) {\n    if (meshes && meshes.length) {\n      const meshInstances = [];\n      for (let i = 0; i < meshes.length; i++) {\n        const mesh = meshes[i];\n        const material = this._materialReferences[i] && this._materialReferences[i].asset && this._materialReferences[i].asset.resource;\n        const meshInst = new _scene_mesh_instance_js__WEBPACK_IMPORTED_MODULE_4__.MeshInstance(mesh, material || this.system.defaultMaterial, this.entity);\n        meshInstances.push(meshInst);\n        if (mesh.morph) {\n          meshInst.morphInstance = new _scene_morph_instance_js__WEBPACK_IMPORTED_MODULE_10__.MorphInstance(mesh.morph);\n        }\n      }\n      this.meshInstances = meshInstances;\n      this._cloneSkinInstances();\n    }\n  }\n  _onRenderAssetUnload() {\n    if (this._type === 'asset') {\n      this.destroyMeshInstances();\n    }\n  }\n  _onRenderAssetRemove() {\n    if (this._assetReference.asset && this._assetReference.asset.resource) {\n      this._assetReference.asset.resource.off('set:meshes', this._onSetMeshes, this);\n    }\n    this._onRenderAssetUnload();\n  }\n  _onMaterialAdded(index, component, asset) {\n    if (asset.resource) {\n      this._onMaterialLoad(index, component, asset);\n    } else {\n      if (this.enabled && this.entity.enabled) {\n        this.system.app.assets.load(asset);\n      }\n    }\n  }\n  _updateMainMaterial(index, material) {\n    if (index === 0) {\n      this.material = material;\n    }\n  }\n  _onMaterialLoad(index, component, asset) {\n    if (this._meshInstances[index]) {\n      this._meshInstances[index].material = asset.resource;\n    }\n    this._updateMainMaterial(index, asset.resource);\n  }\n  _onMaterialRemove(index, component, asset) {\n    if (this._meshInstances[index]) {\n      this._meshInstances[index].material = this.system.defaultMaterial;\n    }\n    this._updateMainMaterial(index, this.system.defaultMaterial);\n  }\n  _onMaterialUnload(index, component, asset) {\n    if (this._meshInstances[index]) {\n      this._meshInstances[index].material = this.system.defaultMaterial;\n    }\n    this._updateMainMaterial(index, this.system.defaultMaterial);\n  }\n  resolveDuplicatedEntityReferenceProperties(oldRender, duplicatedIdsMap) {\n    if (oldRender.rootBone && duplicatedIdsMap[oldRender.rootBone]) {\n      this.rootBone = duplicatedIdsMap[oldRender.rootBone];\n    }\n    this._clearSkinInstances();\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/render/component.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/render/data.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/render/data.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RenderComponentData\": () => (/* binding */ RenderComponentData)\n/* harmony export */ });\nclass RenderComponentData {\n  constructor() {\n    this.enabled = true;\n    this.rootBone = null;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/render/data.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/render/system.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/render/system.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RenderComponentSystem\": () => (/* binding */ RenderComponentSystem)\n/* harmony export */ });\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/shape/bounding-box.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/shape/bounding-box.js\");\n/* harmony import */ var _scene_materials_default_material_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../scene/materials/default-material.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/default-material.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/system.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/render/component.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/render/data.js\");\n\n\n\n\n\n\n\n\nconst _schema = [{\n  name: 'rootBone',\n  type: 'entity'\n}, 'enabled'];\nconst _properties = ['material', 'meshInstances', 'asset', 'materialAssets', 'castShadows', 'receiveShadows', 'castShadowsLightmap', 'lightmapped', 'lightmapSizeMultiplier', 'renderStyle', 'type', 'layers', 'isStatic', 'batchGroupId'];\nclass RenderComponentSystem extends _system_js__WEBPACK_IMPORTED_MODULE_0__.ComponentSystem {\n  constructor(app) {\n    super(app);\n    this.id = 'render';\n    this.ComponentType = _component_js__WEBPACK_IMPORTED_MODULE_1__.RenderComponent;\n    this.DataType = _data_js__WEBPACK_IMPORTED_MODULE_2__.RenderComponentData;\n    this.schema = _schema;\n    this.defaultMaterial = (0,_scene_materials_default_material_js__WEBPACK_IMPORTED_MODULE_3__.getDefaultMaterial)(app.graphicsDevice);\n    this.on('beforeremove', this.onRemove, this);\n  }\n  initializeComponentData(component, _data, properties) {\n    if (_data.batchGroupId === null || _data.batchGroupId === undefined) {\n      _data.batchGroupId = -1;\n    }\n    if (_data.layers && _data.layers.length) {\n      _data.layers = _data.layers.slice(0);\n    }\n    for (let i = 0; i < _properties.length; i++) {\n      if (_data.hasOwnProperty(_properties[i])) {\n        component[_properties[i]] = _data[_properties[i]];\n      }\n    }\n    if (_data.aabbCenter && _data.aabbHalfExtents) {\n      component.customAabb = new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_4__.BoundingBox(new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3(_data.aabbCenter), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3(_data.aabbHalfExtents));\n    }\n    super.initializeComponentData(component, _data, _schema);\n  }\n  cloneComponent(entity, clone) {\n    const data = {};\n    for (let i = 0; i < _properties.length; i++) {\n      data[_properties[i]] = entity.render[_properties[i]];\n    }\n    data.enabled = entity.render.enabled;\n    delete data.meshInstances;\n    const component = this.addComponent(clone, data);\n    const srcMeshInstances = entity.render.meshInstances;\n    const meshes = srcMeshInstances.map(mi => mi.mesh);\n    component._onSetMeshes(meshes);\n    for (let m = 0; m < srcMeshInstances.length; m++) {\n      component.meshInstances[m].material = srcMeshInstances[m].material;\n    }\n    if (entity.render.customAabb) {\n      component.customAabb = entity.render.customAabb.clone();\n    }\n    return component;\n  }\n  onRemove(entity, component) {\n    component.onRemove();\n  }\n}\n_component_js__WEBPACK_IMPORTED_MODULE_6__.Component._buildAccessors(_component_js__WEBPACK_IMPORTED_MODULE_1__.RenderComponent.prototype, _schema);\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/render/system.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/rigid-body/component.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/rigid-body/component.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RigidBodyComponent\": () => (/* binding */ RigidBodyComponent)\n/* harmony export */ });\n/* harmony import */ var _core_math_quat_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/math/quat.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/quat.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/rigid-body/constants.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n\n\n\n\n\nlet _ammoTransform;\nlet _ammoVec1, _ammoVec2, _ammoQuat;\nconst _quat1 = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_0__.Quat();\nconst _quat2 = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_0__.Quat();\nconst _vec3 = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nclass RigidBodyComponent extends _component_js__WEBPACK_IMPORTED_MODULE_2__.Component {\n  constructor(system, entity) {\n    super(system, entity);\n    this._angularDamping = 0;\n    this._angularFactor = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3(1, 1, 1);\n    this._angularVelocity = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n    this._body = null;\n    this._friction = 0.5;\n    this._group = _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYGROUP_STATIC;\n    this._linearDamping = 0;\n    this._linearFactor = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3(1, 1, 1);\n    this._linearVelocity = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n    this._mask = _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYMASK_NOT_STATIC;\n    this._mass = 1;\n    this._restitution = 0;\n    this._rollingFriction = 0;\n    this._simulationEnabled = false;\n    this._type = _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYTYPE_STATIC;\n  }\n  static onLibraryLoaded() {\n    if (typeof Ammo !== 'undefined') {\n      _ammoTransform = new Ammo.btTransform();\n      _ammoVec1 = new Ammo.btVector3();\n      _ammoVec2 = new Ammo.btVector3();\n      _ammoQuat = new Ammo.btQuaternion();\n    }\n  }\n  set angularDamping(damping) {\n    if (this._angularDamping !== damping) {\n      this._angularDamping = damping;\n      if (this._body) {\n        this._body.setDamping(this._linearDamping, damping);\n      }\n    }\n  }\n  get angularDamping() {\n    return this._angularDamping;\n  }\n  set angularFactor(factor) {\n    if (!this._angularFactor.equals(factor)) {\n      this._angularFactor.copy(factor);\n      if (this._body && this._type === _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYTYPE_DYNAMIC) {\n        _ammoVec1.setValue(factor.x, factor.y, factor.z);\n        this._body.setAngularFactor(_ammoVec1);\n      }\n    }\n  }\n  get angularFactor() {\n    return this._angularFactor;\n  }\n  set angularVelocity(velocity) {\n    if (this._body && this._type === _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYTYPE_DYNAMIC) {\n      this._body.activate();\n      _ammoVec1.setValue(velocity.x, velocity.y, velocity.z);\n      this._body.setAngularVelocity(_ammoVec1);\n      this._angularVelocity.copy(velocity);\n    }\n  }\n  get angularVelocity() {\n    if (this._body && this._type === _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYTYPE_DYNAMIC) {\n      const velocity = this._body.getAngularVelocity();\n      this._angularVelocity.set(velocity.x(), velocity.y(), velocity.z());\n    }\n    return this._angularVelocity;\n  }\n  set body(body) {\n    if (this._body !== body) {\n      this._body = body;\n      if (body && this._simulationEnabled) {\n        body.activate();\n      }\n    }\n  }\n  get body() {\n    return this._body;\n  }\n  set friction(friction) {\n    if (this._friction !== friction) {\n      this._friction = friction;\n      if (this._body) {\n        this._body.setFriction(friction);\n      }\n    }\n  }\n  get friction() {\n    return this._friction;\n  }\n  set group(group) {\n    if (this._group !== group) {\n      this._group = group;\n      if (this.enabled && this.entity.enabled) {\n        this.disableSimulation();\n        this.enableSimulation();\n      }\n    }\n  }\n  get group() {\n    return this._group;\n  }\n  set linearDamping(damping) {\n    if (this._linearDamping !== damping) {\n      this._linearDamping = damping;\n      if (this._body) {\n        this._body.setDamping(damping, this._angularDamping);\n      }\n    }\n  }\n  get linearDamping() {\n    return this._linearDamping;\n  }\n  set linearFactor(factor) {\n    if (!this._linearFactor.equals(factor)) {\n      this._linearFactor.copy(factor);\n      if (this._body && this._type === _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYTYPE_DYNAMIC) {\n        _ammoVec1.setValue(factor.x, factor.y, factor.z);\n        this._body.setLinearFactor(_ammoVec1);\n      }\n    }\n  }\n  get linearFactor() {\n    return this._linearFactor;\n  }\n  set linearVelocity(velocity) {\n    if (this._body && this._type === _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYTYPE_DYNAMIC) {\n      this._body.activate();\n      _ammoVec1.setValue(velocity.x, velocity.y, velocity.z);\n      this._body.setLinearVelocity(_ammoVec1);\n      this._linearVelocity.copy(velocity);\n    }\n  }\n  get linearVelocity() {\n    if (this._body && this._type === _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYTYPE_DYNAMIC) {\n      const velocity = this._body.getLinearVelocity();\n      this._linearVelocity.set(velocity.x(), velocity.y(), velocity.z());\n    }\n    return this._linearVelocity;\n  }\n  set mask(mask) {\n    if (this._mask !== mask) {\n      this._mask = mask;\n      if (this.enabled && this.entity.enabled) {\n        this.disableSimulation();\n        this.enableSimulation();\n      }\n    }\n  }\n  get mask() {\n    return this._mask;\n  }\n  set mass(mass) {\n    if (this._mass !== mass) {\n      this._mass = mass;\n      if (this._body && this._type === _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYTYPE_DYNAMIC) {\n        const enabled = this.enabled && this.entity.enabled;\n        if (enabled) {\n          this.disableSimulation();\n        }\n        this._body.getCollisionShape().calculateLocalInertia(mass, _ammoVec1);\n        this._body.setMassProps(mass, _ammoVec1);\n        this._body.updateInertiaTensor();\n        if (enabled) {\n          this.enableSimulation();\n        }\n      }\n    }\n  }\n  get mass() {\n    return this._mass;\n  }\n  set restitution(restitution) {\n    if (this._restitution !== restitution) {\n      this._restitution = restitution;\n      if (this._body) {\n        this._body.setRestitution(restitution);\n      }\n    }\n  }\n  get restitution() {\n    return this._restitution;\n  }\n  set rollingFriction(friction) {\n    if (this._rollingFriction !== friction) {\n      this._rollingFriction = friction;\n      if (this._body) {\n        this._body.setRollingFriction(friction);\n      }\n    }\n  }\n  get rollingFriction() {\n    return this._rollingFriction;\n  }\n  set type(type) {\n    if (this._type !== type) {\n      this._type = type;\n      this.disableSimulation();\n      switch (type) {\n        case _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYTYPE_DYNAMIC:\n          this._group = _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYGROUP_DYNAMIC;\n          this._mask = _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYMASK_ALL;\n          break;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYTYPE_KINEMATIC:\n          this._group = _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYGROUP_KINEMATIC;\n          this._mask = _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYMASK_ALL;\n          break;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYTYPE_STATIC:\n        default:\n          this._group = _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYGROUP_STATIC;\n          this._mask = _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYMASK_NOT_STATIC;\n          break;\n      }\n      this.createBody();\n    }\n  }\n  get type() {\n    return this._type;\n  }\n  createBody() {\n    const entity = this.entity;\n    let shape;\n    if (entity.collision) {\n      shape = entity.collision.shape;\n      if (entity.trigger) {\n        entity.trigger.destroy();\n        delete entity.trigger;\n      }\n    }\n    if (shape) {\n      if (this._body) this.system.onRemove(entity, this);\n      const mass = this._type === _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYTYPE_DYNAMIC ? this._mass : 0;\n      this._getEntityTransform(_ammoTransform);\n      const body = this.system.createBody(mass, shape, _ammoTransform);\n      body.setRestitution(this._restitution);\n      body.setFriction(this._friction);\n      body.setRollingFriction(this._rollingFriction);\n      body.setDamping(this._linearDamping, this._angularDamping);\n      if (this._type === _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYTYPE_DYNAMIC) {\n        const linearFactor = this._linearFactor;\n        _ammoVec1.setValue(linearFactor.x, linearFactor.y, linearFactor.z);\n        body.setLinearFactor(_ammoVec1);\n        const angularFactor = this._angularFactor;\n        _ammoVec1.setValue(angularFactor.x, angularFactor.y, angularFactor.z);\n        body.setAngularFactor(_ammoVec1);\n      } else if (this._type === _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYTYPE_KINEMATIC) {\n        body.setCollisionFlags(body.getCollisionFlags() | _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYFLAG_KINEMATIC_OBJECT);\n        body.setActivationState(_constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYSTATE_DISABLE_DEACTIVATION);\n      }\n      body.entity = entity;\n      this.body = body;\n      if (this.enabled && entity.enabled) {\n        this.enableSimulation();\n      }\n    }\n  }\n  isActive() {\n    return this._body ? this._body.isActive() : false;\n  }\n  activate() {\n    if (this._body) {\n      this._body.activate();\n    }\n  }\n  enableSimulation() {\n    const entity = this.entity;\n    if (entity.collision && entity.collision.enabled && !this._simulationEnabled) {\n      const body = this._body;\n      if (body) {\n        this.system.addBody(body, this._group, this._mask);\n        switch (this._type) {\n          case _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYTYPE_DYNAMIC:\n            this.system._dynamic.push(this);\n            body.forceActivationState(_constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYSTATE_ACTIVE_TAG);\n            this.syncEntityToBody();\n            break;\n          case _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYTYPE_KINEMATIC:\n            this.system._kinematic.push(this);\n            body.forceActivationState(_constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYSTATE_DISABLE_DEACTIVATION);\n            break;\n          case _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYTYPE_STATIC:\n            body.forceActivationState(_constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYSTATE_ACTIVE_TAG);\n            this.syncEntityToBody();\n            break;\n        }\n        if (entity.collision.type === 'compound') {\n          this.system._compounds.push(entity.collision);\n        }\n        body.activate();\n        this._simulationEnabled = true;\n      }\n    }\n  }\n  disableSimulation() {\n    const body = this._body;\n    if (body && this._simulationEnabled) {\n      const system = this.system;\n      let idx = system._compounds.indexOf(this.entity.collision);\n      if (idx > -1) {\n        system._compounds.splice(idx, 1);\n      }\n      idx = system._dynamic.indexOf(this);\n      if (idx > -1) {\n        system._dynamic.splice(idx, 1);\n      }\n      idx = system._kinematic.indexOf(this);\n      if (idx > -1) {\n        system._kinematic.splice(idx, 1);\n      }\n      system.removeBody(body);\n      body.forceActivationState(_constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYSTATE_DISABLE_SIMULATION);\n      this._simulationEnabled = false;\n    }\n  }\n  applyForce(x, y, z, px, py, pz) {\n    const body = this._body;\n    if (body) {\n      body.activate();\n      if (x instanceof _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3) {\n        _ammoVec1.setValue(x.x, x.y, x.z);\n      } else {\n        _ammoVec1.setValue(x, y, z);\n      }\n      if (y instanceof _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3) {\n        _ammoVec2.setValue(y.x, y.y, y.z);\n      } else if (px !== undefined) {\n        _ammoVec2.setValue(px, py, pz);\n      } else {\n        _ammoVec2.setValue(0, 0, 0);\n      }\n      body.applyForce(_ammoVec1, _ammoVec2);\n    }\n  }\n  applyTorque(x, y, z) {\n    const body = this._body;\n    if (body) {\n      body.activate();\n      if (x instanceof _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3) {\n        _ammoVec1.setValue(x.x, x.y, x.z);\n      } else {\n        _ammoVec1.setValue(x, y, z);\n      }\n      body.applyTorque(_ammoVec1);\n    }\n  }\n  applyImpulse(x, y, z, px, py, pz) {\n    const body = this._body;\n    if (body) {\n      body.activate();\n      if (x instanceof _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3) {\n        _ammoVec1.setValue(x.x, x.y, x.z);\n      } else {\n        _ammoVec1.setValue(x, y, z);\n      }\n      if (y instanceof _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3) {\n        _ammoVec2.setValue(y.x, y.y, y.z);\n      } else if (px !== undefined) {\n        _ammoVec2.setValue(px, py, pz);\n      } else {\n        _ammoVec2.setValue(0, 0, 0);\n      }\n      body.applyImpulse(_ammoVec1, _ammoVec2);\n    }\n  }\n  applyTorqueImpulse(x, y, z) {\n    const body = this._body;\n    if (body) {\n      body.activate();\n      if (x instanceof _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3) {\n        _ammoVec1.setValue(x.x, x.y, x.z);\n      } else {\n        _ammoVec1.setValue(x, y, z);\n      }\n      body.applyTorqueImpulse(_ammoVec1);\n    }\n  }\n  isStatic() {\n    return this._type === _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYTYPE_STATIC;\n  }\n  isStaticOrKinematic() {\n    return this._type === _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYTYPE_STATIC || this._type === _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYTYPE_KINEMATIC;\n  }\n  isKinematic() {\n    return this._type === _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYTYPE_KINEMATIC;\n  }\n  _getEntityTransform(transform) {\n    const entity = this.entity;\n    const component = entity.collision;\n    if (component) {\n      const bodyPos = component.getShapePosition();\n      const bodyRot = component.getShapeRotation();\n      _ammoVec1.setValue(bodyPos.x, bodyPos.y, bodyPos.z);\n      _ammoQuat.setValue(bodyRot.x, bodyRot.y, bodyRot.z, bodyRot.w);\n    } else {\n      const pos = entity.getPosition();\n      const rot = entity.getRotation();\n      _ammoVec1.setValue(pos.x, pos.y, pos.z);\n      _ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);\n    }\n    transform.setOrigin(_ammoVec1);\n    transform.setRotation(_ammoQuat);\n  }\n  syncEntityToBody() {\n    const body = this._body;\n    if (body) {\n      this._getEntityTransform(_ammoTransform);\n      body.setWorldTransform(_ammoTransform);\n      if (this._type === _constants_js__WEBPACK_IMPORTED_MODULE_3__.BODYTYPE_KINEMATIC) {\n        const motionState = body.getMotionState();\n        if (motionState) {\n          motionState.setWorldTransform(_ammoTransform);\n        }\n      }\n      body.activate();\n    }\n  }\n  _updateDynamic() {\n    const body = this._body;\n    if (body.isActive()) {\n      const motionState = body.getMotionState();\n      if (motionState) {\n        const entity = this.entity;\n        motionState.getWorldTransform(_ammoTransform);\n        const p = _ammoTransform.getOrigin();\n        const q = _ammoTransform.getRotation();\n        const component = entity.collision;\n        if (component && component._hasOffset) {\n          const lo = component.data.linearOffset;\n          const ao = component.data.angularOffset;\n          const invertedAo = _quat2.copy(ao).invert();\n          const entityRot = _quat1.set(q.x(), q.y(), q.z(), q.w()).mul(invertedAo);\n          entityRot.transformVector(lo, _vec3);\n          entity.setPosition(p.x() - _vec3.x, p.y() - _vec3.y, p.z() - _vec3.z);\n          entity.setRotation(entityRot);\n        } else {\n          entity.setPosition(p.x(), p.y(), p.z());\n          entity.setRotation(q.x(), q.y(), q.z(), q.w());\n        }\n      }\n    }\n  }\n  _updateKinematic() {\n    const motionState = this._body.getMotionState();\n    if (motionState) {\n      this._getEntityTransform(_ammoTransform);\n      motionState.setWorldTransform(_ammoTransform);\n    }\n  }\n  teleport(x, y, z, rx, ry, rz) {\n    if (x instanceof _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3) {\n      this.entity.setPosition(x);\n    } else {\n      this.entity.setPosition(x, y, z);\n    }\n    if (y instanceof _core_math_quat_js__WEBPACK_IMPORTED_MODULE_0__.Quat) {\n      this.entity.setRotation(y);\n    } else if (y instanceof _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3) {\n      this.entity.setEulerAngles(y);\n    } else if (rx !== undefined) {\n      this.entity.setEulerAngles(rx, ry, rz);\n    }\n    this.syncEntityToBody();\n  }\n  onEnable() {\n    if (!this._body) {\n      this.createBody();\n    }\n    this.enableSimulation();\n  }\n  onDisable() {\n    this.disableSimulation();\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/rigid-body/component.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/rigid-body/constants.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/rigid-body/constants.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BODYFLAG_KINEMATIC_OBJECT\": () => (/* binding */ BODYFLAG_KINEMATIC_OBJECT),\n/* harmony export */   \"BODYFLAG_NORESPONSE_OBJECT\": () => (/* binding */ BODYFLAG_NORESPONSE_OBJECT),\n/* harmony export */   \"BODYFLAG_STATIC_OBJECT\": () => (/* binding */ BODYFLAG_STATIC_OBJECT),\n/* harmony export */   \"BODYGROUP_DEFAULT\": () => (/* binding */ BODYGROUP_DEFAULT),\n/* harmony export */   \"BODYGROUP_DYNAMIC\": () => (/* binding */ BODYGROUP_DYNAMIC),\n/* harmony export */   \"BODYGROUP_ENGINE_1\": () => (/* binding */ BODYGROUP_ENGINE_1),\n/* harmony export */   \"BODYGROUP_ENGINE_2\": () => (/* binding */ BODYGROUP_ENGINE_2),\n/* harmony export */   \"BODYGROUP_ENGINE_3\": () => (/* binding */ BODYGROUP_ENGINE_3),\n/* harmony export */   \"BODYGROUP_KINEMATIC\": () => (/* binding */ BODYGROUP_KINEMATIC),\n/* harmony export */   \"BODYGROUP_NONE\": () => (/* binding */ BODYGROUP_NONE),\n/* harmony export */   \"BODYGROUP_STATIC\": () => (/* binding */ BODYGROUP_STATIC),\n/* harmony export */   \"BODYGROUP_TRIGGER\": () => (/* binding */ BODYGROUP_TRIGGER),\n/* harmony export */   \"BODYGROUP_USER_1\": () => (/* binding */ BODYGROUP_USER_1),\n/* harmony export */   \"BODYGROUP_USER_2\": () => (/* binding */ BODYGROUP_USER_2),\n/* harmony export */   \"BODYGROUP_USER_3\": () => (/* binding */ BODYGROUP_USER_3),\n/* harmony export */   \"BODYGROUP_USER_4\": () => (/* binding */ BODYGROUP_USER_4),\n/* harmony export */   \"BODYGROUP_USER_5\": () => (/* binding */ BODYGROUP_USER_5),\n/* harmony export */   \"BODYGROUP_USER_6\": () => (/* binding */ BODYGROUP_USER_6),\n/* harmony export */   \"BODYGROUP_USER_7\": () => (/* binding */ BODYGROUP_USER_7),\n/* harmony export */   \"BODYGROUP_USER_8\": () => (/* binding */ BODYGROUP_USER_8),\n/* harmony export */   \"BODYMASK_ALL\": () => (/* binding */ BODYMASK_ALL),\n/* harmony export */   \"BODYMASK_NONE\": () => (/* binding */ BODYMASK_NONE),\n/* harmony export */   \"BODYMASK_NOT_STATIC\": () => (/* binding */ BODYMASK_NOT_STATIC),\n/* harmony export */   \"BODYMASK_NOT_STATIC_KINEMATIC\": () => (/* binding */ BODYMASK_NOT_STATIC_KINEMATIC),\n/* harmony export */   \"BODYMASK_STATIC\": () => (/* binding */ BODYMASK_STATIC),\n/* harmony export */   \"BODYSTATE_ACTIVE_TAG\": () => (/* binding */ BODYSTATE_ACTIVE_TAG),\n/* harmony export */   \"BODYSTATE_DISABLE_DEACTIVATION\": () => (/* binding */ BODYSTATE_DISABLE_DEACTIVATION),\n/* harmony export */   \"BODYSTATE_DISABLE_SIMULATION\": () => (/* binding */ BODYSTATE_DISABLE_SIMULATION),\n/* harmony export */   \"BODYSTATE_ISLAND_SLEEPING\": () => (/* binding */ BODYSTATE_ISLAND_SLEEPING),\n/* harmony export */   \"BODYSTATE_WANTS_DEACTIVATION\": () => (/* binding */ BODYSTATE_WANTS_DEACTIVATION),\n/* harmony export */   \"BODYTYPE_DYNAMIC\": () => (/* binding */ BODYTYPE_DYNAMIC),\n/* harmony export */   \"BODYTYPE_KINEMATIC\": () => (/* binding */ BODYTYPE_KINEMATIC),\n/* harmony export */   \"BODYTYPE_STATIC\": () => (/* binding */ BODYTYPE_STATIC)\n/* harmony export */ });\nconst BODYTYPE_STATIC = 'static';\nconst BODYTYPE_DYNAMIC = 'dynamic';\nconst BODYTYPE_KINEMATIC = 'kinematic';\nconst BODYFLAG_STATIC_OBJECT = 1;\nconst BODYFLAG_KINEMATIC_OBJECT = 2;\nconst BODYFLAG_NORESPONSE_OBJECT = 4;\nconst BODYSTATE_ACTIVE_TAG = 1;\nconst BODYSTATE_ISLAND_SLEEPING = 2;\nconst BODYSTATE_WANTS_DEACTIVATION = 3;\nconst BODYSTATE_DISABLE_DEACTIVATION = 4;\nconst BODYSTATE_DISABLE_SIMULATION = 5;\nconst BODYGROUP_NONE = 0;\nconst BODYGROUP_DEFAULT = 1;\nconst BODYGROUP_DYNAMIC = 1;\nconst BODYGROUP_STATIC = 2;\nconst BODYGROUP_KINEMATIC = 4;\nconst BODYGROUP_ENGINE_1 = 8;\nconst BODYGROUP_TRIGGER = 16;\nconst BODYGROUP_ENGINE_2 = 32;\nconst BODYGROUP_ENGINE_3 = 64;\nconst BODYGROUP_USER_1 = 128;\nconst BODYGROUP_USER_2 = 256;\nconst BODYGROUP_USER_3 = 512;\nconst BODYGROUP_USER_4 = 1024;\nconst BODYGROUP_USER_5 = 2048;\nconst BODYGROUP_USER_6 = 4096;\nconst BODYGROUP_USER_7 = 8192;\nconst BODYGROUP_USER_8 = 16384;\nconst BODYMASK_NONE = 0;\nconst BODYMASK_ALL = 65535;\nconst BODYMASK_STATIC = 2;\nconst BODYMASK_NOT_STATIC = 65535 ^ 2;\nconst BODYMASK_NOT_STATIC_KINEMATIC = 65535 ^ (2 | 4);\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/rigid-body/constants.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/rigid-body/data.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/rigid-body/data.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RigidBodyComponentData\": () => (/* binding */ RigidBodyComponentData)\n/* harmony export */ });\nclass RigidBodyComponentData {\n  constructor() {\n    this.enabled = true;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/rigid-body/data.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/rigid-body/system.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/rigid-body/system.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ContactPoint\": () => (/* binding */ ContactPoint),\n/* harmony export */   \"ContactResult\": () => (/* binding */ ContactResult),\n/* harmony export */   \"RaycastResult\": () => (/* binding */ RaycastResult),\n/* harmony export */   \"RigidBodyComponentSystem\": () => (/* binding */ RigidBodyComponentSystem),\n/* harmony export */   \"SingleContactResult\": () => (/* binding */ SingleContactResult)\n/* harmony export */ });\n/* harmony import */ var _core_object_pool_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/object-pool.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/object-pool.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/system.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/rigid-body/constants.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/rigid-body/component.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/rigid-body/data.js\");\n\n\n\n\n\n\n\n\n\n\nlet ammoRayStart, ammoRayEnd;\nclass RaycastResult {\n  constructor(entity, point, normal) {\n    this.entity = entity;\n    this.point = point;\n    this.normal = normal;\n  }\n}\nclass SingleContactResult {\n  constructor(a, b, contactPoint) {\n    if (arguments.length === 0) {\n      this.a = null;\n      this.b = null;\n      this.impulse = 0;\n      this.localPointA = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n      this.localPointB = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n      this.pointA = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n      this.pointB = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n      this.normal = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n    } else {\n      this.a = a;\n      this.b = b;\n      this.impulse = contactPoint.impulse;\n      this.localPointA = contactPoint.localPoint;\n      this.localPointB = contactPoint.localPointOther;\n      this.pointA = contactPoint.point;\n      this.pointB = contactPoint.pointOther;\n      this.normal = contactPoint.normal;\n    }\n  }\n}\nclass ContactPoint {\n  constructor(localPoint = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(), localPointOther = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(), point = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(), pointOther = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(), normal = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(), impulse = 0) {\n    this.localPoint = localPoint;\n    this.localPointOther = localPointOther;\n    this.point = point;\n    this.pointOther = pointOther;\n    this.normal = normal;\n    this.impulse = impulse;\n  }\n}\nclass ContactResult {\n  constructor(other, contacts) {\n    this.other = other;\n    this.contacts = contacts;\n  }\n}\nconst _schema = ['enabled'];\nclass RigidBodyComponentSystem extends _system_js__WEBPACK_IMPORTED_MODULE_1__.ComponentSystem {\n  constructor(app) {\n    super(app);\n    this.maxSubSteps = 10;\n    this.fixedTimeStep = 1 / 60;\n    this.gravity = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(0, -9.81, 0);\n    this._dynamic = [];\n    this._kinematic = [];\n    this._triggers = [];\n    this._compounds = [];\n    this.id = 'rigidbody';\n    this._stats = app.stats.frame;\n    this.ComponentType = _component_js__WEBPACK_IMPORTED_MODULE_2__.RigidBodyComponent;\n    this.DataType = _data_js__WEBPACK_IMPORTED_MODULE_3__.RigidBodyComponentData;\n    this.contactPointPool = null;\n    this.contactResultPool = null;\n    this.singleContactResultPool = null;\n    this.schema = _schema;\n    this.collisions = {};\n    this.frameCollisions = {};\n    this.on('beforeremove', this.onBeforeRemove, this);\n    this.on('remove', this.onRemove, this);\n  }\n  onLibraryLoaded() {\n    if (typeof Ammo !== 'undefined') {\n      this.collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();\n      this.dispatcher = new Ammo.btCollisionDispatcher(this.collisionConfiguration);\n      this.overlappingPairCache = new Ammo.btDbvtBroadphase();\n      this.solver = new Ammo.btSequentialImpulseConstraintSolver();\n      this.dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(this.dispatcher, this.overlappingPairCache, this.solver, this.collisionConfiguration);\n      if (this.dynamicsWorld.setInternalTickCallback) {\n        const checkForCollisionsPointer = Ammo.addFunction(this._checkForCollisions.bind(this), 'vif');\n        this.dynamicsWorld.setInternalTickCallback(checkForCollisionsPointer);\n      }\n      ammoRayStart = new Ammo.btVector3();\n      ammoRayEnd = new Ammo.btVector3();\n      _component_js__WEBPACK_IMPORTED_MODULE_2__.RigidBodyComponent.onLibraryLoaded();\n      this.contactPointPool = new _core_object_pool_js__WEBPACK_IMPORTED_MODULE_4__.ObjectPool(ContactPoint, 1);\n      this.contactResultPool = new _core_object_pool_js__WEBPACK_IMPORTED_MODULE_4__.ObjectPool(ContactResult, 1);\n      this.singleContactResultPool = new _core_object_pool_js__WEBPACK_IMPORTED_MODULE_4__.ObjectPool(SingleContactResult, 1);\n      this.app.systems.on('update', this.onUpdate, this);\n    } else {\n      this.app.systems.off('update', this.onUpdate, this);\n    }\n  }\n  initializeComponentData(component, data, properties) {\n    const props = ['mass', 'linearDamping', 'angularDamping', 'linearFactor', 'angularFactor', 'friction', 'rollingFriction', 'restitution', 'type', 'group', 'mask'];\n    for (const property of props) {\n      if (data.hasOwnProperty(property)) {\n        const value = data[property];\n        if (Array.isArray(value)) {\n          component[property] = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(value[0], value[1], value[2]);\n        } else {\n          component[property] = value;\n        }\n      }\n    }\n    super.initializeComponentData(component, data, ['enabled']);\n  }\n  cloneComponent(entity, clone) {\n    const rigidbody = entity.rigidbody;\n    const data = {\n      enabled: rigidbody.enabled,\n      mass: rigidbody.mass,\n      linearDamping: rigidbody.linearDamping,\n      angularDamping: rigidbody.angularDamping,\n      linearFactor: [rigidbody.linearFactor.x, rigidbody.linearFactor.y, rigidbody.linearFactor.z],\n      angularFactor: [rigidbody.angularFactor.x, rigidbody.angularFactor.y, rigidbody.angularFactor.z],\n      friction: rigidbody.friction,\n      rollingFriction: rigidbody.rollingFriction,\n      restitution: rigidbody.restitution,\n      type: rigidbody.type,\n      group: rigidbody.group,\n      mask: rigidbody.mask\n    };\n    return this.addComponent(clone, data);\n  }\n  onBeforeRemove(entity, component) {\n    if (component.enabled) {\n      component.enabled = false;\n    }\n  }\n  onRemove(entity, component) {\n    const body = component.body;\n    if (body) {\n      this.removeBody(body);\n      this.destroyBody(body);\n      component.body = null;\n    }\n  }\n  addBody(body, group, mask) {\n    if (group !== undefined && mask !== undefined) {\n      this.dynamicsWorld.addRigidBody(body, group, mask);\n    } else {\n      this.dynamicsWorld.addRigidBody(body);\n    }\n  }\n  removeBody(body) {\n    this.dynamicsWorld.removeRigidBody(body);\n  }\n  createBody(mass, shape, transform) {\n    const localInertia = new Ammo.btVector3(0, 0, 0);\n    if (mass !== 0) {\n      shape.calculateLocalInertia(mass, localInertia);\n    }\n    const motionState = new Ammo.btDefaultMotionState(transform);\n    const bodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);\n    const body = new Ammo.btRigidBody(bodyInfo);\n    Ammo.destroy(bodyInfo);\n    Ammo.destroy(localInertia);\n    return body;\n  }\n  destroyBody(body) {\n    const motionState = body.getMotionState();\n    if (motionState) {\n      Ammo.destroy(motionState);\n    }\n    Ammo.destroy(body);\n  }\n  raycastFirst(start, end) {\n    let result = null;\n    ammoRayStart.setValue(start.x, start.y, start.z);\n    ammoRayEnd.setValue(end.x, end.y, end.z);\n    const rayCallback = new Ammo.ClosestRayResultCallback(ammoRayStart, ammoRayEnd);\n    this.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);\n    if (rayCallback.hasHit()) {\n      const collisionObj = rayCallback.get_m_collisionObject();\n      const body = Ammo.castObject(collisionObj, Ammo.btRigidBody);\n      if (body) {\n        const point = rayCallback.get_m_hitPointWorld();\n        const normal = rayCallback.get_m_hitNormalWorld();\n        result = new RaycastResult(body.entity, new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(point.x(), point.y(), point.z()), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(normal.x(), normal.y(), normal.z()));\n        if (arguments.length > 2) {\n          const callback = arguments[2];\n          callback(result);\n        }\n      }\n    }\n    Ammo.destroy(rayCallback);\n    return result;\n  }\n  raycastAll(start, end) {\n    const results = [];\n    ammoRayStart.setValue(start.x, start.y, start.z);\n    ammoRayEnd.setValue(end.x, end.y, end.z);\n    const rayCallback = new Ammo.AllHitsRayResultCallback(ammoRayStart, ammoRayEnd);\n    this.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);\n    if (rayCallback.hasHit()) {\n      const collisionObjs = rayCallback.get_m_collisionObjects();\n      const points = rayCallback.get_m_hitPointWorld();\n      const normals = rayCallback.get_m_hitNormalWorld();\n      const numHits = collisionObjs.size();\n      for (let i = 0; i < numHits; i++) {\n        const body = Ammo.castObject(collisionObjs.at(i), Ammo.btRigidBody);\n        if (body) {\n          const point = points.at(i);\n          const normal = normals.at(i);\n          const result = new RaycastResult(body.entity, new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(point.x(), point.y(), point.z()), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(normal.x(), normal.y(), normal.z()));\n          results.push(result);\n        }\n      }\n    }\n    Ammo.destroy(rayCallback);\n    return results;\n  }\n  _storeCollision(entity, other) {\n    let isNewCollision = false;\n    const guid = entity.getGuid();\n    this.collisions[guid] = this.collisions[guid] || {\n      others: [],\n      entity: entity\n    };\n    if (this.collisions[guid].others.indexOf(other) < 0) {\n      this.collisions[guid].others.push(other);\n      isNewCollision = true;\n    }\n    this.frameCollisions[guid] = this.frameCollisions[guid] || {\n      others: [],\n      entity: entity\n    };\n    this.frameCollisions[guid].others.push(other);\n    return isNewCollision;\n  }\n  _createContactPointFromAmmo(contactPoint) {\n    const localPointA = contactPoint.get_m_localPointA();\n    const localPointB = contactPoint.get_m_localPointB();\n    const positionWorldOnA = contactPoint.getPositionWorldOnA();\n    const positionWorldOnB = contactPoint.getPositionWorldOnB();\n    const normalWorldOnB = contactPoint.get_m_normalWorldOnB();\n    const contact = this.contactPointPool.allocate();\n    contact.localPoint.set(localPointA.x(), localPointA.y(), localPointA.z());\n    contact.localPointOther.set(localPointB.x(), localPointB.y(), localPointB.z());\n    contact.point.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());\n    contact.pointOther.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());\n    contact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());\n    contact.impulse = contactPoint.getAppliedImpulse();\n    return contact;\n  }\n  _createReverseContactPointFromAmmo(contactPoint) {\n    const localPointA = contactPoint.get_m_localPointA();\n    const localPointB = contactPoint.get_m_localPointB();\n    const positionWorldOnA = contactPoint.getPositionWorldOnA();\n    const positionWorldOnB = contactPoint.getPositionWorldOnB();\n    const normalWorldOnB = contactPoint.get_m_normalWorldOnB();\n    const contact = this.contactPointPool.allocate();\n    contact.localPointOther.set(localPointA.x(), localPointA.y(), localPointA.z());\n    contact.localPoint.set(localPointB.x(), localPointB.y(), localPointB.z());\n    contact.pointOther.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());\n    contact.point.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());\n    contact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());\n    contact.impulse = contactPoint.getAppliedImpulse();\n    return contact;\n  }\n  _createSingleContactResult(a, b, contactPoint) {\n    const result = this.singleContactResultPool.allocate();\n    result.a = a;\n    result.b = b;\n    result.localPointA = contactPoint.localPoint;\n    result.localPointB = contactPoint.localPointOther;\n    result.pointA = contactPoint.point;\n    result.pointB = contactPoint.pointOther;\n    result.normal = contactPoint.normal;\n    result.impulse = contactPoint.impulse;\n    return result;\n  }\n  _createContactResult(other, contacts) {\n    const result = this.contactResultPool.allocate();\n    result.other = other;\n    result.contacts = contacts;\n    return result;\n  }\n  _cleanOldCollisions() {\n    for (const guid in this.collisions) {\n      if (this.collisions.hasOwnProperty(guid)) {\n        const frameCollision = this.frameCollisions[guid];\n        const collision = this.collisions[guid];\n        const entity = collision.entity;\n        const entityCollision = entity.collision;\n        const entityRigidbody = entity.rigidbody;\n        const others = collision.others;\n        const length = others.length;\n        let i = length;\n        while (i--) {\n          const other = others[i];\n          if (!frameCollision || frameCollision.others.indexOf(other) < 0) {\n            others.splice(i, 1);\n            if (entity.trigger) {\n              if (entityCollision) {\n                entityCollision.fire('triggerleave', other);\n              }\n              if (other.rigidbody) {\n                other.rigidbody.fire('triggerleave', entity);\n              }\n            } else if (!other.trigger) {\n              if (entityRigidbody) {\n                entityRigidbody.fire('collisionend', other);\n              }\n              if (entityCollision) {\n                entityCollision.fire('collisionend', other);\n              }\n            }\n          }\n        }\n        if (others.length === 0) {\n          delete this.collisions[guid];\n        }\n      }\n    }\n  }\n  _hasContactEvent(entity) {\n    const c = entity.collision;\n    if (c && (c.hasEvent('collisionstart') || c.hasEvent('collisionend') || c.hasEvent('contact'))) {\n      return true;\n    }\n    const r = entity.rigidbody;\n    return r && (r.hasEvent('collisionstart') || r.hasEvent('collisionend') || r.hasEvent('contact'));\n  }\n  _checkForCollisions(world, timeStep) {\n    const dynamicsWorld = Ammo.wrapPointer(world, Ammo.btDynamicsWorld);\n    const dispatcher = dynamicsWorld.getDispatcher();\n    const numManifolds = dispatcher.getNumManifolds();\n    this.frameCollisions = {};\n    for (let i = 0; i < numManifolds; i++) {\n      const manifold = dispatcher.getManifoldByIndexInternal(i);\n      const body0 = manifold.getBody0();\n      const body1 = manifold.getBody1();\n      const wb0 = Ammo.castObject(body0, Ammo.btRigidBody);\n      const wb1 = Ammo.castObject(body1, Ammo.btRigidBody);\n      const e0 = wb0.entity;\n      const e1 = wb1.entity;\n      if (!e0 || !e1) {\n        continue;\n      }\n      const flags0 = wb0.getCollisionFlags();\n      const flags1 = wb1.getCollisionFlags();\n      const numContacts = manifold.getNumContacts();\n      const forwardContacts = [];\n      const reverseContacts = [];\n      let newCollision;\n      if (numContacts > 0) {\n        if (flags0 & _constants_js__WEBPACK_IMPORTED_MODULE_5__.BODYFLAG_NORESPONSE_OBJECT || flags1 & _constants_js__WEBPACK_IMPORTED_MODULE_5__.BODYFLAG_NORESPONSE_OBJECT) {\n          const e0Events = e0.collision && (e0.collision.hasEvent('triggerenter') || e0.collision.hasEvent('triggerleave'));\n          const e1Events = e1.collision && (e1.collision.hasEvent('triggerenter') || e1.collision.hasEvent('triggerleave'));\n          const e0BodyEvents = e0.rigidbody && (e0.rigidbody.hasEvent('triggerenter') || e0.rigidbody.hasEvent('triggerleave'));\n          const e1BodyEvents = e1.rigidbody && (e1.rigidbody.hasEvent('triggerenter') || e1.rigidbody.hasEvent('triggerleave'));\n          if (e0Events) {\n            newCollision = this._storeCollision(e0, e1);\n            if (newCollision && !(flags1 & _constants_js__WEBPACK_IMPORTED_MODULE_5__.BODYFLAG_NORESPONSE_OBJECT)) {\n              e0.collision.fire('triggerenter', e1);\n            }\n          }\n          if (e1Events) {\n            newCollision = this._storeCollision(e1, e0);\n            if (newCollision && !(flags0 & _constants_js__WEBPACK_IMPORTED_MODULE_5__.BODYFLAG_NORESPONSE_OBJECT)) {\n              e1.collision.fire('triggerenter', e0);\n            }\n          }\n          if (e0BodyEvents) {\n            if (!newCollision) {\n              newCollision = this._storeCollision(e1, e0);\n            }\n            if (newCollision) {\n              e0.rigidbody.fire('triggerenter', e1);\n            }\n          }\n          if (e1BodyEvents) {\n            if (!newCollision) {\n              newCollision = this._storeCollision(e0, e1);\n            }\n            if (newCollision) {\n              e1.rigidbody.fire('triggerenter', e0);\n            }\n          }\n        } else {\n          const e0Events = this._hasContactEvent(e0);\n          const e1Events = this._hasContactEvent(e1);\n          const globalEvents = this.hasEvent('contact');\n          if (globalEvents || e0Events || e1Events) {\n            for (let j = 0; j < numContacts; j++) {\n              const btContactPoint = manifold.getContactPoint(j);\n              const contactPoint = this._createContactPointFromAmmo(btContactPoint);\n              if (e0Events || e1Events) {\n                forwardContacts.push(contactPoint);\n                const reverseContactPoint = this._createReverseContactPointFromAmmo(btContactPoint);\n                reverseContacts.push(reverseContactPoint);\n              }\n              if (globalEvents) {\n                const result = this._createSingleContactResult(e0, e1, contactPoint);\n                this.fire('contact', result);\n              }\n            }\n            if (e0Events) {\n              const forwardResult = this._createContactResult(e1, forwardContacts);\n              newCollision = this._storeCollision(e0, e1);\n              if (e0.collision) {\n                e0.collision.fire('contact', forwardResult);\n                if (newCollision) {\n                  e0.collision.fire('collisionstart', forwardResult);\n                }\n              }\n              if (e0.rigidbody) {\n                e0.rigidbody.fire('contact', forwardResult);\n                if (newCollision) {\n                  e0.rigidbody.fire('collisionstart', forwardResult);\n                }\n              }\n            }\n            if (e1Events) {\n              const reverseResult = this._createContactResult(e0, reverseContacts);\n              newCollision = this._storeCollision(e1, e0);\n              if (e1.collision) {\n                e1.collision.fire('contact', reverseResult);\n                if (newCollision) {\n                  e1.collision.fire('collisionstart', reverseResult);\n                }\n              }\n              if (e1.rigidbody) {\n                e1.rigidbody.fire('contact', reverseResult);\n                if (newCollision) {\n                  e1.rigidbody.fire('collisionstart', reverseResult);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    this._cleanOldCollisions();\n    this.contactPointPool.freeAll();\n    this.contactResultPool.freeAll();\n    this.singleContactResultPool.freeAll();\n  }\n  onUpdate(dt) {\n    let i, len;\n    const gravity = this.dynamicsWorld.getGravity();\n    if (gravity.x() !== this.gravity.x || gravity.y() !== this.gravity.y || gravity.z() !== this.gravity.z) {\n      gravity.setValue(this.gravity.x, this.gravity.y, this.gravity.z);\n      this.dynamicsWorld.setGravity(gravity);\n    }\n    const triggers = this._triggers;\n    for (i = 0, len = triggers.length; i < len; i++) {\n      triggers[i].updateTransform();\n    }\n    const compounds = this._compounds;\n    for (i = 0, len = compounds.length; i < len; i++) {\n      compounds[i]._updateCompound();\n    }\n    const kinematic = this._kinematic;\n    for (i = 0, len = kinematic.length; i < len; i++) {\n      kinematic[i]._updateKinematic();\n    }\n    this.dynamicsWorld.stepSimulation(dt, this.maxSubSteps, this.fixedTimeStep);\n    const dynamic = this._dynamic;\n    for (i = 0, len = dynamic.length; i < len; i++) {\n      dynamic[i]._updateDynamic();\n    }\n    if (!this.dynamicsWorld.setInternalTickCallback) this._checkForCollisions(Ammo.getPointer(this.dynamicsWorld), dt);\n  }\n  destroy() {\n    super.destroy();\n    this.app.systems.off('update', this.onUpdate, this);\n    if (typeof Ammo !== 'undefined') {\n      Ammo.destroy(this.dynamicsWorld);\n      Ammo.destroy(this.solver);\n      Ammo.destroy(this.overlappingPairCache);\n      Ammo.destroy(this.dispatcher);\n      Ammo.destroy(this.collisionConfiguration);\n      this.dynamicsWorld = null;\n      this.solver = null;\n      this.overlappingPairCache = null;\n      this.dispatcher = null;\n      this.collisionConfiguration = null;\n    }\n  }\n}\n_component_js__WEBPACK_IMPORTED_MODULE_6__.Component._buildAccessors(_component_js__WEBPACK_IMPORTED_MODULE_2__.RigidBodyComponent.prototype, _schema);\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/rigid-body/system.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/screen/component.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/screen/component.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScreenComponent\": () => (/* binding */ ScreenComponent)\n/* harmony export */ });\n/* harmony import */ var _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/math/mat4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js\");\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _entity_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../entity.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/entity.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/screen/constants.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n\n\n\n\n\n\n\nconst _transform = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\nclass ScreenComponent extends _component_js__WEBPACK_IMPORTED_MODULE_1__.Component {\n  constructor(system, entity) {\n    super(system, entity);\n    this._resolution = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_2__.Vec2(640, 320);\n    this._referenceResolution = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_2__.Vec2(640, 320);\n    this._scaleMode = _constants_js__WEBPACK_IMPORTED_MODULE_3__.SCALEMODE_NONE;\n    this.scale = 1;\n    this._scaleBlend = 0.5;\n    this._priority = 0;\n    this._screenSpace = false;\n    this.cull = this._screenSpace;\n    this._screenMatrix = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\n    this._elements = new Set();\n    system.app.graphicsDevice.on('resizecanvas', this._onResize, this);\n  }\n  syncDrawOrder() {\n    this.system.queueDrawOrderSync(this.entity.getGuid(), this._processDrawOrderSync, this);\n  }\n  _recurseDrawOrderSync(e, i) {\n    if (!(e instanceof _entity_js__WEBPACK_IMPORTED_MODULE_4__.Entity)) {\n      return i;\n    }\n    if (e.element) {\n      const prevDrawOrder = e.element.drawOrder;\n      e.element.drawOrder = i++;\n      if (e.element._batchGroupId >= 0 && prevDrawOrder !== e.element.drawOrder) {\n        var _this$system$app$batc;\n        (_this$system$app$batc = this.system.app.batcher) == null ? void 0 : _this$system$app$batc.markGroupDirty(e.element._batchGroupId);\n      }\n    }\n    if (e.particlesystem) {\n      e.particlesystem.drawOrder = i++;\n    }\n    const children = e.children;\n    for (let j = 0; j < children.length; j++) {\n      i = this._recurseDrawOrderSync(children[j], i);\n    }\n    return i;\n  }\n  _processDrawOrderSync() {\n    const i = 1;\n    this._recurseDrawOrderSync(this.entity, i);\n    this.fire('syncdraworder');\n  }\n  _calcProjectionMatrix() {\n    const w = this._resolution.x / this.scale;\n    const h = this._resolution.y / this.scale;\n    const left = 0;\n    const right = w;\n    const bottom = -h;\n    const top = 0;\n    const near = 1;\n    const far = -1;\n    this._screenMatrix.setOrtho(left, right, bottom, top, near, far);\n    if (!this._screenSpace) {\n      _transform.setScale(0.5 * w, 0.5 * h, 1);\n      this._screenMatrix.mul2(_transform, this._screenMatrix);\n    }\n  }\n  _updateScale() {\n    this.scale = this._calcScale(this._resolution, this.referenceResolution);\n  }\n  _calcScale(resolution, referenceResolution) {\n    const lx = Math.log2(resolution.x / referenceResolution.x);\n    const ly = Math.log2(resolution.y / referenceResolution.y);\n    return Math.pow(2, lx * (1 - this._scaleBlend) + ly * this._scaleBlend);\n  }\n  _onResize(width, height) {\n    if (this._screenSpace) {\n      this._resolution.set(width, height);\n      this.resolution = this._resolution;\n    }\n  }\n  _bindElement(element) {\n    this._elements.add(element);\n  }\n  _unbindElement(element) {\n    this._elements.delete(element);\n  }\n  onRemove() {\n    this.system.app.graphicsDevice.off('resizecanvas', this._onResize, this);\n    this.fire('remove');\n    this._elements.forEach(element => element._onScreenRemove());\n    this._elements.clear();\n    this.off();\n  }\n  set resolution(value) {\n    if (!this._screenSpace) {\n      this._resolution.set(value.x, value.y);\n    } else {\n      this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);\n    }\n    this._updateScale();\n    this._calcProjectionMatrix();\n    if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();\n    this.fire('set:resolution', this._resolution);\n    this._elements.forEach(element => element._onScreenResize(this._resolution));\n  }\n  get resolution() {\n    return this._resolution;\n  }\n  set referenceResolution(value) {\n    this._referenceResolution.set(value.x, value.y);\n    this._updateScale();\n    this._calcProjectionMatrix();\n    if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();\n    this.fire('set:referenceresolution', this._resolution);\n    this._elements.forEach(element => element._onScreenResize(this._resolution));\n  }\n  get referenceResolution() {\n    if (this._scaleMode === _constants_js__WEBPACK_IMPORTED_MODULE_3__.SCALEMODE_NONE) {\n      return this._resolution;\n    }\n    return this._referenceResolution;\n  }\n  set screenSpace(value) {\n    this._screenSpace = value;\n    if (this._screenSpace) {\n      this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);\n    }\n    this.resolution = this._resolution;\n    if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();\n    this.fire('set:screenspace', this._screenSpace);\n    this._elements.forEach(element => element._onScreenSpaceChange());\n  }\n  get screenSpace() {\n    return this._screenSpace;\n  }\n  set scaleMode(value) {\n    if (value !== _constants_js__WEBPACK_IMPORTED_MODULE_3__.SCALEMODE_NONE && value !== _constants_js__WEBPACK_IMPORTED_MODULE_3__.SCALEMODE_BLEND) {\n      value = _constants_js__WEBPACK_IMPORTED_MODULE_3__.SCALEMODE_NONE;\n    }\n    if (!this._screenSpace && value !== _constants_js__WEBPACK_IMPORTED_MODULE_3__.SCALEMODE_NONE) {\n      value = _constants_js__WEBPACK_IMPORTED_MODULE_3__.SCALEMODE_NONE;\n    }\n    this._scaleMode = value;\n    this.resolution = this._resolution;\n    this.fire('set:scalemode', this._scaleMode);\n  }\n  get scaleMode() {\n    return this._scaleMode;\n  }\n  set scaleBlend(value) {\n    this._scaleBlend = value;\n    this._updateScale();\n    this._calcProjectionMatrix();\n    if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();\n    this.fire('set:scaleblend', this._scaleBlend);\n    this._elements.forEach(element => element._onScreenResize(this._resolution));\n  }\n  get scaleBlend() {\n    return this._scaleBlend;\n  }\n  set priority(value) {\n    if (value > 0xFF) {\n      value = 0xFF;\n    }\n    if (this._priority === value) {\n      return;\n    }\n    this._priority = value;\n    this.syncDrawOrder();\n  }\n  get priority() {\n    return this._priority;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/screen/component.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/screen/constants.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/screen/constants.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SCALEMODE_BLEND\": () => (/* binding */ SCALEMODE_BLEND),\n/* harmony export */   \"SCALEMODE_NONE\": () => (/* binding */ SCALEMODE_NONE)\n/* harmony export */ });\nconst SCALEMODE_NONE = 'none';\nconst SCALEMODE_BLEND = 'blend';\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/screen/constants.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/screen/data.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/screen/data.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScreenComponentData\": () => (/* binding */ ScreenComponentData)\n/* harmony export */ });\nclass ScreenComponentData {\n  constructor() {\n    this.enabled = true;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/screen/data.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/screen/system.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/screen/system.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScreenComponentSystem\": () => (/* binding */ ScreenComponentSystem)\n/* harmony export */ });\n/* harmony import */ var _core_indexed_list_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/indexed-list.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/indexed-list.js\");\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/system.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/screen/component.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/screen/data.js\");\n\n\n\n\n\n\n\nconst _schema = ['enabled'];\nclass ScreenComponentSystem extends _system_js__WEBPACK_IMPORTED_MODULE_0__.ComponentSystem {\n  constructor(app) {\n    super(app);\n    this.id = 'screen';\n    this.ComponentType = _component_js__WEBPACK_IMPORTED_MODULE_1__.ScreenComponent;\n    this.DataType = _data_js__WEBPACK_IMPORTED_MODULE_2__.ScreenComponentData;\n    this.schema = _schema;\n    this.windowResolution = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_3__.Vec2();\n    this._drawOrderSyncQueue = new _core_indexed_list_js__WEBPACK_IMPORTED_MODULE_4__.IndexedList();\n    this.app.graphicsDevice.on('resizecanvas', this._onResize, this);\n    this.app.systems.on('update', this._onUpdate, this);\n    this.on('beforeremove', this.onRemoveComponent, this);\n  }\n  initializeComponentData(component, data, properties) {\n    if (data.priority !== undefined) component.priority = data.priority;\n    if (data.screenSpace !== undefined) component.screenSpace = data.screenSpace;\n    component.cull = component.screenSpace;\n    if (data.scaleMode !== undefined) component.scaleMode = data.scaleMode;\n    if (data.scaleBlend !== undefined) component.scaleBlend = data.scaleBlend;\n    if (data.resolution !== undefined) {\n      if (data.resolution instanceof _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_3__.Vec2) {\n        component._resolution.copy(data.resolution);\n      } else {\n        component._resolution.set(data.resolution[0], data.resolution[1]);\n      }\n      component.resolution = component._resolution;\n    }\n    if (data.referenceResolution !== undefined) {\n      if (data.referenceResolution instanceof _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_3__.Vec2) {\n        component._referenceResolution.copy(data.referenceResolution);\n      } else {\n        component._referenceResolution.set(data.referenceResolution[0], data.referenceResolution[1]);\n      }\n      component.referenceResolution = component._referenceResolution;\n    }\n    component.syncDrawOrder();\n    super.initializeComponentData(component, data, properties);\n  }\n  destroy() {\n    super.destroy();\n    this.app.graphicsDevice.off('resizecanvas', this._onResize, this);\n    this.app.systems.off('update', this._onUpdate, this);\n  }\n  _onUpdate(dt) {\n    const components = this.store;\n    for (const id in components) {\n      if (components[id].entity.screen.update) components[id].entity.screen.update(dt);\n    }\n  }\n  _onResize(width, height) {\n    this.windowResolution.x = width;\n    this.windowResolution.y = height;\n  }\n  cloneComponent(entity, clone) {\n    const screen = entity.screen;\n    return this.addComponent(clone, {\n      enabled: screen.enabled,\n      screenSpace: screen.screenSpace,\n      scaleMode: screen.scaleMode,\n      resolution: screen.resolution.clone(),\n      referenceResolution: screen.referenceResolution.clone()\n    });\n  }\n  onRemoveComponent(entity, component) {\n    component.onRemove();\n  }\n  processDrawOrderSyncQueue() {\n    const list = this._drawOrderSyncQueue.list();\n    for (let i = 0; i < list.length; i++) {\n      const item = list[i];\n      item.callback.call(item.scope);\n    }\n    this._drawOrderSyncQueue.clear();\n  }\n  queueDrawOrderSync(id, fn, scope) {\n    if (!this._drawOrderSyncQueue.list().length) {\n      this.app.once('prerender', this.processDrawOrderSyncQueue, this);\n    }\n    if (!this._drawOrderSyncQueue.has(id)) {\n      this._drawOrderSyncQueue.push(id, {\n        callback: fn,\n        scope: scope\n      });\n    }\n  }\n}\n_component_js__WEBPACK_IMPORTED_MODULE_5__.Component._buildAccessors(_component_js__WEBPACK_IMPORTED_MODULE_1__.ScreenComponent.prototype, _schema);\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/screen/system.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/script-legacy/component.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/script-legacy/component.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScriptLegacyComponent\": () => (/* binding */ ScriptLegacyComponent)\n/* harmony export */ });\n/* harmony import */ var _core_path_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/path.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/path.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n\n\n\n\nclass ScriptLegacyComponent extends _component_js__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(system, entity) {\n    super(system, entity);\n    this.on('set_scripts', this.onSetScripts, this);\n  }\n  send(name, functionName) {\n    const args = Array.prototype.slice.call(arguments, 2);\n    const instances = this.entity.script.instances;\n    let fn;\n    if (instances && instances[name]) {\n      fn = instances[name].instance[functionName];\n      if (fn) {\n        return fn.apply(instances[name].instance, args);\n      }\n    }\n    return undefined;\n  }\n  onEnable() {\n    if (this.data.areScriptsLoaded && !this.system.preloading) {\n      if (!this.data.initialized) {\n        this.system._initializeScriptComponent(this);\n      } else {\n        this.system._enableScriptComponent(this);\n      }\n      if (!this.data.postInitialized) {\n        this.system._postInitializeScriptComponent(this);\n      }\n    }\n  }\n  onDisable() {\n    this.system._disableScriptComponent(this);\n  }\n  onSetScripts(name, oldValue, newValue) {\n    if (!this.system._inTools || this.runInTools) {\n      if (this._updateScriptAttributes(oldValue, newValue)) {\n        return;\n      }\n      if (this.enabled) {\n        this.system._disableScriptComponent(this);\n      }\n      this.system._destroyScriptComponent(this);\n      this.data.areScriptsLoaded = false;\n      const scripts = newValue;\n      const urls = scripts.map(function (s) {\n        return s.url;\n      });\n      if (this._loadFromCache(urls)) {\n        return;\n      }\n      this._loadScripts(urls);\n    }\n  }\n  _updateScriptAttributes(oldValue, newValue) {\n    let onlyUpdateAttributes = true;\n    if (oldValue.length !== newValue.length) {\n      onlyUpdateAttributes = false;\n    } else {\n      for (let i = 0, len = newValue.length; i < len; i++) {\n        if (oldValue[i].url !== newValue[i].url) {\n          onlyUpdateAttributes = false;\n          break;\n        }\n      }\n    }\n    if (onlyUpdateAttributes) {\n      for (const key in this.instances) {\n        if (this.instances.hasOwnProperty(key)) {\n          this.system._updateAccessors(this.entity, this.instances[key]);\n        }\n      }\n    }\n    return onlyUpdateAttributes;\n  }\n  _loadFromCache(urls) {\n    const cached = [];\n    const prefix = this.system.app._scriptPrefix || '';\n    const regex = /^http(s)?:\\/\\//i;\n    for (let i = 0, len = urls.length; i < len; i++) {\n      let url = urls[i];\n      if (!regex.test(url)) {\n        url = _core_path_js__WEBPACK_IMPORTED_MODULE_1__.path.join(prefix, url);\n      }\n      const type = this.system.app.loader.getFromCache(url, 'script');\n      if (!type) {\n        return false;\n      }\n      cached.push(type);\n    }\n    for (let i = 0, len = cached.length; i < len; i++) {\n      const ScriptType = cached[i];\n      if (ScriptType === true) {\n        continue;\n      }\n      if (ScriptType && this.entity.script) {\n        if (!this.entity.script.instances[ScriptType._pcScriptName]) {\n          const instance = new ScriptType(this.entity);\n          this.system._preRegisterInstance(this.entity, urls[i], ScriptType._pcScriptName, instance);\n        }\n      }\n    }\n    if (this.data) {\n      this.data.areScriptsLoaded = true;\n    }\n    if (!this.system.preloading) {\n      this.system.onInitialize(this.entity);\n      this.system.onPostInitialize(this.entity);\n    }\n    return true;\n  }\n  _loadScripts(urls) {\n    let count = urls.length;\n    const prefix = this.system.app._scriptPrefix || '';\n    urls.forEach(url => {\n      let _url = null;\n      let _unprefixed = null;\n      if (url.toLowerCase().startsWith('http://') || url.toLowerCase().startsWith('https://')) {\n        _unprefixed = url;\n        _url = url;\n      } else {\n        _unprefixed = url;\n        _url = _core_path_js__WEBPACK_IMPORTED_MODULE_1__.path.join(prefix, url);\n      }\n      this.system.app.loader.load(_url, 'script', (err, ScriptType) => {\n        count--;\n        if (!err) {\n          if (ScriptType && this.entity.script) {\n            if (!this.entity.script.instances[ScriptType._pcScriptName]) {\n              const instance = new ScriptType(this.entity);\n              this.system._preRegisterInstance(this.entity, _unprefixed, ScriptType._pcScriptName, instance);\n            }\n          }\n        } else {\n          console.error(err);\n        }\n        if (count === 0) {\n          this.data.areScriptsLoaded = true;\n          if (!this.system.preloading) {\n            this.system.onInitialize(this.entity);\n            this.system.onPostInitialize(this.entity);\n          }\n        }\n      });\n    });\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/script-legacy/component.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/script-legacy/data.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/script-legacy/data.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScriptLegacyComponentData\": () => (/* binding */ ScriptLegacyComponentData)\n/* harmony export */ });\nclass ScriptLegacyComponentData {\n  constructor() {\n    this.scripts = [];\n    this.enabled = true;\n    this.instances = {};\n    this._instances = {};\n    this.runInTools = false;\n    this.attributes = {};\n    this.initialized = false;\n    this.postInitialized = false;\n    this.areScriptsLoaded = false;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/script-legacy/data.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/script-legacy/system.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/script-legacy/system.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScriptLegacyComponentSystem\": () => (/* binding */ ScriptLegacyComponentSystem)\n/* harmony export */ });\n/* harmony import */ var _core_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/core.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/core.js\");\n/* harmony import */ var _core_events_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/events.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/events.js\");\n/* harmony import */ var _core_math_color_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../core/math/color.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n/* harmony import */ var _core_math_curve_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../core/math/curve.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/curve.js\");\n/* harmony import */ var _core_math_curve_set_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../core/math/curve-set.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/curve-set.js\");\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../core/math/vec4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec4.js\");\n/* harmony import */ var _entity_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../entity.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/entity.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/system.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/script-legacy/component.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/script-legacy/data.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst _schema = ['enabled', 'scripts', 'instances', 'runInTools'];\nconst INITIALIZE = 'initialize';\nconst POST_INITIALIZE = 'postInitialize';\nconst UPDATE = 'update';\nconst POST_UPDATE = 'postUpdate';\nconst FIXED_UPDATE = 'fixedUpdate';\nconst TOOLS_UPDATE = 'toolsUpdate';\nconst ON_ENABLE = 'onEnable';\nconst ON_DISABLE = 'onDisable';\nclass ScriptLegacyComponentSystem extends _system_js__WEBPACK_IMPORTED_MODULE_0__.ComponentSystem {\n  constructor(app) {\n    super(app);\n    this.id = 'script';\n    this.ComponentType = _component_js__WEBPACK_IMPORTED_MODULE_1__.ScriptLegacyComponent;\n    this.DataType = _data_js__WEBPACK_IMPORTED_MODULE_2__.ScriptLegacyComponentData;\n    this.schema = _schema;\n    this.preloading = false;\n    this.instancesWithUpdate = [];\n    this.instancesWithFixedUpdate = [];\n    this.instancesWithPostUpdate = [];\n    this.instancesWithToolsUpdate = [];\n    this.on('beforeremove', this.onBeforeRemove, this);\n    this.app.systems.on(INITIALIZE, this.onInitialize, this);\n    this.app.systems.on(POST_INITIALIZE, this.onPostInitialize, this);\n    this.app.systems.on(UPDATE, this.onUpdate, this);\n    this.app.systems.on(FIXED_UPDATE, this.onFixedUpdate, this);\n    this.app.systems.on(POST_UPDATE, this.onPostUpdate, this);\n    this.app.systems.on(TOOLS_UPDATE, this.onToolsUpdate, this);\n  }\n  initializeComponentData(component, data, properties) {\n    properties = ['runInTools', 'enabled', 'scripts'];\n    if (data.scripts && data.scripts.length) {\n      data.scripts.forEach(function (script) {\n        if (script.attributes && Array.isArray(script.attributes)) {\n          const dict = {};\n          for (let i = 0; i < script.attributes.length; i++) {\n            dict[script.attributes[i].name] = script.attributes[i];\n          }\n          script.attributes = dict;\n        }\n      });\n    }\n    super.initializeComponentData(component, data, properties);\n  }\n  cloneComponent(entity, clone) {\n    const src = this.store[entity.getGuid()];\n    const data = {\n      runInTools: src.data.runInTools,\n      scripts: [],\n      enabled: src.data.enabled\n    };\n    const scripts = src.data.scripts;\n    for (let i = 0, len = scripts.length; i < len; i++) {\n      const attributes = scripts[i].attributes;\n      if (attributes) {\n        delete scripts[i].attributes;\n      }\n      data.scripts.push((0,_core_core_js__WEBPACK_IMPORTED_MODULE_3__.extend)({}, scripts[i]));\n      if (attributes) {\n        data.scripts[i].attributes = this._cloneAttributes(attributes);\n        scripts[i].attributes = attributes;\n      }\n    }\n    return this.addComponent(clone, data);\n  }\n  onBeforeRemove(entity, component) {\n    if (component.enabled) {\n      this._disableScriptComponent(component);\n    }\n    this._destroyScriptComponent(component);\n  }\n  onInitialize(root) {\n    this._registerInstances(root);\n    if (root.enabled) {\n      if (root.script && root.script.enabled) {\n        this._initializeScriptComponent(root.script);\n      }\n      const children = root._children;\n      for (let i = 0, len = children.length; i < len; i++) {\n        if (children[i] instanceof _entity_js__WEBPACK_IMPORTED_MODULE_4__.Entity) {\n          this.onInitialize(children[i]);\n        }\n      }\n    }\n  }\n  onPostInitialize(root) {\n    if (root.enabled) {\n      if (root.script && root.script.enabled) {\n        this._postInitializeScriptComponent(root.script);\n      }\n      const children = root._children;\n      for (let i = 0, len = children.length; i < len; i++) {\n        if (children[i] instanceof _entity_js__WEBPACK_IMPORTED_MODULE_4__.Entity) {\n          this.onPostInitialize(children[i]);\n        }\n      }\n    }\n  }\n  _callInstancesMethod(script, method) {\n    const instances = script.data.instances;\n    for (const name in instances) {\n      if (instances.hasOwnProperty(name)) {\n        const instance = instances[name].instance;\n        if (instance[method]) {\n          instance[method]();\n        }\n      }\n    }\n  }\n  _initializeScriptComponent(script) {\n    this._callInstancesMethod(script, INITIALIZE);\n    script.data.initialized = true;\n    if (script.enabled && script.entity.enabled) {\n      this._enableScriptComponent(script);\n    }\n  }\n  _enableScriptComponent(script) {\n    this._callInstancesMethod(script, ON_ENABLE);\n  }\n  _disableScriptComponent(script) {\n    this._callInstancesMethod(script, ON_DISABLE);\n  }\n  _destroyScriptComponent(script) {\n    const instances = script.data.instances;\n    for (const name in instances) {\n      if (instances.hasOwnProperty(name)) {\n        const instance = instances[name].instance;\n        if (instance.destroy) {\n          instance.destroy();\n        }\n        if (instance.update) {\n          const index = this.instancesWithUpdate.indexOf(instance);\n          if (index >= 0) {\n            this.instancesWithUpdate.splice(index, 1);\n          }\n        }\n        if (instance.fixedUpdate) {\n          const index = this.instancesWithFixedUpdate.indexOf(instance);\n          if (index >= 0) {\n            this.instancesWithFixedUpdate.splice(index, 1);\n          }\n        }\n        if (instance.postUpdate) {\n          const index = this.instancesWithPostUpdate.indexOf(instance);\n          if (index >= 0) {\n            this.instancesWithPostUpdate.splice(index, 1);\n          }\n        }\n        if (instance.toolsUpdate) {\n          const index = this.instancesWithToolsUpdate.indexOf(instance);\n          if (index >= 0) {\n            this.instancesWithToolsUpdate.splice(index, 1);\n          }\n        }\n        if (script.instances[name].instance === script[name]) {\n          delete script[name];\n        }\n        delete script.instances[name];\n      }\n    }\n  }\n  _postInitializeScriptComponent(script) {\n    this._callInstancesMethod(script, POST_INITIALIZE);\n    script.data.postInitialized = true;\n  }\n  _updateInstances(method, updateList, dt) {\n    for (let i = 0, len = updateList.length; i < len; i++) {\n      const item = updateList[i];\n      if (item && item.entity && item.entity.enabled && item.entity.script.enabled) {\n        item[method](dt);\n      }\n    }\n  }\n  onUpdate(dt) {\n    this._updateInstances(UPDATE, this.instancesWithUpdate, dt);\n  }\n  onFixedUpdate(dt) {\n    this._updateInstances(FIXED_UPDATE, this.instancesWithFixedUpdate, dt);\n  }\n  onPostUpdate(dt) {\n    this._updateInstances(POST_UPDATE, this.instancesWithPostUpdate, dt);\n  }\n  onToolsUpdate(dt) {\n    this._updateInstances(TOOLS_UPDATE, this.instancesWithToolsUpdate, dt);\n  }\n  broadcast(name, functionName) {\n    const args = Array.prototype.slice.call(arguments, 2);\n    const dataStore = this.store;\n    for (const id in dataStore) {\n      if (dataStore.hasOwnProperty(id)) {\n        const data = dataStore[id].data;\n        if (data.instances[name]) {\n          const fn = data.instances[name].instance[functionName];\n          if (fn) {\n            fn.apply(data.instances[name].instance, args);\n          }\n        }\n      }\n    }\n  }\n  _preRegisterInstance(entity, url, name, instance) {\n    if (entity.script) {\n      entity.script.data._instances = entity.script.data._instances || {};\n      if (entity.script.data._instances[name]) {\n        throw Error(`Script name collision '${name}'. Scripts from '${url}' and '${entity.script.data._instances[name].url}' {${entity.getGuid()}}`);\n      }\n      entity.script.data._instances[name] = {\n        url: url,\n        name: name,\n        instance: instance\n      };\n    }\n  }\n  _registerInstances(entity) {\n    if (entity.script) {\n      if (entity.script.data._instances) {\n        entity.script.instances = entity.script.data._instances;\n        for (const instanceName in entity.script.instances) {\n          const preRegistered = entity.script.instances[instanceName];\n          const instance = preRegistered.instance;\n          _core_events_js__WEBPACK_IMPORTED_MODULE_5__.events.attach(instance);\n          if (instance.update) {\n            this.instancesWithUpdate.push(instance);\n          }\n          if (instance.fixedUpdate) {\n            this.instancesWithFixedUpdate.push(instance);\n          }\n          if (instance.postUpdate) {\n            this.instancesWithPostUpdate.push(instance);\n          }\n          if (instance.toolsUpdate) {\n            this.instancesWithToolsUpdate.push(instance);\n          }\n          if (entity.script.scripts) {\n            this._createAccessors(entity, preRegistered);\n          }\n          if (entity.script[instanceName]) {\n            throw Error(`Script with name '${instanceName}' is already attached to Script Component`);\n          } else {\n            entity.script[instanceName] = instance;\n          }\n        }\n        delete entity.script.data._instances;\n      }\n    }\n    const children = entity._children;\n    for (let i = 0, len = children.length; i < len; i++) {\n      if (children[i] instanceof _entity_js__WEBPACK_IMPORTED_MODULE_4__.Entity) {\n        this._registerInstances(children[i]);\n      }\n    }\n  }\n  _cloneAttributes(attributes) {\n    const result = {};\n    for (const key in attributes) {\n      if (!attributes.hasOwnProperty(key)) continue;\n      if (attributes[key].type !== 'entity') {\n        result[key] = (0,_core_core_js__WEBPACK_IMPORTED_MODULE_3__.extend)({}, attributes[key]);\n      } else {\n        const val = attributes[key].value;\n        delete attributes[key].value;\n        result[key] = (0,_core_core_js__WEBPACK_IMPORTED_MODULE_3__.extend)({}, attributes[key]);\n        result[key].value = val;\n        attributes[key].value = val;\n      }\n    }\n    return result;\n  }\n  _createAccessors(entity, instance) {\n    const len = entity.script.scripts.length;\n    const url = instance.url;\n    for (let i = 0; i < len; i++) {\n      const script = entity.script.scripts[i];\n      if (script.url === url) {\n        const attributes = script.attributes;\n        if (script.name && attributes) {\n          for (const key in attributes) {\n            if (attributes.hasOwnProperty(key)) {\n              this._createAccessor(attributes[key], instance);\n            }\n          }\n          entity.script.data.attributes[script.name] = this._cloneAttributes(attributes);\n        }\n        break;\n      }\n    }\n  }\n  _createAccessor(attribute, instance) {\n    const self = this;\n    attribute = {\n      name: attribute.name,\n      value: attribute.value,\n      type: attribute.type\n    };\n    this._convertAttributeValue(attribute);\n    Object.defineProperty(instance.instance, attribute.name, {\n      get: function () {\n        return attribute.value;\n      },\n      set: function (value) {\n        const oldValue = attribute.value;\n        attribute.value = value;\n        self._convertAttributeValue(attribute);\n        instance.instance.fire('set', attribute.name, oldValue, attribute.value);\n      },\n      configurable: true\n    });\n  }\n  _updateAccessors(entity, instance) {\n    const len = entity.script.scripts.length;\n    const url = instance.url;\n    for (let i = 0; i < len; i++) {\n      const scriptComponent = entity.script;\n      const script = scriptComponent.scripts[i];\n      if (script.url === url) {\n        const name = script.name;\n        const attributes = script.attributes;\n        if (name) {\n          if (attributes) {\n            for (const key in attributes) {\n              if (attributes.hasOwnProperty(key)) {\n                this._createAccessor(attributes[key], instance);\n              }\n            }\n          }\n          const previousAttributes = scriptComponent.data.attributes[name];\n          if (previousAttributes) {\n            for (const key in previousAttributes) {\n              const oldAttribute = previousAttributes[key];\n              if (!(key in attributes)) {\n                delete instance.instance[oldAttribute.name];\n              } else {\n                if (attributes[key].value !== oldAttribute.value) {\n                  if (instance.instance.onAttributeChanged) {\n                    instance.instance.onAttributeChanged(oldAttribute.name, oldAttribute.value, attributes[key].value);\n                  }\n                }\n              }\n            }\n          }\n          if (attributes) {\n            scriptComponent.data.attributes[name] = this._cloneAttributes(attributes);\n          } else {\n            delete scriptComponent.data.attributes[name];\n          }\n        }\n        break;\n      }\n    }\n  }\n  _convertAttributeValue(attribute) {\n    if (attribute.type === 'rgb' || attribute.type === 'rgba') {\n      if (Array.isArray(attribute.value)) {\n        attribute.value = attribute.value.length === 3 ? new _core_math_color_js__WEBPACK_IMPORTED_MODULE_6__.Color(attribute.value[0], attribute.value[1], attribute.value[2]) : new _core_math_color_js__WEBPACK_IMPORTED_MODULE_6__.Color(attribute.value[0], attribute.value[1], attribute.value[2], attribute.value[3]);\n      }\n    } else if (attribute.type === 'vec2') {\n      if (Array.isArray(attribute.value)) attribute.value = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_7__.Vec2(attribute.value[0], attribute.value[1]);\n    } else if (attribute.type === 'vec3' || attribute.type === 'vector') {\n      if (Array.isArray(attribute.value)) attribute.value = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_8__.Vec3(attribute.value[0], attribute.value[1], attribute.value[2]);\n    } else if (attribute.type === 'vec4') {\n      if (Array.isArray(attribute.value)) attribute.value = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_9__.Vec4(attribute.value[0], attribute.value[1], attribute.value[2], attribute.value[3]);\n    } else if (attribute.type === 'entity') {\n      if (attribute.value !== null && typeof attribute.value === 'string') attribute.value = this.app.root.findByGuid(attribute.value);\n    } else if (attribute.type === 'curve' || attribute.type === 'colorcurve') {\n      const curveType = attribute.value.keys[0] instanceof Array ? _core_math_curve_set_js__WEBPACK_IMPORTED_MODULE_10__.CurveSet : _core_math_curve_js__WEBPACK_IMPORTED_MODULE_11__.Curve;\n      attribute.value = new curveType(attribute.value.keys);\n      attribute.value.type = attribute.value.type;\n    }\n  }\n  destroy() {\n    super.destroy();\n    this.app.systems.off(INITIALIZE, this.onInitialize, this);\n    this.app.systems.off(POST_INITIALIZE, this.onPostInitialize, this);\n    this.app.systems.off(UPDATE, this.onUpdate, this);\n    this.app.systems.off(FIXED_UPDATE, this.onFixedUpdate, this);\n    this.app.systems.off(POST_UPDATE, this.onPostUpdate, this);\n    this.app.systems.off(TOOLS_UPDATE, this.onToolsUpdate, this);\n  }\n}\n_component_js__WEBPACK_IMPORTED_MODULE_12__.Component._buildAccessors(_component_js__WEBPACK_IMPORTED_MODULE_1__.ScriptLegacyComponent.prototype, _schema);\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/script-legacy/system.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/script/component.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/script/component.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScriptComponent\": () => (/* binding */ ScriptComponent)\n/* harmony export */ });\n/* harmony import */ var _core_sorted_loop_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/sorted-loop-array.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/sorted-loop-array.js\");\n/* harmony import */ var _script_script_attributes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../script/script-attributes.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/script/script-attributes.js\");\n/* harmony import */ var _script_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../script/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/script/constants.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _entity_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../entity.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/entity.js\");\n\n\n\n\n\n\n\nclass ScriptComponent extends _component_js__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(system, entity) {\n    super(system, entity);\n    this._scripts = [];\n    this._updateList = new _core_sorted_loop_array_js__WEBPACK_IMPORTED_MODULE_1__.SortedLoopArray({\n      sortBy: '__executionOrder'\n    });\n    this._postUpdateList = new _core_sorted_loop_array_js__WEBPACK_IMPORTED_MODULE_1__.SortedLoopArray({\n      sortBy: '__executionOrder'\n    });\n    this._scriptsIndex = {};\n    this._destroyedScripts = [];\n    this._destroyed = false;\n    this._scriptsData = null;\n    this._oldState = true;\n    this._enabled = true;\n    this._beingEnabled = false;\n    this._isLoopingThroughScripts = false;\n    this._executionOrder = -1;\n    this.on('set_enabled', this._onSetEnabled, this);\n  }\n  set scripts(value) {\n    this._scriptsData = value;\n    for (const key in value) {\n      if (!value.hasOwnProperty(key)) continue;\n      const script = this._scriptsIndex[key];\n      if (script) {\n        if (typeof value[key].enabled === 'boolean') script.enabled = !!value[key].enabled;\n        if (typeof value[key].attributes === 'object') {\n          for (const attr in value[key].attributes) {\n            if (_script_script_attributes_js__WEBPACK_IMPORTED_MODULE_2__.ScriptAttributes.reservedNames.has(attr)) continue;\n            if (!script.__attributes.hasOwnProperty(attr)) {\n              const scriptType = this.system.app.scripts.get(key);\n              if (scriptType) scriptType.attributes.add(attr, {});\n            }\n            script[attr] = value[key].attributes[attr];\n          }\n        }\n      } else {\n        console.log(this.order);\n      }\n    }\n  }\n  get scripts() {\n    return this._scripts;\n  }\n  set enabled(value) {\n    const oldValue = this._enabled;\n    this._enabled = value;\n    this.fire('set', 'enabled', oldValue, value);\n  }\n  get enabled() {\n    return this._enabled;\n  }\n  onEnable() {\n    this._beingEnabled = true;\n    this._checkState();\n    if (!this.entity._beingEnabled) {\n      this.onPostStateChange();\n    }\n    this._beingEnabled = false;\n  }\n  onDisable() {\n    this._checkState();\n  }\n  onPostStateChange() {\n    const wasLooping = this._beginLooping();\n    for (let i = 0, len = this.scripts.length; i < len; i++) {\n      const script = this.scripts[i];\n      if (script._initialized && !script._postInitialized && script.enabled) {\n        script._postInitialized = true;\n        if (script.postInitialize) this._scriptMethod(script, _script_constants_js__WEBPACK_IMPORTED_MODULE_3__.SCRIPT_POST_INITIALIZE);\n      }\n    }\n    this._endLooping(wasLooping);\n  }\n  _beginLooping() {\n    const looping = this._isLoopingThroughScripts;\n    this._isLoopingThroughScripts = true;\n    return looping;\n  }\n  _endLooping(wasLoopingBefore) {\n    this._isLoopingThroughScripts = wasLoopingBefore;\n    if (!this._isLoopingThroughScripts) {\n      this._removeDestroyedScripts();\n    }\n  }\n  _onSetEnabled(prop, old, value) {\n    this._beingEnabled = true;\n    this._checkState();\n    this._beingEnabled = false;\n  }\n  _checkState() {\n    const state = this.enabled && this.entity.enabled;\n    if (state === this._oldState) return;\n    this._oldState = state;\n    this.fire(state ? 'enable' : 'disable');\n    this.fire('state', state);\n    if (state) {\n      this.system._addComponentToEnabled(this);\n    } else {\n      this.system._removeComponentFromEnabled(this);\n    }\n    const wasLooping = this._beginLooping();\n    for (let i = 0, len = this.scripts.length; i < len; i++) {\n      const script = this.scripts[i];\n      script.enabled = script._enabled;\n    }\n    this._endLooping(wasLooping);\n  }\n  _onBeforeRemove() {\n    this.fire('remove');\n    const wasLooping = this._beginLooping();\n    for (let i = 0; i < this.scripts.length; i++) {\n      const script = this.scripts[i];\n      if (!script) continue;\n      this.destroy(script.__scriptType.__name);\n    }\n    this._endLooping(wasLooping);\n  }\n  _removeDestroyedScripts() {\n    const len = this._destroyedScripts.length;\n    if (!len) return;\n    for (let i = 0; i < len; i++) {\n      const script = this._destroyedScripts[i];\n      this._removeScriptInstance(script);\n    }\n    this._destroyedScripts.length = 0;\n    this._resetExecutionOrder(0, this._scripts.length);\n  }\n  _onInitializeAttributes() {\n    for (let i = 0, len = this.scripts.length; i < len; i++) this.scripts[i].__initializeAttributes();\n  }\n  _scriptMethod(script, method, arg) {\n    script[method](arg);\n  }\n  _onInitialize() {\n    const scripts = this._scripts;\n    const wasLooping = this._beginLooping();\n    for (let i = 0, len = scripts.length; i < len; i++) {\n      const script = scripts[i];\n      if (!script._initialized && script.enabled) {\n        script._initialized = true;\n        if (script.initialize) this._scriptMethod(script, _script_constants_js__WEBPACK_IMPORTED_MODULE_3__.SCRIPT_INITIALIZE);\n      }\n    }\n    this._endLooping(wasLooping);\n  }\n  _onPostInitialize() {\n    this.onPostStateChange();\n  }\n  _onUpdate(dt) {\n    const list = this._updateList;\n    if (!list.length) return;\n    const wasLooping = this._beginLooping();\n    for (list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++) {\n      const script = list.items[list.loopIndex];\n      if (script.enabled) {\n        this._scriptMethod(script, _script_constants_js__WEBPACK_IMPORTED_MODULE_3__.SCRIPT_UPDATE, dt);\n      }\n    }\n    this._endLooping(wasLooping);\n  }\n  _onPostUpdate(dt) {\n    const list = this._postUpdateList;\n    if (!list.length) return;\n    const wasLooping = this._beginLooping();\n    for (list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++) {\n      const script = list.items[list.loopIndex];\n      if (script.enabled) {\n        this._scriptMethod(script, _script_constants_js__WEBPACK_IMPORTED_MODULE_3__.SCRIPT_POST_UPDATE, dt);\n      }\n    }\n    this._endLooping(wasLooping);\n  }\n  _insertScriptInstance(scriptInstance, index, scriptsLength) {\n    if (index === -1) {\n      this._scripts.push(scriptInstance);\n      scriptInstance.__executionOrder = scriptsLength;\n      if (scriptInstance.update) {\n        this._updateList.append(scriptInstance);\n      }\n      if (scriptInstance.postUpdate) {\n        this._postUpdateList.append(scriptInstance);\n      }\n    } else {\n      this._scripts.splice(index, 0, scriptInstance);\n      scriptInstance.__executionOrder = index;\n      this._resetExecutionOrder(index + 1, scriptsLength + 1);\n      if (scriptInstance.update) {\n        this._updateList.insert(scriptInstance);\n      }\n      if (scriptInstance.postUpdate) {\n        this._postUpdateList.insert(scriptInstance);\n      }\n    }\n  }\n  _removeScriptInstance(scriptInstance) {\n    const idx = this._scripts.indexOf(scriptInstance);\n    if (idx === -1) return idx;\n    this._scripts.splice(idx, 1);\n    if (scriptInstance.update) {\n      this._updateList.remove(scriptInstance);\n    }\n    if (scriptInstance.postUpdate) {\n      this._postUpdateList.remove(scriptInstance);\n    }\n    return idx;\n  }\n  _resetExecutionOrder(startIndex, scriptsLength) {\n    for (let i = startIndex; i < scriptsLength; i++) {\n      this._scripts[i].__executionOrder = i;\n    }\n  }\n  _resolveEntityScriptAttribute(attribute, attributeName, oldValue, useGuid, newAttributes, duplicatedIdsMap) {\n    if (attribute.array) {\n      const len = oldValue.length;\n      if (!len) {\n        return;\n      }\n      const newGuidArray = oldValue.slice();\n      for (let i = 0; i < len; i++) {\n        const guid = newGuidArray[i] instanceof _entity_js__WEBPACK_IMPORTED_MODULE_4__.Entity ? newGuidArray[i].getGuid() : newGuidArray[i];\n        if (duplicatedIdsMap[guid]) {\n          newGuidArray[i] = useGuid ? duplicatedIdsMap[guid].getGuid() : duplicatedIdsMap[guid];\n        }\n      }\n      newAttributes[attributeName] = newGuidArray;\n    } else {\n      if (oldValue instanceof _entity_js__WEBPACK_IMPORTED_MODULE_4__.Entity) {\n        oldValue = oldValue.getGuid();\n      } else if (typeof oldValue !== 'string') {\n        return;\n      }\n      if (duplicatedIdsMap[oldValue]) {\n        newAttributes[attributeName] = duplicatedIdsMap[oldValue];\n      }\n    }\n  }\n  has(nameOrType) {\n    if (typeof nameOrType === 'string') {\n      return !!this._scriptsIndex[nameOrType];\n    }\n    if (!nameOrType) return false;\n    const scriptType = nameOrType;\n    const scriptName = scriptType.__name;\n    const scriptData = this._scriptsIndex[scriptName];\n    const scriptInstance = scriptData && scriptData.instance;\n    return scriptInstance instanceof scriptType;\n  }\n  get(nameOrType) {\n    if (typeof nameOrType === 'string') {\n      const data = this._scriptsIndex[nameOrType];\n      return data ? data.instance : null;\n    }\n    if (!nameOrType) return null;\n    const scriptType = nameOrType;\n    const scriptName = scriptType.__name;\n    const scriptData = this._scriptsIndex[scriptName];\n    const scriptInstance = scriptData && scriptData.instance;\n    return scriptInstance instanceof scriptType ? scriptInstance : null;\n  }\n  create(nameOrType, args = {}) {\n    const self = this;\n    let scriptType = nameOrType;\n    let scriptName = nameOrType;\n    if (typeof scriptType === 'string') {\n      scriptType = this.system.app.scripts.get(scriptType);\n    } else if (scriptType) {\n      scriptName = scriptType.__name;\n    }\n    if (scriptType) {\n      if (!this._scriptsIndex[scriptName] || !this._scriptsIndex[scriptName].instance) {\n        const scriptInstance = new scriptType({\n          app: this.system.app,\n          entity: this.entity,\n          enabled: args.hasOwnProperty('enabled') ? args.enabled : true,\n          attributes: args.attributes\n        });\n        const len = this._scripts.length;\n        let ind = -1;\n        if (typeof args.ind === 'number' && args.ind !== -1 && len > args.ind) ind = args.ind;\n        this._insertScriptInstance(scriptInstance, ind, len);\n        this._scriptsIndex[scriptName] = {\n          instance: scriptInstance,\n          onSwap: function () {\n            self.swap(scriptName);\n          }\n        };\n        this[scriptName] = scriptInstance;\n        if (!args.preloading) scriptInstance.__initializeAttributes();\n        this.fire('create', scriptName, scriptInstance);\n        this.fire('create:' + scriptName, scriptInstance);\n        this.system.app.scripts.on('swap:' + scriptName, this._scriptsIndex[scriptName].onSwap);\n        if (!args.preloading) {\n          if (scriptInstance.enabled && !scriptInstance._initialized) {\n            scriptInstance._initialized = true;\n            if (scriptInstance.initialize) this._scriptMethod(scriptInstance, _script_constants_js__WEBPACK_IMPORTED_MODULE_3__.SCRIPT_INITIALIZE);\n          }\n          if (scriptInstance.enabled && !scriptInstance._postInitialized) {\n            scriptInstance._postInitialized = true;\n            if (scriptInstance.postInitialize) this._scriptMethod(scriptInstance, _script_constants_js__WEBPACK_IMPORTED_MODULE_3__.SCRIPT_POST_INITIALIZE);\n          }\n        }\n        return scriptInstance;\n      }\n    } else {\n      this._scriptsIndex[scriptName] = {\n        awaiting: true,\n        ind: this._scripts.length\n      };\n    }\n    return null;\n  }\n  destroy(nameOrType) {\n    let scriptName = nameOrType;\n    let scriptType = nameOrType;\n    if (typeof scriptType === 'string') {\n      scriptType = this.system.app.scripts.get(scriptType);\n    } else if (scriptType) {\n      scriptName = scriptType.__name;\n    }\n    const scriptData = this._scriptsIndex[scriptName];\n    delete this._scriptsIndex[scriptName];\n    if (!scriptData) return false;\n    const scriptInstance = scriptData.instance;\n    if (scriptInstance && !scriptInstance._destroyed) {\n      scriptInstance.enabled = false;\n      scriptInstance._destroyed = true;\n      if (!this._isLoopingThroughScripts) {\n        const ind = this._removeScriptInstance(scriptInstance);\n        if (ind >= 0) {\n          this._resetExecutionOrder(ind, this._scripts.length);\n        }\n      } else {\n        this._destroyedScripts.push(scriptInstance);\n      }\n    }\n    this.system.app.scripts.off('swap:' + scriptName, scriptData.onSwap);\n    delete this[scriptName];\n    this.fire('destroy', scriptName, scriptInstance || null);\n    this.fire('destroy:' + scriptName, scriptInstance || null);\n    if (scriptInstance) scriptInstance.fire('destroy');\n    return true;\n  }\n  swap(nameOrType) {\n    let scriptName = nameOrType;\n    let scriptType = nameOrType;\n    if (typeof scriptType === 'string') {\n      scriptType = this.system.app.scripts.get(scriptType);\n    } else if (scriptType) {\n      scriptName = scriptType.__name;\n    }\n    const old = this._scriptsIndex[scriptName];\n    if (!old || !old.instance) return false;\n    const scriptInstanceOld = old.instance;\n    const ind = this._scripts.indexOf(scriptInstanceOld);\n    const scriptInstance = new scriptType({\n      app: this.system.app,\n      entity: this.entity,\n      enabled: scriptInstanceOld.enabled,\n      attributes: scriptInstanceOld.__attributes\n    });\n    if (!scriptInstance.swap) return false;\n    scriptInstance.__initializeAttributes();\n    this._scripts[ind] = scriptInstance;\n    this._scriptsIndex[scriptName].instance = scriptInstance;\n    this[scriptName] = scriptInstance;\n    scriptInstance.__executionOrder = ind;\n    if (scriptInstanceOld.update) {\n      this._updateList.remove(scriptInstanceOld);\n    }\n    if (scriptInstanceOld.postUpdate) {\n      this._postUpdateList.remove(scriptInstanceOld);\n    }\n    if (scriptInstance.update) {\n      this._updateList.insert(scriptInstance);\n    }\n    if (scriptInstance.postUpdate) {\n      this._postUpdateList.insert(scriptInstance);\n    }\n    this._scriptMethod(scriptInstance, _script_constants_js__WEBPACK_IMPORTED_MODULE_3__.SCRIPT_SWAP, scriptInstanceOld);\n    this.fire('swap', scriptName, scriptInstance);\n    this.fire('swap:' + scriptName, scriptInstance);\n    return true;\n  }\n  resolveDuplicatedEntityReferenceProperties(oldScriptComponent, duplicatedIdsMap) {\n    const newScriptComponent = this.entity.script;\n    for (const scriptName in oldScriptComponent._scriptsIndex) {\n      const scriptType = this.system.app.scripts.get(scriptName);\n      if (!scriptType) {\n        continue;\n      }\n      const script = oldScriptComponent._scriptsIndex[scriptName];\n      if (!script || !script.instance) {\n        continue;\n      }\n      const newAttributesRaw = newScriptComponent[scriptName].__attributesRaw;\n      const newAttributes = newScriptComponent[scriptName].__attributes;\n      if (!newAttributesRaw && !newAttributes) {\n        continue;\n      }\n      const useGuid = !!newAttributesRaw;\n      const oldAttributes = script.instance.__attributes;\n      for (const attributeName in oldAttributes) {\n        if (!oldAttributes[attributeName]) {\n          continue;\n        }\n        const attribute = scriptType.attributes.get(attributeName);\n        if (!attribute) {\n          continue;\n        }\n        if (attribute.type === 'entity') {\n          this._resolveEntityScriptAttribute(attribute, attributeName, oldAttributes[attributeName], useGuid, newAttributesRaw || newAttributes, duplicatedIdsMap);\n        } else if (attribute.type === 'json' && Array.isArray(attribute.schema)) {\n          const oldValue = oldAttributes[attributeName];\n          const newJsonValue = newAttributesRaw ? newAttributesRaw[attributeName] : newAttributes[attributeName];\n          for (let i = 0; i < attribute.schema.length; i++) {\n            const field = attribute.schema[i];\n            if (field.type !== 'entity') {\n              continue;\n            }\n            if (attribute.array) {\n              for (let j = 0; j < oldValue.length; j++) {\n                this._resolveEntityScriptAttribute(field, field.name, oldValue[j][field.name], useGuid, newJsonValue[j], duplicatedIdsMap);\n              }\n            } else {\n              this._resolveEntityScriptAttribute(field, field.name, oldValue[field.name], useGuid, newJsonValue, duplicatedIdsMap);\n            }\n          }\n        }\n      }\n    }\n  }\n  move(nameOrType, ind) {\n    const len = this._scripts.length;\n    if (ind >= len || ind < 0) return false;\n    let scriptType = nameOrType;\n    let scriptName = nameOrType;\n    if (typeof scriptName !== 'string') {\n      scriptName = nameOrType.__name;\n    } else {\n      scriptType = null;\n    }\n    const scriptData = this._scriptsIndex[scriptName];\n    if (!scriptData || !scriptData.instance) return false;\n    const scriptInstance = scriptData.instance;\n    if (scriptType && !(scriptInstance instanceof scriptType)) return false;\n    const indOld = this._scripts.indexOf(scriptInstance);\n    if (indOld === -1 || indOld === ind) return false;\n    this._scripts.splice(ind, 0, this._scripts.splice(indOld, 1)[0]);\n    this._resetExecutionOrder(0, len);\n    this._updateList.sort();\n    this._postUpdateList.sort();\n    this.fire('move', scriptName, scriptInstance, ind, indOld);\n    this.fire('move:' + scriptName, scriptInstance, ind, indOld);\n    return true;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/script/component.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/script/data.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/script/data.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScriptComponentData\": () => (/* binding */ ScriptComponentData)\n/* harmony export */ });\nclass ScriptComponentData {\n  constructor() {\n    this.enabled = true;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/script/data.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/script/system.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/script/system.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScriptComponentSystem\": () => (/* binding */ ScriptComponentSystem)\n/* harmony export */ });\n/* harmony import */ var _core_sorted_loop_array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/sorted-loop-array.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/sorted-loop-array.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/system.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/script/component.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/script/data.js\");\n\n\n\n\n\nconst METHOD_INITIALIZE_ATTRIBUTES = '_onInitializeAttributes';\nconst METHOD_INITIALIZE = '_onInitialize';\nconst METHOD_POST_INITIALIZE = '_onPostInitialize';\nconst METHOD_UPDATE = '_onUpdate';\nconst METHOD_POST_UPDATE = '_onPostUpdate';\nlet executionOrderCounter = 0;\nclass ScriptComponentSystem extends _system_js__WEBPACK_IMPORTED_MODULE_0__.ComponentSystem {\n  constructor(app) {\n    super(app);\n    this.id = 'script';\n    this.ComponentType = _component_js__WEBPACK_IMPORTED_MODULE_1__.ScriptComponent;\n    this.DataType = _data_js__WEBPACK_IMPORTED_MODULE_2__.ScriptComponentData;\n    this._components = new _core_sorted_loop_array_js__WEBPACK_IMPORTED_MODULE_3__.SortedLoopArray({\n      sortBy: '_executionOrder'\n    });\n    this._enabledComponents = new _core_sorted_loop_array_js__WEBPACK_IMPORTED_MODULE_3__.SortedLoopArray({\n      sortBy: '_executionOrder'\n    });\n    this.preloading = true;\n    this.on('beforeremove', this._onBeforeRemove, this);\n    this.app.systems.on('initialize', this._onInitialize, this);\n    this.app.systems.on('postInitialize', this._onPostInitialize, this);\n    this.app.systems.on('update', this._onUpdate, this);\n    this.app.systems.on('postUpdate', this._onPostUpdate, this);\n  }\n  initializeComponentData(component, data) {\n    component._executionOrder = executionOrderCounter++;\n    this._components.append(component);\n    if (executionOrderCounter > Number.MAX_SAFE_INTEGER) {\n      this._resetExecutionOrder();\n    }\n    component.enabled = data.hasOwnProperty('enabled') ? !!data.enabled : true;\n    if (component.enabled && component.entity.enabled) {\n      this._enabledComponents.append(component);\n    }\n    if (data.hasOwnProperty('order') && data.hasOwnProperty('scripts')) {\n      component._scriptsData = data.scripts;\n      for (let i = 0; i < data.order.length; i++) {\n        component.create(data.order[i], {\n          enabled: data.scripts[data.order[i]].enabled,\n          attributes: data.scripts[data.order[i]].attributes,\n          preloading: this.preloading\n        });\n      }\n    }\n  }\n  cloneComponent(entity, clone) {\n    const order = [];\n    const scripts = {};\n    for (let i = 0; i < entity.script._scripts.length; i++) {\n      const scriptInstance = entity.script._scripts[i];\n      const scriptName = scriptInstance.__scriptType.__name;\n      order.push(scriptName);\n      const attributes = {};\n      for (const key in scriptInstance.__attributes) attributes[key] = scriptInstance.__attributes[key];\n      scripts[scriptName] = {\n        enabled: scriptInstance._enabled,\n        attributes: attributes\n      };\n    }\n    for (const key in entity.script._scriptsIndex) {\n      if (key.awaiting) {\n        order.splice(key.ind, 0, key);\n      }\n    }\n    const data = {\n      enabled: entity.script.enabled,\n      order: order,\n      scripts: scripts\n    };\n    return this.addComponent(clone, data);\n  }\n  _resetExecutionOrder() {\n    executionOrderCounter = 0;\n    for (let i = 0, len = this._components.length; i < len; i++) {\n      this._components.items[i]._executionOrder = executionOrderCounter++;\n    }\n  }\n  _callComponentMethod(components, name, dt) {\n    for (components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++) {\n      components.items[components.loopIndex][name](dt);\n    }\n  }\n  _onInitialize() {\n    this.preloading = false;\n    this._callComponentMethod(this._components, METHOD_INITIALIZE_ATTRIBUTES);\n    this._callComponentMethod(this._enabledComponents, METHOD_INITIALIZE);\n  }\n  _onPostInitialize() {\n    this._callComponentMethod(this._enabledComponents, METHOD_POST_INITIALIZE);\n  }\n  _onUpdate(dt) {\n    this._callComponentMethod(this._enabledComponents, METHOD_UPDATE, dt);\n  }\n  _onPostUpdate(dt) {\n    this._callComponentMethod(this._enabledComponents, METHOD_POST_UPDATE, dt);\n  }\n  _addComponentToEnabled(component) {\n    this._enabledComponents.insert(component);\n  }\n  _removeComponentFromEnabled(component) {\n    this._enabledComponents.remove(component);\n  }\n  _onBeforeRemove(entity, component) {\n    const ind = this._components.items.indexOf(component);\n    if (ind >= 0) {\n      component._onBeforeRemove();\n    }\n    this._removeComponentFromEnabled(component);\n    this._components.remove(component);\n  }\n  destroy() {\n    super.destroy();\n    this.app.systems.off('initialize', this._onInitialize, this);\n    this.app.systems.off('postInitialize', this._onPostInitialize, this);\n    this.app.systems.off('update', this._onUpdate, this);\n    this.app.systems.off('postUpdate', this._onPostUpdate, this);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/script/system.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/scroll-view/component.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/scroll-view/component.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScrollViewComponent\": () => (/* binding */ ScrollViewComponent)\n/* harmony export */ });\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../scene/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _utils_entity_reference_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/entity-reference.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/utils/entity-reference.js\");\n/* harmony import */ var _element_element_drag_helper_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../element/element-drag-helper.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/element-drag-helper.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/scroll-view/constants.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _platform_input_constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../platform/input/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/input/constants.js\");\n\n\n\n\n\n\n\n\n\n\n\nconst _tempScrollValue = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_0__.Vec2();\nclass ScrollViewComponent extends _component_js__WEBPACK_IMPORTED_MODULE_1__.Component {\n  constructor(system, entity) {\n    super(system, entity);\n    this._viewportReference = new _utils_entity_reference_js__WEBPACK_IMPORTED_MODULE_2__.EntityReference(this, 'viewportEntity', {\n      'element#gain': this._onViewportElementGain,\n      'element#resize': this._onSetContentOrViewportSize\n    });\n    this._contentReference = new _utils_entity_reference_js__WEBPACK_IMPORTED_MODULE_2__.EntityReference(this, 'contentEntity', {\n      'element#gain': this._onContentElementGain,\n      'element#lose': this._onContentElementLose,\n      'element#resize': this._onSetContentOrViewportSize\n    });\n    this._scrollbarUpdateFlags = {};\n    this._scrollbarReferences = {};\n    this._scrollbarReferences[_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_HORIZONTAL] = new _utils_entity_reference_js__WEBPACK_IMPORTED_MODULE_2__.EntityReference(this, 'horizontalScrollbarEntity', {\n      'scrollbar#set:value': this._onSetHorizontalScrollbarValue,\n      'scrollbar#gain': this._onHorizontalScrollbarGain\n    });\n    this._scrollbarReferences[_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_VERTICAL] = new _utils_entity_reference_js__WEBPACK_IMPORTED_MODULE_2__.EntityReference(this, 'verticalScrollbarEntity', {\n      'scrollbar#set:value': this._onSetVerticalScrollbarValue,\n      'scrollbar#gain': this._onVerticalScrollbarGain\n    });\n    this._prevContentSizes = {};\n    this._prevContentSizes[_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_HORIZONTAL] = null;\n    this._prevContentSizes[_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_VERTICAL] = null;\n    this._scroll = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_0__.Vec2();\n    this._velocity = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_4__.Vec3();\n    this._dragStartPosition = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_4__.Vec3();\n    this._disabledContentInput = false;\n    this._disabledContentInputEntities = [];\n    this._toggleLifecycleListeners('on', system);\n    this._toggleElementListeners('on');\n  }\n  _toggleLifecycleListeners(onOrOff, system) {\n    this[onOrOff]('set_horizontal', this._onSetHorizontalScrollingEnabled, this);\n    this[onOrOff]('set_vertical', this._onSetVerticalScrollingEnabled, this);\n    system.app.systems.element[onOrOff]('add', this._onElementComponentAdd, this);\n    system.app.systems.element[onOrOff]('beforeremove', this._onElementComponentRemove, this);\n  }\n  _toggleElementListeners(onOrOff) {\n    if (this.entity.element) {\n      if (onOrOff === 'on' && this._hasElementListeners) {\n        return;\n      }\n      this.entity.element[onOrOff]('resize', this._onSetContentOrViewportSize, this);\n      this.entity.element[onOrOff](_platform_input_constants_js__WEBPACK_IMPORTED_MODULE_5__.EVENT_MOUSEWHEEL, this._onMouseWheel, this);\n      this._hasElementListeners = onOrOff === 'on';\n    }\n  }\n  _onElementComponentAdd(entity) {\n    if (this.entity === entity) {\n      this._toggleElementListeners('on');\n    }\n  }\n  _onElementComponentRemove(entity) {\n    if (this.entity === entity) {\n      this._toggleElementListeners('off');\n    }\n  }\n  _onViewportElementGain() {\n    this._syncAll();\n  }\n  _onContentElementGain() {\n    this._destroyDragHelper();\n    this._contentDragHelper = new _element_element_drag_helper_js__WEBPACK_IMPORTED_MODULE_6__.ElementDragHelper(this._contentReference.entity.element);\n    this._contentDragHelper.on('drag:start', this._onContentDragStart, this);\n    this._contentDragHelper.on('drag:end', this._onContentDragEnd, this);\n    this._contentDragHelper.on('drag:move', this._onContentDragMove, this);\n    this._prevContentSizes[_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_HORIZONTAL] = null;\n    this._prevContentSizes[_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_VERTICAL] = null;\n    this._syncAll();\n  }\n  _onContentElementLose() {\n    this._destroyDragHelper();\n  }\n  _onContentDragStart() {\n    if (this._contentReference.entity && this.enabled && this.entity.enabled) {\n      this._dragStartPosition.copy(this._contentReference.entity.getLocalPosition());\n    }\n  }\n  _onContentDragEnd() {\n    this._prevContentDragPosition = null;\n    this._enableContentInput();\n  }\n  _onContentDragMove(position) {\n    if (this._contentReference.entity && this.enabled && this.entity.enabled) {\n      this._wasDragged = true;\n      this._setScrollFromContentPosition(position);\n      this._setVelocityFromContentPositionDelta(position);\n      if (!this._disabledContentInput) {\n        const dx = position.x - this._dragStartPosition.x;\n        const dy = position.y - this._dragStartPosition.y;\n        if (Math.abs(dx) > this.dragThreshold || Math.abs(dy) > this.dragThreshold) {\n          this._disableContentInput();\n        }\n      }\n    }\n  }\n  _onSetContentOrViewportSize() {\n    this._syncAll();\n  }\n  _onSetHorizontalScrollbarValue(scrollValueX) {\n    if (!this._scrollbarUpdateFlags[_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_HORIZONTAL] && this.enabled && this.entity.enabled) {\n      this._onSetScroll(scrollValueX, null);\n    }\n  }\n  _onSetVerticalScrollbarValue(scrollValueY) {\n    if (!this._scrollbarUpdateFlags[_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_VERTICAL] && this.enabled && this.entity.enabled) {\n      this._onSetScroll(null, scrollValueY);\n    }\n  }\n  _onSetHorizontalScrollingEnabled() {\n    this._syncScrollbarEnabledState(_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_HORIZONTAL);\n  }\n  _onSetVerticalScrollingEnabled() {\n    this._syncScrollbarEnabledState(_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_VERTICAL);\n  }\n  _onHorizontalScrollbarGain() {\n    this._syncScrollbarEnabledState(_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_HORIZONTAL);\n    this._syncScrollbarPosition(_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_HORIZONTAL);\n  }\n  _onVerticalScrollbarGain() {\n    this._syncScrollbarEnabledState(_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_VERTICAL);\n    this._syncScrollbarPosition(_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_VERTICAL);\n  }\n  _onSetScroll(x, y, resetVelocity) {\n    if (resetVelocity !== false) {\n      this._velocity.set(0, 0, 0);\n    }\n    const xChanged = this._updateAxis(x, 'x', _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_HORIZONTAL);\n    const yChanged = this._updateAxis(y, 'y', _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_VERTICAL);\n    if (xChanged || yChanged) {\n      this.fire('set:scroll', this._scroll);\n    }\n  }\n  _updateAxis(scrollValue, axis, orientation) {\n    const hasChanged = scrollValue !== null && Math.abs(scrollValue - this._scroll[axis]) > 1e-5;\n    if (hasChanged || this._isDragging() || scrollValue === 0) {\n      this._scroll[axis] = this._determineNewScrollValue(scrollValue, axis, orientation);\n      this._syncContentPosition(orientation);\n      this._syncScrollbarPosition(orientation);\n    }\n    return hasChanged;\n  }\n  _determineNewScrollValue(scrollValue, axis, orientation) {\n    if (!this._getScrollingEnabled(orientation)) {\n      return this._scroll[axis];\n    }\n    switch (this.scrollMode) {\n      case _constants_js__WEBPACK_IMPORTED_MODULE_7__.SCROLL_MODE_CLAMP:\n        return _core_math_math_js__WEBPACK_IMPORTED_MODULE_8__.math.clamp(scrollValue, 0, this._getMaxScrollValue(orientation));\n      case _constants_js__WEBPACK_IMPORTED_MODULE_7__.SCROLL_MODE_BOUNCE:\n        this._setVelocityFromOvershoot(scrollValue, axis, orientation);\n        return scrollValue;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_7__.SCROLL_MODE_INFINITE:\n        return scrollValue;\n      default:\n        console.warn('Unhandled scroll mode:' + this.scrollMode);\n        return scrollValue;\n    }\n  }\n  _syncAll() {\n    this._syncContentPosition(_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_HORIZONTAL);\n    this._syncContentPosition(_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_VERTICAL);\n    this._syncScrollbarPosition(_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_HORIZONTAL);\n    this._syncScrollbarPosition(_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_VERTICAL);\n    this._syncScrollbarEnabledState(_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_HORIZONTAL);\n    this._syncScrollbarEnabledState(_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_VERTICAL);\n  }\n  _syncContentPosition(orientation) {\n    const axis = this._getAxis(orientation);\n    const sign = this._getSign(orientation);\n    const contentEntity = this._contentReference.entity;\n    if (contentEntity) {\n      const prevContentSize = this._prevContentSizes[orientation];\n      const currContentSize = this._getContentSize(orientation);\n      if (prevContentSize !== null && Math.abs(prevContentSize - currContentSize) > 1e-4) {\n        const prevMaxOffset = this._getMaxOffset(orientation, prevContentSize);\n        const currMaxOffset = this._getMaxOffset(orientation, currContentSize);\n        if (currMaxOffset === 0) {\n          this._scroll[axis] = 1;\n        } else {\n          this._scroll[axis] = _core_math_math_js__WEBPACK_IMPORTED_MODULE_8__.math.clamp(this._scroll[axis] * prevMaxOffset / currMaxOffset, 0, 1);\n        }\n      }\n      const offset = this._scroll[axis] * this._getMaxOffset(orientation);\n      const contentPosition = contentEntity.getLocalPosition();\n      contentPosition[axis] = offset * sign;\n      contentEntity.setLocalPosition(contentPosition);\n      this._prevContentSizes[orientation] = currContentSize;\n    }\n  }\n  _syncScrollbarPosition(orientation) {\n    const axis = this._getAxis(orientation);\n    const scrollbarEntity = this._scrollbarReferences[orientation].entity;\n    if (scrollbarEntity && scrollbarEntity.scrollbar) {\n      this._scrollbarUpdateFlags[orientation] = true;\n      scrollbarEntity.scrollbar.value = this._scroll[axis];\n      scrollbarEntity.scrollbar.handleSize = this._getScrollbarHandleSize(axis, orientation);\n      this._scrollbarUpdateFlags[orientation] = false;\n    }\n  }\n  _syncScrollbarEnabledState(orientation) {\n    const entity = this._scrollbarReferences[orientation].entity;\n    if (entity) {\n      const isScrollingEnabled = this._getScrollingEnabled(orientation);\n      const requestedVisibility = this._getScrollbarVisibility(orientation);\n      switch (requestedVisibility) {\n        case _constants_js__WEBPACK_IMPORTED_MODULE_7__.SCROLLBAR_VISIBILITY_SHOW_ALWAYS:\n          entity.enabled = isScrollingEnabled;\n          return;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_7__.SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED:\n          entity.enabled = isScrollingEnabled && this._contentIsLargerThanViewport(orientation);\n          return;\n        default:\n          console.warn('Unhandled scrollbar visibility:' + requestedVisibility);\n          entity.enabled = isScrollingEnabled;\n      }\n    }\n  }\n  _contentIsLargerThanViewport(orientation) {\n    return this._getContentSize(orientation) > this._getViewportSize(orientation);\n  }\n  _contentPositionToScrollValue(contentPosition) {\n    const maxOffsetH = this._getMaxOffset(_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_HORIZONTAL);\n    const maxOffsetV = this._getMaxOffset(_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_VERTICAL);\n    if (maxOffsetH === 0) {\n      _tempScrollValue.x = 0;\n    } else {\n      _tempScrollValue.x = contentPosition.x / maxOffsetH;\n    }\n    if (maxOffsetV === 0) {\n      _tempScrollValue.y = 0;\n    } else {\n      _tempScrollValue.y = contentPosition.y / -maxOffsetV;\n    }\n    return _tempScrollValue;\n  }\n  _getMaxOffset(orientation, contentSize) {\n    contentSize = contentSize === undefined ? this._getContentSize(orientation) : contentSize;\n    const viewportSize = this._getViewportSize(orientation);\n    if (contentSize < viewportSize) {\n      return -this._getViewportSize(orientation);\n    }\n    return viewportSize - contentSize;\n  }\n  _getMaxScrollValue(orientation) {\n    return this._contentIsLargerThanViewport(orientation) ? 1 : 0;\n  }\n  _getScrollbarHandleSize(axis, orientation) {\n    const viewportSize = this._getViewportSize(orientation);\n    const contentSize = this._getContentSize(orientation);\n    if (Math.abs(contentSize) < 0.001) {\n      return 1;\n    }\n    const handleSize = Math.min(viewportSize / contentSize, 1);\n    const overshoot = this._toOvershoot(this._scroll[axis], orientation);\n    if (overshoot === 0) {\n      return handleSize;\n    }\n    return handleSize / (1 + Math.abs(overshoot));\n  }\n  _getViewportSize(orientation) {\n    return this._getSize(orientation, this._viewportReference);\n  }\n  _getContentSize(orientation) {\n    return this._getSize(orientation, this._contentReference);\n  }\n  _getSize(orientation, entityReference) {\n    if (entityReference.entity && entityReference.entity.element) {\n      return entityReference.entity.element[this._getCalculatedDimension(orientation)];\n    }\n    return 0;\n  }\n  _getScrollingEnabled(orientation) {\n    if (orientation === _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_HORIZONTAL) {\n      return this.horizontal;\n    } else if (orientation === _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_VERTICAL) {\n      return this.vertical;\n    }\n    return undefined;\n  }\n  _getScrollbarVisibility(orientation) {\n    if (orientation === _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_HORIZONTAL) {\n      return this.horizontalScrollbarVisibility;\n    } else if (orientation === _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_VERTICAL) {\n      return this.verticalScrollbarVisibility;\n    }\n    return undefined;\n  }\n  _getSign(orientation) {\n    return orientation === _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_HORIZONTAL ? 1 : -1;\n  }\n  _getAxis(orientation) {\n    return orientation === _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_HORIZONTAL ? 'x' : 'y';\n  }\n  _getCalculatedDimension(orientation) {\n    return orientation === _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_HORIZONTAL ? 'calculatedWidth' : 'calculatedHeight';\n  }\n  _destroyDragHelper() {\n    if (this._contentDragHelper) {\n      this._contentDragHelper.destroy();\n    }\n  }\n  onUpdate() {\n    if (this._contentReference.entity) {\n      this._updateVelocity();\n      this._syncScrollbarEnabledState(_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_HORIZONTAL);\n      this._syncScrollbarEnabledState(_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_VERTICAL);\n    }\n  }\n  _updateVelocity() {\n    if (!this._isDragging()) {\n      if (this.scrollMode === _constants_js__WEBPACK_IMPORTED_MODULE_7__.SCROLL_MODE_BOUNCE) {\n        if (this._hasOvershoot('x', _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_HORIZONTAL)) {\n          this._setVelocityFromOvershoot(this.scroll.x, 'x', _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_HORIZONTAL);\n        }\n        if (this._hasOvershoot('y', _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_VERTICAL)) {\n          this._setVelocityFromOvershoot(this.scroll.y, 'y', _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_VERTICAL);\n        }\n      }\n      if (Math.abs(this._velocity.x) > 1e-4 || Math.abs(this._velocity.y) > 1e-4) {\n        const position = this._contentReference.entity.getLocalPosition();\n        position.x += this._velocity.x;\n        position.y += this._velocity.y;\n        this._contentReference.entity.setLocalPosition(position);\n        this._setScrollFromContentPosition(position);\n      }\n      this._velocity.x *= 1 - this.friction;\n      this._velocity.y *= 1 - this.friction;\n    }\n  }\n  _hasOvershoot(axis, orientation) {\n    return Math.abs(this._toOvershoot(this.scroll[axis], orientation)) > 0.001;\n  }\n  _toOvershoot(scrollValue, orientation) {\n    const maxScrollValue = this._getMaxScrollValue(orientation);\n    if (scrollValue < 0) {\n      return scrollValue;\n    } else if (scrollValue > maxScrollValue) {\n      return scrollValue - maxScrollValue;\n    }\n    return 0;\n  }\n  _setVelocityFromOvershoot(scrollValue, axis, orientation) {\n    const overshootValue = this._toOvershoot(scrollValue, orientation);\n    const overshootPixels = overshootValue * this._getMaxOffset(orientation) * this._getSign(orientation);\n    if (Math.abs(overshootPixels) > 0) {\n      this._velocity[axis] = -overshootPixels / (this.bounceAmount * 50 + 1);\n    }\n  }\n  _setVelocityFromContentPositionDelta(position) {\n    if (this._prevContentDragPosition) {\n      this._velocity.sub2(position, this._prevContentDragPosition);\n      this._prevContentDragPosition.copy(position);\n    } else {\n      this._velocity.set(0, 0, 0);\n      this._prevContentDragPosition = position.clone();\n    }\n  }\n  _setScrollFromContentPosition(position) {\n    let scrollValue = this._contentPositionToScrollValue(position);\n    if (this._isDragging()) {\n      scrollValue = this._applyScrollValueTension(scrollValue);\n    }\n    this._onSetScroll(scrollValue.x, scrollValue.y, false);\n  }\n  _applyScrollValueTension(scrollValue) {\n    const factor = 1;\n    let max = this._getMaxScrollValue(_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_HORIZONTAL);\n    let overshoot = this._toOvershoot(scrollValue.x, _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_HORIZONTAL);\n    if (overshoot > 0) {\n      scrollValue.x = max + factor * Math.log10(1 + overshoot);\n    } else if (overshoot < 0) {\n      scrollValue.x = -factor * Math.log10(1 - overshoot);\n    }\n    max = this._getMaxScrollValue(_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_VERTICAL);\n    overshoot = this._toOvershoot(scrollValue.y, _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_VERTICAL);\n    if (overshoot > 0) {\n      scrollValue.y = max + factor * Math.log10(1 + overshoot);\n    } else if (overshoot < 0) {\n      scrollValue.y = -factor * Math.log10(1 - overshoot);\n    }\n    return scrollValue;\n  }\n  _isDragging() {\n    return this._contentDragHelper && this._contentDragHelper.isDragging;\n  }\n  _setScrollbarComponentsEnabled(enabled) {\n    if (this._scrollbarReferences[_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_HORIZONTAL].hasComponent('scrollbar')) {\n      this._scrollbarReferences[_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_HORIZONTAL].entity.scrollbar.enabled = enabled;\n    }\n    if (this._scrollbarReferences[_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_VERTICAL].hasComponent('scrollbar')) {\n      this._scrollbarReferences[_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_VERTICAL].entity.scrollbar.enabled = enabled;\n    }\n  }\n  _setContentDraggingEnabled(enabled) {\n    if (this._contentDragHelper) {\n      this._contentDragHelper.enabled = enabled;\n    }\n  }\n  _onMouseWheel(event) {\n    if (this.useMouseWheel) {\n      const wheelEvent = event.event;\n      const normalizedDeltaX = wheelEvent.deltaX / this._contentReference.entity.element.calculatedWidth * this.mouseWheelSensitivity.x;\n      const normalizedDeltaY = wheelEvent.deltaY / this._contentReference.entity.element.calculatedHeight * this.mouseWheelSensitivity.y;\n      const scrollX = _core_math_math_js__WEBPACK_IMPORTED_MODULE_8__.math.clamp(this._scroll.x + normalizedDeltaX, 0, this._getMaxScrollValue(_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_HORIZONTAL));\n      const scrollY = _core_math_math_js__WEBPACK_IMPORTED_MODULE_8__.math.clamp(this._scroll.y + normalizedDeltaY, 0, this._getMaxScrollValue(_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_VERTICAL));\n      this.scroll = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_0__.Vec2(scrollX, scrollY);\n    }\n  }\n  _enableContentInput() {\n    while (this._disabledContentInputEntities.length) {\n      const e = this._disabledContentInputEntities.pop();\n      if (e.element) {\n        e.element.useInput = true;\n      }\n    }\n    this._disabledContentInput = false;\n  }\n  _disableContentInput() {\n    const _disableInput = e => {\n      if (e.element && e.element.useInput) {\n        this._disabledContentInputEntities.push(e);\n        e.element.useInput = false;\n      }\n      const children = e.children;\n      for (let i = 0, l = children.length; i < l; i++) {\n        _disableInput(children[i]);\n      }\n    };\n    const contentEntity = this._contentReference.entity;\n    if (contentEntity) {\n      const children = contentEntity.children;\n      for (let i = 0, l = children.length; i < l; i++) {\n        _disableInput(children[i]);\n      }\n    }\n    this._disabledContentInput = true;\n  }\n  onEnable() {\n    this._viewportReference.onParentComponentEnable();\n    this._contentReference.onParentComponentEnable();\n    this._scrollbarReferences[_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_HORIZONTAL].onParentComponentEnable();\n    this._scrollbarReferences[_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION_VERTICAL].onParentComponentEnable();\n    this._setScrollbarComponentsEnabled(true);\n    this._setContentDraggingEnabled(true);\n    this._syncAll();\n  }\n  onDisable() {\n    this._setScrollbarComponentsEnabled(false);\n    this._setContentDraggingEnabled(false);\n  }\n  onRemove() {\n    this._toggleLifecycleListeners('off', this.system);\n    this._toggleElementListeners('off');\n    this._destroyDragHelper();\n  }\n  set scroll(value) {\n    this._onSetScroll(value.x, value.y);\n  }\n  get scroll() {\n    return this._scroll;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/scroll-view/component.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/scroll-view/constants.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/scroll-view/constants.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SCROLLBAR_VISIBILITY_SHOW_ALWAYS\": () => (/* binding */ SCROLLBAR_VISIBILITY_SHOW_ALWAYS),\n/* harmony export */   \"SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED\": () => (/* binding */ SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED),\n/* harmony export */   \"SCROLL_MODE_BOUNCE\": () => (/* binding */ SCROLL_MODE_BOUNCE),\n/* harmony export */   \"SCROLL_MODE_CLAMP\": () => (/* binding */ SCROLL_MODE_CLAMP),\n/* harmony export */   \"SCROLL_MODE_INFINITE\": () => (/* binding */ SCROLL_MODE_INFINITE)\n/* harmony export */ });\nconst SCROLL_MODE_CLAMP = 0;\nconst SCROLL_MODE_BOUNCE = 1;\nconst SCROLL_MODE_INFINITE = 2;\nconst SCROLLBAR_VISIBILITY_SHOW_ALWAYS = 0;\nconst SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED = 1;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/scroll-view/constants.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/scroll-view/data.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/scroll-view/data.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScrollViewComponentData\": () => (/* binding */ ScrollViewComponentData)\n/* harmony export */ });\nclass ScrollViewComponentData {\n  constructor() {\n    this.enabled = true;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/scroll-view/data.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/scroll-view/system.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/scroll-view/system.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScrollViewComponentSystem\": () => (/* binding */ ScrollViewComponentSystem)\n/* harmony export */ });\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/system.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/scroll-view/component.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/scroll-view/data.js\");\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n\n\n\n\n\n\nconst _schema = [{\n  name: 'enabled',\n  type: 'boolean'\n}, {\n  name: 'horizontal',\n  type: 'boolean'\n}, {\n  name: 'vertical',\n  type: 'boolean'\n}, {\n  name: 'scrollMode',\n  type: 'number'\n}, {\n  name: 'bounceAmount',\n  type: 'number'\n}, {\n  name: 'friction',\n  type: 'number'\n}, {\n  name: 'dragThreshold',\n  type: 'number'\n}, {\n  name: 'useMouseWheel',\n  type: 'boolean'\n}, {\n  name: 'mouseWheelSensitivity',\n  type: 'vec2'\n}, {\n  name: 'horizontalScrollbarVisibility',\n  type: 'number'\n}, {\n  name: 'verticalScrollbarVisibility',\n  type: 'number'\n}, {\n  name: 'viewportEntity',\n  type: 'entity'\n}, {\n  name: 'contentEntity',\n  type: 'entity'\n}, {\n  name: 'horizontalScrollbarEntity',\n  type: 'entity'\n}, {\n  name: 'verticalScrollbarEntity',\n  type: 'entity'\n}];\nconst DEFAULT_DRAG_THRESHOLD = 10;\nclass ScrollViewComponentSystem extends _system_js__WEBPACK_IMPORTED_MODULE_0__.ComponentSystem {\n  constructor(app) {\n    super(app);\n    this.id = 'scrollview';\n    this.ComponentType = _component_js__WEBPACK_IMPORTED_MODULE_1__.ScrollViewComponent;\n    this.DataType = _data_js__WEBPACK_IMPORTED_MODULE_2__.ScrollViewComponentData;\n    this.schema = _schema;\n    this.on('beforeremove', this._onRemoveComponent, this);\n    this.app.systems.on('update', this.onUpdate, this);\n  }\n  initializeComponentData(component, data, properties) {\n    if (data.dragThreshold === undefined) {\n      data.dragThreshold = DEFAULT_DRAG_THRESHOLD;\n    }\n    if (data.useMouseWheel === undefined) {\n      data.useMouseWheel = true;\n    }\n    if (data.mouseWheelSensitivity === undefined) {\n      data.mouseWheelSensitivity = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_3__.Vec2(1, 1);\n    }\n    super.initializeComponentData(component, data, _schema);\n  }\n  onUpdate(dt) {\n    const components = this.store;\n    for (const id in components) {\n      const entity = components[id].entity;\n      const component = entity.scrollview;\n      if (component.enabled && entity.enabled) {\n        component.onUpdate();\n      }\n    }\n  }\n  _onRemoveComponent(entity, component) {\n    component.onRemove();\n  }\n  destroy() {\n    super.destroy();\n    this.app.systems.off('update', this.onUpdate, this);\n  }\n}\n_component_js__WEBPACK_IMPORTED_MODULE_4__.Component._buildAccessors(_component_js__WEBPACK_IMPORTED_MODULE_1__.ScrollViewComponent.prototype, _schema);\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/scroll-view/system.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/scrollbar/component.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/scrollbar/component.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScrollbarComponent\": () => (/* binding */ ScrollbarComponent)\n/* harmony export */ });\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _scene_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../scene/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _element_element_drag_helper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../element/element-drag-helper.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/element/element-drag-helper.js\");\n/* harmony import */ var _utils_entity_reference_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/entity-reference.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/utils/entity-reference.js\");\n\n\n\n\n\n\nclass ScrollbarComponent extends _component_js__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(system, entity) {\n    super(system, entity);\n    this._handleReference = new _utils_entity_reference_js__WEBPACK_IMPORTED_MODULE_1__.EntityReference(this, 'handleEntity', {\n      'element#gain': this._onHandleElementGain,\n      'element#lose': this._onHandleElementLose,\n      'element#set:anchor': this._onSetHandleAlignment,\n      'element#set:margin': this._onSetHandleAlignment,\n      'element#set:pivot': this._onSetHandleAlignment\n    });\n    this._toggleLifecycleListeners('on');\n  }\n  _toggleLifecycleListeners(onOrOff) {\n    this[onOrOff]('set_value', this._onSetValue, this);\n    this[onOrOff]('set_handleSize', this._onSetHandleSize, this);\n    this[onOrOff]('set_orientation', this._onSetOrientation, this);\n  }\n  _onHandleElementGain() {\n    this._destroyDragHelper();\n    this._handleDragHelper = new _element_element_drag_helper_js__WEBPACK_IMPORTED_MODULE_2__.ElementDragHelper(this._handleReference.entity.element, this._getAxis());\n    this._handleDragHelper.on('drag:move', this._onHandleDrag, this);\n    this._updateHandlePositionAndSize();\n  }\n  _onHandleElementLose() {\n    this._destroyDragHelper();\n  }\n  _onHandleDrag(position) {\n    if (this._handleReference.entity && this.enabled && this.entity.enabled) {\n      this.value = this._handlePositionToScrollValue(position[this._getAxis()]);\n    }\n  }\n  _onSetValue(name, oldValue, newValue) {\n    if (Math.abs(newValue - oldValue) > 1e-5) {\n      this.data.value = _core_math_math_js__WEBPACK_IMPORTED_MODULE_3__.math.clamp(newValue, 0, 1);\n      this._updateHandlePositionAndSize();\n      this.fire('set:value', this.data.value);\n    }\n  }\n  _onSetHandleSize(name, oldValue, newValue) {\n    if (Math.abs(newValue - oldValue) > 1e-5) {\n      this.data.handleSize = _core_math_math_js__WEBPACK_IMPORTED_MODULE_3__.math.clamp(newValue, 0, 1);\n      this._updateHandlePositionAndSize();\n    }\n  }\n  _onSetHandleAlignment() {\n    this._updateHandlePositionAndSize();\n  }\n  _onSetOrientation(name, oldValue, newValue) {\n    if (newValue !== oldValue && this._handleReference.hasComponent('element')) {\n      this._handleReference.entity.element[this._getOppositeDimension()] = 0;\n    }\n  }\n  _updateHandlePositionAndSize() {\n    const handleEntity = this._handleReference.entity;\n    const handleElement = handleEntity && handleEntity.element;\n    if (handleEntity) {\n      const position = handleEntity.getLocalPosition();\n      position[this._getAxis()] = this._getHandlePosition();\n      this._handleReference.entity.setLocalPosition(position);\n    }\n    if (handleElement) {\n      handleElement[this._getDimension()] = this._getHandleLength();\n    }\n  }\n  _handlePositionToScrollValue(handlePosition) {\n    return handlePosition * this._getSign() / this._getUsableTrackLength();\n  }\n  _scrollValueToHandlePosition(value) {\n    return value * this._getSign() * this._getUsableTrackLength();\n  }\n  _getUsableTrackLength() {\n    return Math.max(this._getTrackLength() - this._getHandleLength(), 0.001);\n  }\n  _getTrackLength() {\n    if (this.entity.element) {\n      return this.orientation === _scene_constants_js__WEBPACK_IMPORTED_MODULE_4__.ORIENTATION_HORIZONTAL ? this.entity.element.calculatedWidth : this.entity.element.calculatedHeight;\n    }\n    return 0;\n  }\n  _getHandleLength() {\n    return this._getTrackLength() * this.handleSize;\n  }\n  _getHandlePosition() {\n    return this._scrollValueToHandlePosition(this.value);\n  }\n  _getSign() {\n    return this.orientation === _scene_constants_js__WEBPACK_IMPORTED_MODULE_4__.ORIENTATION_HORIZONTAL ? 1 : -1;\n  }\n  _getAxis() {\n    return this.orientation === _scene_constants_js__WEBPACK_IMPORTED_MODULE_4__.ORIENTATION_HORIZONTAL ? 'x' : 'y';\n  }\n  _getDimension() {\n    return this.orientation === _scene_constants_js__WEBPACK_IMPORTED_MODULE_4__.ORIENTATION_HORIZONTAL ? 'width' : 'height';\n  }\n  _getOppositeDimension() {\n    return this.orientation === _scene_constants_js__WEBPACK_IMPORTED_MODULE_4__.ORIENTATION_HORIZONTAL ? 'height' : 'width';\n  }\n  _destroyDragHelper() {\n    if (this._handleDragHelper) {\n      this._handleDragHelper.destroy();\n    }\n  }\n  _setHandleDraggingEnabled(enabled) {\n    if (this._handleDragHelper) {\n      this._handleDragHelper.enabled = enabled;\n    }\n  }\n  onEnable() {\n    this._handleReference.onParentComponentEnable();\n    this._setHandleDraggingEnabled(true);\n  }\n  onDisable() {\n    this._setHandleDraggingEnabled(false);\n  }\n  onRemove() {\n    this._destroyDragHelper();\n    this._toggleLifecycleListeners('off');\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/scrollbar/component.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/scrollbar/data.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/scrollbar/data.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScrollbarComponentData\": () => (/* binding */ ScrollbarComponentData)\n/* harmony export */ });\nclass ScrollbarComponentData {\n  constructor() {\n    this.enabled = true;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/scrollbar/data.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/scrollbar/system.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/scrollbar/system.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScrollbarComponentSystem\": () => (/* binding */ ScrollbarComponentSystem)\n/* harmony export */ });\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/system.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/scrollbar/component.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/scrollbar/data.js\");\n\n\n\n\n\nconst _schema = [{\n  name: 'enabled',\n  type: 'boolean'\n}, {\n  name: 'orientation',\n  type: 'number'\n}, {\n  name: 'value',\n  type: 'number'\n}, {\n  name: 'handleSize',\n  type: 'number'\n}, {\n  name: 'handleEntity',\n  type: 'entity'\n}];\nclass ScrollbarComponentSystem extends _system_js__WEBPACK_IMPORTED_MODULE_0__.ComponentSystem {\n  constructor(app) {\n    super(app);\n    this.id = 'scrollbar';\n    this.ComponentType = _component_js__WEBPACK_IMPORTED_MODULE_1__.ScrollbarComponent;\n    this.DataType = _data_js__WEBPACK_IMPORTED_MODULE_2__.ScrollbarComponentData;\n    this.schema = _schema;\n    this.on('beforeremove', this._onRemoveComponent, this);\n  }\n  initializeComponentData(component, data, properties) {\n    super.initializeComponentData(component, data, _schema);\n  }\n  _onRemoveComponent(entity, component) {\n    component.onRemove();\n  }\n}\n_component_js__WEBPACK_IMPORTED_MODULE_3__.Component._buildAccessors(_component_js__WEBPACK_IMPORTED_MODULE_1__.ScrollbarComponent.prototype, _schema);\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/scrollbar/system.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sound/component.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sound/component.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SoundComponent\": () => (/* binding */ SoundComponent)\n/* harmony export */ });\n/* harmony import */ var _platform_audio_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../platform/audio/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/audio/constants.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _slot_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./slot.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sound/slot.js\");\n\n\n\n\n\nclass SoundComponent extends _component_js__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(system, entity) {\n    super(system, entity);\n    this._volume = 1;\n    this._pitch = 1;\n    this._positional = true;\n    this._refDistance = 1;\n    this._maxDistance = 10000;\n    this._rollOffFactor = 1;\n    this._distanceModel = _platform_audio_constants_js__WEBPACK_IMPORTED_MODULE_1__.DISTANCE_LINEAR;\n    this._slots = {};\n    this._playingBeforeDisable = {};\n  }\n  _updateSoundInstances(property, value, isFactor) {\n    const slots = this._slots;\n    for (const key in slots) {\n      const slot = slots[key];\n      if (!slot.overlap) {\n        const instances = slot.instances;\n        for (let i = 0, len = instances.length; i < len; i++) {\n          instances[i][property] = isFactor ? slot[property] * value : value;\n        }\n      }\n    }\n  }\n  set distanceModel(value) {\n    this._distanceModel = value;\n    this._updateSoundInstances('distanceModel', value, false);\n  }\n  get distanceModel() {\n    return this._distanceModel;\n  }\n  set maxDistance(value) {\n    this._maxDistance = value;\n    this._updateSoundInstances('maxDistance', value, false);\n  }\n  get maxDistance() {\n    return this._maxDistance;\n  }\n  set refDistance(value) {\n    this._refDistance = value;\n    this._updateSoundInstances('refDistance', value, false);\n  }\n  get refDistance() {\n    return this._refDistance;\n  }\n  set rollOffFactor(value) {\n    this._rollOffFactor = value;\n    this._updateSoundInstances('rollOffFactor', value, false);\n  }\n  get rollOffFactor() {\n    return this._rollOffFactor;\n  }\n  set pitch(value) {\n    this._pitch = value;\n    this._updateSoundInstances('pitch', value, true);\n  }\n  get pitch() {\n    return this._pitch;\n  }\n  set volume(value) {\n    this._volume = value;\n    this._updateSoundInstances('volume', value, true);\n  }\n  get volume() {\n    return this._volume;\n  }\n  set positional(newValue) {\n    this._positional = newValue;\n    const slots = this._slots;\n    for (const key in slots) {\n      const slot = slots[key];\n      if (!slot.overlap) {\n        const instances = slot.instances;\n        const oldLength = instances.length;\n        for (let i = oldLength - 1; i >= 0; i--) {\n          const isPlaying = instances[i].isPlaying || instances[i].isSuspended;\n          const currentTime = instances[i].currentTime;\n          if (isPlaying) instances[i].stop();\n          const instance = slot._createInstance();\n          if (isPlaying) {\n            instance.play();\n            instance.currentTime = currentTime;\n          }\n          instances.push(instance);\n        }\n      }\n    }\n  }\n  get positional() {\n    return this._positional;\n  }\n  set slots(newValue) {\n    const oldValue = this._slots;\n    if (oldValue) {\n      for (const key in oldValue) {\n        oldValue[key].stop();\n      }\n    }\n    const slots = {};\n    for (const key in newValue) {\n      if (!(newValue[key] instanceof _slot_js__WEBPACK_IMPORTED_MODULE_2__.SoundSlot)) {\n        if (newValue[key].name) {\n          slots[newValue[key].name] = new _slot_js__WEBPACK_IMPORTED_MODULE_2__.SoundSlot(this, newValue[key].name, newValue[key]);\n        }\n      } else {\n        slots[newValue[key].name] = newValue[key];\n      }\n    }\n    this._slots = slots;\n    if (this.enabled && this.entity.enabled) this.onEnable();\n  }\n  get slots() {\n    return this._slots;\n  }\n  onEnable() {\n    if (this.system._inTools) {\n      return;\n    }\n    const slots = this._slots;\n    const playingBeforeDisable = this._playingBeforeDisable;\n    for (const key in slots) {\n      const slot = slots[key];\n      if (slot.autoPlay && slot.isStopped) {\n        slot.play();\n      } else if (playingBeforeDisable[key]) {\n        slot.resume();\n      } else if (!slot.isLoaded) {\n        slot.load();\n      }\n    }\n  }\n  onDisable() {\n    const slots = this._slots;\n    const playingBeforeDisable = {};\n    for (const key in slots) {\n      if (!slots[key].overlap) {\n        if (slots[key].isPlaying) {\n          slots[key].pause();\n          playingBeforeDisable[key] = true;\n        }\n      }\n    }\n    this._playingBeforeDisable = playingBeforeDisable;\n  }\n  onRemove() {\n    this.off();\n  }\n  addSlot(name, options) {\n    const slots = this._slots;\n    if (slots[name]) {\n      return null;\n    }\n    const slot = new _slot_js__WEBPACK_IMPORTED_MODULE_2__.SoundSlot(this, name, options);\n    slots[name] = slot;\n    if (slot.autoPlay && this.enabled && this.entity.enabled) {\n      slot.play();\n    }\n    return slot;\n  }\n  removeSlot(name) {\n    const slots = this._slots;\n    if (slots[name]) {\n      slots[name].stop();\n      delete slots[name];\n    }\n  }\n  slot(name) {\n    return this._slots[name];\n  }\n  play(name) {\n    if (!this.enabled || !this.entity.enabled) {\n      return null;\n    }\n    const slot = this._slots[name];\n    if (!slot) {\n      return null;\n    }\n    return slot.play();\n  }\n  pause(name) {\n    const slots = this._slots;\n    if (name) {\n      const slot = slots[name];\n      if (!slot) {\n        return;\n      }\n      slot.pause();\n    } else {\n      for (const key in slots) {\n        slots[key].pause();\n      }\n    }\n  }\n  resume(name) {\n    const slots = this._slots;\n    if (name) {\n      const slot = slots[name];\n      if (!slot) {\n        return;\n      }\n      if (slot.isPaused) {\n        slot.resume();\n      }\n    } else {\n      for (const key in slots) {\n        slots[key].resume();\n      }\n    }\n  }\n  stop(name) {\n    const slots = this._slots;\n    if (name) {\n      const slot = slots[name];\n      if (!slot) {\n        return;\n      }\n      slot.stop();\n    } else {\n      for (const key in slots) {\n        slots[key].stop();\n      }\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sound/component.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sound/data.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sound/data.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SoundComponentData\": () => (/* binding */ SoundComponentData)\n/* harmony export */ });\nclass SoundComponentData {\n  constructor() {\n    this.enabled = true;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sound/data.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sound/slot.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sound/slot.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SoundSlot\": () => (/* binding */ SoundSlot)\n/* harmony export */ });\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _asset_asset_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../asset/asset.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset.js\");\n/* harmony import */ var _platform_sound_instance_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../platform/sound/instance.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/sound/instance.js\");\n/* harmony import */ var _platform_sound_instance3d_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../platform/sound/instance3d.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/sound/instance3d.js\");\n\n\n\n\n\n\n\n\nconst instanceOptions = {\n  volume: 0,\n  pitch: 0,\n  loop: false,\n  startTime: 0,\n  duration: 0,\n  position: new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(),\n  maxDistance: 0,\n  refDistance: 0,\n  rollOffFactor: 0,\n  distanceModel: 0,\n  onPlay: null,\n  onPause: null,\n  onResume: null,\n  onStop: null,\n  onEnd: null\n};\nclass SoundSlot extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_1__.EventHandler {\n  constructor(component, name = 'Untitled', options = {}) {\n    super();\n    this.name = void 0;\n    this.instances = [];\n    this._component = component;\n    this._assets = component.system.app.assets;\n    this._manager = component.system.manager;\n    this.name = name;\n    this._volume = options.volume !== undefined ? _core_math_math_js__WEBPACK_IMPORTED_MODULE_2__.math.clamp(Number(options.volume) || 0, 0, 1) : 1;\n    this._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;\n    this._loop = !!(options.loop !== undefined ? options.loop : false);\n    this._duration = options.duration > 0 ? options.duration : null;\n    this._startTime = Math.max(0, Number(options.startTime) || 0);\n    this._overlap = !!options.overlap;\n    this._autoPlay = !!options.autoPlay;\n    this._firstNode = null;\n    this._lastNode = null;\n    this._asset = options.asset;\n    if (this._asset instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_3__.Asset) {\n      this._asset = this._asset.id;\n    }\n    this._onInstancePlayHandler = this._onInstancePlay.bind(this);\n    this._onInstancePauseHandler = this._onInstancePause.bind(this);\n    this._onInstanceResumeHandler = this._onInstanceResume.bind(this);\n    this._onInstanceStopHandler = this._onInstanceStop.bind(this);\n    this._onInstanceEndHandler = this._onInstanceEnd.bind(this);\n  }\n  play() {\n    if (!this.overlap) {\n      this.stop();\n    }\n    if (!this.isLoaded && !this._hasAsset()) {\n      return undefined;\n    }\n    const instance = this._createInstance();\n    this.instances.push(instance);\n    if (!this.isLoaded) {\n      const onLoad = function onLoad(sound) {\n        const playWhenLoaded = instance._playWhenLoaded;\n        instance.sound = sound;\n        if (playWhenLoaded) {\n          instance.play();\n        }\n      };\n      this.off('load', onLoad);\n      this.once('load', onLoad);\n      this.load();\n    } else {\n      instance.play();\n    }\n    return instance;\n  }\n  pause() {\n    let paused = false;\n    const instances = this.instances;\n    for (let i = 0, len = instances.length; i < len; i++) {\n      if (instances[i].pause()) {\n        paused = true;\n      }\n    }\n    return paused;\n  }\n  resume() {\n    let resumed = false;\n    const instances = this.instances;\n    for (let i = 0, len = instances.length; i < len; i++) {\n      if (instances[i].resume()) resumed = true;\n    }\n    return resumed;\n  }\n  stop() {\n    let stopped = false;\n    const instances = this.instances;\n    let i = instances.length;\n    while (i--) {\n      instances[i].stop();\n      stopped = true;\n    }\n    instances.length = 0;\n    return stopped;\n  }\n  load() {\n    if (!this._hasAsset()) return;\n    const asset = this._assets.get(this._asset);\n    if (!asset) {\n      this._assets.off('add:' + this._asset, this._onAssetAdd, this);\n      this._assets.once('add:' + this._asset, this._onAssetAdd, this);\n      return;\n    }\n    asset.off('remove', this._onAssetRemoved, this);\n    asset.on('remove', this._onAssetRemoved, this);\n    if (!asset.resource) {\n      asset.off('load', this._onAssetLoad, this);\n      asset.once('load', this._onAssetLoad, this);\n      this._assets.load(asset);\n      return;\n    }\n    this.fire('load', asset.resource);\n  }\n  setExternalNodes(firstNode, lastNode) {\n    if (!firstNode) {\n      console.error('The firstNode must have a valid AudioNode');\n      return;\n    }\n    if (!lastNode) {\n      lastNode = firstNode;\n    }\n    this._firstNode = firstNode;\n    this._lastNode = lastNode;\n    if (!this._overlap) {\n      const instances = this.instances;\n      for (let i = 0, len = instances.length; i < len; i++) {\n        instances[i].setExternalNodes(firstNode, lastNode);\n      }\n    }\n  }\n  clearExternalNodes() {\n    this._firstNode = null;\n    this._lastNode = null;\n    if (!this._overlap) {\n      const instances = this.instances;\n      for (let i = 0, len = instances.length; i < len; i++) {\n        instances[i].clearExternalNodes();\n      }\n    }\n  }\n  getExternalNodes() {\n    return [this._firstNode, this._lastNode];\n  }\n  _hasAsset() {\n    return this._asset != null;\n  }\n  _createInstance() {\n    let instance = null;\n    const component = this._component;\n    let sound = null;\n    if (this._hasAsset()) {\n      const asset = this._assets.get(this._asset);\n      if (asset) {\n        sound = asset.resource;\n      }\n    }\n    const data = instanceOptions;\n    data.volume = this._volume * component.volume;\n    data.pitch = this._pitch * component.pitch;\n    data.loop = this._loop;\n    data.startTime = this._startTime;\n    data.duration = this._duration;\n    data.onPlay = this._onInstancePlayHandler;\n    data.onPause = this._onInstancePauseHandler;\n    data.onResume = this._onInstanceResumeHandler;\n    data.onStop = this._onInstanceStopHandler;\n    data.onEnd = this._onInstanceEndHandler;\n    if (component.positional) {\n      data.position.copy(component.entity.getPosition());\n      data.maxDistance = component.maxDistance;\n      data.refDistance = component.refDistance;\n      data.rollOffFactor = component.rollOffFactor;\n      data.distanceModel = component.distanceModel;\n      instance = new _platform_sound_instance3d_js__WEBPACK_IMPORTED_MODULE_4__.SoundInstance3d(this._manager, sound, data);\n    } else {\n      instance = new _platform_sound_instance_js__WEBPACK_IMPORTED_MODULE_5__.SoundInstance(this._manager, sound, data);\n    }\n    if (this._firstNode) {\n      instance.setExternalNodes(this._firstNode, this._lastNode);\n    }\n    return instance;\n  }\n  _onInstancePlay(instance) {\n    this.fire('play', instance);\n    this._component.fire('play', this, instance);\n  }\n  _onInstancePause(instance) {\n    this.fire('pause', instance);\n    this._component.fire('pause', this, instance);\n  }\n  _onInstanceResume(instance) {\n    this.fire('resume', instance);\n    this._component.fire('resume', this, instance);\n  }\n  _onInstanceStop(instance) {\n    const idx = this.instances.indexOf(instance);\n    if (idx !== -1) {\n      this.instances.splice(idx, 1);\n    }\n    this.fire('stop', instance);\n    this._component.fire('stop', this, instance);\n  }\n  _onInstanceEnd(instance) {\n    const idx = this.instances.indexOf(instance);\n    if (idx !== -1) {\n      this.instances.splice(idx, 1);\n    }\n    this.fire('end', instance);\n    this._component.fire('end', this, instance);\n  }\n  _onAssetAdd(asset) {\n    this.load();\n  }\n  _onAssetLoad(asset) {\n    this.load();\n  }\n  _onAssetRemoved(asset) {\n    asset.off('remove', this._onAssetRemoved, this);\n    this._assets.off('add:' + asset.id, this._onAssetAdd, this);\n    this.stop();\n  }\n  updatePosition(position) {\n    const instances = this.instances;\n    for (let i = 0, len = instances.length; i < len; i++) {\n      instances[i].position = position;\n    }\n  }\n  set asset(value) {\n    const old = this._asset;\n    if (old) {\n      this._assets.off('add:' + old, this._onAssetAdd, this);\n      const oldAsset = this._assets.get(old);\n      if (oldAsset) {\n        oldAsset.off('remove', this._onAssetRemoved, this);\n      }\n    }\n    this._asset = value;\n    if (this._asset instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_3__.Asset) {\n      this._asset = this._asset.id;\n    }\n    if (this._hasAsset() && this._component.enabled && this._component.entity.enabled) {\n      this.load();\n    }\n  }\n  get asset() {\n    return this._asset;\n  }\n  set autoPlay(value) {\n    this._autoPlay = !!value;\n  }\n  get autoPlay() {\n    return this._autoPlay;\n  }\n  set duration(value) {\n    this._duration = Math.max(0, Number(value) || 0) || null;\n    if (!this._overlap) {\n      const instances = this.instances;\n      for (let i = 0, len = instances.length; i < len; i++) {\n        instances[i].duration = this._duration;\n      }\n    }\n  }\n  get duration() {\n    let assetDuration = 0;\n    if (this._hasAsset()) {\n      const asset = this._assets.get(this._asset);\n      assetDuration = asset != null && asset.resource ? asset.resource.duration : 0;\n    }\n    if (this._duration != null) {\n      return this._duration % (assetDuration || 1);\n    }\n    return assetDuration;\n  }\n  get isLoaded() {\n    if (this._hasAsset()) {\n      const asset = this._assets.get(this._asset);\n      if (asset) {\n        return !!asset.resource;\n      }\n    }\n    return false;\n  }\n  get isPaused() {\n    const instances = this.instances;\n    const len = instances.length;\n    if (len === 0) return false;\n    for (let i = 0; i < len; i++) {\n      if (!instances[i].isPaused) return false;\n    }\n    return true;\n  }\n  get isPlaying() {\n    const instances = this.instances;\n    for (let i = 0, len = instances.length; i < len; i++) {\n      if (instances[i].isPlaying) return true;\n    }\n    return false;\n  }\n  get isStopped() {\n    const instances = this.instances;\n    for (let i = 0, len = instances.length; i < len; i++) {\n      if (!instances[i].isStopped) return false;\n    }\n    return true;\n  }\n  set loop(value) {\n    this._loop = !!value;\n    const instances = this.instances;\n    for (let i = 0, len = instances.length; i < len; i++) {\n      instances[i].loop = this._loop;\n    }\n  }\n  get loop() {\n    return this._loop;\n  }\n  set overlap(value) {\n    this._overlap = !!value;\n  }\n  get overlap() {\n    return this._overlap;\n  }\n  set pitch(value) {\n    this._pitch = Math.max(Number(value) || 0, 0.01);\n    if (!this._overlap) {\n      const instances = this.instances;\n      for (let i = 0, len = instances.length; i < len; i++) {\n        instances[i].pitch = this.pitch * this._component.pitch;\n      }\n    }\n  }\n  get pitch() {\n    return this._pitch;\n  }\n  set startTime(value) {\n    this._startTime = Math.max(0, Number(value) || 0);\n    if (!this._overlap) {\n      const instances = this.instances;\n      for (let i = 0, len = instances.length; i < len; i++) {\n        instances[i].startTime = this._startTime;\n      }\n    }\n  }\n  get startTime() {\n    return this._startTime;\n  }\n  set volume(value) {\n    this._volume = _core_math_math_js__WEBPACK_IMPORTED_MODULE_2__.math.clamp(Number(value) || 0, 0, 1);\n    if (!this._overlap) {\n      const instances = this.instances;\n      for (let i = 0, len = instances.length; i < len; i++) {\n        instances[i].volume = this._volume * this._component.volume;\n      }\n    }\n  }\n  get volume() {\n    return this._volume;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sound/slot.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sound/system.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sound/system.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SoundComponentSystem\": () => (/* binding */ SoundComponentSystem)\n/* harmony export */ });\n/* harmony import */ var _platform_audio_capabilities_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../platform/audio/capabilities.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/audio/capabilities.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/system.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sound/component.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sound/data.js\");\n\n\n\n\n\n\n\nconst _schema = ['enabled'];\nclass SoundComponentSystem extends _system_js__WEBPACK_IMPORTED_MODULE_0__.ComponentSystem {\n  constructor(app) {\n    super(app);\n    this.id = 'sound';\n    this.ComponentType = _component_js__WEBPACK_IMPORTED_MODULE_1__.SoundComponent;\n    this.DataType = _data_js__WEBPACK_IMPORTED_MODULE_2__.SoundComponentData;\n    this.schema = _schema;\n    this.manager = app.soundManager;\n    this.app.systems.on('update', this.onUpdate, this);\n    this.on('beforeremove', this.onBeforeRemove, this);\n  }\n  set volume(volume) {\n    this.manager.volume = volume;\n  }\n  get volume() {\n    return this.manager.volume;\n  }\n  get context() {\n    if (!(0,_platform_audio_capabilities_js__WEBPACK_IMPORTED_MODULE_3__.hasAudioContext)()) {\n      return null;\n    }\n    return this.manager.context;\n  }\n  initializeComponentData(component, data, properties) {\n    properties = ['volume', 'pitch', 'positional', 'refDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'slots'];\n    for (let i = 0; i < properties.length; i++) {\n      if (data.hasOwnProperty(properties[i])) {\n        component[properties[i]] = data[properties[i]];\n      }\n    }\n    super.initializeComponentData(component, data, ['enabled']);\n  }\n  cloneComponent(entity, clone) {\n    const srcComponent = entity.sound;\n    const srcSlots = srcComponent.slots;\n    const slots = {};\n    for (const key in srcSlots) {\n      const srcSlot = srcSlots[key];\n      slots[key] = {\n        name: srcSlot.name,\n        volume: srcSlot.volume,\n        pitch: srcSlot.pitch,\n        loop: srcSlot.loop,\n        duration: srcSlot.duration,\n        startTime: srcSlot.startTime,\n        overlap: srcSlot.overlap,\n        autoPlay: srcSlot.autoPlay,\n        asset: srcSlot.asset\n      };\n    }\n    const cloneData = {\n      distanceModel: srcComponent.distanceModel,\n      enabled: srcComponent.enabled,\n      maxDistance: srcComponent.maxDistance,\n      pitch: srcComponent.pitch,\n      positional: srcComponent.positional,\n      refDistance: srcComponent.refDistance,\n      rollOffFactor: srcComponent.rollOffFactor,\n      slots: slots,\n      volume: srcComponent.volume\n    };\n    return this.addComponent(clone, cloneData);\n  }\n  onUpdate(dt) {\n    const store = this.store;\n    for (const id in store) {\n      if (store.hasOwnProperty(id)) {\n        const item = store[id];\n        const entity = item.entity;\n        if (entity.enabled) {\n          const component = entity.sound;\n          if (component.enabled && component.positional) {\n            const position = entity.getPosition();\n            const slots = component.slots;\n            for (const key in slots) {\n              slots[key].updatePosition(position);\n            }\n          }\n        }\n      }\n    }\n  }\n  onBeforeRemove(entity, component) {\n    const slots = component.slots;\n    for (const key in slots) {\n      if (!slots[key].overlap) {\n        slots[key].stop();\n      }\n    }\n    component.onRemove();\n  }\n  destroy() {\n    super.destroy();\n    this.app.systems.off('update', this.onUpdate, this);\n  }\n}\n_component_js__WEBPACK_IMPORTED_MODULE_4__.Component._buildAccessors(_component_js__WEBPACK_IMPORTED_MODULE_1__.SoundComponent.prototype, _schema);\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sound/system.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sprite/component.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sprite/component.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SpriteComponent\": () => (/* binding */ SpriteComponent)\n/* harmony export */ });\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _core_math_color_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/math/color.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/math/vec4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec4.js\");\n/* harmony import */ var _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../scene/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _scene_batching_batch_group_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../scene/batching/batch-group.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/batching/batch-group.js\");\n/* harmony import */ var _scene_graph_node_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../scene/graph-node.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/graph-node.js\");\n/* harmony import */ var _scene_mesh_instance_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../scene/mesh-instance.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh-instance.js\");\n/* harmony import */ var _scene_model_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../scene/model.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/model.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sprite/constants.js\");\n/* harmony import */ var _sprite_animation_clip_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./sprite-animation-clip.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sprite/sprite-animation-clip.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst PARAM_EMISSIVE_MAP = 'texture_emissiveMap';\nconst PARAM_OPACITY_MAP = 'texture_opacityMap';\nconst PARAM_EMISSIVE = 'material_emissive';\nconst PARAM_OPACITY = 'material_opacity';\nconst PARAM_INNER_OFFSET = 'innerOffset';\nconst PARAM_OUTER_SCALE = 'outerScale';\nconst PARAM_ATLAS_RECT = 'atlasRect';\nclass SpriteComponent extends _component_js__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(system, entity) {\n    super(system, entity);\n    this._type = _constants_js__WEBPACK_IMPORTED_MODULE_1__.SPRITETYPE_SIMPLE;\n    this._material = system.defaultMaterial;\n    this._color = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_2__.Color(1, 1, 1, 1);\n    this._colorUniform = new Float32Array(3);\n    this._speed = 1;\n    this._flipX = false;\n    this._flipY = false;\n    this._width = 1;\n    this._height = 1;\n    this._drawOrder = 0;\n    this._layers = [_scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.LAYERID_WORLD];\n    this._outerScale = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_4__.Vec2(1, 1);\n    this._outerScaleUniform = new Float32Array(2);\n    this._innerOffset = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_5__.Vec4();\n    this._innerOffsetUniform = new Float32Array(4);\n    this._atlasRect = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_5__.Vec4();\n    this._atlasRectUniform = new Float32Array(4);\n    this._batchGroupId = -1;\n    this._batchGroup = null;\n    this._node = new _scene_graph_node_js__WEBPACK_IMPORTED_MODULE_6__.GraphNode();\n    this._model = new _scene_model_js__WEBPACK_IMPORTED_MODULE_7__.Model();\n    this._model.graph = this._node;\n    this._meshInstance = null;\n    entity.addChild(this._model.graph);\n    this._model._entity = entity;\n    this._updateAabbFunc = this._updateAabb.bind(this);\n    this._addedModel = false;\n    this._autoPlayClip = null;\n    this._clips = {};\n    this._defaultClip = new _sprite_animation_clip_js__WEBPACK_IMPORTED_MODULE_8__.SpriteAnimationClip(this, {\n      name: this.entity.name,\n      fps: 0,\n      loop: false,\n      spriteAsset: null\n    });\n    this._currentClip = this._defaultClip;\n  }\n  set type(value) {\n    if (this._type === value) return;\n    this._type = value;\n    if (this._type === _constants_js__WEBPACK_IMPORTED_MODULE_1__.SPRITETYPE_SIMPLE) {\n      this.stop();\n      this._currentClip = this._defaultClip;\n      if (this.enabled && this.entity.enabled) {\n        this._currentClip.frame = this.frame;\n        if (this._currentClip.sprite) {\n          this._showModel();\n        } else {\n          this._hideModel();\n        }\n      }\n    } else if (this._type === _constants_js__WEBPACK_IMPORTED_MODULE_1__.SPRITETYPE_ANIMATED) {\n      this.stop();\n      if (this._autoPlayClip) {\n        this._tryAutoPlay();\n      }\n      if (this._currentClip && this._currentClip.isPlaying && this.enabled && this.entity.enabled) {\n        this._showModel();\n      } else {\n        this._hideModel();\n      }\n    }\n  }\n  get type() {\n    return this._type;\n  }\n  set frame(value) {\n    this._currentClip.frame = value;\n  }\n  get frame() {\n    return this._currentClip.frame;\n  }\n  set spriteAsset(value) {\n    this._defaultClip.spriteAsset = value;\n  }\n  get spriteAsset() {\n    return this._defaultClip._spriteAsset;\n  }\n  set sprite(value) {\n    this._currentClip.sprite = value;\n  }\n  get sprite() {\n    return this._currentClip.sprite;\n  }\n  set material(value) {\n    this._material = value;\n    if (this._meshInstance) {\n      this._meshInstance.material = value;\n    }\n  }\n  get material() {\n    return this._material;\n  }\n  set color(value) {\n    this._color.r = value.r;\n    this._color.g = value.g;\n    this._color.b = value.b;\n    if (this._meshInstance) {\n      this._colorUniform[0] = this._color.r;\n      this._colorUniform[1] = this._color.g;\n      this._colorUniform[2] = this._color.b;\n      this._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);\n    }\n  }\n  get color() {\n    return this._color;\n  }\n  set opacity(value) {\n    this._color.a = value;\n    if (this._meshInstance) {\n      this._meshInstance.setParameter(PARAM_OPACITY, value);\n    }\n  }\n  get opacity() {\n    return this._color.a;\n  }\n  set clips(value) {\n    if (!value) {\n      for (const name in this._clips) {\n        this.removeClip(name);\n      }\n      return;\n    }\n    for (const name in this._clips) {\n      let found = false;\n      for (const key in value) {\n        if (value[key].name === name) {\n          found = true;\n          this._clips[name].fps = value[key].fps;\n          this._clips[name].loop = value[key].loop;\n          if (value[key].hasOwnProperty('sprite')) {\n            this._clips[name].sprite = value[key].sprite;\n          } else if (value[key].hasOwnProperty('spriteAsset')) {\n            this._clips[name].spriteAsset = value[key].spriteAsset;\n          }\n          break;\n        }\n      }\n      if (!found) {\n        this.removeClip(name);\n      }\n    }\n    for (const key in value) {\n      if (this._clips[value[key].name]) continue;\n      this.addClip(value[key]);\n    }\n    if (this._autoPlayClip) {\n      this._tryAutoPlay();\n    }\n    if (!this._currentClip || !this._currentClip.sprite) {\n      this._hideModel();\n    }\n  }\n  get clips() {\n    return this._clips;\n  }\n  get currentClip() {\n    return this._currentClip;\n  }\n  set speed(value) {\n    this._speed = value;\n  }\n  get speed() {\n    return this._speed;\n  }\n  set flipX(value) {\n    if (this._flipX === value) return;\n    this._flipX = value;\n    this._updateTransform();\n  }\n  get flipX() {\n    return this._flipX;\n  }\n  set flipY(value) {\n    if (this._flipY === value) return;\n    this._flipY = value;\n    this._updateTransform();\n  }\n  get flipY() {\n    return this._flipY;\n  }\n  set width(value) {\n    if (value === this._width) return;\n    this._width = value;\n    this._outerScale.x = this._width;\n    if (this.sprite && (this.sprite.renderMode === _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.SPRITE_RENDERMODE_TILED || this.sprite.renderMode === _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.SPRITE_RENDERMODE_SLICED)) {\n      this._updateTransform();\n    }\n  }\n  get width() {\n    return this._width;\n  }\n  set height(value) {\n    if (value === this._height) return;\n    this._height = value;\n    this._outerScale.y = this.height;\n    if (this.sprite && (this.sprite.renderMode === _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.SPRITE_RENDERMODE_TILED || this.sprite.renderMode === _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.SPRITE_RENDERMODE_SLICED)) {\n      this._updateTransform();\n    }\n  }\n  get height() {\n    return this._height;\n  }\n  set batchGroupId(value) {\n    if (this._batchGroupId === value) return;\n    const prev = this._batchGroupId;\n    this._batchGroupId = value;\n    if (this.entity.enabled && prev >= 0) {\n      var _this$system$app$batc;\n      (_this$system$app$batc = this.system.app.batcher) == null ? void 0 : _this$system$app$batc.remove(_scene_batching_batch_group_js__WEBPACK_IMPORTED_MODULE_9__.BatchGroup.SPRITE, prev, this.entity);\n    }\n    if (this.entity.enabled && value >= 0) {\n      var _this$system$app$batc2;\n      (_this$system$app$batc2 = this.system.app.batcher) == null ? void 0 : _this$system$app$batc2.insert(_scene_batching_batch_group_js__WEBPACK_IMPORTED_MODULE_9__.BatchGroup.SPRITE, value, this.entity);\n    } else {\n      if (prev >= 0) {\n        if (this._currentClip && this._currentClip.sprite && this.enabled && this.entity.enabled) {\n          this._showModel();\n        }\n      }\n    }\n  }\n  get batchGroupId() {\n    return this._batchGroupId;\n  }\n  set autoPlayClip(value) {\n    this._autoPlayClip = value instanceof _sprite_animation_clip_js__WEBPACK_IMPORTED_MODULE_8__.SpriteAnimationClip ? value.name : value;\n    this._tryAutoPlay();\n  }\n  get autoPlayClip() {\n    return this._autoPlayClip;\n  }\n  set drawOrder(value) {\n    this._drawOrder = value;\n    if (this._meshInstance) {\n      this._meshInstance.drawOrder = value;\n    }\n  }\n  get drawOrder() {\n    return this._drawOrder;\n  }\n  set layers(value) {\n    if (this._addedModel) {\n      this._hideModel();\n    }\n    this._layers = value;\n    if (!this._meshInstance) {\n      return;\n    }\n    if (this.enabled && this.entity.enabled) {\n      this._showModel();\n    }\n  }\n  get layers() {\n    return this._layers;\n  }\n  get aabb() {\n    if (this._meshInstance) {\n      return this._meshInstance.aabb;\n    }\n    return null;\n  }\n  onEnable() {\n    const app = this.system.app;\n    const scene = app.scene;\n    scene.on('set:layers', this._onLayersChanged, this);\n    if (scene.layers) {\n      scene.layers.on('add', this._onLayerAdded, this);\n      scene.layers.on('remove', this._onLayerRemoved, this);\n    }\n    this._showModel();\n    if (this._autoPlayClip) this._tryAutoPlay();\n    if (this._batchGroupId >= 0) {\n      var _app$batcher;\n      (_app$batcher = app.batcher) == null ? void 0 : _app$batcher.insert(_scene_batching_batch_group_js__WEBPACK_IMPORTED_MODULE_9__.BatchGroup.SPRITE, this._batchGroupId, this.entity);\n    }\n  }\n  onDisable() {\n    const app = this.system.app;\n    const scene = app.scene;\n    scene.off('set:layers', this._onLayersChanged, this);\n    if (scene.layers) {\n      scene.layers.off('add', this._onLayerAdded, this);\n      scene.layers.off('remove', this._onLayerRemoved, this);\n    }\n    this.stop();\n    this._hideModel();\n    if (this._batchGroupId >= 0) {\n      var _app$batcher2;\n      (_app$batcher2 = app.batcher) == null ? void 0 : _app$batcher2.remove(_scene_batching_batch_group_js__WEBPACK_IMPORTED_MODULE_9__.BatchGroup.SPRITE, this._batchGroupId, this.entity);\n    }\n  }\n  onDestroy() {\n    this._currentClip = null;\n    if (this._defaultClip) {\n      this._defaultClip._destroy();\n      this._defaultClip = null;\n    }\n    for (const key in this._clips) {\n      this._clips[key]._destroy();\n    }\n    this._clips = null;\n    this._hideModel();\n    this._model = null;\n    if (this._node) {\n      if (this._node.parent) this._node.parent.removeChild(this._node);\n      this._node = null;\n    }\n    if (this._meshInstance) {\n      this._meshInstance.material = null;\n      this._meshInstance.mesh = null;\n      this._meshInstance = null;\n    }\n  }\n  _showModel() {\n    if (this._addedModel) return;\n    if (!this._meshInstance) return;\n    const meshInstances = [this._meshInstance];\n    for (let i = 0, len = this._layers.length; i < len; i++) {\n      const layer = this.system.app.scene.layers.getLayerById(this._layers[i]);\n      if (layer) {\n        layer.addMeshInstances(meshInstances);\n      }\n    }\n    this._addedModel = true;\n  }\n  _hideModel() {\n    if (!this._addedModel || !this._meshInstance) return;\n    const meshInstances = [this._meshInstance];\n    for (let i = 0, len = this._layers.length; i < len; i++) {\n      const layer = this.system.app.scene.layers.getLayerById(this._layers[i]);\n      if (layer) {\n        layer.removeMeshInstances(meshInstances);\n      }\n    }\n    this._addedModel = false;\n  }\n  _showFrame(frame) {\n    if (!this.sprite) return;\n    const mesh = this.sprite.meshes[frame];\n    if (!mesh) {\n      if (this._meshInstance) {\n        this._meshInstance.mesh = null;\n        this._meshInstance.visible = false;\n      }\n      return;\n    }\n    let material;\n    if (this.sprite.renderMode === _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.SPRITE_RENDERMODE_SLICED) {\n      material = this.system.default9SlicedMaterialSlicedMode;\n    } else if (this.sprite.renderMode === _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.SPRITE_RENDERMODE_TILED) {\n      material = this.system.default9SlicedMaterialTiledMode;\n    } else {\n      material = this.system.defaultMaterial;\n    }\n    if (!this._meshInstance) {\n      this._meshInstance = new _scene_mesh_instance_js__WEBPACK_IMPORTED_MODULE_10__.MeshInstance(mesh, this._material, this._node);\n      this._meshInstance.castShadow = false;\n      this._meshInstance.receiveShadow = false;\n      this._meshInstance.drawOrder = this._drawOrder;\n      this._model.meshInstances.push(this._meshInstance);\n      this._colorUniform[0] = this._color.r;\n      this._colorUniform[1] = this._color.g;\n      this._colorUniform[2] = this._color.b;\n      this._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);\n      this._meshInstance.setParameter(PARAM_OPACITY, this._color.a);\n      if (this.enabled && this.entity.enabled) {\n        this._showModel();\n      }\n    }\n    if (this._meshInstance.material !== material) {\n      this._meshInstance.material = material;\n    }\n    if (this._meshInstance.mesh !== mesh) {\n      this._meshInstance.mesh = mesh;\n      this._meshInstance.visible = true;\n      this._meshInstance._aabbVer = -1;\n    }\n    if (this.sprite.atlas && this.sprite.atlas.texture) {\n      this._meshInstance.setParameter(PARAM_EMISSIVE_MAP, this.sprite.atlas.texture);\n      this._meshInstance.setParameter(PARAM_OPACITY_MAP, this.sprite.atlas.texture);\n    } else {\n      this._meshInstance.deleteParameter(PARAM_EMISSIVE_MAP);\n      this._meshInstance.deleteParameter(PARAM_OPACITY_MAP);\n    }\n    if (this.sprite.atlas && (this.sprite.renderMode === _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.SPRITE_RENDERMODE_TILED)) {\n      this._meshInstance._updateAabbFunc = this._updateAabbFunc;\n      const frameData = this.sprite.atlas.frames[this.sprite.frameKeys[frame]];\n      if (frameData) {\n        const borderWidthScale = 2 / frameData.rect.z;\n        const borderHeightScale = 2 / frameData.rect.w;\n        this._innerOffset.set(frameData.border.x * borderWidthScale, frameData.border.y * borderHeightScale, frameData.border.z * borderWidthScale, frameData.border.w * borderHeightScale);\n        const tex = this.sprite.atlas.texture;\n        this._atlasRect.set(frameData.rect.x / tex.width, frameData.rect.y / tex.height, frameData.rect.z / tex.width, frameData.rect.w / tex.height);\n      } else {\n        this._innerOffset.set(0, 0, 0, 0);\n      }\n      this._innerOffsetUniform[0] = this._innerOffset.x;\n      this._innerOffsetUniform[1] = this._innerOffset.y;\n      this._innerOffsetUniform[2] = this._innerOffset.z;\n      this._innerOffsetUniform[3] = this._innerOffset.w;\n      this._meshInstance.setParameter(PARAM_INNER_OFFSET, this._innerOffsetUniform);\n      this._atlasRectUniform[0] = this._atlasRect.x;\n      this._atlasRectUniform[1] = this._atlasRect.y;\n      this._atlasRectUniform[2] = this._atlasRect.z;\n      this._atlasRectUniform[3] = this._atlasRect.w;\n      this._meshInstance.setParameter(PARAM_ATLAS_RECT, this._atlasRectUniform);\n    } else {\n      this._meshInstance._updateAabbFunc = null;\n    }\n    this._updateTransform();\n  }\n  _updateTransform() {\n    let scaleX = this.flipX ? -1 : 1;\n    let scaleY = this.flipY ? -1 : 1;\n    let posX = 0;\n    let posY = 0;\n    if (this.sprite && (this.sprite.renderMode === _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.SPRITE_RENDERMODE_TILED)) {\n      let w = 1;\n      let h = 1;\n      if (this.sprite.atlas) {\n        const frameData = this.sprite.atlas.frames[this.sprite.frameKeys[this.frame]];\n        if (frameData) {\n          w = frameData.rect.z;\n          h = frameData.rect.w;\n          posX = (0.5 - frameData.pivot.x) * this._width;\n          posY = (0.5 - frameData.pivot.y) * this._height;\n        }\n      }\n      const scaleMulX = w / this.sprite.pixelsPerUnit;\n      const scaleMulY = h / this.sprite.pixelsPerUnit;\n      this._outerScale.set(Math.max(this._width, this._innerOffset.x * scaleMulX), Math.max(this._height, this._innerOffset.y * scaleMulY));\n      scaleX *= scaleMulX;\n      scaleY *= scaleMulY;\n      this._outerScale.x /= scaleMulX;\n      this._outerScale.y /= scaleMulY;\n      scaleX *= _core_math_math_js__WEBPACK_IMPORTED_MODULE_11__.math.clamp(this._width / (this._innerOffset.x * scaleMulX), 0.0001, 1);\n      scaleY *= _core_math_math_js__WEBPACK_IMPORTED_MODULE_11__.math.clamp(this._height / (this._innerOffset.y * scaleMulY), 0.0001, 1);\n      if (this._meshInstance) {\n        this._outerScaleUniform[0] = this._outerScale.x;\n        this._outerScaleUniform[1] = this._outerScale.y;\n        this._meshInstance.setParameter(PARAM_OUTER_SCALE, this._outerScaleUniform);\n      }\n    }\n    this._node.setLocalScale(scaleX, scaleY, 1);\n    this._node.setLocalPosition(posX, posY, 0);\n  }\n  _updateAabb(aabb) {\n    aabb.center.set(0, 0, 0);\n    aabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);\n    aabb.setFromTransformedAabb(aabb, this._node.getWorldTransform());\n    return aabb;\n  }\n  _tryAutoPlay() {\n    if (!this._autoPlayClip) return;\n    if (this.type !== _constants_js__WEBPACK_IMPORTED_MODULE_1__.SPRITETYPE_ANIMATED) return;\n    const clip = this._clips[this._autoPlayClip];\n    if (clip && !clip.isPlaying && (!this._currentClip || !this._currentClip.isPlaying)) {\n      if (this.enabled && this.entity.enabled) {\n        this.play(clip.name);\n      }\n    }\n  }\n  _onLayersChanged(oldComp, newComp) {\n    oldComp.off('add', this.onLayerAdded, this);\n    oldComp.off('remove', this.onLayerRemoved, this);\n    newComp.on('add', this.onLayerAdded, this);\n    newComp.on('remove', this.onLayerRemoved, this);\n    if (this.enabled && this.entity.enabled) {\n      this._showModel();\n    }\n  }\n  _onLayerAdded(layer) {\n    const index = this.layers.indexOf(layer.id);\n    if (index < 0) return;\n    if (this._addedModel && this.enabled && this.entity.enabled && this._meshInstance) {\n      layer.addMeshInstances([this._meshInstance]);\n    }\n  }\n  _onLayerRemoved(layer) {\n    if (!this._meshInstance) return;\n    const index = this.layers.indexOf(layer.id);\n    if (index < 0) return;\n    layer.removeMeshInstances([this._meshInstance]);\n  }\n  removeModelFromLayers() {\n    for (let i = 0; i < this.layers.length; i++) {\n      const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n      if (!layer) continue;\n      layer.removeMeshInstances([this._meshInstance]);\n    }\n  }\n  addClip(data) {\n    const clip = new _sprite_animation_clip_js__WEBPACK_IMPORTED_MODULE_8__.SpriteAnimationClip(this, {\n      name: data.name,\n      fps: data.fps,\n      loop: data.loop,\n      spriteAsset: data.spriteAsset\n    });\n    this._clips[data.name] = clip;\n    if (clip.name && clip.name === this._autoPlayClip) this._tryAutoPlay();\n    return clip;\n  }\n  removeClip(name) {\n    delete this._clips[name];\n  }\n  clip(name) {\n    return this._clips[name];\n  }\n  play(name) {\n    const clip = this._clips[name];\n    const current = this._currentClip;\n    if (current && current !== clip) {\n      current._playing = false;\n    }\n    this._currentClip = clip;\n    if (this._currentClip) {\n      this._currentClip = clip;\n      this._currentClip.play();\n    }\n    return clip;\n  }\n  pause() {\n    if (this._currentClip === this._defaultClip) return;\n    if (this._currentClip.isPlaying) {\n      this._currentClip.pause();\n    }\n  }\n  resume() {\n    if (this._currentClip === this._defaultClip) return;\n    if (this._currentClip.isPaused) {\n      this._currentClip.resume();\n    }\n  }\n  stop() {\n    if (this._currentClip === this._defaultClip) return;\n    this._currentClip.stop();\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sprite/component.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sprite/constants.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sprite/constants.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SPRITETYPE_ANIMATED\": () => (/* binding */ SPRITETYPE_ANIMATED),\n/* harmony export */   \"SPRITETYPE_SIMPLE\": () => (/* binding */ SPRITETYPE_SIMPLE)\n/* harmony export */ });\nconst SPRITETYPE_SIMPLE = 'simple';\nconst SPRITETYPE_ANIMATED = 'animated';\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sprite/constants.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sprite/data.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sprite/data.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SpriteComponentData\": () => (/* binding */ SpriteComponentData)\n/* harmony export */ });\nclass SpriteComponentData {\n  constructor() {\n    this.enabled = true;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sprite/data.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sprite/sprite-animation-clip.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sprite/sprite-animation-clip.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SpriteAnimationClip\": () => (/* binding */ SpriteAnimationClip)\n/* harmony export */ });\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _asset_asset_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../asset/asset.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset.js\");\n/* harmony import */ var _scene_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../scene/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n\n\n\n\n\nclass SpriteAnimationClip extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor(component, data) {\n    super();\n    this._component = component;\n    this._frame = 0;\n    this._sprite = null;\n    this._spriteAsset = null;\n    this.spriteAsset = data.spriteAsset;\n    this.name = data.name;\n    this.fps = data.fps || 0;\n    this.loop = data.loop || false;\n    this._playing = false;\n    this._paused = false;\n    this._time = 0;\n  }\n  get duration() {\n    if (this._sprite) {\n      const fps = this.fps || Number.MIN_VALUE;\n      return this._sprite.frameKeys.length / Math.abs(fps);\n    }\n    return 0;\n  }\n  set frame(value) {\n    this._setFrame(value);\n    const fps = this.fps || Number.MIN_VALUE;\n    this._setTime(this._frame / fps);\n  }\n  get frame() {\n    return this._frame;\n  }\n  get isPaused() {\n    return this._paused;\n  }\n  get isPlaying() {\n    return this._playing;\n  }\n  set sprite(value) {\n    if (this._sprite) {\n      this._sprite.off('set:meshes', this._onSpriteMeshesChange, this);\n      this._sprite.off('set:pixelsPerUnit', this._onSpritePpuChanged, this);\n      this._sprite.off('set:atlas', this._onSpriteMeshesChange, this);\n      if (this._sprite.atlas) {\n        this._sprite.atlas.off('set:texture', this._onSpriteMeshesChange, this);\n      }\n    }\n    this._sprite = value;\n    if (this._sprite) {\n      this._sprite.on('set:meshes', this._onSpriteMeshesChange, this);\n      this._sprite.on('set:pixelsPerUnit', this._onSpritePpuChanged, this);\n      this._sprite.on('set:atlas', this._onSpriteMeshesChange, this);\n      if (this._sprite.atlas) {\n        this._sprite.atlas.on('set:texture', this._onSpriteMeshesChange, this);\n      }\n    }\n    if (this._component.currentClip === this) {\n      let mi;\n      if (!value || !value.atlas) {\n        mi = this._component._meshInstance;\n        if (mi) {\n          mi.deleteParameter('texture_emissiveMap');\n          mi.deleteParameter('texture_opacityMap');\n        }\n        this._component._hideModel();\n      } else {\n        if (value.atlas.texture) {\n          mi = this._component._meshInstance;\n          if (mi) {\n            mi.setParameter('texture_emissiveMap', value.atlas.texture);\n            mi.setParameter('texture_opacityMap', value.atlas.texture);\n          }\n          if (this._component.enabled && this._component.entity.enabled) {\n            this._component._showModel();\n          }\n        }\n        if (this.time && this.fps) {\n          this.time = this.time;\n        } else {\n          this.frame = this.frame;\n        }\n      }\n    }\n  }\n  get sprite() {\n    return this._sprite;\n  }\n  set spriteAsset(value) {\n    const assets = this._component.system.app.assets;\n    let id = value;\n    if (value instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_1__.Asset) {\n      id = value.id;\n    }\n    if (this._spriteAsset !== id) {\n      if (this._spriteAsset) {\n        const prev = assets.get(this._spriteAsset);\n        if (prev) {\n          this._unbindSpriteAsset(prev);\n        }\n      }\n      this._spriteAsset = id;\n      if (this._spriteAsset) {\n        const asset = assets.get(this._spriteAsset);\n        if (!asset) {\n          this.sprite = null;\n          assets.on('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);\n        } else {\n          this._bindSpriteAsset(asset);\n        }\n      } else {\n        this.sprite = null;\n      }\n    }\n  }\n  get spriteAsset() {\n    return this._spriteAsset;\n  }\n  set time(value) {\n    this._setTime(value);\n    if (this._sprite) {\n      this.frame = Math.min(this._sprite.frameKeys.length - 1, Math.floor(this._time * Math.abs(this.fps)));\n    } else {\n      this.frame = 0;\n    }\n  }\n  get time() {\n    return this._time;\n  }\n  _onSpriteAssetAdded(asset) {\n    this._component.system.app.assets.off('add:' + asset.id, this._onSpriteAssetAdded, this);\n    if (this._spriteAsset === asset.id) {\n      this._bindSpriteAsset(asset);\n    }\n  }\n  _bindSpriteAsset(asset) {\n    asset.on('load', this._onSpriteAssetLoad, this);\n    asset.on('remove', this._onSpriteAssetRemove, this);\n    if (asset.resource) {\n      this._onSpriteAssetLoad(asset);\n    } else {\n      this._component.system.app.assets.load(asset);\n    }\n  }\n  _unbindSpriteAsset(asset) {\n    asset.off('load', this._onSpriteAssetLoad, this);\n    asset.off('remove', this._onSpriteAssetRemove, this);\n    if (asset.resource && asset.resource.atlas) {\n      this._component.system.app.assets.off('load:' + asset.data.textureAtlasAsset, this._onTextureAtlasLoad, this);\n    }\n  }\n  _onSpriteAssetLoad(asset) {\n    if (!asset.resource) {\n      this.sprite = null;\n    } else {\n      if (!asset.resource.atlas) {\n        const atlasAssetId = asset.data.textureAtlasAsset;\n        const assets = this._component.system.app.assets;\n        assets.off('load:' + atlasAssetId, this._onTextureAtlasLoad, this);\n        assets.once('load:' + atlasAssetId, this._onTextureAtlasLoad, this);\n      } else {\n        this.sprite = asset.resource;\n      }\n    }\n  }\n  _onTextureAtlasLoad(atlasAsset) {\n    const spriteAsset = this._spriteAsset;\n    if (spriteAsset instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_1__.Asset) {\n      this._onSpriteAssetLoad(spriteAsset);\n    } else {\n      this._onSpriteAssetLoad(this._component.system.app.assets.get(spriteAsset));\n    }\n  }\n  _onSpriteAssetRemove(asset) {\n    this.sprite = null;\n  }\n  _onSpriteMeshesChange() {\n    if (this._component.currentClip === this) {\n      this._component._showFrame(this.frame);\n    }\n  }\n  _onSpritePpuChanged() {\n    if (this._component.currentClip === this) {\n      if (this.sprite.renderMode !== _scene_constants_js__WEBPACK_IMPORTED_MODULE_2__.SPRITE_RENDERMODE_SIMPLE) {\n        this._component._showFrame(this.frame);\n      }\n    }\n  }\n  _update(dt) {\n    if (this.fps === 0) return;\n    if (!this._playing || this._paused || !this._sprite) return;\n    const dir = this.fps < 0 ? -1 : 1;\n    const time = this._time + dt * this._component.speed * dir;\n    const duration = this.duration;\n    const end = time > duration || time < 0;\n    this._setTime(time);\n    let frame = this.frame;\n    if (this._sprite) {\n      frame = Math.floor(this._sprite.frameKeys.length * this._time / duration);\n    } else {\n      frame = 0;\n    }\n    if (frame !== this._frame) {\n      this._setFrame(frame);\n    }\n    if (end) {\n      if (this.loop) {\n        this.fire('loop');\n        this._component.fire('loop', this);\n      } else {\n        this._playing = false;\n        this._paused = false;\n        this.fire('end');\n        this._component.fire('end', this);\n      }\n    }\n  }\n  _setTime(value) {\n    this._time = value;\n    const duration = this.duration;\n    if (this._time < 0) {\n      if (this.loop) {\n        this._time = this._time % duration + duration;\n      } else {\n        this._time = 0;\n      }\n    } else if (this._time > duration) {\n      if (this.loop) {\n        this._time %= duration;\n      } else {\n        this._time = duration;\n      }\n    }\n  }\n  _setFrame(value) {\n    if (this._sprite) {\n      this._frame = _core_math_math_js__WEBPACK_IMPORTED_MODULE_3__.math.clamp(value, 0, this._sprite.frameKeys.length - 1);\n    } else {\n      this._frame = value;\n    }\n    if (this._component.currentClip === this) {\n      this._component._showFrame(this._frame);\n    }\n  }\n  _destroy() {\n    if (this._sprite) {\n      this.sprite = null;\n    }\n    if (this._spriteAsset) {\n      this.spriteAsset = null;\n    }\n  }\n  play() {\n    if (this._playing) return;\n    this._playing = true;\n    this._paused = false;\n    this.frame = 0;\n    this.fire('play');\n    this._component.fire('play', this);\n  }\n  pause() {\n    if (!this._playing || this._paused) return;\n    this._paused = true;\n    this.fire('pause');\n    this._component.fire('pause', this);\n  }\n  resume() {\n    if (!this._paused) return;\n    this._paused = false;\n    this.fire('resume');\n    this._component.fire('resume', this);\n  }\n  stop() {\n    if (!this._playing) return;\n    this._playing = false;\n    this._paused = false;\n    this._time = 0;\n    this.frame = 0;\n    this.fire('stop');\n    this._component.fire('stop', this);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sprite/sprite-animation-clip.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sprite/system.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sprite/system.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SpriteComponentSystem\": () => (/* binding */ SpriteComponentSystem)\n/* harmony export */ });\n/* harmony import */ var _core_math_color_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../core/math/color.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../platform/graphics/texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js\");\n/* harmony import */ var _scene_constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../scene/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _scene_materials_standard_material_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../scene/materials/standard-material.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/system.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sprite/component.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sprite/data.js\");\n\n\n\n\n\n\n\n\n\n\nconst _schema = ['enabled'];\nclass SpriteComponentSystem extends _system_js__WEBPACK_IMPORTED_MODULE_0__.ComponentSystem {\n  constructor(app) {\n    super(app);\n    this.id = 'sprite';\n    this.ComponentType = _component_js__WEBPACK_IMPORTED_MODULE_1__.SpriteComponent;\n    this.DataType = _data_js__WEBPACK_IMPORTED_MODULE_2__.SpriteComponentData;\n    this.schema = _schema;\n    this._defaultTexture = null;\n    this._defaultMaterial = null;\n    this._default9SlicedMaterialSlicedMode = null;\n    this._default9SlicedMaterialTiledMode = null;\n    this.app.systems.on('update', this.onUpdate, this);\n    this.on('beforeremove', this.onBeforeRemove, this);\n  }\n  set defaultMaterial(material) {\n    this._defaultMaterial = material;\n  }\n  get defaultMaterial() {\n    if (!this._defaultMaterial) {\n      const texture = new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_3__.Texture(this.app.graphicsDevice, {\n        width: 1,\n        height: 1,\n        format: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_4__.PIXELFORMAT_RGBA8,\n        name: 'sprite'\n      });\n      const pixels = new Uint8Array(texture.lock());\n      pixels[0] = pixels[1] = pixels[2] = pixels[3] = 255;\n      texture.unlock();\n      const material = new _scene_materials_standard_material_js__WEBPACK_IMPORTED_MODULE_5__.StandardMaterial();\n      material.diffuse.set(0, 0, 0);\n      material.emissive.set(0.5, 0.5, 0.5);\n      material.emissiveMap = texture;\n      material.emissiveTint = true;\n      material.opacityMap = texture;\n      material.opacityMapChannel = 'a';\n      material.opacityTint = true;\n      material.opacity = 0;\n      material.useLighting = false;\n      material.useGammaTonemap = false;\n      material.useFog = false;\n      material.useSkybox = false;\n      material.blendType = _scene_constants_js__WEBPACK_IMPORTED_MODULE_6__.BLEND_PREMULTIPLIED;\n      material.depthWrite = false;\n      material.pixelSnap = false;\n      material.cull = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_4__.CULLFACE_NONE;\n      material.update();\n      this._defaultTexture = texture;\n      this._defaultMaterial = material;\n    }\n    return this._defaultMaterial;\n  }\n  set default9SlicedMaterialSlicedMode(material) {\n    this._default9SlicedMaterialSlicedMode = material;\n  }\n  get default9SlicedMaterialSlicedMode() {\n    if (!this._default9SlicedMaterialSlicedMode) {\n      const material = this.defaultMaterial.clone();\n      material.nineSlicedMode = _scene_constants_js__WEBPACK_IMPORTED_MODULE_6__.SPRITE_RENDERMODE_SLICED;\n      material.update();\n      this._default9SlicedMaterialSlicedMode = material;\n    }\n    return this._default9SlicedMaterialSlicedMode;\n  }\n  set default9SlicedMaterialTiledMode(material) {\n    this._default9SlicedMaterialTiledMode = material;\n  }\n  get default9SlicedMaterialTiledMode() {\n    if (!this._default9SlicedMaterialTiledMode) {\n      const material = this.defaultMaterial.clone();\n      material.nineSlicedMode = _scene_constants_js__WEBPACK_IMPORTED_MODULE_6__.SPRITE_RENDERMODE_TILED;\n      material.update();\n      this._default9SlicedMaterialTiledMode = material;\n    }\n    return this._default9SlicedMaterialTiledMode;\n  }\n  destroy() {\n    super.destroy();\n    this.app.systems.off('update', this.onUpdate, this);\n    if (this._defaultTexture) {\n      this._defaultTexture.destroy();\n      this._defaultTexture = null;\n    }\n  }\n  initializeComponentData(component, data, properties) {\n    if (data.enabled !== undefined) {\n      component.enabled = data.enabled;\n    }\n    component.type = data.type;\n    if (data.layers && Array.isArray(data.layers)) {\n      component.layers = data.layers.slice(0);\n    }\n    if (data.drawOrder !== undefined) {\n      component.drawOrder = data.drawOrder;\n    }\n    if (data.color !== undefined) {\n      if (data.color instanceof _core_math_color_js__WEBPACK_IMPORTED_MODULE_7__.Color) {\n        component.color.set(data.color.r, data.color.g, data.color.b, data.opacity !== undefined ? data.opacity : 1);\n      } else {\n        component.color.set(data.color[0], data.color[1], data.color[2], data.opacity !== undefined ? data.opacity : 1);\n      }\n      component.color = component.color;\n    }\n    if (data.opacity !== undefined) {\n      component.opacity = data.opacity;\n    }\n    if (data.flipX !== undefined) {\n      component.flipX = data.flipX;\n    }\n    if (data.flipY !== undefined) {\n      component.flipY = data.flipY;\n    }\n    if (data.width !== undefined) {\n      component.width = data.width;\n    }\n    if (data.height !== undefined) {\n      component.height = data.height;\n    }\n    if (data.spriteAsset !== undefined) {\n      component.spriteAsset = data.spriteAsset;\n    }\n    if (data.sprite) {\n      component.sprite = data.sprite;\n    }\n    if (data.frame !== undefined) {\n      component.frame = data.frame;\n    }\n    if (data.clips) {\n      for (const name in data.clips) {\n        component.addClip(data.clips[name]);\n      }\n    }\n    if (data.speed !== undefined) {\n      component.speed = data.speed;\n    }\n    if (data.autoPlayClip) {\n      component.autoPlayClip = data.autoPlayClip;\n    }\n    component.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;\n    super.initializeComponentData(component, data, properties);\n  }\n  cloneComponent(entity, clone) {\n    const source = entity.sprite;\n    return this.addComponent(clone, {\n      enabled: source.enabled,\n      type: source.type,\n      spriteAsset: source.spriteAsset,\n      sprite: source.sprite,\n      frame: source.frame,\n      color: source.color.clone(),\n      opacity: source.opacity,\n      flipX: source.flipX,\n      flipY: source.flipY,\n      speed: source.speed,\n      clips: source.clips,\n      autoPlayClip: source.autoPlayClip,\n      batchGroupId: source.batchGroupId,\n      drawOrder: source.drawOrder,\n      layers: source.layers.slice(0)\n    });\n  }\n  onUpdate(dt) {\n    const components = this.store;\n    for (const id in components) {\n      if (components.hasOwnProperty(id)) {\n        const component = components[id];\n        if (component.data.enabled && component.entity.enabled) {\n          const sprite = component.entity.sprite;\n          if (sprite._currentClip) {\n            sprite._currentClip._update(dt);\n          }\n        }\n      }\n    }\n  }\n  onBeforeRemove(entity, component) {\n    component.onDestroy();\n  }\n}\n_component_js__WEBPACK_IMPORTED_MODULE_8__.Component._buildAccessors(_component_js__WEBPACK_IMPORTED_MODULE_1__.SpriteComponent.prototype, _schema);\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/sprite/system.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/system.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/system.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ComponentSystem\": () => (/* binding */ ComponentSystem)\n/* harmony export */ });\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _core_math_color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/math/color.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/math/vec4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec4.js\");\n\n\n\n\n\n\nclass ComponentSystem extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor(app) {\n    super();\n    this.app = app;\n    this.store = {};\n    this.schema = [];\n  }\n  addComponent(entity, data = {}) {\n    const component = new this.ComponentType(this, entity);\n    const componentData = new this.DataType();\n    this.store[entity.getGuid()] = {\n      entity: entity,\n      data: componentData\n    };\n    entity[this.id] = component;\n    entity.c[this.id] = component;\n    this.initializeComponentData(component, data, []);\n    this.fire('add', entity, component);\n    return component;\n  }\n  removeComponent(entity) {\n    const record = this.store[entity.getGuid()];\n    const component = entity.c[this.id];\n    this.fire('beforeremove', entity, component);\n    delete this.store[entity.getGuid()];\n    entity[this.id] = undefined;\n    delete entity.c[this.id];\n    this.fire('remove', entity, record.data);\n  }\n  cloneComponent(entity, clone) {\n    const src = this.store[entity.getGuid()];\n    return this.addComponent(clone, src.data);\n  }\n  initializeComponentData(component, data = {}, properties) {\n    for (let i = 0, len = properties.length; i < len; i++) {\n      const descriptor = properties[i];\n      let name, type;\n      if (typeof descriptor === 'object') {\n        name = descriptor.name;\n        type = descriptor.type;\n      } else {\n        name = descriptor;\n        type = undefined;\n      }\n      let value = data[name];\n      if (value !== undefined) {\n        if (type !== undefined) {\n          value = convertValue(value, type);\n        }\n        component[name] = value;\n      } else {\n        component[name] = component.data[name];\n      }\n    }\n    if (component.enabled && component.entity.enabled) {\n      component.onEnable();\n    }\n  }\n  getPropertiesOfType(type) {\n    const matchingProperties = [];\n    const schema = this.schema || [];\n    schema.forEach(function (descriptor) {\n      if (descriptor && typeof descriptor === 'object' && descriptor.type === type) {\n        matchingProperties.push(descriptor);\n      }\n    });\n    return matchingProperties;\n  }\n  destroy() {\n    this.off();\n  }\n}\nfunction convertValue(value, type) {\n  if (!value) {\n    return value;\n  }\n  switch (type) {\n    case 'rgb':\n      if (value instanceof _core_math_color_js__WEBPACK_IMPORTED_MODULE_1__.Color) {\n        return value.clone();\n      }\n      return new _core_math_color_js__WEBPACK_IMPORTED_MODULE_1__.Color(value[0], value[1], value[2]);\n    case 'rgba':\n      if (value instanceof _core_math_color_js__WEBPACK_IMPORTED_MODULE_1__.Color) {\n        return value.clone();\n      }\n      return new _core_math_color_js__WEBPACK_IMPORTED_MODULE_1__.Color(value[0], value[1], value[2], value[3]);\n    case 'vec2':\n      if (value instanceof _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_2__.Vec2) {\n        return value.clone();\n      }\n      return new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_2__.Vec2(value[0], value[1]);\n    case 'vec3':\n      if (value instanceof _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_3__.Vec3) {\n        return value.clone();\n      }\n      return new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_3__.Vec3(value[0], value[1], value[2]);\n    case 'vec4':\n      if (value instanceof _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_4__.Vec4) {\n        return value.clone();\n      }\n      return new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_4__.Vec4(value[0], value[1], value[2], value[3]);\n    case 'boolean':\n    case 'number':\n    case 'string':\n      return value;\n    case 'entity':\n      return value;\n    default:\n      throw new Error('Could not convert unhandled type: ' + type);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/system.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/zone/component.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/zone/component.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ZoneComponent\": () => (/* binding */ ZoneComponent)\n/* harmony export */ });\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n\n\n\nclass ZoneComponent extends _component_js__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(system, entity) {\n    super(system, entity);\n    this._oldState = true;\n    this._size = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n    this.on('set_enabled', this._onSetEnabled, this);\n  }\n  set size(data) {\n    if (data instanceof _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3) {\n      this._size.copy(data);\n    } else if (data instanceof Array && data.length >= 3) {\n      this.size.set(data[0], data[1], data[2]);\n    }\n  }\n  get size() {\n    return this._size;\n  }\n  onEnable() {\n    this._checkState();\n  }\n  onDisable() {\n    this._checkState();\n  }\n  _onSetEnabled(prop, old, value) {\n    this._checkState();\n  }\n  _checkState() {\n    const state = this.enabled && this.entity.enabled;\n    if (state === this._oldState) return;\n    this._oldState = state;\n    this.fire('enable');\n    this.fire('state', this.enabled);\n  }\n  _onBeforeRemove() {\n    this.fire('remove');\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/zone/component.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/zone/data.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/zone/data.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ZoneComponentData\": () => (/* binding */ ZoneComponentData)\n/* harmony export */ });\nclass ZoneComponentData {\n  constructor() {\n    this.enabled = true;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/zone/data.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/components/zone/system.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/components/zone/system.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ZoneComponentSystem\": () => (/* binding */ ZoneComponentSystem)\n/* harmony export */ });\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../system.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/system.js\");\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/zone/component.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/zone/data.js\");\n\n\n\n\n\n\nconst _schema = ['enabled'];\nclass ZoneComponentSystem extends _system_js__WEBPACK_IMPORTED_MODULE_0__.ComponentSystem {\n  constructor(app) {\n    super(app);\n    this.id = 'zone';\n    this.ComponentType = _component_js__WEBPACK_IMPORTED_MODULE_1__.ZoneComponent;\n    this.DataType = _data_js__WEBPACK_IMPORTED_MODULE_2__.ZoneComponentData;\n    this.schema = _schema;\n    this.on('beforeremove', this._onBeforeRemove, this);\n  }\n  initializeComponentData(component, data, properties) {\n    component.enabled = data.hasOwnProperty('enabled') ? !!data.enabled : true;\n    if (data.size) {\n      if (data.size instanceof _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_3__.Vec3) {\n        component.size.copy(data.size);\n      } else if (data.size instanceof Array && data.size.length >= 3) {\n        component.size.set(data.size[0], data.size[1], data.size[2]);\n      }\n    }\n  }\n  cloneComponent(entity, clone) {\n    const data = {\n      size: entity.zone.size\n    };\n    return this.addComponent(clone, data);\n  }\n  _onBeforeRemove(entity, component) {\n    component._onBeforeRemove();\n  }\n}\n_component_js__WEBPACK_IMPORTED_MODULE_4__.Component._buildAccessors(_component_js__WEBPACK_IMPORTED_MODULE_1__.ZoneComponent.prototype, _schema);\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/components/zone/system.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/constants.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/constants.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FILLMODE_FILL_WINDOW\": () => (/* binding */ FILLMODE_FILL_WINDOW),\n/* harmony export */   \"FILLMODE_KEEP_ASPECT\": () => (/* binding */ FILLMODE_KEEP_ASPECT),\n/* harmony export */   \"FILLMODE_NONE\": () => (/* binding */ FILLMODE_NONE),\n/* harmony export */   \"RESOLUTION_AUTO\": () => (/* binding */ RESOLUTION_AUTO),\n/* harmony export */   \"RESOLUTION_FIXED\": () => (/* binding */ RESOLUTION_FIXED)\n/* harmony export */ });\nconst FILLMODE_NONE = 'NONE';\nconst FILLMODE_FILL_WINDOW = 'FILL_WINDOW';\nconst FILLMODE_KEEP_ASPECT = 'KEEP_ASPECT';\nconst RESOLUTION_AUTO = 'AUTO';\nconst RESOLUTION_FIXED = 'FIXED';\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/constants.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/entity.js":
/*!**************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/entity.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Entity\": () => (/* binding */ Entity)\n/* harmony export */ });\n/* harmony import */ var _core_guid_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/guid.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/guid.js\");\n/* harmony import */ var _scene_graph_node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scene/graph-node.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/graph-node.js\");\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./globals.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/globals.js\");\n\n\n\n\n\nconst _enableList = [];\nclass Entity extends _scene_graph_node_js__WEBPACK_IMPORTED_MODULE_0__.GraphNode {\n  constructor(name, app = (0,_globals_js__WEBPACK_IMPORTED_MODULE_1__.getApplication)()) {\n    super(name);\n    this.anim = void 0;\n    this.animation = void 0;\n    this.audiolistener = void 0;\n    this.button = void 0;\n    this.camera = void 0;\n    this.collision = void 0;\n    this.element = void 0;\n    this.layoutchild = void 0;\n    this.layoutgroup = void 0;\n    this.light = void 0;\n    this.model = void 0;\n    this.particlesystem = void 0;\n    this.render = void 0;\n    this.rigidbody = void 0;\n    this.screen = void 0;\n    this.script = void 0;\n    this.scrollbar = void 0;\n    this.scrollview = void 0;\n    this.sound = void 0;\n    this.sprite = void 0;\n    this.c = {};\n    this._app = void 0;\n    this._destroying = false;\n    this._guid = null;\n    this._template = false;\n    this._app = app;\n  }\n  addComponent(type, data) {\n    const system = this._app.systems[type];\n    if (!system) {\n      return null;\n    }\n    if (this.c[type]) {\n      return null;\n    }\n    return system.addComponent(this, data);\n  }\n  removeComponent(type) {\n    const system = this._app.systems[type];\n    if (!system) {\n      return;\n    }\n    if (!this.c[type]) {\n      return;\n    }\n    system.removeComponent(this);\n  }\n  findComponent(type) {\n    const entity = this.findOne(function (node) {\n      return node.c && node.c[type];\n    });\n    return entity && entity.c[type];\n  }\n  findComponents(type) {\n    const entities = this.find(function (node) {\n      return node.c && node.c[type];\n    });\n    return entities.map(function (entity) {\n      return entity.c[type];\n    });\n  }\n  getGuid() {\n    if (!this._guid) {\n      this.setGuid(_core_guid_js__WEBPACK_IMPORTED_MODULE_2__.guid.create());\n    }\n    return this._guid;\n  }\n  setGuid(guid) {\n    const index = this._app._entityIndex;\n    if (this._guid) {\n      delete index[this._guid];\n    }\n    this._guid = guid;\n    index[this._guid] = this;\n  }\n  _notifyHierarchyStateChanged(node, enabled) {\n    let enableFirst = false;\n    if (node === this && _enableList.length === 0) enableFirst = true;\n    node._beingEnabled = true;\n    node._onHierarchyStateChanged(enabled);\n    if (node._onHierarchyStatePostChanged) _enableList.push(node);\n    const c = node._children;\n    for (let i = 0, len = c.length; i < len; i++) {\n      if (c[i]._enabled) this._notifyHierarchyStateChanged(c[i], enabled);\n    }\n    node._beingEnabled = false;\n    if (enableFirst) {\n      for (let i = 0; i < _enableList.length; i++) {\n        _enableList[i]._onHierarchyStatePostChanged();\n      }\n      _enableList.length = 0;\n    }\n  }\n  _onHierarchyStateChanged(enabled) {\n    super._onHierarchyStateChanged(enabled);\n    const components = this.c;\n    for (const type in components) {\n      if (components.hasOwnProperty(type)) {\n        const component = components[type];\n        if (component.enabled) {\n          if (enabled) {\n            component.onEnable();\n          } else {\n            component.onDisable();\n          }\n        }\n      }\n    }\n  }\n  _onHierarchyStatePostChanged() {\n    const components = this.c;\n    for (const type in components) {\n      if (components.hasOwnProperty(type)) components[type].onPostStateChange();\n    }\n  }\n  findByGuid(guid) {\n    if (this._guid === guid) return this;\n    const e = this._app._entityIndex[guid];\n    if (e && (e === this || e.isDescendantOf(this))) {\n      return e;\n    }\n    return null;\n  }\n  destroy() {\n    this._destroying = true;\n    for (const name in this.c) {\n      this.c[name].enabled = false;\n    }\n    for (const name in this.c) {\n      this.c[name].system.removeComponent(this);\n    }\n    if (this._parent) this._parent.removeChild(this);\n    const children = this._children;\n    while (children.length) {\n      const child = children.pop();\n      child._parent = null;\n      if (child instanceof Entity) {\n        child.destroy();\n      }\n    }\n    this.fire('destroy', this);\n    this.off();\n    if (this._guid) {\n      delete this._app._entityIndex[this._guid];\n    }\n    this._destroying = false;\n  }\n  clone() {\n    const duplicatedIdsMap = {};\n    const clone = this._cloneRecursively(duplicatedIdsMap);\n    duplicatedIdsMap[this.getGuid()] = clone;\n    resolveDuplicatedEntityReferenceProperties(this, this, clone, duplicatedIdsMap);\n    return clone;\n  }\n  _cloneRecursively(duplicatedIdsMap) {\n    const clone = new this.constructor(undefined, this._app);\n    super._cloneInternal(clone);\n    for (const type in this.c) {\n      const component = this.c[type];\n      component.system.cloneComponent(this, clone);\n    }\n    for (let i = 0; i < this._children.length; i++) {\n      const oldChild = this._children[i];\n      if (oldChild instanceof Entity) {\n        const newChild = oldChild._cloneRecursively(duplicatedIdsMap);\n        clone.addChild(newChild);\n        duplicatedIdsMap[oldChild.getGuid()] = newChild;\n      }\n    }\n    return clone;\n  }\n}\nfunction resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, oldEntity, newEntity, duplicatedIdsMap) {\n  if (oldEntity instanceof Entity) {\n    const components = oldEntity.c;\n    for (const componentName in components) {\n      const component = components[componentName];\n      const entityProperties = component.system.getPropertiesOfType('entity');\n      for (let i = 0, len = entityProperties.length; i < len; i++) {\n        const propertyDescriptor = entityProperties[i];\n        const propertyName = propertyDescriptor.name;\n        const oldEntityReferenceId = component[propertyName];\n        const entityIsWithinOldSubtree = !!oldSubtreeRoot.findByGuid(oldEntityReferenceId);\n        if (entityIsWithinOldSubtree) {\n          const newEntityReferenceId = duplicatedIdsMap[oldEntityReferenceId].getGuid();\n          if (newEntityReferenceId) {\n            newEntity.c[componentName][propertyName] = newEntityReferenceId;\n          }\n        }\n      }\n    }\n    if (components.script && !newEntity._app.useLegacyScriptAttributeCloning) {\n      newEntity.script.resolveDuplicatedEntityReferenceProperties(components.script, duplicatedIdsMap);\n    }\n    if (components.render) {\n      newEntity.render.resolveDuplicatedEntityReferenceProperties(components.render, duplicatedIdsMap);\n    }\n    if (components.anim) {\n      newEntity.anim.resolveDuplicatedEntityReferenceProperties(components.anim, duplicatedIdsMap);\n    }\n    const _old = oldEntity.children.filter(function (e) {\n      return e instanceof Entity;\n    });\n    const _new = newEntity.children.filter(function (e) {\n      return e instanceof Entity;\n    });\n    for (let i = 0, len = _old.length; i < len; i++) {\n      resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, _old[i], _new[i], duplicatedIdsMap);\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/entity.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/font/constants.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/font/constants.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FONT_BITMAP\": () => (/* binding */ FONT_BITMAP),\n/* harmony export */   \"FONT_MSDF\": () => (/* binding */ FONT_MSDF)\n/* harmony export */ });\nconst FONT_MSDF = 'msdf';\nconst FONT_BITMAP = 'bitmap';\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/font/constants.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/font/font.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/font/font.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Font\": () => (/* binding */ Font)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/font/constants.js\");\n\n\nclass Font {\n  constructor(textures, data) {\n    this.type = data ? data.type || _constants_js__WEBPACK_IMPORTED_MODULE_0__.FONT_MSDF : _constants_js__WEBPACK_IMPORTED_MODULE_0__.FONT_MSDF;\n    this.em = 1;\n    this.textures = textures;\n    this.intensity = 0.0;\n    this._data = null;\n    this.data = data;\n  }\n  set data(value) {\n    this._data = value;\n    if (!value) return;\n    if (this._data.intensity !== undefined) {\n      this.intensity = this._data.intensity;\n    }\n    if (!this._data.info) this._data.info = {};\n    if (!this._data.version || this._data.version < 2) {\n      this._data.info.maps = [{\n        width: this._data.info.width,\n        height: this._data.info.height\n      }];\n      if (this._data.chars) {\n        for (const key in this._data.chars) {\n          this._data.chars[key].map = 0;\n        }\n      }\n    }\n  }\n  get data() {\n    return this._data;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/font/font.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/globals.js":
/*!***************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/globals.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getApplication\": () => (/* binding */ getApplication),\n/* harmony export */   \"setApplication\": () => (/* binding */ setApplication)\n/* harmony export */ });\n/* harmony import */ var _platform_graphics_graphics_device_access_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/graphics/graphics-device-access.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/graphics-device-access.js\");\n\n\nlet currentApplication;\nfunction getApplication() {\n  return currentApplication;\n}\nfunction setApplication(app) {\n  currentApplication = app;\n  _platform_graphics_graphics_device_access_js__WEBPACK_IMPORTED_MODULE_0__.GraphicsDeviceAccess.set(app == null ? void 0 : app.graphicsDevice);\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/globals.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/anim-clip.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/anim-clip.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimClipHandler\": () => (/* binding */ AnimClipHandler)\n/* harmony export */ });\n/* harmony import */ var _platform_net_http_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/net/http.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/net/http.js\");\n/* harmony import */ var _anim_evaluator_anim_curve_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../anim/evaluator/anim-curve.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-curve.js\");\n/* harmony import */ var _anim_evaluator_anim_data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../anim/evaluator/anim-data.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-data.js\");\n/* harmony import */ var _anim_evaluator_anim_track_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../anim/evaluator/anim-track.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-track.js\");\n\n\n\n\n\nclass AnimClipHandler {\n  constructor(app) {\n    this.handlerType = \"animclip\";\n    this.maxRetries = 0;\n  }\n  load(url, callback) {\n    if (typeof url === 'string') {\n      url = {\n        load: url,\n        original: url\n      };\n    }\n    const options = {\n      retry: this.maxRetries > 0,\n      maxRetries: this.maxRetries\n    };\n    if (url.load.startsWith('blob:')) {\n      options.responseType = _platform_net_http_js__WEBPACK_IMPORTED_MODULE_0__.Http.ResponseType.JSON;\n    }\n    _platform_net_http_js__WEBPACK_IMPORTED_MODULE_0__.http.get(url.load, options, function (err, response) {\n      if (err) {\n        callback(`Error loading animation clip resource: ${url.original} [${err}]`);\n      } else {\n        callback(null, response);\n      }\n    });\n  }\n  open(url, data) {\n    const name = data.name;\n    const duration = data.duration;\n    const inputs = data.inputs.map(function (input) {\n      return new _anim_evaluator_anim_data_js__WEBPACK_IMPORTED_MODULE_1__.AnimData(1, input);\n    });\n    const outputs = data.outputs.map(function (output) {\n      return new _anim_evaluator_anim_data_js__WEBPACK_IMPORTED_MODULE_1__.AnimData(output.components, output.data);\n    });\n    const curves = data.curves.map(function (curve) {\n      return new _anim_evaluator_anim_curve_js__WEBPACK_IMPORTED_MODULE_2__.AnimCurve([curve.path], curve.inputIndex, curve.outputIndex, curve.interpolation);\n    });\n    return new _anim_evaluator_anim_track_js__WEBPACK_IMPORTED_MODULE_3__.AnimTrack(name, duration, inputs, outputs, curves);\n  }\n  patch(asset, assets) {}\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/anim-clip.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/anim-state-graph.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/anim-state-graph.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimStateGraphHandler\": () => (/* binding */ AnimStateGraphHandler)\n/* harmony export */ });\n/* harmony import */ var _platform_net_http_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/net/http.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/net/http.js\");\n/* harmony import */ var _anim_state_graph_anim_state_graph_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../anim/state-graph/anim-state-graph.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/state-graph/anim-state-graph.js\");\n\n\n\nclass AnimStateGraphHandler {\n  constructor(app) {\n    this.handlerType = \"animstategraph\";\n    this.maxRetries = 0;\n  }\n  load(url, callback) {\n    if (typeof url === 'string') {\n      url = {\n        load: url,\n        original: url\n      };\n    }\n    const options = {\n      retry: this.maxRetries > 0,\n      maxRetries: this.maxRetries\n    };\n    if (url.load.startsWith('blob:')) {\n      options.responseType = _platform_net_http_js__WEBPACK_IMPORTED_MODULE_0__.Http.ResponseType.JSON;\n    }\n    _platform_net_http_js__WEBPACK_IMPORTED_MODULE_0__.http.get(url.load, options, function (err, response) {\n      if (err) {\n        callback(`Error loading animation state graph resource: ${url.original} [${err}]`);\n      } else {\n        callback(null, response);\n      }\n    });\n  }\n  open(url, data) {\n    return new _anim_state_graph_anim_state_graph_js__WEBPACK_IMPORTED_MODULE_1__.AnimStateGraph(data);\n  }\n  patch(asset, assets) {}\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/anim-state-graph.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/animation.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/animation.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimationHandler\": () => (/* binding */ AnimationHandler)\n/* harmony export */ });\n/* harmony import */ var _core_path_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/path.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/path.js\");\n/* harmony import */ var _core_math_quat_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/math/quat.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/quat.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _platform_net_http_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../platform/net/http.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/net/http.js\");\n/* harmony import */ var _scene_animation_animation_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../scene/animation/animation.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/animation/animation.js\");\n/* harmony import */ var _anim_evaluator_anim_events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../anim/evaluator/anim-events.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-events.js\");\n/* harmony import */ var _parsers_glb_parser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parsers/glb-parser.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/glb-parser.js\");\n\n\n\n\n\n\n\n\nclass AnimationHandler {\n  constructor(app) {\n    this.handlerType = \"animation\";\n    this.maxRetries = 0;\n  }\n  load(url, callback) {\n    if (typeof url === 'string') {\n      url = {\n        load: url,\n        original: url\n      };\n    }\n    const options = {\n      retry: this.maxRetries > 0,\n      maxRetries: this.maxRetries\n    };\n    if (url.load.startsWith('blob:') || url.load.startsWith('data:')) {\n      if (_core_path_js__WEBPACK_IMPORTED_MODULE_0__.path.getExtension(url.original).toLowerCase() === '.glb') {\n        options.responseType = _platform_net_http_js__WEBPACK_IMPORTED_MODULE_1__.Http.ResponseType.ARRAY_BUFFER;\n      } else {\n        options.responseType = _platform_net_http_js__WEBPACK_IMPORTED_MODULE_1__.Http.ResponseType.JSON;\n      }\n    }\n    _platform_net_http_js__WEBPACK_IMPORTED_MODULE_1__.http.get(url.load, options, function (err, response) {\n      if (err) {\n        callback(`Error loading animation resource: ${url.original} [${err}]`);\n      } else {\n        callback(null, response);\n      }\n    });\n  }\n  open(url, data, asset) {\n    if (_core_path_js__WEBPACK_IMPORTED_MODULE_0__.path.getExtension(url).toLowerCase() === '.glb') {\n      const glbResources = _parsers_glb_parser_js__WEBPACK_IMPORTED_MODULE_2__.GlbParser.parse('filename.glb', data, null);\n      if (glbResources) {\n        var _asset$data;\n        const animations = glbResources.animations;\n        if (asset != null && (_asset$data = asset.data) != null && _asset$data.events) {\n          for (let i = 0; i < animations.length; i++) {\n            animations[i].events = new _anim_evaluator_anim_events_js__WEBPACK_IMPORTED_MODULE_3__.AnimEvents(Object.values(asset.data.events));\n          }\n        }\n        glbResources.destroy();\n        return animations;\n      }\n      return null;\n    }\n    return this['_parseAnimationV' + data.animation.version](data);\n  }\n  patch(asset, assets) {}\n  _parseAnimationV3(data) {\n    const animData = data.animation;\n    const anim = new _scene_animation_animation_js__WEBPACK_IMPORTED_MODULE_4__.Animation();\n    anim.name = animData.name;\n    anim.duration = animData.duration;\n    for (let i = 0; i < animData.nodes.length; i++) {\n      const node = new _scene_animation_animation_js__WEBPACK_IMPORTED_MODULE_4__.Node();\n      const n = animData.nodes[i];\n      node._name = n.name;\n      for (let j = 0; j < n.keys.length; j++) {\n        const k = n.keys[j];\n        const t = k.time;\n        const p = k.pos;\n        const r = k.rot;\n        const s = k.scale;\n        const pos = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3(p[0], p[1], p[2]);\n        const rot = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_6__.Quat().setFromEulerAngles(r[0], r[1], r[2]);\n        const scl = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3(s[0], s[1], s[2]);\n        const key = new _scene_animation_animation_js__WEBPACK_IMPORTED_MODULE_4__.Key(t, pos, rot, scl);\n        node._keys.push(key);\n      }\n      anim.addNode(node);\n    }\n    return anim;\n  }\n  _parseAnimationV4(data) {\n    const animData = data.animation;\n    const anim = new _scene_animation_animation_js__WEBPACK_IMPORTED_MODULE_4__.Animation();\n    anim.name = animData.name;\n    anim.duration = animData.duration;\n    for (let i = 0; i < animData.nodes.length; i++) {\n      const node = new _scene_animation_animation_js__WEBPACK_IMPORTED_MODULE_4__.Node();\n      const n = animData.nodes[i];\n      node._name = n.name;\n      const defPos = n.defaults.p;\n      const defRot = n.defaults.r;\n      const defScl = n.defaults.s;\n      for (let j = 0; j < n.keys.length; j++) {\n        const k = n.keys[j];\n        const t = k.t;\n        const p = defPos ? defPos : k.p;\n        const r = defRot ? defRot : k.r;\n        const s = defScl ? defScl : k.s;\n        const pos = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3(p[0], p[1], p[2]);\n        const rot = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_6__.Quat().setFromEulerAngles(r[0], r[1], r[2]);\n        const scl = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3(s[0], s[1], s[2]);\n        const key = new _scene_animation_animation_js__WEBPACK_IMPORTED_MODULE_4__.Key(t, pos, rot, scl);\n        node._keys.push(key);\n      }\n      anim.addNode(node);\n    }\n    return anim;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/animation.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/audio.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/audio.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AudioHandler\": () => (/* binding */ AudioHandler)\n/* harmony export */ });\n/* harmony import */ var _core_path_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/path.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/path.js\");\n/* harmony import */ var _platform_net_http_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../platform/net/http.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/net/http.js\");\n/* harmony import */ var _platform_audio_capabilities_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../platform/audio/capabilities.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/audio/capabilities.js\");\n/* harmony import */ var _platform_sound_sound_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../platform/sound/sound.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/sound/sound.js\");\n\n\n\n\n\n\nconst ie = function () {\n  if (typeof window === 'undefined') {\n    return false;\n  }\n  const ua = window.navigator.userAgent;\n  const msie = ua.indexOf('MSIE ');\n  if (msie > 0) {\n    return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n  }\n  const trident = ua.indexOf('Trident/');\n  if (trident > 0) {\n    const rv = ua.indexOf('rv:');\n    return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n  }\n  return false;\n}();\nconst supportedExtensions = ['.ogg', '.mp3', '.wav', '.mp4a', '.m4a', '.mp4', '.aac', '.opus'];\nclass AudioHandler {\n  constructor(app) {\n    this.handlerType = \"audio\";\n    this.manager = app.soundManager;\n    this.maxRetries = 0;\n  }\n  _isSupported(url) {\n    const ext = _core_path_js__WEBPACK_IMPORTED_MODULE_0__.path.getExtension(url);\n    return supportedExtensions.indexOf(ext) > -1;\n  }\n  load(url, callback) {\n    if (typeof url === 'string') {\n      url = {\n        load: url,\n        original: url\n      };\n    }\n    const success = function success(resource) {\n      callback(null, new _platform_sound_sound_js__WEBPACK_IMPORTED_MODULE_1__.Sound(resource));\n    };\n    const error = function error(err) {\n      let msg = 'Error loading audio url: ' + url.original;\n      if (err) {\n        msg += ': ' + (err.message || err);\n      }\n      console.warn(msg);\n      callback(msg);\n    };\n    if (this._createSound) {\n      if (!this._isSupported(url.original)) {\n        error(`Audio format for ${url.original} not supported`);\n        return;\n      }\n      this._createSound(url.load, success, error);\n    } else {\n      error(null);\n    }\n  }\n  open(url, data) {\n    return data;\n  }\n  patch(asset, assets) {}\n  _createSound(url, success, error) {\n    if ((0,_platform_audio_capabilities_js__WEBPACK_IMPORTED_MODULE_2__.hasAudioContext)()) {\n      const manager = this.manager;\n      if (!manager.context) {\n        error('Audio manager has no audio context');\n        return;\n      }\n      const options = {\n        retry: this.maxRetries > 0,\n        maxRetries: this.maxRetries\n      };\n      if (url.startsWith('blob:') || url.startsWith('data:')) {\n        options.responseType = _platform_net_http_js__WEBPACK_IMPORTED_MODULE_3__.Http.ResponseType.ARRAY_BUFFER;\n      }\n      _platform_net_http_js__WEBPACK_IMPORTED_MODULE_3__.http.get(url, options, function (err, response) {\n        if (err) {\n          error(err);\n          return;\n        }\n        manager.context.decodeAudioData(response, success, error);\n      });\n    } else {\n      let audio = null;\n      try {\n        audio = new Audio();\n      } catch (e) {\n        error('No support for Audio element');\n        return;\n      }\n      if (ie) {\n        document.body.appendChild(audio);\n      }\n      const onReady = function onReady() {\n        audio.removeEventListener('canplaythrough', onReady);\n        if (ie) {\n          document.body.removeChild(audio);\n        }\n        success(audio);\n      };\n      audio.onerror = function () {\n        audio.onerror = null;\n        if (ie) {\n          document.body.removeChild(audio);\n        }\n        error();\n      };\n      audio.addEventListener('canplaythrough', onReady);\n      audio.src = url;\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/audio.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/basis-worker.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/basis-worker.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BasisWorker\": () => (/* binding */ BasisWorker)\n/* harmony export */ });\nfunction BasisWorker() {\n  const BASIS_FORMAT = {\n    cTFETC1: 0,\n    cTFETC2: 1,\n    cTFBC1: 2,\n    cTFBC3: 3,\n    cTFPVRTC1_4_RGB: 8,\n    cTFPVRTC1_4_RGBA: 9,\n    cTFASTC_4x4: 10,\n    cTFATC_RGB: 11,\n    cTFATC_RGBA_INTERPOLATED_ALPHA: 12,\n    cTFRGBA32: 13,\n    cTFRGB565: 14,\n    cTFRGBA4444: 16\n  };\n  const opaqueMapping = {\n    astc: BASIS_FORMAT.cTFASTC_4x4,\n    dxt: BASIS_FORMAT.cTFBC1,\n    etc1: BASIS_FORMAT.cTFETC1,\n    etc2: BASIS_FORMAT.cTFETC1,\n    pvr: BASIS_FORMAT.cTFPVRTC1_4_RGB,\n    atc: BASIS_FORMAT.cTFATC_RGB,\n    none: BASIS_FORMAT.cTFRGB565\n  };\n  const alphaMapping = {\n    astc: BASIS_FORMAT.cTFASTC_4x4,\n    dxt: BASIS_FORMAT.cTFBC3,\n    etc1: BASIS_FORMAT.cTFRGBA4444,\n    etc2: BASIS_FORMAT.cTFETC2,\n    pvr: BASIS_FORMAT.cTFPVRTC1_4_RGBA,\n    atc: BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA,\n    none: BASIS_FORMAT.cTFRGBA4444\n  };\n  const PIXEL_FORMAT = {\n    ETC1: 21,\n    ETC2_RGB: 22,\n    ETC2_RGBA: 23,\n    DXT1: 8,\n    DXT5: 10,\n    PVRTC_4BPP_RGB_1: 26,\n    PVRTC_4BPP_RGBA_1: 27,\n    ASTC_4x4: 28,\n    ATC_RGB: 29,\n    ATC_RGBA: 30,\n    R8_G8_B8_A8: 7,\n    R5_G6_B5: 3,\n    R4_G4_B4_A4: 5\n  };\n  const basisToEngineMapping = (basisFormat, deviceDetails) => {\n    switch (basisFormat) {\n      case BASIS_FORMAT.cTFETC1:\n        return deviceDetails.formats.etc1 ? PIXEL_FORMAT.ETC1 : PIXEL_FORMAT.ETC2_RGB;\n      case BASIS_FORMAT.cTFETC2:\n        return PIXEL_FORMAT.ETC2_RGBA;\n      case BASIS_FORMAT.cTFBC1:\n        return PIXEL_FORMAT.DXT1;\n      case BASIS_FORMAT.cTFBC3:\n        return PIXEL_FORMAT.DXT5;\n      case BASIS_FORMAT.cTFPVRTC1_4_RGB:\n        return PIXEL_FORMAT.PVRTC_4BPP_RGB_1;\n      case BASIS_FORMAT.cTFPVRTC1_4_RGBA:\n        return PIXEL_FORMAT.PVRTC_4BPP_RGBA_1;\n      case BASIS_FORMAT.cTFASTC_4x4:\n        return PIXEL_FORMAT.ASTC_4x4;\n      case BASIS_FORMAT.cTFATC_RGB:\n        return PIXEL_FORMAT.ATC_RGB;\n      case BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA:\n        return PIXEL_FORMAT.ATC_RGBA;\n      case BASIS_FORMAT.cTFRGBA32:\n        return PIXEL_FORMAT.R8_G8_B8_A8;\n      case BASIS_FORMAT.cTFRGB565:\n        return PIXEL_FORMAT.R5_G6_B5;\n      case BASIS_FORMAT.cTFRGBA4444:\n        return PIXEL_FORMAT.R4_G4_B4_A4;\n    }\n  };\n  const unswizzleGGGR = data => {\n    const genB = function genB(R, G) {\n      const r = R * (2.0 / 255.0) - 1.0;\n      const g = G * (2.0 / 255.0) - 1.0;\n      const b = Math.sqrt(1.0 - Math.min(1.0, r * r + g * g));\n      return Math.max(0, Math.min(255, Math.floor((b + 1.0) * 0.5 * 255.0)));\n    };\n    for (let offset = 0; offset < data.length; offset += 4) {\n      const R = data[offset + 3];\n      const G = data[offset + 1];\n      data[offset + 0] = R;\n      data[offset + 2] = genB(R, G);\n      data[offset + 3] = 255;\n    }\n    return data;\n  };\n  const pack565 = data => {\n    const result = new Uint16Array(data.length / 4);\n    for (let offset = 0; offset < data.length; offset += 4) {\n      const R = data[offset + 0];\n      const G = data[offset + 1];\n      const B = data[offset + 2];\n      result[offset / 4] = (R & 0xf8) << 8 | (G & 0xfc) << 3 | B >> 3;\n    }\n    return result;\n  };\n  const isPOT = (width, height) => {\n    return (width & width - 1) === 0 && (height & height - 1) === 0;\n  };\n  const performanceNow = () => {\n    return typeof performance !== 'undefined' ? performance.now() : 0;\n  };\n  let basis;\n  let rgbPriority;\n  let rgbaPriority;\n  const chooseTargetFormat = (deviceDetails, hasAlpha, isUASTC) => {\n    if (isUASTC) {\n      if (deviceDetails.formats.astc) {\n        return 'astc';\n      }\n    } else {\n      if (hasAlpha) {\n        if (deviceDetails.formats.etc2) {\n          return 'etc2';\n        }\n      } else {\n        if (deviceDetails.formats.etc1 || deviceDetails.formats.etc2) {\n          return 'etc1';\n        }\n      }\n    }\n    const testInOrder = priority => {\n      for (let i = 0; i < priority.length; ++i) {\n        const format = priority[i];\n        if (deviceDetails.formats[format]) {\n          return format;\n        }\n      }\n      return 'none';\n    };\n    return testInOrder(hasAlpha ? rgbaPriority : rgbPriority);\n  };\n  const dimensionsValid = (width, height, format, webgl2) => {\n    switch (format) {\n      case BASIS_FORMAT.cTFETC1:\n      case BASIS_FORMAT.cTFETC2:\n        return true;\n      case BASIS_FORMAT.cTFBC1:\n      case BASIS_FORMAT.cTFBC3:\n        return (width & 0x3) === 0 && (height & 0x3) === 0;\n      case BASIS_FORMAT.cTFPVRTC1_4_RGB:\n      case BASIS_FORMAT.cTFPVRTC1_4_RGBA:\n        return isPOT(width, height) && (width === height || webgl2);\n      case BASIS_FORMAT.cTFASTC_4x4:\n        return true;\n      case BASIS_FORMAT.cTFATC_RGB:\n      case BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA:\n        return true;\n    }\n  };\n  const transcodeKTX2 = (url, data, options) => {\n    if (!basis.KTX2File) {\n      throw new Error('Basis transcoder module does not include support for KTX2.');\n    }\n    const funcStart = performanceNow();\n    const basisFile = new basis.KTX2File(new Uint8Array(data));\n    const width = basisFile.getWidth();\n    const height = basisFile.getHeight();\n    const levels = basisFile.getLevels();\n    const hasAlpha = !!basisFile.getHasAlpha();\n    const isUASTC = basisFile.isUASTC && basisFile.isUASTC();\n    if (!width || !height || !levels) {\n      basisFile.close();\n      basisFile.delete();\n      throw new Error(`Invalid image dimensions url=${url} width=${width} height=${height} levels=${levels}`);\n    }\n    const format = chooseTargetFormat(options.deviceDetails, hasAlpha, isUASTC);\n    const unswizzle = !!options.isGGGR && format === 'pvr';\n    let basisFormat;\n    if (unswizzle) {\n      basisFormat = BASIS_FORMAT.cTFRGBA32;\n    } else {\n      basisFormat = hasAlpha ? alphaMapping[format] : opaqueMapping[format];\n      if (!dimensionsValid(width, height, basisFormat, options.deviceDetails.webgl2)) {\n        basisFormat = hasAlpha ? BASIS_FORMAT.cTFRGBA32 : BASIS_FORMAT.cTFRGB565;\n      }\n    }\n    if (!basisFile.startTranscoding()) {\n      basisFile.close();\n      basisFile.delete();\n      throw new Error('Failed to start transcoding url=' + url);\n    }\n    let i;\n    const levelData = [];\n    for (let mip = 0; mip < levels; ++mip) {\n      const dstSize = basisFile.getImageTranscodedSizeInBytes(mip, 0, 0, basisFormat);\n      const dst = new Uint8Array(dstSize);\n      if (!basisFile.transcodeImage(dst, mip, 0, 0, basisFormat, 0, -1, -1)) {\n        basisFile.close();\n        basisFile.delete();\n        throw new Error('Failed to transcode image url=' + url);\n      }\n      const is16BitFormat = basisFormat === BASIS_FORMAT.cTFRGB565 || basisFormat === BASIS_FORMAT.cTFRGBA4444;\n      levelData.push(is16BitFormat ? new Uint16Array(dst.buffer) : dst);\n    }\n    basisFile.close();\n    basisFile.delete();\n    if (unswizzle) {\n      basisFormat = BASIS_FORMAT.cTFRGB565;\n      for (i = 0; i < levelData.length; ++i) {\n        levelData[i] = pack565(unswizzleGGGR(levelData[i]));\n      }\n    }\n    return {\n      format: basisToEngineMapping(basisFormat, options.deviceDetails),\n      width: width,\n      height: height,\n      levels: levelData,\n      cubemap: false,\n      transcodeTime: performanceNow() - funcStart,\n      url: url,\n      unswizzledGGGR: unswizzle\n    };\n  };\n  const transcodeBasis = (url, data, options) => {\n    const funcStart = performanceNow();\n    const basisFile = new basis.BasisFile(new Uint8Array(data));\n    const width = basisFile.getImageWidth(0, 0);\n    const height = basisFile.getImageHeight(0, 0);\n    const images = basisFile.getNumImages();\n    const levels = basisFile.getNumLevels(0);\n    const hasAlpha = !!basisFile.getHasAlpha();\n    const isUASTC = basisFile.isUASTC && basisFile.isUASTC();\n    if (!width || !height || !images || !levels) {\n      basisFile.close();\n      basisFile.delete();\n      throw new Error(`Invalid image dimensions url=${url} width=${width} height=${height} images=${images} levels=${levels}`);\n    }\n    const format = chooseTargetFormat(options.deviceDetails, hasAlpha, isUASTC);\n    const unswizzle = !!options.isGGGR && format === 'pvr';\n    let basisFormat;\n    if (unswizzle) {\n      basisFormat = BASIS_FORMAT.cTFRGBA32;\n    } else {\n      basisFormat = hasAlpha ? alphaMapping[format] : opaqueMapping[format];\n      if (!dimensionsValid(width, height, basisFormat, options.deviceDetails.webgl2)) {\n        basisFormat = hasAlpha ? BASIS_FORMAT.cTFRGBA32 : BASIS_FORMAT.cTFRGB565;\n      }\n    }\n    if (!basisFile.startTranscoding()) {\n      basisFile.close();\n      basisFile.delete();\n      throw new Error('Failed to start transcoding url=' + url);\n    }\n    let i;\n    const levelData = [];\n    for (let mip = 0; mip < levels; ++mip) {\n      const dstSize = basisFile.getImageTranscodedSizeInBytes(0, mip, basisFormat);\n      const dst = new Uint8Array(dstSize);\n      if (!basisFile.transcodeImage(dst, 0, mip, basisFormat, 0, 0)) {\n        basisFile.close();\n        basisFile.delete();\n        throw new Error('Failed to transcode image url=' + url);\n      }\n      const is16BitFormat = basisFormat === BASIS_FORMAT.cTFRGB565 || basisFormat === BASIS_FORMAT.cTFRGBA4444;\n      levelData.push(is16BitFormat ? new Uint16Array(dst.buffer) : dst);\n    }\n    basisFile.close();\n    basisFile.delete();\n    if (unswizzle) {\n      basisFormat = BASIS_FORMAT.cTFRGB565;\n      for (i = 0; i < levelData.length; ++i) {\n        levelData[i] = pack565(unswizzleGGGR(levelData[i]));\n      }\n    }\n    return {\n      format: basisToEngineMapping(basisFormat, options.deviceDetails),\n      width: width,\n      height: height,\n      levels: levelData,\n      cubemap: false,\n      transcodeTime: performanceNow() - funcStart,\n      url: url,\n      unswizzledGGGR: unswizzle\n    };\n  };\n  const transcode = (url, data, options) => {\n    return options.isKTX2 ? transcodeKTX2(url, data, options) : transcodeBasis(url, data, options);\n  };\n  const workerTranscode = (url, data, options) => {\n    try {\n      const result = transcode(url, data, options);\n      result.levels = result.levels.map(v => v.buffer);\n      self.postMessage({\n        url: url,\n        data: result\n      }, result.levels);\n    } catch (err) {\n      self.postMessage({\n        url: url,\n        err: err\n      }, null);\n    }\n  };\n  const workerInit = (config, callback) => {\n    self.importScripts(config.basisUrl);\n    const instantiateWasmFunc = (imports, successCallback) => {\n      WebAssembly.instantiate(config.module, imports).then(result => {\n        successCallback(result);\n      }).catch(reason => {\n        console.error('instantiate failed + ' + reason);\n      });\n      return {};\n    };\n    self.BASIS(config.module ? {\n      instantiateWasm: instantiateWasmFunc\n    } : null).then(instance => {\n      instance.initializeBasis();\n      basis = instance;\n      rgbPriority = config.rgbPriority;\n      rgbaPriority = config.rgbaPriority;\n      callback(null);\n    });\n  };\n  const queue = [];\n  self.onmessage = message => {\n    const data = message.data;\n    switch (data.type) {\n      case 'init':\n        workerInit(data.config, () => {\n          for (let i = 0; i < queue.length; ++i) {\n            workerTranscode(queue[i].url, queue[i].data, queue[i].options);\n          }\n          queue.length = 0;\n        });\n        break;\n      case 'transcode':\n        if (basis) {\n          workerTranscode(data.url, data.data, data.options);\n        } else {\n          queue.push(data);\n        }\n        break;\n    }\n  };\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/basis-worker.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/basis.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/basis.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"basisInitialize\": () => (/* binding */ basisInitialize),\n/* harmony export */   \"basisTranscode\": () => (/* binding */ basisTranscode)\n/* harmony export */ });\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _basis_worker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis-worker.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/basis-worker.js\");\n/* harmony import */ var _platform_net_http_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../platform/net/http.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/net/http.js\");\n\n\n\n\n\nconst getCompressionFormats = device => {\n  return {\n    astc: !!device.extCompressedTextureASTC,\n    atc: !!device.extCompressedTextureATC,\n    dxt: !!device.extCompressedTextureS3TC,\n    etc1: !!device.extCompressedTextureETC1,\n    etc2: !!device.extCompressedTextureETC,\n    pvr: !!device.extCompressedTexturePVRTC\n  };\n};\nconst prepareWorkerModules = (config, callback) => {\n  const getWorkerBlob = () => {\n    const code = '(' + _basis_worker_js__WEBPACK_IMPORTED_MODULE_0__.BasisWorker.toString() + ')()\\n\\n';\n    return new Blob([code], {\n      type: 'application/javascript'\n    });\n  };\n  const wasmSupported = () => {\n    try {\n      if (typeof WebAssembly === 'object' && typeof WebAssembly.instantiate === 'function') {\n        const module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));\n        if (module instanceof WebAssembly.Module) return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;\n      }\n    } catch (e) {}\n    return false;\n  };\n  const sendResponse = (basisCode, module) => {\n    callback(null, {\n      workerUrl: URL.createObjectURL(getWorkerBlob()),\n      basisUrl: URL.createObjectURL(basisCode),\n      module: module,\n      rgbPriority: config.rgbPriority,\n      rgbaPriority: config.rgbaPriority\n    });\n  };\n  const options = {\n    responseType: 'blob',\n    retry: config.maxRetries > 0,\n    maxRetries: config.maxRetries\n  };\n  if (config.glueUrl && config.wasmUrl && wasmSupported()) {\n    let basisCode = null;\n    let module = null;\n    _platform_net_http_js__WEBPACK_IMPORTED_MODULE_1__.http.get(config.glueUrl, options, (err, response) => {\n      if (err) {\n        callback(err);\n      } else {\n        if (module) {\n          sendResponse(response, module);\n        } else {\n          basisCode = response;\n        }\n      }\n    });\n    const fetchPromise = fetch(config.wasmUrl);\n    const compileManual = () => {\n      fetchPromise.then(result => result.arrayBuffer()).then(buffer => WebAssembly.compile(buffer)).then(module_ => {\n        if (basisCode) {\n          sendResponse(basisCode, module_);\n        } else {\n          module = module_;\n        }\n      }).catch(err => {\n        callback(err, null);\n      });\n    };\n    if (WebAssembly.compileStreaming) {\n      WebAssembly.compileStreaming(fetchPromise).then(module_ => {\n        if (basisCode) {\n          sendResponse(basisCode, module_);\n        } else {\n          module = module_;\n        }\n      }).catch(err => {\n        compileManual();\n      });\n    } else {\n      compileManual();\n    }\n  } else {\n    _platform_net_http_js__WEBPACK_IMPORTED_MODULE_1__.http.get(config.fallbackUrl, options, (err, response) => {\n      if (err) {\n        callback(err, null);\n      } else {\n        sendResponse(response, null);\n      }\n    });\n  }\n};\nclass BasisQueue {\n  constructor() {\n    this.callbacks = {};\n    this.queue = [];\n    this.clients = [];\n  }\n  enqueueJob(url, data, callback, options) {\n    if (this.callbacks.hasOwnProperty(url)) {\n      this.callbacks[url].push(callback);\n    } else {\n      this.callbacks[url] = [callback];\n      const job = {\n        url: url,\n        data: data,\n        options: options\n      };\n      if (this.clients.length > 0) {\n        this.clients.shift().run(job);\n      } else {\n        this.queue.push(job);\n      }\n    }\n  }\n  enqueueClient(client) {\n    if (this.queue.length > 0) {\n      client.run(this.queue.shift());\n    } else {\n      this.clients.push(client);\n    }\n  }\n  handleResponse(url, err, data) {\n    const callback = this.callbacks[url];\n    if (err) {\n      for (let i = 0; i < callback.length; ++i) {\n        callback[i](err);\n      }\n    } else {\n      if (data.format === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.PIXELFORMAT_RGB565 || data.format === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.PIXELFORMAT_RGBA4) {\n        data.levels = data.levels.map(function (v) {\n          return new Uint16Array(v);\n        });\n      } else {\n        data.levels = data.levels.map(function (v) {\n          return new Uint8Array(v);\n        });\n      }\n      for (let i = 0; i < callback.length; ++i) {\n        callback[i](null, data);\n      }\n    }\n    delete this.callbacks[url];\n  }\n}\nclass BasisClient {\n  constructor(queue, config, eager) {\n    this.queue = queue;\n    this.worker = new Worker(config.workerUrl);\n    this.worker.addEventListener('message', message => {\n      const data = message.data;\n      this.queue.handleResponse(data.url, data.err, data.data);\n      if (!this.eager) {\n        this.queue.enqueueClient(this);\n      }\n    });\n    this.worker.postMessage({\n      type: 'init',\n      config: config\n    });\n    this.eager = eager;\n  }\n  run(job) {\n    const transfer = [];\n    if (job.data instanceof ArrayBuffer) {\n      transfer.push(job.data);\n    }\n    this.worker.postMessage({\n      type: 'transcode',\n      url: job.url,\n      format: job.format,\n      data: job.data,\n      options: job.options\n    }, transfer);\n    if (this.eager) {\n      this.queue.enqueueClient(this);\n    }\n  }\n}\nconst defaultNumWorkers = 1;\nconst defaultRgbPriority = ['etc1', 'etc2', 'astc', 'dxt', 'pvr', 'atc'];\nconst defaultRgbaPriority = ['astc', 'dxt', 'etc2', 'pvr', 'atc'];\nconst defaultMaxRetries = 5;\nconst queue = new BasisQueue();\nlet lazyConfig = null;\nlet initializing = false;\nfunction basisInitialize(config) {\n  if (initializing) {\n    return;\n  }\n  if (!config) {\n    config = lazyConfig || {};\n  } else if (config.lazyInit) {\n    lazyConfig = config;\n    return;\n  }\n  if (!config.glueUrl || !config.wasmUrl || !config.fallbackUrl) {\n    const modules = (window.config ? window.config.wasmModules : window.PRELOAD_MODULES) || [];\n    const wasmModule = modules.find(function (m) {\n      return m.moduleName === 'BASIS';\n    });\n    if (wasmModule) {\n      const urlBase = window.ASSET_PREFIX || '';\n      if (!config.glueUrl) {\n        config.glueUrl = urlBase + wasmModule.glueUrl;\n      }\n      if (!config.wasmUrl) {\n        config.wasmUrl = urlBase + wasmModule.wasmUrl;\n      }\n      if (!config.fallbackUrl) {\n        config.fallbackUrl = urlBase + wasmModule.fallbackUrl;\n      }\n    }\n  }\n  if (config.glueUrl || config.wasmUrl || config.fallbackUrl) {\n    initializing = true;\n    const numWorkers = Math.max(1, Math.min(16, config.numWorkers || defaultNumWorkers));\n    const eagerWorkers = config.numWorkers === 1 || (config.hasOwnProperty('eagerWorkers') ? config.eagerWorkers : true);\n    config.rgbPriority = config.rgbPriority || defaultRgbPriority;\n    config.rgbaPriority = config.rgbaPriority || defaultRgbaPriority;\n    config.maxRetries = config.hasOwnProperty('maxRetries') ? config.maxRetries : defaultMaxRetries;\n    prepareWorkerModules(config, (err, clientConfig) => {\n      if (err) {\n        console.error(`failed to initialize basis worker: ${err}`);\n      } else {\n        for (let i = 0; i < numWorkers; ++i) {\n          queue.enqueueClient(new BasisClient(queue, clientConfig, eagerWorkers));\n        }\n      }\n    });\n  }\n}\nlet deviceDetails = null;\nfunction basisTranscode(device, url, data, callback, options) {\n  basisInitialize();\n  if (!deviceDetails) {\n    deviceDetails = {\n      webgl2: device.webgl2,\n      formats: getCompressionFormats(device)\n    };\n  }\n  queue.enqueueJob(url, data, callback, {\n    deviceDetails: deviceDetails,\n    isGGGR: !!(options != null && options.isGGGR),\n    isKTX2: !!(options != null && options.isKTX2)\n  });\n  return initializing;\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/basis.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/binary.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/binary.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BinaryHandler\": () => (/* binding */ BinaryHandler)\n/* harmony export */ });\n/* harmony import */ var _platform_net_http_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/net/http.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/net/http.js\");\n\n\nclass BinaryHandler {\n  constructor(app) {\n    this.handlerType = \"binary\";\n    this.maxRetries = 0;\n  }\n  load(url, callback) {\n    if (typeof url === 'string') {\n      url = {\n        load: url,\n        original: url\n      };\n    }\n    _platform_net_http_js__WEBPACK_IMPORTED_MODULE_0__.http.get(url.load, {\n      responseType: _platform_net_http_js__WEBPACK_IMPORTED_MODULE_0__.Http.ResponseType.ARRAY_BUFFER,\n      retry: this.maxRetries > 0,\n      maxRetries: this.maxRetries\n    }, function (err, response) {\n      if (!err) {\n        callback(null, response);\n      } else {\n        callback(`Error loading binary resource: ${url.original} [${err}]`);\n      }\n    });\n  }\n  open(url, data) {\n    return data;\n  }\n  patch(asset, assets) {}\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/binary.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/bundle.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/bundle.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BundleHandler\": () => (/* binding */ BundleHandler)\n/* harmony export */ });\n/* harmony import */ var _core_platform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/platform.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/platform.js\");\n/* harmony import */ var _platform_net_http_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/net/http.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/net/http.js\");\n/* harmony import */ var _bundle_bundle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../bundle/bundle.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/bundle/bundle.js\");\n/* harmony import */ var _untar_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./untar.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/untar.js\");\n\n\n\n\n\nclass BundleHandler {\n  constructor(app) {\n    this.handlerType = \"bundle\";\n    this._assets = app.assets;\n    this._worker = null;\n    this.maxRetries = 0;\n  }\n  load(url, callback) {\n    if (typeof url === 'string') {\n      url = {\n        load: url,\n        original: url\n      };\n    }\n    const self = this;\n    _platform_net_http_js__WEBPACK_IMPORTED_MODULE_0__.http.get(url.load, {\n      responseType: _platform_net_http_js__WEBPACK_IMPORTED_MODULE_0__.Http.ResponseType.ARRAY_BUFFER,\n      retry: this.maxRetries > 0,\n      maxRetries: this.maxRetries\n    }, function (err, response) {\n      if (!err) {\n        try {\n          self._untar(response, callback);\n        } catch (ex) {\n          callback('Error loading bundle resource ' + url.original + ': ' + ex);\n        }\n      } else {\n        callback('Error loading bundle resource ' + url.original + ': ' + err);\n      }\n    });\n  }\n  _untar(response, callback) {\n    const self = this;\n    if (_core_platform_js__WEBPACK_IMPORTED_MODULE_1__.platform.workers) {\n      if (!self._worker) {\n        self._worker = new _untar_js__WEBPACK_IMPORTED_MODULE_2__.UntarWorker(self._assets.prefix);\n      }\n      self._worker.untar(response, function (err, files) {\n        callback(err, files);\n        if (!self._worker.hasPendingRequests()) {\n          self._worker.destroy();\n          self._worker = null;\n        }\n      });\n    } else {\n      const archive = new _untar_js__WEBPACK_IMPORTED_MODULE_2__.Untar(response);\n      const files = archive.untar(self._assets.prefix);\n      callback(null, files);\n    }\n  }\n  open(url, data) {\n    return new _bundle_bundle_js__WEBPACK_IMPORTED_MODULE_3__.Bundle(data);\n  }\n  patch(asset, assets) {}\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/bundle.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/container.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/container.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ContainerHandler\": () => (/* binding */ ContainerHandler),\n/* harmony export */   \"ContainerResource\": () => (/* binding */ ContainerResource)\n/* harmony export */ });\n/* harmony import */ var _core_path_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/path.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/path.js\");\n/* harmony import */ var _parsers_glb_parser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parsers/glb-parser.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/glb-parser.js\");\n\n\n\nclass ContainerResource {\n  instantiateModelEntity(options) {\n    return null;\n  }\n  instantiateRenderEntity(options) {\n    return null;\n  }\n  getMaterialVariants() {\n    return null;\n  }\n  applyMaterialVariant(entity, name) {}\n  applyMaterialVariantInstances(instances, name) {}\n}\nclass ContainerHandler {\n  constructor(app) {\n    this.handlerType = \"container\";\n    this.glbParser = new _parsers_glb_parser_js__WEBPACK_IMPORTED_MODULE_0__.GlbParser(app.graphicsDevice, app.assets, 0);\n    this.parsers = {};\n  }\n  set maxRetries(value) {\n    this.glbParser.maxRetries = value;\n    for (const parser in this.parsers) {\n      if (this.parsers.hasOwnProperty(parser)) {\n        this.parsers[parser].maxRetries = value;\n      }\n    }\n  }\n  get maxRetries() {\n    return this.glbParser.maxRetries;\n  }\n  _getUrlWithoutParams(url) {\n    return url.indexOf('?') >= 0 ? url.split('?')[0] : url;\n  }\n  _getParser(url) {\n    const ext = url ? _core_path_js__WEBPACK_IMPORTED_MODULE_1__.path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace('.', '') : null;\n    return this.parsers[ext] || this.glbParser;\n  }\n  load(url, callback, asset) {\n    if (typeof url === 'string') {\n      url = {\n        load: url,\n        original: url\n      };\n    }\n    this._getParser(url.original).load(url, callback, asset);\n  }\n  open(url, data, asset) {\n    return this._getParser(url).open(url, data, asset);\n  }\n  patch(asset, assets) {}\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/container.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/css.js":
/*!********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/css.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CssHandler\": () => (/* binding */ CssHandler),\n/* harmony export */   \"createStyle\": () => (/* binding */ createStyle)\n/* harmony export */ });\n/* harmony import */ var _platform_net_http_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/net/http.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/net/http.js\");\n\n\nclass CssHandler {\n  constructor(app) {\n    this.handlerType = \"css\";\n    this.maxRetries = 0;\n  }\n  load(url, callback) {\n    if (typeof url === 'string') {\n      url = {\n        load: url,\n        original: url\n      };\n    }\n    _platform_net_http_js__WEBPACK_IMPORTED_MODULE_0__.http.get(url.load, {\n      retry: this.maxRetries > 0,\n      maxRetries: this.maxRetries\n    }, function (err, response) {\n      if (!err) {\n        callback(null, response);\n      } else {\n        callback(`Error loading css resource: ${url.original} [${err}]`);\n      }\n    });\n  }\n  open(url, data) {\n    return data;\n  }\n  patch(asset, assets) {}\n}\nfunction createStyle(cssString) {\n  const result = document.createElement('style');\n  result.type = 'text/css';\n  if (result.styleSheet) {\n    result.styleSheet.cssText = cssString;\n  } else {\n    result.appendChild(document.createTextNode(cssString));\n  }\n  return result;\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/css.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/cubemap.js":
/*!************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/cubemap.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubemapHandler\": () => (/* binding */ CubemapHandler)\n/* harmony export */ });\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../platform/graphics/texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js\");\n/* harmony import */ var _asset_asset_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../asset/asset.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset.js\");\n\n\n\n\nclass CubemapHandler {\n  constructor(app) {\n    this.handlerType = \"cubemap\";\n    this._device = app.graphicsDevice;\n    this._registry = app.assets;\n    this._loader = app.loader;\n  }\n  load(url, callback, asset) {\n    this.loadAssets(asset, callback);\n  }\n  open(url, data, asset) {\n    return asset ? asset.resource : null;\n  }\n  patch(asset, registry) {\n    this.loadAssets(asset, function (err, result) {\n      if (err) {\n        registry.fire('error', asset);\n        registry.fire('error:' + asset.id, err, asset);\n        asset.fire('error', asset);\n      }\n    });\n  }\n  getAssetIds(cubemapAsset) {\n    const result = [];\n    result[0] = cubemapAsset.file;\n    if ((cubemapAsset.loadFaces || !cubemapAsset.file) && cubemapAsset.data && cubemapAsset.data.textures) {\n      for (let i = 0; i < 6; ++i) {\n        result[i + 1] = cubemapAsset.data.textures[i];\n      }\n    } else {\n      result[1] = result[2] = result[3] = result[4] = result[5] = result[6] = null;\n    }\n    return result;\n  }\n  compareAssetIds(assetIdA, assetIdB) {\n    if (assetIdA && assetIdB) {\n      if (parseInt(assetIdA, 10) === assetIdA || typeof assetIdA === 'string') {\n        return assetIdA === assetIdB;\n      }\n      return assetIdA.url === assetIdB.url;\n    }\n    return assetIdA !== null === (assetIdB !== null);\n  }\n  update(cubemapAsset, assetIds, assets) {\n    const assetData = cubemapAsset.data || {};\n    const oldAssets = cubemapAsset._handlerState.assets;\n    const oldResources = cubemapAsset._resources;\n    let tex, mip, i;\n    const resources = [null, null, null, null, null, null, null];\n    const getType = function getType() {\n      if (assetData.hasOwnProperty('type')) {\n        return assetData.type;\n      }\n      if (assetData.hasOwnProperty('rgbm')) {\n        return assetData.rgbm ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTURETYPE_RGBM : _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTURETYPE_DEFAULT;\n      }\n      return null;\n    };\n    if (!cubemapAsset.loaded || assets[0] !== oldAssets[0]) {\n      if (assets[0]) {\n        tex = assets[0].resource;\n        for (i = 0; i < 6; ++i) {\n          resources[i + 1] = new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture(this._device, {\n            name: cubemapAsset.name + '_prelitCubemap' + (tex.width >> i),\n            cubemap: true,\n            type: getType() || tex.type,\n            width: tex.width >> i,\n            height: tex.height >> i,\n            format: tex.format,\n            levels: [tex._levels[i]],\n            fixCubemapSeams: true,\n            addressU: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_CLAMP_TO_EDGE,\n            addressV: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_CLAMP_TO_EDGE,\n            mipmaps: i === 0\n          });\n        }\n      }\n    } else {\n      resources[1] = oldResources[1] || null;\n      resources[2] = oldResources[2] || null;\n      resources[3] = oldResources[3] || null;\n      resources[4] = oldResources[4] || null;\n      resources[5] = oldResources[5] || null;\n      resources[6] = oldResources[6] || null;\n    }\n    const faceAssets = assets.slice(1);\n    if (!cubemapAsset.loaded || !this.cmpArrays(faceAssets, oldAssets.slice(1))) {\n      if (faceAssets.indexOf(null) === -1) {\n        const faceTextures = faceAssets.map(function (asset) {\n          return asset.resource;\n        });\n        const faceLevels = [];\n        for (mip = 0; mip < faceTextures[0]._levels.length; ++mip) {\n          faceLevels.push(faceTextures.map(function (faceTexture) {\n            return faceTexture._levels[mip];\n          }));\n        }\n        const format = faceTextures[0].format;\n        const faces = new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture(this._device, {\n          name: cubemapAsset.name + '_faces',\n          cubemap: true,\n          type: getType() || faceTextures[0].type,\n          width: faceTextures[0].width,\n          height: faceTextures[0].height,\n          format: format === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGB8 ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA8 : format,\n          levels: faceLevels,\n          minFilter: assetData.hasOwnProperty('minFilter') ? assetData.minFilter : faceTextures[0].minFilter,\n          magFilter: assetData.hasOwnProperty('magFilter') ? assetData.magFilter : faceTextures[0].magFilter,\n          anisotropy: assetData.hasOwnProperty('anisotropy') ? assetData.anisotropy : 1,\n          addressU: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_CLAMP_TO_EDGE,\n          addressV: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_CLAMP_TO_EDGE,\n          fixCubemapSeams: !!assets[0]\n        });\n        resources[0] = faces;\n      }\n    } else {\n      resources[0] = oldResources[0] || null;\n    }\n    if (!this.cmpArrays(resources, oldResources)) {\n      cubemapAsset.resources = resources;\n      cubemapAsset._handlerState.assetIds = assetIds;\n      cubemapAsset._handlerState.assets = assets;\n      for (i = 0; i < oldResources.length; ++i) {\n        if (oldResources[i] !== null && resources.indexOf(oldResources[i]) === -1) {\n          oldResources[i].destroy();\n        }\n      }\n    }\n    for (i = 0; i < oldAssets.length; ++i) {\n      if (oldAssets[i] !== null && assets.indexOf(oldAssets[i]) === -1) {\n        oldAssets[i].unload();\n      }\n    }\n  }\n  cmpArrays(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n      return false;\n    }\n    for (let i = 0; i < arr1.length; ++i) {\n      if (arr1[i] !== arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  resolveId(value) {\n    const valueInt = parseInt(value, 10);\n    return valueInt === value || valueInt.toString() === value ? valueInt : value;\n  }\n  loadAssets(cubemapAsset, callback) {\n    if (!cubemapAsset.hasOwnProperty('_handlerState')) {\n      cubemapAsset._handlerState = {\n        assetIds: [null, null, null, null, null, null, null],\n        assets: [null, null, null, null, null, null, null]\n      };\n    }\n    const self = this;\n    const assetIds = self.getAssetIds(cubemapAsset);\n    const assets = [null, null, null, null, null, null, null];\n    const loadedAssetIds = cubemapAsset._handlerState.assetIds;\n    const loadedAssets = cubemapAsset._handlerState.assets;\n    const registry = self._registry;\n    let awaiting = 7;\n    const onLoad = function onLoad(index, asset) {\n      assets[index] = asset;\n      awaiting--;\n      if (awaiting === 0) {\n        self.update(cubemapAsset, assetIds, assets);\n        callback(null, cubemapAsset.resources);\n      }\n    };\n    const onError = function onError(index, err, asset) {\n      callback(err);\n    };\n    const processTexAsset = function processTexAsset(index, texAsset) {\n      if (texAsset.loaded) {\n        onLoad(index, texAsset);\n      } else {\n        registry.once('load:' + texAsset.id, onLoad.bind(self, index));\n        registry.once('error:' + texAsset.id, onError.bind(self, index));\n        if (!texAsset.loading) {\n          registry.load(texAsset);\n        }\n      }\n    };\n    let texAsset;\n    for (let i = 0; i < 7; ++i) {\n      const assetId = this.resolveId(assetIds[i]);\n      if (!assetId) {\n        onLoad(i, null);\n      } else if (self.compareAssetIds(assetId, loadedAssetIds[i])) {\n        onLoad(i, loadedAssets[i]);\n      } else if (parseInt(assetId, 10) === assetId) {\n        texAsset = registry.get(assetId);\n        if (texAsset) {\n          processTexAsset(i, texAsset);\n        } else {\n          setTimeout(function (index, assetId_) {\n            const texAsset = registry.get(assetId_);\n            if (texAsset) {\n              processTexAsset(index, texAsset);\n            } else {\n              onError(index, 'failed to find dependent cubemap asset=' + assetId_);\n            }\n          }.bind(null, i, assetId));\n        }\n      } else {\n        const file = typeof assetId === 'string' ? {\n          url: assetId,\n          filename: assetId\n        } : assetId;\n        texAsset = new _asset_asset_js__WEBPACK_IMPORTED_MODULE_2__.Asset(cubemapAsset.name + '_part_' + i, 'texture', file);\n        registry.add(texAsset);\n        registry.once('load:' + texAsset.id, onLoad.bind(self, i));\n        registry.once('error:' + texAsset.id, onError.bind(self, i));\n        registry.load(texAsset);\n      }\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/cubemap.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/folder.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/folder.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FolderHandler\": () => (/* binding */ FolderHandler)\n/* harmony export */ });\nclass FolderHandler {\n  constructor() {\n    this.handlerType = \"folder\";\n  }\n  load(url, callback) {\n    callback(null, null);\n  }\n  open(url, data) {\n    return data;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/folder.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/font.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/font.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FontHandler\": () => (/* binding */ FontHandler)\n/* harmony export */ });\n/* harmony import */ var _core_path_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/path.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/path.js\");\n/* harmony import */ var _core_string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/string.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/string.js\");\n/* harmony import */ var _platform_net_http_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../platform/net/http.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/net/http.js\");\n/* harmony import */ var _font_font_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../font/font.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/font/font.js\");\n\n\n\n\n\nfunction upgradeDataSchema(data) {\n  if (data.version < 3) {\n    if (data.version < 2) {\n      data.info.maps = data.info.maps || [{\n        width: data.info.width,\n        height: data.info.height\n      }];\n    }\n    data.chars = Object.keys(data.chars || {}).reduce(function (newChars, key) {\n      const existing = data.chars[key];\n      const newKey = existing.letter !== undefined ? existing.letter : _core_string_js__WEBPACK_IMPORTED_MODULE_0__.string.fromCodePoint(key);\n      if (data.version < 2) {\n        existing.map = existing.map || 0;\n      }\n      newChars[newKey] = existing;\n      return newChars;\n    }, {});\n    data.version = 3;\n  }\n  return data;\n}\nclass FontHandler {\n  constructor(app) {\n    this.handlerType = \"font\";\n    this._loader = app.loader;\n    this.maxRetries = 0;\n  }\n  load(url, callback, asset) {\n    if (typeof url === 'string') {\n      url = {\n        load: url,\n        original: url\n      };\n    }\n    const self = this;\n    if (_core_path_js__WEBPACK_IMPORTED_MODULE_1__.path.getExtension(url.original) === '.json') {\n      _platform_net_http_js__WEBPACK_IMPORTED_MODULE_2__.http.get(url.load, {\n        retry: this.maxRetries > 0,\n        maxRetries: this.maxRetries\n      }, function (err, response) {\n        if (!err) {\n          const data = upgradeDataSchema(response);\n          self._loadTextures(url.load.replace('.json', '.png'), data, function (err, textures) {\n            if (err) return callback(err);\n            callback(null, {\n              data: data,\n              textures: textures\n            });\n          });\n        } else {\n          callback(`Error loading font resource: ${url.original} [${err}]`);\n        }\n      });\n    } else {\n      if (asset && asset.data) {\n        asset.data = upgradeDataSchema(asset.data);\n      }\n      this._loadTextures(url.load, asset && asset.data, callback);\n    }\n  }\n  _loadTextures(url, data, callback) {\n    const numTextures = data.info.maps.length;\n    let numLoaded = 0;\n    let error = null;\n    const textures = new Array(numTextures);\n    const loader = this._loader;\n    const loadTexture = function loadTexture(index) {\n      const onLoaded = function onLoaded(err, texture) {\n        if (error) return;\n        if (err) {\n          error = err;\n          return callback(err);\n        }\n        texture.upload();\n        textures[index] = texture;\n        numLoaded++;\n        if (numLoaded === numTextures) {\n          callback(null, textures);\n        }\n      };\n      if (index === 0) {\n        loader.load(url, 'texture', onLoaded);\n      } else {\n        loader.load(url.replace('.png', index + '.png'), 'texture', onLoaded);\n      }\n    };\n    for (let i = 0; i < numTextures; i++) loadTexture(i);\n  }\n  open(url, data, asset) {\n    let font;\n    if (data.textures) {\n      font = new _font_font_js__WEBPACK_IMPORTED_MODULE_3__.Font(data.textures, data.data);\n    } else {\n      font = new _font_font_js__WEBPACK_IMPORTED_MODULE_3__.Font(data, null);\n    }\n    return font;\n  }\n  patch(asset, assets) {\n    const font = asset.resource;\n    if (!font.data && asset.data) {\n      font.data = asset.data;\n    } else if (!asset.data && font.data) {\n      asset.data = font.data;\n    }\n    if (asset.data) {\n      asset.data = upgradeDataSchema(asset.data);\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/font.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/hierarchy.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/hierarchy.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HierarchyHandler\": () => (/* binding */ HierarchyHandler)\n/* harmony export */ });\n/* harmony import */ var _parsers_scene_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parsers/scene.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/scene.js\");\n/* harmony import */ var _scene_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scene-utils.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/scene-utils.js\");\n\n\n\nclass HierarchyHandler {\n  constructor(app) {\n    this.handlerType = \"hierarchy\";\n    this._app = app;\n    this.maxRetries = 0;\n  }\n  load(url, callback) {\n    _scene_utils_js__WEBPACK_IMPORTED_MODULE_0__.SceneUtils.load(url, this.maxRetries, callback);\n  }\n  open(url, data) {\n    this._app.systems.script.preloading = true;\n    const parser = new _parsers_scene_js__WEBPACK_IMPORTED_MODULE_1__.SceneParser(this._app, false);\n    const parent = parser.parse(data);\n    this._app.systems.script.preloading = false;\n    return parent;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/hierarchy.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/html.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/html.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HtmlHandler\": () => (/* binding */ HtmlHandler)\n/* harmony export */ });\n/* harmony import */ var _platform_net_http_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/net/http.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/net/http.js\");\n\n\nclass HtmlHandler {\n  constructor(app) {\n    this.handlerType = \"html\";\n    this.maxRetries = 0;\n  }\n  load(url, callback) {\n    if (typeof url === 'string') {\n      url = {\n        load: url,\n        original: url\n      };\n    }\n    _platform_net_http_js__WEBPACK_IMPORTED_MODULE_0__.http.get(url.load, {\n      retry: this.maxRetries > 0,\n      maxRetries: this.maxRetries\n    }, function (err, response) {\n      if (!err) {\n        callback(null, response);\n      } else {\n        callback(`Error loading html resource: ${url.original} [${err}]`);\n      }\n    });\n  }\n  open(url, data) {\n    return data;\n  }\n  patch(asset, assets) {}\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/html.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/json.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/json.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"JsonHandler\": () => (/* binding */ JsonHandler)\n/* harmony export */ });\n/* harmony import */ var _platform_net_http_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/net/http.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/net/http.js\");\n\n\nclass JsonHandler {\n  constructor(app) {\n    this.handlerType = \"json\";\n    this.maxRetries = 0;\n  }\n  load(url, callback) {\n    if (typeof url === 'string') {\n      url = {\n        load: url,\n        original: url\n      };\n    }\n    const options = {\n      retry: this.maxRetries > 0,\n      maxRetries: this.maxRetries\n    };\n    if (url.load.startsWith('blob:')) {\n      options.responseType = _platform_net_http_js__WEBPACK_IMPORTED_MODULE_0__.Http.ResponseType.JSON;\n    }\n    _platform_net_http_js__WEBPACK_IMPORTED_MODULE_0__.http.get(url.load, options, function (err, response) {\n      if (!err) {\n        callback(null, response);\n      } else {\n        callback(`Error loading JSON resource: ${url.original} [${err}]`);\n      }\n    });\n  }\n  open(url, data) {\n    return data;\n  }\n  patch(asset, assets) {}\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/json.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/loader.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/loader.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ResourceLoader\": () => (/* binding */ ResourceLoader)\n/* harmony export */ });\n\n\nclass ResourceLoader {\n  constructor(app) {\n    this._handlers = {};\n    this._requests = {};\n    this._cache = {};\n    this._app = app;\n  }\n  addHandler(type, handler) {\n    this._handlers[type] = handler;\n    handler._loader = this;\n  }\n  removeHandler(type) {\n    delete this._handlers[type];\n  }\n  getHandler(type) {\n    return this._handlers[type];\n  }\n  load(url, type, callback, asset) {\n    const handler = this._handlers[type];\n    if (!handler) {\n      const err = `No resource handler for asset type: '${type}' when loading [${url}]`;\n      callback(err);\n      return;\n    }\n    if (!url) {\n      this._loadNull(handler, callback, asset);\n      return;\n    }\n    const key = url + type;\n    if (this._cache[key] !== undefined) {\n      callback(null, this._cache[key]);\n    } else if (this._requests[key]) {\n      this._requests[key].push(callback);\n    } else {\n      this._requests[key] = [callback];\n      const self = this;\n      const handleLoad = function handleLoad(err, urlObj) {\n        if (err) {\n          self._onFailure(key, err);\n          return;\n        }\n        handler.load(urlObj, function (err, data, extra) {\n          if (!self._requests[key]) {\n            return;\n          }\n          if (err) {\n            self._onFailure(key, err);\n            return;\n          }\n          try {\n            self._onSuccess(key, handler.open(urlObj.original, data, asset), extra);\n          } catch (e) {\n            self._onFailure(key, e);\n          }\n        }, asset);\n      };\n      const normalizedUrl = url.split('?')[0];\n      if (this._app.enableBundles && this._app.bundles.hasUrl(normalizedUrl)) {\n        if (!this._app.bundles.canLoadUrl(normalizedUrl)) {\n          handleLoad(`Bundle for ${url} not loaded yet`);\n          return;\n        }\n        this._app.bundles.loadUrl(normalizedUrl, function (err, fileUrlFromBundle) {\n          handleLoad(err, {\n            load: fileUrlFromBundle,\n            original: normalizedUrl\n          });\n        });\n      } else {\n        handleLoad(null, {\n          load: url,\n          original: asset && asset.file.filename || url\n        });\n      }\n    }\n  }\n  _loadNull(handler, callback, asset) {\n    const onLoad = function onLoad(err, data, extra) {\n      if (err) {\n        callback(err);\n      } else {\n        try {\n          callback(null, handler.open(null, data, asset), extra);\n        } catch (e) {\n          callback(e);\n        }\n      }\n    };\n    handler.load(null, onLoad, asset);\n  }\n  _onSuccess(key, result, extra) {\n    this._cache[key] = result;\n    for (let i = 0; i < this._requests[key].length; i++) {\n      this._requests[key][i](null, result, extra);\n    }\n    delete this._requests[key];\n  }\n  _onFailure(key, err) {\n    console.error(err);\n    if (this._requests[key]) {\n      for (let i = 0; i < this._requests[key].length; i++) {\n        this._requests[key][i](err);\n      }\n      delete this._requests[key];\n    }\n  }\n  open(type, data) {\n    const handler = this._handlers[type];\n    if (!handler) {\n      console.warn('No resource handler found for: ' + type);\n      return data;\n    }\n    return handler.open(null, data);\n  }\n  patch(asset, assets) {\n    const handler = this._handlers[asset.type];\n    if (!handler) {\n      console.warn('No resource handler found for: ' + asset.type);\n      return;\n    }\n    if (handler.patch) {\n      handler.patch(asset, assets);\n    }\n  }\n  clearCache(url, type) {\n    delete this._cache[url + type];\n  }\n  getFromCache(url, type) {\n    if (this._cache[url + type]) {\n      return this._cache[url + type];\n    }\n    return undefined;\n  }\n  enableRetry(maxRetries = 5) {\n    maxRetries = Math.max(0, maxRetries) || 0;\n    for (const key in this._handlers) {\n      this._handlers[key].maxRetries = maxRetries;\n    }\n  }\n  disableRetry() {\n    for (const key in this._handlers) {\n      this._handlers[key].maxRetries = 0;\n    }\n  }\n  destroy() {\n    this._handlers = {};\n    this._requests = {};\n    this._cache = {};\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/loader.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/material.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/material.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MaterialHandler\": () => (/* binding */ MaterialHandler)\n/* harmony export */ });\n/* harmony import */ var _platform_net_http_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../platform/net/http.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/net/http.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../platform/graphics/texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js\");\n/* harmony import */ var _scene_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../scene/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _scene_materials_standard_material_parameters_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../scene/materials/standard-material-parameters.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material-parameters.js\");\n/* harmony import */ var _asset_asset_reference_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../asset/asset-reference.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset-reference.js\");\n/* harmony import */ var _parsers_material_json_standard_material_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parsers/material/json-standard-material.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/material/json-standard-material.js\");\n\n\n\n\n\n\n\n\nconst PLACEHOLDER_MAP = {\n  aoMap: 'white',\n  diffuseMap: 'gray',\n  specularMap: 'gray',\n  specularityFactorMap: 'white',\n  metalnessMap: 'black',\n  glossMap: 'gray',\n  sheenMap: 'black',\n  sheenGlossinessMap: 'gray',\n  clearCoatMap: 'black',\n  clearCoatGlossMap: 'gray',\n  clearCoatNormalMap: 'normal',\n  refractionMap: 'white',\n  emissiveMap: 'gray',\n  normalMap: 'normal',\n  heightMap: 'gray',\n  opacityMap: 'gray',\n  sphereMap: 'gray',\n  lightMap: 'white'\n};\nclass MaterialHandler {\n  constructor(app) {\n    this.handlerType = \"material\";\n    this._assets = app.assets;\n    this._device = app.graphicsDevice;\n    this._placeholderTextures = null;\n    this._parser = new _parsers_material_json_standard_material_js__WEBPACK_IMPORTED_MODULE_0__.JsonStandardMaterialParser();\n    this.maxRetries = 0;\n  }\n  load(url, callback) {\n    if (typeof url === 'string') {\n      url = {\n        load: url,\n        original: url\n      };\n    }\n    _platform_net_http_js__WEBPACK_IMPORTED_MODULE_1__.http.get(url.load, {\n      retry: this.maxRetries > 0,\n      maxRetries: this.maxRetries\n    }, function (err, response) {\n      if (!err) {\n        if (callback) {\n          response._engine = true;\n          callback(null, response);\n        }\n      } else {\n        if (callback) {\n          callback(`Error loading material: ${url.original} [${err}]`);\n        }\n      }\n    });\n  }\n  open(url, data) {\n    const material = this._parser.parse(data);\n    if (data._engine) {\n      material._data = data;\n      delete data._engine;\n    }\n    return material;\n  }\n  _createPlaceholders() {\n    this._placeholderTextures = {};\n    const textures = {\n      white: [255, 255, 255, 255],\n      gray: [128, 128, 128, 255],\n      black: [0, 0, 0, 255],\n      normal: [128, 128, 255, 255]\n    };\n    for (const key in textures) {\n      if (!textures.hasOwnProperty(key)) continue;\n      this._placeholderTextures[key] = new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_2__.Texture(this._device, {\n        width: 2,\n        height: 2,\n        format: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.PIXELFORMAT_RGBA8,\n        name: 'material_placeholder'\n      });\n      const pixels = this._placeholderTextures[key].lock();\n      for (let i = 0; i < 4; i++) {\n        for (let c = 0; c < 4; c++) {\n          pixels[i * 4 + c] = textures[key][c];\n        }\n      }\n      this._placeholderTextures[key].unlock();\n    }\n  }\n  patch(asset, assets) {\n    if (asset.resource._data) {\n      asset._data = asset.resource._data;\n      delete asset.resource._data;\n    }\n    asset.data.name = asset.name;\n    asset.resource.name = asset.name;\n    this._bindAndAssignAssets(asset, assets);\n    asset.off('unload', this._onAssetUnload, this);\n    asset.on('unload', this._onAssetUnload, this);\n  }\n  _onAssetUnload(asset) {\n    delete asset.data.parameters;\n    delete asset.data.chunks;\n    delete asset.data.name;\n  }\n  _assignTexture(parameterName, materialAsset, texture) {\n    materialAsset.resource[parameterName] = texture;\n  }\n  _getPlaceholderTexture(parameterName) {\n    if (!this._placeholderTextures) {\n      this._createPlaceholders();\n    }\n    const placeholder = PLACEHOLDER_MAP[parameterName];\n    const texture = this._placeholderTextures[placeholder];\n    return texture;\n  }\n  _assignPlaceholderTexture(parameterName, materialAsset) {\n    materialAsset.resource[parameterName] = this._getPlaceholderTexture(parameterName);\n  }\n  _onTextureLoad(parameterName, materialAsset, textureAsset) {\n    this._assignTexture(parameterName, materialAsset, textureAsset.resource);\n    materialAsset.resource.update();\n  }\n  _onTextureAdd(parameterName, materialAsset, textureAsset) {\n    this._assets.load(textureAsset);\n  }\n  _onTextureRemoveOrUnload(parameterName, materialAsset, textureAsset) {\n    const material = materialAsset.resource;\n    if (material) {\n      if (materialAsset.resource[parameterName] === textureAsset.resource) {\n        this._assignPlaceholderTexture(parameterName, materialAsset);\n        material.update();\n      }\n    }\n  }\n  _assignCubemap(parameterName, materialAsset, textures) {\n    materialAsset.resource[parameterName] = textures[0];\n    if (parameterName === 'cubeMap') {\n      materialAsset.resource.prefilteredCubemaps = textures.slice(1);\n    }\n  }\n  _onCubemapLoad(parameterName, materialAsset, cubemapAsset) {\n    this._assignCubemap(parameterName, materialAsset, cubemapAsset.resources);\n    this._parser.initialize(materialAsset.resource, materialAsset.data);\n  }\n  _onCubemapAdd(parameterName, materialAsset, cubemapAsset) {\n    if (materialAsset.data.shadingModel === _scene_constants_js__WEBPACK_IMPORTED_MODULE_4__.SPECULAR_PHONG) {\n      materialAsset.loadFaces = true;\n    }\n    this._assets.load(cubemapAsset);\n  }\n  _onCubemapRemoveOrUnload(parameterName, materialAsset, cubemapAsset) {\n    const material = materialAsset.resource;\n    if (materialAsset.data.prefilteredCubeMap128 === cubemapAsset.resources[1]) {\n      this._assignCubemap(parameterName, materialAsset, [null, null, null, null, null, null, null]);\n      material.update();\n    }\n  }\n  _bindAndAssignAssets(materialAsset, assets) {\n    const data = this._parser.migrate(materialAsset.data);\n    const material = materialAsset.resource;\n    const pathMapping = data.mappingFormat === 'path';\n    const TEXTURES = _scene_materials_standard_material_parameters_js__WEBPACK_IMPORTED_MODULE_5__.standardMaterialTextureParameters;\n    let i, name, assetReference;\n    for (i = 0; i < TEXTURES.length; i++) {\n      name = TEXTURES[i];\n      assetReference = material._assetReferences[name];\n      const dataAssetId = data[name];\n      const materialTexture = material[name];\n      const isPlaceHolderTexture = materialTexture === this._getPlaceholderTexture(name);\n      const dataValidated = data.validated;\n      if (dataAssetId && (!materialTexture || !dataValidated || isPlaceHolderTexture)) {\n        if (!assetReference) {\n          assetReference = new _asset_asset_reference_js__WEBPACK_IMPORTED_MODULE_6__.AssetReference(name, materialAsset, assets, {\n            load: this._onTextureLoad,\n            add: this._onTextureAdd,\n            remove: this._onTextureRemoveOrUnload,\n            unload: this._onTextureRemoveOrUnload\n          }, this);\n          material._assetReferences[name] = assetReference;\n        }\n        if (pathMapping) {\n          assetReference.url = materialAsset.getAbsoluteUrl(dataAssetId);\n        } else {\n          assetReference.id = dataAssetId;\n        }\n        if (assetReference.asset) {\n          if (assetReference.asset.resource) {\n            this._assignTexture(name, materialAsset, assetReference.asset.resource);\n          } else {\n            this._assignPlaceholderTexture(name, materialAsset);\n          }\n          assets.load(assetReference.asset);\n        }\n      } else {\n        if (assetReference) {\n          if (pathMapping) {\n            assetReference.url = null;\n          } else {\n            assetReference.id = null;\n          }\n        }\n      }\n    }\n    const CUBEMAPS = _scene_materials_standard_material_parameters_js__WEBPACK_IMPORTED_MODULE_5__.standardMaterialCubemapParameters;\n    for (i = 0; i < CUBEMAPS.length; i++) {\n      name = CUBEMAPS[i];\n      assetReference = material._assetReferences[name];\n      if (data[name] && !materialAsset.data.prefilteredCubeMap128) {\n        if (!assetReference) {\n          assetReference = new _asset_asset_reference_js__WEBPACK_IMPORTED_MODULE_6__.AssetReference(name, materialAsset, assets, {\n            load: this._onCubemapLoad,\n            add: this._onCubemapAdd,\n            remove: this._onCubemapRemoveOrUnload,\n            unload: this._onCubemapRemoveOrUnload\n          }, this);\n          material._assetReferences[name] = assetReference;\n        }\n        if (pathMapping) {\n          assetReference.url = data[name];\n        } else {\n          assetReference.id = data[name];\n        }\n        if (assetReference.asset) {\n          if (assetReference.asset.loaded) {\n            this._assignCubemap(name, materialAsset, assetReference.asset.resources);\n          }\n          assets.load(assetReference.asset);\n        }\n      }\n    }\n    this._parser.initialize(material, data);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/material.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/model.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/model.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ModelHandler\": () => (/* binding */ ModelHandler)\n/* harmony export */ });\n/* harmony import */ var _core_path_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/path.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/path.js\");\n/* harmony import */ var _platform_net_http_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../platform/net/http.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/net/http.js\");\n/* harmony import */ var _scene_materials_default_material_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../scene/materials/default-material.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/default-material.js\");\n/* harmony import */ var _parsers_glb_model_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parsers/glb-model.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/glb-model.js\");\n/* harmony import */ var _parsers_json_model_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parsers/json-model.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/json-model.js\");\n\n\n\n\n\n\n\nclass ModelHandler {\n  constructor(app) {\n    this.handlerType = \"model\";\n    this._device = app.graphicsDevice;\n    this._parsers = [];\n    this._defaultMaterial = (0,_scene_materials_default_material_js__WEBPACK_IMPORTED_MODULE_0__.getDefaultMaterial)(this._device);\n    this.maxRetries = 0;\n    this.addParser(new _parsers_json_model_js__WEBPACK_IMPORTED_MODULE_1__.JsonModelParser(this._device, this._defaultMaterial), function (url, data) {\n      return _core_path_js__WEBPACK_IMPORTED_MODULE_2__.path.getExtension(url) === '.json';\n    });\n    this.addParser(new _parsers_glb_model_js__WEBPACK_IMPORTED_MODULE_3__.GlbModelParser(this._device, this._defaultMaterial), function (url, data) {\n      return _core_path_js__WEBPACK_IMPORTED_MODULE_2__.path.getExtension(url) === '.glb';\n    });\n  }\n  load(url, callback) {\n    if (typeof url === 'string') {\n      url = {\n        load: url,\n        original: url\n      };\n    }\n    const options = {\n      retry: this.maxRetries > 0,\n      maxRetries: this.maxRetries\n    };\n    if (url.load.startsWith('blob:') || url.load.startsWith('data:')) {\n      if (_core_path_js__WEBPACK_IMPORTED_MODULE_2__.path.getExtension(url.original).toLowerCase() === '.glb') {\n        options.responseType = _platform_net_http_js__WEBPACK_IMPORTED_MODULE_4__.Http.ResponseType.ARRAY_BUFFER;\n      } else {\n        options.responseType = _platform_net_http_js__WEBPACK_IMPORTED_MODULE_4__.Http.ResponseType.JSON;\n      }\n    }\n    _platform_net_http_js__WEBPACK_IMPORTED_MODULE_4__.http.get(url.load, options, function (err, response) {\n      if (!callback) return;\n      if (!err) {\n        callback(null, response);\n      } else {\n        callback(`Error loading model: ${url.original} [${err}]`);\n      }\n    });\n  }\n  open(url, data) {\n    for (let i = 0; i < this._parsers.length; i++) {\n      const p = this._parsers[i];\n      if (p.decider(url, data)) {\n        return p.parser.parse(data);\n      }\n    }\n    return null;\n  }\n  patch(asset, assets) {\n    if (!asset.resource) return;\n    const data = asset.data;\n    const self = this;\n    asset.resource.meshInstances.forEach(function (meshInstance, i) {\n      if (data.mapping) {\n        const handleMaterial = function handleMaterial(asset) {\n          if (asset.resource) {\n            meshInstance.material = asset.resource;\n          } else {\n            asset.once('load', handleMaterial);\n            assets.load(asset);\n          }\n          asset.once('remove', function (asset) {\n            if (meshInstance.material === asset.resource) {\n              meshInstance.material = self._defaultMaterial;\n            }\n          });\n        };\n        if (!data.mapping[i]) {\n          meshInstance.material = self._defaultMaterial;\n          return;\n        }\n        const id = data.mapping[i].material;\n        const url = data.mapping[i].path;\n        let material;\n        if (id !== undefined) {\n          if (!id) {\n            meshInstance.material = self._defaultMaterial;\n          } else {\n            material = assets.get(id);\n            if (material) {\n              handleMaterial(material);\n            } else {\n              assets.once('add:' + id, handleMaterial);\n            }\n          }\n        } else if (url) {\n          const path = asset.getAbsoluteUrl(data.mapping[i].path);\n          material = assets.getByUrl(path);\n          if (material) {\n            handleMaterial(material);\n          } else {\n            assets.once('add:url:' + path, handleMaterial);\n          }\n        }\n      }\n    });\n  }\n  addParser(parser, decider) {\n    this._parsers.push({\n      parser: parser,\n      decider: decider\n    });\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/model.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/render.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/render.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RenderHandler\": () => (/* binding */ RenderHandler)\n/* harmony export */ });\n/* harmony import */ var _scene_render_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../scene/render.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/render.js\");\n\n\nfunction onContainerAssetLoaded(containerAsset) {\n  const renderAsset = this;\n  if (!renderAsset.resource) return;\n  const containerResource = containerAsset.resource;\n  const render = containerResource.renders && containerResource.renders[renderAsset.data.renderIndex];\n  if (render) {\n    renderAsset.resource.meshes = render.resource.meshes;\n  }\n}\nfunction onContainerAssetAdded(containerAsset) {\n  const renderAsset = this;\n  renderAsset.registry.off('load:' + containerAsset.id, onContainerAssetLoaded, renderAsset);\n  renderAsset.registry.on('load:' + containerAsset.id, onContainerAssetLoaded, renderAsset);\n  renderAsset.registry.off('remove:' + containerAsset.id, onContainerAssetRemoved, renderAsset);\n  renderAsset.registry.once('remove:' + containerAsset.id, onContainerAssetRemoved, renderAsset);\n  if (!containerAsset.resource) {\n    renderAsset.registry.load(containerAsset);\n  } else {\n    onContainerAssetLoaded.call(renderAsset, containerAsset);\n  }\n}\nfunction onContainerAssetRemoved(containerAsset) {\n  const renderAsset = this;\n  renderAsset.registry.off('load:' + containerAsset.id, onContainerAssetLoaded, renderAsset);\n  if (renderAsset.resource) {\n    renderAsset.resource.destroy();\n  }\n}\nclass RenderHandler {\n  constructor(app) {\n    this.handlerType = \"render\";\n    this._registry = app.assets;\n  }\n  load(url, callback, asset) {}\n  open(url, data) {\n    return new _scene_render_js__WEBPACK_IMPORTED_MODULE_0__.Render();\n  }\n  patch(asset, registry) {\n    if (!asset.data.containerAsset) return;\n    const containerAsset = registry.get(asset.data.containerAsset);\n    if (!containerAsset) {\n      registry.once('add:' + asset.data.containerAsset, onContainerAssetAdded, asset);\n      return;\n    }\n    onContainerAssetAdded.call(asset, containerAsset);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/render.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/scene-utils.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/scene-utils.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SceneUtils\": () => (/* binding */ SceneUtils)\n/* harmony export */ });\n/* harmony import */ var _platform_net_http_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/net/http.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/net/http.js\");\n\n\nconst SceneUtils = {\n  load: function (url, maxRetries, callback) {\n    if (typeof url === 'string') {\n      url = {\n        load: url,\n        original: url\n      };\n    }\n    _platform_net_http_js__WEBPACK_IMPORTED_MODULE_0__.http.get(url.load, {\n      retry: maxRetries > 0,\n      maxRetries: maxRetries\n    }, function (err, response) {\n      if (!err) {\n        callback(err, response);\n      } else {\n        let errMsg = 'Error while loading scene JSON ' + url.original;\n        if (err.message) {\n          errMsg += ': ' + err.message;\n          if (err.stack) {\n            errMsg += '\\n' + err.stack;\n          }\n        } else {\n          errMsg += ': ' + err;\n        }\n        callback(errMsg);\n      }\n    });\n  }\n};\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/scene-utils.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/scene.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/scene.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SceneHandler\": () => (/* binding */ SceneHandler)\n/* harmony export */ });\n/* harmony import */ var _scene_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scene-utils.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/scene-utils.js\");\n/* harmony import */ var _parsers_scene_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parsers/scene.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/scene.js\");\n\n\n\nclass SceneHandler {\n  constructor(app) {\n    this.handlerType = \"scene\";\n    this._app = app;\n    this.maxRetries = 0;\n  }\n  load(url, callback) {\n    _scene_utils_js__WEBPACK_IMPORTED_MODULE_0__.SceneUtils.load(url, this.maxRetries, callback);\n  }\n  open(url, data) {\n    this._app.systems.script.preloading = true;\n    const parser = new _parsers_scene_js__WEBPACK_IMPORTED_MODULE_1__.SceneParser(this._app, false);\n    const parent = parser.parse(data);\n    const scene = this._app.scene;\n    scene.root = parent;\n    this._app.applySceneSettings(data.settings);\n    this._app.systems.script.preloading = false;\n    return scene;\n  }\n  patch(asset, assets) {}\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/scene.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/script.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/script.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScriptHandler\": () => (/* binding */ ScriptHandler)\n/* harmony export */ });\n/* harmony import */ var _script_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../script.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/script.js\");\n/* harmony import */ var _script_script_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../script/script-types.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/script/script-types.js\");\n\n\n\nclass ScriptHandler {\n  constructor(app) {\n    this.handlerType = \"script\";\n    this._app = app;\n    this._scripts = {};\n    this._cache = {};\n  }\n  load(url, callback) {\n    if (typeof url === 'string') {\n      url = {\n        load: url,\n        original: url\n      };\n    }\n    const self = this;\n    _script_js__WEBPACK_IMPORTED_MODULE_0__.script.app = this._app;\n    this._loadScript(url.load, (err, url, extra) => {\n      if (!err) {\n        if (_script_js__WEBPACK_IMPORTED_MODULE_0__.script.legacy) {\n          let Type = null;\n          if (_script_script_types_js__WEBPACK_IMPORTED_MODULE_1__.ScriptTypes._types.length) {\n            Type = _script_script_types_js__WEBPACK_IMPORTED_MODULE_1__.ScriptTypes._types.pop();\n          }\n          if (Type) {\n            this._scripts[url] = Type;\n          } else {\n            Type = null;\n          }\n          callback(null, Type, extra);\n        } else {\n          const obj = {};\n          for (let i = 0; i < _script_script_types_js__WEBPACK_IMPORTED_MODULE_1__.ScriptTypes._types.length; i++) obj[_script_script_types_js__WEBPACK_IMPORTED_MODULE_1__.ScriptTypes._types[i].name] = _script_script_types_js__WEBPACK_IMPORTED_MODULE_1__.ScriptTypes._types[i];\n          _script_script_types_js__WEBPACK_IMPORTED_MODULE_1__.ScriptTypes._types.length = 0;\n          callback(null, obj, extra);\n          delete self._loader._cache[url + 'script'];\n        }\n      } else {\n        callback(err);\n      }\n    });\n  }\n  open(url, data) {\n    return data;\n  }\n  patch(asset, assets) {}\n  _loadScript(url, callback) {\n    const head = document.head;\n    const element = document.createElement('script');\n    this._cache[url] = element;\n    element.async = false;\n    element.addEventListener('error', function (e) {\n      callback(`Script: ${e.target.src} failed to load`);\n    }, false);\n    let done = false;\n    element.onload = element.onreadystatechange = function () {\n      if (!done && (!this.readyState || this.readyState === 'loaded' || this.readyState === 'complete')) {\n        done = true;\n        callback(null, url, element);\n      }\n    };\n    element.src = url;\n    head.appendChild(element);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/script.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/shader.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/shader.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ShaderHandler\": () => (/* binding */ ShaderHandler)\n/* harmony export */ });\n/* harmony import */ var _platform_net_http_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/net/http.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/net/http.js\");\n\n\nclass ShaderHandler {\n  constructor(app) {\n    this.handlerType = \"shader\";\n    this.maxRetries = 0;\n  }\n  load(url, callback) {\n    if (typeof url === 'string') {\n      url = {\n        load: url,\n        original: url\n      };\n    }\n    _platform_net_http_js__WEBPACK_IMPORTED_MODULE_0__.http.get(url.load, {\n      retry: this.maxRetries > 0,\n      maxRetries: this.maxRetries\n    }, function (err, response) {\n      if (!err) {\n        callback(null, response);\n      } else {\n        callback(`Error loading shader resource: ${url.original} [${err}]`);\n      }\n    });\n  }\n  open(url, data) {\n    return data;\n  }\n  patch(asset, assets) {}\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/shader.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/sprite.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/sprite.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SpriteHandler\": () => (/* binding */ SpriteHandler)\n/* harmony export */ });\n/* harmony import */ var _core_path_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/path.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/path.js\");\n/* harmony import */ var _platform_net_http_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../platform/net/http.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/net/http.js\");\n/* harmony import */ var _scene_sprite_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../scene/sprite.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/sprite.js\");\n\n\n\n\nfunction onTextureAtlasLoaded(atlasAsset) {\n  const spriteAsset = this;\n  if (spriteAsset.resource) {\n    spriteAsset.resource.atlas = atlasAsset.resource;\n  }\n}\nfunction onTextureAtlasAdded(atlasAsset) {\n  const spriteAsset = this;\n  spriteAsset.registry.load(atlasAsset);\n}\nclass SpriteHandler {\n  constructor(app) {\n    this.handlerType = \"sprite\";\n    this._assets = app.assets;\n    this._device = app.graphicsDevice;\n    this.maxRetries = 0;\n  }\n  load(url, callback) {\n    if (typeof url === 'string') {\n      url = {\n        load: url,\n        original: url\n      };\n    }\n    if (_core_path_js__WEBPACK_IMPORTED_MODULE_0__.path.getExtension(url.original) === '.json') {\n      _platform_net_http_js__WEBPACK_IMPORTED_MODULE_1__.http.get(url.load, {\n        retry: this.maxRetries > 0,\n        maxRetries: this.maxRetries\n      }, function (err, response) {\n        if (!err) {\n          callback(null, response);\n        } else {\n          callback(err);\n        }\n      });\n    }\n  }\n  open(url, data) {\n    const sprite = new _scene_sprite_js__WEBPACK_IMPORTED_MODULE_2__.Sprite(this._device);\n    if (url) {\n      sprite.__data = data;\n    }\n    return sprite;\n  }\n  patch(asset, assets) {\n    const sprite = asset.resource;\n    if (sprite.__data) {\n      asset.data.pixelsPerUnit = sprite.__data.pixelsPerUnit;\n      asset.data.renderMode = sprite.__data.renderMode;\n      asset.data.frameKeys = sprite.__data.frameKeys;\n      if (sprite.__data.textureAtlasAsset) {\n        const atlas = assets.getByUrl(sprite.__data.textureAtlasAsset);\n        if (atlas) {\n          asset.data.textureAtlasAsset = atlas.id;\n        } else {\n          console.warn('Could not find textureatlas with url: ' + sprite.__data.textureAtlasAsset);\n        }\n      }\n    }\n    sprite.startUpdate();\n    sprite.renderMode = asset.data.renderMode;\n    sprite.pixelsPerUnit = asset.data.pixelsPerUnit;\n    sprite.frameKeys = asset.data.frameKeys;\n    this._updateAtlas(asset);\n    sprite.endUpdate();\n    asset.off('change', this._onAssetChange, this);\n    asset.on('change', this._onAssetChange, this);\n  }\n  _updateAtlas(asset) {\n    const sprite = asset.resource;\n    if (!asset.data.textureAtlasAsset) {\n      sprite.atlas = null;\n      return;\n    }\n    this._assets.off('load:' + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);\n    this._assets.on('load:' + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);\n    const atlasAsset = this._assets.get(asset.data.textureAtlasAsset);\n    if (atlasAsset && atlasAsset.resource) {\n      sprite.atlas = atlasAsset.resource;\n    } else {\n      if (!atlasAsset) {\n        this._assets.off('add:' + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);\n        this._assets.on('add:' + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);\n      } else {\n        this._assets.load(atlasAsset);\n      }\n    }\n  }\n  _onAssetChange(asset, attribute, value, oldValue) {\n    if (attribute === 'data') {\n      if (value && value.textureAtlasAsset && oldValue && value.textureAtlasAsset !== oldValue.textureAtlasAsset) {\n        this._assets.off('load:' + oldValue.textureAtlasAsset, onTextureAtlasLoaded, asset);\n        this._assets.off('add:' + oldValue.textureAtlasAsset, onTextureAtlasAdded, asset);\n      }\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/sprite.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/template.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/template.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TemplateHandler\": () => (/* binding */ TemplateHandler)\n/* harmony export */ });\n/* harmony import */ var _platform_net_http_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/net/http.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/net/http.js\");\n/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../template.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/template.js\");\n\n\n\nclass TemplateHandler {\n  constructor(app) {\n    this.handlerType = \"template\";\n    this._app = app;\n    this.maxRetries = 0;\n  }\n  load(url, callback) {\n    if (typeof url === 'string') {\n      url = {\n        load: url,\n        original: url\n      };\n    }\n    const options = {\n      retry: this.maxRetries > 0,\n      maxRetries: this.maxRetries\n    };\n    _platform_net_http_js__WEBPACK_IMPORTED_MODULE_0__.http.get(url.load, options, function (err, response) {\n      if (err) {\n        callback('Error requesting template: ' + url.original);\n      } else {\n        callback(err, response);\n      }\n    });\n  }\n  open(url, data) {\n    return new _template_js__WEBPACK_IMPORTED_MODULE_1__.Template(this._app, data);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/template.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/text.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/text.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TextHandler\": () => (/* binding */ TextHandler)\n/* harmony export */ });\n/* harmony import */ var _platform_net_http_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/net/http.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/net/http.js\");\n\n\nclass TextHandler {\n  constructor(app) {\n    this.handlerType = \"text\";\n    this.maxRetries = 0;\n  }\n  load(url, callback) {\n    if (typeof url === 'string') {\n      url = {\n        load: url,\n        original: url\n      };\n    }\n    _platform_net_http_js__WEBPACK_IMPORTED_MODULE_0__.http.get(url.load, {\n      retry: this.maxRetries > 0,\n      maxRetries: this.maxRetries\n    }, function (err, response) {\n      if (!err) {\n        callback(null, response);\n      } else {\n        callback(`Error loading text resource: ${url.original} [${err}]`);\n      }\n    });\n  }\n  open(url, data) {\n    return data;\n  }\n  patch(asset, assets) {}\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/text.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/texture-atlas.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/texture-atlas.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TextureAtlasHandler\": () => (/* binding */ TextureAtlasHandler)\n/* harmony export */ });\n/* harmony import */ var _core_path_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/path.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/path.js\");\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/math/vec4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec4.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_net_http_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../platform/net/http.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/net/http.js\");\n/* harmony import */ var _scene_texture_atlas_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../scene/texture-atlas.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/texture-atlas.js\");\n\n\n\n\n\n\n\nconst JSON_ADDRESS_MODE = {\n  'repeat': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_REPEAT,\n  'clamp': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_CLAMP_TO_EDGE,\n  'mirror': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_MIRRORED_REPEAT\n};\nconst JSON_FILTER_MODE = {\n  'nearest': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_NEAREST,\n  'linear': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_LINEAR,\n  'nearest_mip_nearest': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_NEAREST_MIPMAP_NEAREST,\n  'linear_mip_nearest': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_LINEAR_MIPMAP_NEAREST,\n  'nearest_mip_linear': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_NEAREST_MIPMAP_LINEAR,\n  'linear_mip_linear': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_LINEAR_MIPMAP_LINEAR\n};\nconst regexFrame = /^data\\.frames\\.(\\d+)$/;\nclass TextureAtlasHandler {\n  constructor(app) {\n    this.handlerType = \"textureatlas\";\n    this._loader = app.loader;\n    this.maxRetries = 0;\n  }\n  load(url, callback) {\n    if (typeof url === 'string') {\n      url = {\n        load: url,\n        original: url\n      };\n    }\n    const self = this;\n    const handler = this._loader.getHandler('texture');\n    if (_core_path_js__WEBPACK_IMPORTED_MODULE_1__.path.getExtension(url.original) === '.json') {\n      _platform_net_http_js__WEBPACK_IMPORTED_MODULE_2__.http.get(url.load, {\n        retry: this.maxRetries > 0,\n        maxRetries: this.maxRetries\n      }, function (err, response) {\n        if (!err) {\n          const textureUrl = url.original.replace('.json', '.png');\n          self._loader.load(textureUrl, 'texture', function (err, texture) {\n            if (err) {\n              callback(err);\n            } else {\n              callback(null, {\n                data: response,\n                texture: texture\n              });\n            }\n          });\n        } else {\n          callback(err);\n        }\n      });\n    } else {\n      return handler.load(url, callback);\n    }\n  }\n  open(url, data) {\n    const resource = new _scene_texture_atlas_js__WEBPACK_IMPORTED_MODULE_3__.TextureAtlas();\n    if (data.texture && data.data) {\n      resource.texture = data.texture;\n      resource.__data = data.data;\n    } else {\n      const handler = this._loader.getHandler('texture');\n      const texture = handler.open(url, data);\n      if (!texture) return null;\n      resource.texture = texture;\n    }\n    return resource;\n  }\n  patch(asset, assets) {\n    if (!asset.resource) {\n      return;\n    }\n    if (asset.resource.__data) {\n      if (asset.resource.__data.minfilter !== undefined) asset.data.minfilter = asset.resource.__data.minfilter;\n      if (asset.resource.__data.magfilter !== undefined) asset.data.magfilter = asset.resource.__data.magfilter;\n      if (asset.resource.__data.addressu !== undefined) asset.data.addressu = asset.resource.__data.addressu;\n      if (asset.resource.__data.addressv !== undefined) asset.data.addressv = asset.resource.__data.addressv;\n      if (asset.resource.__data.mipmaps !== undefined) asset.data.mipmaps = asset.resource.__data.mipmaps;\n      if (asset.resource.__data.anisotropy !== undefined) asset.data.anisotropy = asset.resource.__data.anisotropy;\n      if (asset.resource.__data.rgbm !== undefined) asset.data.rgbm = !!asset.resource.__data.rgbm;\n      asset.data.frames = asset.resource.__data.frames;\n      delete asset.resource.__data;\n    }\n    const texture = asset.resource.texture;\n    if (texture) {\n      texture.name = asset.name;\n      if (asset.data.hasOwnProperty('minfilter') && texture.minFilter !== JSON_FILTER_MODE[asset.data.minfilter]) texture.minFilter = JSON_FILTER_MODE[asset.data.minfilter];\n      if (asset.data.hasOwnProperty('magfilter') && texture.magFilter !== JSON_FILTER_MODE[asset.data.magfilter]) texture.magFilter = JSON_FILTER_MODE[asset.data.magfilter];\n      if (asset.data.hasOwnProperty('addressu') && texture.addressU !== JSON_ADDRESS_MODE[asset.data.addressu]) texture.addressU = JSON_ADDRESS_MODE[asset.data.addressu];\n      if (asset.data.hasOwnProperty('addressv') && texture.addressV !== JSON_ADDRESS_MODE[asset.data.addressv]) texture.addressV = JSON_ADDRESS_MODE[asset.data.addressv];\n      if (asset.data.hasOwnProperty('mipmaps') && texture.mipmaps !== asset.data.mipmaps) texture.mipmaps = asset.data.mipmaps;\n      if (asset.data.hasOwnProperty('anisotropy') && texture.anisotropy !== asset.data.anisotropy) texture.anisotropy = asset.data.anisotropy;\n      if (asset.data.hasOwnProperty('rgbm')) {\n        const type = asset.data.rgbm ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTURETYPE_RGBM : _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTURETYPE_DEFAULT;\n        if (texture.type !== type) {\n          texture.type = type;\n        }\n      }\n    }\n    asset.resource.texture = texture;\n    const frames = {};\n    for (const key in asset.data.frames) {\n      const frame = asset.data.frames[key];\n      frames[key] = {\n        rect: new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_4__.Vec4(frame.rect),\n        pivot: new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_5__.Vec2(frame.pivot),\n        border: new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_4__.Vec4(frame.border)\n      };\n    }\n    asset.resource.frames = frames;\n    asset.off('change', this._onAssetChange, this);\n    asset.on('change', this._onAssetChange, this);\n  }\n  _onAssetChange(asset, attribute, value) {\n    let frame;\n    if (attribute === 'data' || attribute === 'data.frames') {\n      const frames = {};\n      for (const key in value.frames) {\n        frame = value.frames[key];\n        frames[key] = {\n          rect: new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_4__.Vec4(frame.rect),\n          pivot: new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_5__.Vec2(frame.pivot),\n          border: new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_4__.Vec4(frame.border)\n        };\n      }\n      asset.resource.frames = frames;\n    } else {\n      const match = attribute.match(regexFrame);\n      if (match) {\n        const frameKey = match[1];\n        if (value) {\n          if (!asset.resource.frames[frameKey]) {\n            asset.resource.frames[frameKey] = {\n              rect: new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_4__.Vec4(value.rect),\n              pivot: new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_5__.Vec2(value.pivot),\n              border: new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_4__.Vec4(value.border)\n            };\n          } else {\n            frame = asset.resource.frames[frameKey];\n            frame.rect.set(value.rect[0], value.rect[1], value.rect[2], value.rect[3]);\n            frame.pivot.set(value.pivot[0], value.pivot[1]);\n            frame.border.set(value.border[0], value.border[1], value.border[2], value.border[3]);\n          }\n          asset.resource.fire('set:frame', frameKey, asset.resource.frames[frameKey]);\n        } else {\n          if (asset.resource.frames[frameKey]) {\n            delete asset.resource.frames[frameKey];\n            asset.resource.fire('remove:frame', frameKey);\n          }\n        }\n      }\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/texture-atlas.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/texture.js":
/*!************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/texture.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TextureHandler\": () => (/* binding */ TextureHandler),\n/* harmony export */   \"TextureParser\": () => (/* binding */ TextureParser)\n/* harmony export */ });\n/* harmony import */ var _core_path_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/path.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/path.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../platform/graphics/texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js\");\n/* harmony import */ var _parsers_texture_basis_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../parsers/texture/basis.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/texture/basis.js\");\n/* harmony import */ var _parsers_texture_img_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parsers/texture/img.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/texture/img.js\");\n/* harmony import */ var _parsers_texture_ktx_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parsers/texture/ktx.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/texture/ktx.js\");\n/* harmony import */ var _parsers_texture_ktx2_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../parsers/texture/ktx2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/texture/ktx2.js\");\n/* harmony import */ var _parsers_texture_dds_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parsers/texture/dds.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/texture/dds.js\");\n/* harmony import */ var _parsers_texture_hdr_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../parsers/texture/hdr.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/texture/hdr.js\");\n\n\n\n\n\n\n\n\n\n\nconst JSON_ADDRESS_MODE = {\n  'repeat': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_REPEAT,\n  'clamp': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_CLAMP_TO_EDGE,\n  'mirror': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_MIRRORED_REPEAT\n};\nconst JSON_FILTER_MODE = {\n  'nearest': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_NEAREST,\n  'linear': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_LINEAR,\n  'nearest_mip_nearest': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_NEAREST_MIPMAP_NEAREST,\n  'linear_mip_nearest': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_LINEAR_MIPMAP_NEAREST,\n  'nearest_mip_linear': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_NEAREST_MIPMAP_LINEAR,\n  'linear_mip_linear': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_LINEAR_MIPMAP_LINEAR\n};\nconst JSON_TEXTURE_TYPE = {\n  'default': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTURETYPE_DEFAULT,\n  'rgbm': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTURETYPE_RGBM,\n  'rgbe': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTURETYPE_RGBE,\n  'rgbp': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTURETYPE_RGBP,\n  'swizzleGGGR': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTURETYPE_SWIZZLEGGGR\n};\nclass TextureParser {\n  load(url, callback, asset) {\n    throw new Error('not implemented');\n  }\n  open(url, data, device) {\n    throw new Error('not implemented');\n  }\n}\nconst _completePartialMipmapChain = function _completePartialMipmapChain(texture) {\n  const requiredMipLevels = Math.log2(Math.max(texture._width, texture._height)) + 1;\n  const isHtmlElement = function isHtmlElement(object) {\n    return object instanceof HTMLCanvasElement || object instanceof HTMLImageElement || object instanceof HTMLVideoElement;\n  };\n  if (!(texture._format === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA8 || texture._format === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA32F) || texture._volume || texture._compressed || texture._levels.length === 1 || texture._levels.length === requiredMipLevels || isHtmlElement(texture._cubemap ? texture._levels[0][0] : texture._levels[0])) {\n    return;\n  }\n  const downsample = function downsample(width, height, data) {\n    const sampledWidth = Math.max(1, width >> 1);\n    const sampledHeight = Math.max(1, height >> 1);\n    const sampledData = new data.constructor(sampledWidth * sampledHeight * 4);\n    const xs = Math.floor(width / sampledWidth);\n    const ys = Math.floor(height / sampledHeight);\n    const xsys = xs * ys;\n    for (let y = 0; y < sampledHeight; ++y) {\n      for (let x = 0; x < sampledWidth; ++x) {\n        for (let e = 0; e < 4; ++e) {\n          let sum = 0;\n          for (let sy = 0; sy < ys; ++sy) {\n            for (let sx = 0; sx < xs; ++sx) {\n              sum += data[(x * xs + sx + (y * ys + sy) * width) * 4 + e];\n            }\n          }\n          sampledData[(x + y * sampledWidth) * 4 + e] = sum / xsys;\n        }\n      }\n    }\n    return sampledData;\n  };\n  for (let level = texture._levels.length; level < requiredMipLevels; ++level) {\n    const width = Math.max(1, texture._width >> level - 1);\n    const height = Math.max(1, texture._height >> level - 1);\n    if (texture._cubemap) {\n      const mips = [];\n      for (let face = 0; face < 6; ++face) {\n        mips.push(downsample(width, height, texture._levels[level - 1][face]));\n      }\n      texture._levels.push(mips);\n    } else {\n      texture._levels.push(downsample(width, height, texture._levels[level - 1]));\n    }\n  }\n  texture._levelsUpdated = texture._cubemap ? [[true, true, true, true, true, true]] : [true];\n};\nclass TextureHandler {\n  constructor(app) {\n    this.handlerType = \"texture\";\n    const assets = app.assets;\n    const device = app.graphicsDevice;\n    this._device = device;\n    this._assets = assets;\n    this._loader = app.loader;\n    this.imgParser = new _parsers_texture_img_js__WEBPACK_IMPORTED_MODULE_1__.ImgParser(assets, device);\n    this.parsers = {\n      dds: new _parsers_texture_dds_js__WEBPACK_IMPORTED_MODULE_2__.DdsParser(assets),\n      ktx: new _parsers_texture_ktx_js__WEBPACK_IMPORTED_MODULE_3__.KtxParser(assets),\n      ktx2: new _parsers_texture_ktx2_js__WEBPACK_IMPORTED_MODULE_4__.Ktx2Parser(assets, device),\n      basis: new _parsers_texture_basis_js__WEBPACK_IMPORTED_MODULE_5__.BasisParser(assets, device),\n      hdr: new _parsers_texture_hdr_js__WEBPACK_IMPORTED_MODULE_6__.HdrParser(assets)\n    };\n  }\n  set crossOrigin(value) {\n    this.imgParser.crossOrigin = value;\n  }\n  get crossOrigin() {\n    return this.imgParser.crossOrigin;\n  }\n  set maxRetries(value) {\n    this.imgParser.maxRetries = value;\n    for (const parser in this.parsers) {\n      if (this.parsers.hasOwnProperty(parser)) {\n        this.parsers[parser].maxRetries = value;\n      }\n    }\n  }\n  get maxRetries() {\n    return this.imgParser.maxRetries;\n  }\n  _getUrlWithoutParams(url) {\n    return url.indexOf('?') >= 0 ? url.split('?')[0] : url;\n  }\n  _getParser(url) {\n    const ext = _core_path_js__WEBPACK_IMPORTED_MODULE_7__.path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace('.', '');\n    return this.parsers[ext] || this.imgParser;\n  }\n  load(url, callback, asset) {\n    if (typeof url === 'string') {\n      url = {\n        load: url,\n        original: url\n      };\n    }\n    this._getParser(url.original).load(url, callback, asset);\n  }\n  open(url, data, asset) {\n    if (!url) return undefined;\n    let texture = this._getParser(url).open(url, data, this._device);\n    if (texture === null) {\n      texture = new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_8__.Texture(this._device, {\n        width: 4,\n        height: 4,\n        format: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGB8\n      });\n    } else {\n      _completePartialMipmapChain(texture);\n      if (data.unswizzledGGGR) {\n        asset.file.variants.basis.opt &= ~8;\n      }\n    }\n    return texture;\n  }\n  patch(asset, assets) {\n    const texture = asset.resource;\n    if (!texture) {\n      return;\n    }\n    if (asset.name && asset.name.length > 0) {\n      texture.name = asset.name;\n    }\n    const assetData = asset.data;\n    if (assetData.hasOwnProperty('minfilter')) {\n      texture.minFilter = JSON_FILTER_MODE[assetData.minfilter];\n    }\n    if (assetData.hasOwnProperty('magfilter')) {\n      texture.magFilter = JSON_FILTER_MODE[assetData.magfilter];\n    }\n    if (!texture.cubemap) {\n      if (assetData.hasOwnProperty('addressu')) {\n        texture.addressU = JSON_ADDRESS_MODE[assetData.addressu];\n      }\n      if (assetData.hasOwnProperty('addressv')) {\n        texture.addressV = JSON_ADDRESS_MODE[assetData.addressv];\n      }\n    }\n    if (assetData.hasOwnProperty('mipmaps')) {\n      texture.mipmaps = assetData.mipmaps;\n    }\n    if (assetData.hasOwnProperty('anisotropy')) {\n      texture.anisotropy = assetData.anisotropy;\n    }\n    if (assetData.hasOwnProperty('flipY')) {\n      texture.flipY = !!assetData.flipY;\n    }\n    if (assetData.hasOwnProperty('type')) {\n      texture.type = JSON_TEXTURE_TYPE[assetData.type];\n    } else if (assetData.hasOwnProperty('rgbm') && assetData.rgbm) {\n      texture.type = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTURETYPE_RGBM;\n    } else if (asset.file && (asset.file.opt & 8) !== 0) {\n      texture.type = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTURETYPE_SWIZZLEGGGR;\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/texture.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/untar.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/untar.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Untar\": () => (/* binding */ Untar),\n/* harmony export */   \"UntarWorker\": () => (/* binding */ UntarWorker)\n/* harmony export */ });\nlet Untar;\nfunction UntarScope(isWorker) {\n  let utfDecoder;\n  let asciiDecoder;\n  if (typeof TextDecoder !== 'undefined') {\n    try {\n      utfDecoder = new TextDecoder('utf-8');\n      asciiDecoder = new TextDecoder('windows-1252');\n    } catch (e) {\n      console.warn('TextDecoder not supported - pc.Untar module will not work');\n    }\n  } else {\n    console.warn('TextDecoder not supported - pc.Untar module will not work');\n  }\n  function PaxHeader(fields) {\n    this._fields = fields;\n  }\n  PaxHeader.parse = function (buffer, start, length) {\n    const paxArray = new Uint8Array(buffer, start, length);\n    let bytesRead = 0;\n    const fields = [];\n    while (bytesRead < length) {\n      let spaceIndex;\n      for (spaceIndex = bytesRead; spaceIndex < length; spaceIndex++) {\n        if (paxArray[spaceIndex] === 0x20) break;\n      }\n      if (spaceIndex >= length) {\n        throw new Error('Invalid PAX header data format.');\n      }\n      const fieldLength = parseInt(utfDecoder.decode(new Uint8Array(buffer, start + bytesRead, spaceIndex - bytesRead)), 10);\n      const fieldText = utfDecoder.decode(new Uint8Array(buffer, start + spaceIndex + 1, fieldLength - (spaceIndex - bytesRead) - 2));\n      const field = fieldText.split('=');\n      if (field.length !== 2) {\n        throw new Error('Invalid PAX header data format.');\n      }\n      if (field[1].length === 0) {\n        field[1] = null;\n      }\n      fields.push({\n        name: field[0],\n        value: field[1]\n      });\n      bytesRead += fieldLength;\n    }\n    return new PaxHeader(fields);\n  };\n  PaxHeader.prototype.applyHeader = function (file) {\n    for (let i = 0; i < this._fields.length; i++) {\n      let fieldName = this._fields[i].name;\n      const fieldValue = this._fields[i].value;\n      if (fieldName === 'path') {\n        fieldName = 'name';\n      }\n      if (fieldValue === null) {\n        delete file[fieldName];\n      } else {\n        file[fieldName] = fieldValue;\n      }\n    }\n  };\n  function UntarInternal(arrayBuffer) {\n    this._arrayBuffer = arrayBuffer || new ArrayBuffer(0);\n    this._bufferView = new DataView(this._arrayBuffer);\n    this._globalPaxHeader = null;\n    this._paxHeader = null;\n    this._bytesRead = 0;\n  }\n  if (!isWorker) {\n    Untar = UntarInternal;\n  }\n  UntarInternal.prototype._hasNext = function () {\n    return this._bytesRead + 4 < this._arrayBuffer.byteLength && this._bufferView.getUint32(this._bytesRead) !== 0;\n  };\n  UntarInternal.prototype._readNextFile = function () {\n    const headersDataView = new DataView(this._arrayBuffer, this._bytesRead, 512);\n    const headers = asciiDecoder.decode(headersDataView);\n    this._bytesRead += 512;\n    let name = headers.substring(0, 100).replace(/\\0/g, '');\n    const ustarFormat = headers.substring(257, 263);\n    const size = parseInt(headers.substring(124, 136), 8);\n    const type = headers.substring(156, 157);\n    const start = this._bytesRead;\n    let url = null;\n    let normalFile = false;\n    switch (type) {\n      case '0':\n      case '':\n        normalFile = true;\n        if (!isWorker) {\n          const blob = new Blob([this._arrayBuffer.slice(this._bytesRead, this._bytesRead + size)]);\n          url = URL.createObjectURL(blob);\n        }\n        break;\n      case 'g':\n        this._globalPaxHeader = PaxHeader.parse(this._arrayBuffer, this._bytesRead, size);\n        break;\n      case 'x':\n        this._paxHeader = PaxHeader.parse(this._arrayBuffer, this._bytesRead, size);\n        break;\n    }\n    this._bytesRead += size;\n    const remainder = size % 512;\n    if (remainder !== 0) {\n      this._bytesRead += 512 - remainder;\n    }\n    if (!normalFile) {\n      return null;\n    }\n    if (ustarFormat.indexOf('ustar') !== -1) {\n      const namePrefix = headers.substring(345, 500).replace(/\\0/g, '');\n      if (namePrefix.length > 0) {\n        name = namePrefix.trim() + name.trim();\n      }\n    }\n    const file = {\n      name: name,\n      start: start,\n      size: size,\n      url: url\n    };\n    if (this._globalPaxHeader) {\n      this._globalPaxHeader.applyHeader(file);\n    }\n    if (this._paxHeader) {\n      this._paxHeader.applyHeader(file);\n      this._paxHeader = null;\n    }\n    return file;\n  };\n  UntarInternal.prototype.untar = function (filenamePrefix) {\n    if (!utfDecoder) {\n      console.error('Cannot untar because TextDecoder interface is not available for this platform.');\n      return [];\n    }\n    const files = [];\n    while (this._hasNext()) {\n      const file = this._readNextFile();\n      if (!file) continue;\n      if (filenamePrefix && file.name) {\n        file.name = filenamePrefix + file.name;\n      }\n      files.push(file);\n    }\n    return files;\n  };\n  if (isWorker) {\n    self.onmessage = function (e) {\n      const id = e.data.id;\n      try {\n        const archive = new UntarInternal(e.data.arrayBuffer);\n        const files = archive.untar(e.data.prefix);\n        postMessage({\n          id: id,\n          files: files,\n          arrayBuffer: e.data.arrayBuffer\n        }, [e.data.arrayBuffer]);\n      } catch (err) {\n        postMessage({\n          id: id,\n          error: err.toString()\n        });\n      }\n    };\n  }\n}\nlet workerUrl = null;\nfunction getWorkerUrl() {\n  if (!workerUrl) {\n    const code = '(' + UntarScope.toString() + ')(true)\\n\\n';\n    const blob = new Blob([code], {\n      type: 'application/javascript'\n    });\n    workerUrl = URL.createObjectURL(blob);\n  }\n  return workerUrl;\n}\nclass UntarWorker {\n  constructor(filenamePrefix) {\n    this._requestId = 0;\n    this._pendingRequests = {};\n    this._filenamePrefix = filenamePrefix;\n    this._worker = new Worker(getWorkerUrl());\n    this._worker.addEventListener('message', this._onMessage.bind(this));\n  }\n  _onMessage(e) {\n    const id = e.data.id;\n    if (!this._pendingRequests[id]) return;\n    const callback = this._pendingRequests[id];\n    delete this._pendingRequests[id];\n    if (e.data.error) {\n      callback(e.data.error);\n    } else {\n      const arrayBuffer = e.data.arrayBuffer;\n      for (let i = 0, len = e.data.files.length; i < len; i++) {\n        const file = e.data.files[i];\n        const blob = new Blob([arrayBuffer.slice(file.start, file.start + file.size)]);\n        file.url = URL.createObjectURL(blob);\n      }\n      callback(null, e.data.files);\n    }\n  }\n  untar(arrayBuffer, callback) {\n    const id = this._requestId++;\n    this._pendingRequests[id] = callback;\n    this._worker.postMessage({\n      id: id,\n      prefix: this._filenamePrefix,\n      arrayBuffer: arrayBuffer\n    }, [arrayBuffer]);\n  }\n  hasPendingRequests() {\n    return Object.keys(this._pendingRequests).length > 0;\n  }\n  destroy() {\n    if (this._worker) {\n      this._worker.terminate();\n      this._worker = null;\n      this._pendingRequests = null;\n    }\n  }\n}\nUntarScope();\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/untar.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/i18n/constants.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/i18n/constants.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DEFAULT_LOCALE\": () => (/* binding */ DEFAULT_LOCALE),\n/* harmony export */   \"DEFAULT_LOCALE_FALLBACKS\": () => (/* binding */ DEFAULT_LOCALE_FALLBACKS)\n/* harmony export */ });\nconst DEFAULT_LOCALE = 'en-US';\nconst DEFAULT_LOCALE_FALLBACKS = {\n  'en': 'en-US',\n  'es': 'en-ES',\n  'zh': 'zh-CN',\n  'zh-HK': 'zh-TW',\n  'zh-TW': 'zh-HK',\n  'zh-MO': 'zh-HK',\n  'fr': 'fr-FR',\n  'de': 'de-DE',\n  'it': 'it-IT',\n  'ru': 'ru-RU',\n  'ja': 'ja-JP'\n};\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/i18n/constants.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/i18n/i18n-parser.js":
/*!************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/i18n/i18n-parser.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"I18nParser\": () => (/* binding */ I18nParser)\n/* harmony export */ });\nclass I18nParser {\n  _validate(data) {\n    if (!data.header) {\n      throw new Error('pc.I18n#addData: Missing \"header\" field');\n    }\n    if (!data.header.version) {\n      throw new Error('pc.I18n#addData: Missing \"header.version\" field');\n    }\n    if (data.header.version !== 1) {\n      throw new Error('pc.I18n#addData: Invalid \"header.version\" field');\n    }\n    if (!data.data) {\n      throw new Error('pc.I18n#addData: Missing \"data\" field');\n    } else if (!Array.isArray(data.data)) {\n      throw new Error('pc.I18n#addData: \"data\" field must be an array');\n    }\n    for (let i = 0, len = data.data.length; i < len; i++) {\n      const entry = data.data[i];\n      if (!entry.info) {\n        throw new Error(`pc.I18n#addData: missing \"data[${i}].info\" field`);\n      }\n      if (!entry.info.locale) {\n        throw new Error(`pc.I18n#addData: missing \"data[${i}].info.locale\" field`);\n      }\n      if (typeof entry.info.locale !== 'string') {\n        throw new Error(`pc.I18n#addData: \"data[${i}].info.locale\" must be a string`);\n      }\n      if (!entry.messages) {\n        throw new Error(`pc.I18n#addData: missing \"data[${i}].messages\" field`);\n      }\n    }\n  }\n  parse(data) {\n    return data.data;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/i18n/i18n-parser.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/i18n/i18n.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/i18n/i18n.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"I18n\": () => (/* binding */ I18n)\n/* harmony export */ });\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _asset_asset_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../asset/asset.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset.js\");\n/* harmony import */ var _i18n_parser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./i18n-parser.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/i18n/i18n-parser.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/i18n/constants.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/i18n/utils.js\");\n\n\n\n\n\n\nclass I18n extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor(app) {\n    super();\n    this.locale = _constants_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_LOCALE;\n    this._translations = {};\n    this._availableLangs = {};\n    this._app = app;\n    this._assets = [];\n    this._parser = new _i18n_parser_js__WEBPACK_IMPORTED_MODULE_2__.I18nParser();\n  }\n  set assets(value) {\n    const index = {};\n    for (let _i = 0, len = value.length; _i < len; _i++) {\n      const id = value[_i] instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_3__.Asset ? value[_i].id : value[_i];\n      index[id] = true;\n    }\n    let i = this._assets.length;\n    while (i--) {\n      const id = this._assets[i];\n      if (!index[id]) {\n        this._app.assets.off('add:' + id, this._onAssetAdd, this);\n        const asset = this._app.assets.get(id);\n        if (asset) {\n          this._onAssetRemove(asset);\n        }\n        this._assets.splice(i, 1);\n      }\n    }\n    for (const id in index) {\n      const idNum = parseInt(id, 10);\n      if (this._assets.indexOf(idNum) !== -1) continue;\n      this._assets.push(idNum);\n      const asset = this._app.assets.get(idNum);\n      if (!asset) {\n        this._app.assets.once('add:' + idNum, this._onAssetAdd, this);\n      } else {\n        this._onAssetAdd(asset);\n      }\n    }\n  }\n  get assets() {\n    return this._assets;\n  }\n  set locale(value) {\n    if (this._locale === value) {\n      return;\n    }\n    let lang = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.getLang)(value);\n    if (lang === 'in') {\n      lang = 'id';\n      value = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.replaceLang)(value, lang);\n      if (this._locale === value) {\n        return;\n      }\n    }\n    const old = this._locale;\n    this._locale = value;\n    this._lang = lang;\n    this._pluralFn = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.getPluralFn)(this._lang);\n    this.fire('set:locale', value, old);\n  }\n  get locale() {\n    return this._locale;\n  }\n  static findAvailableLocale(desiredLocale, availableLocales) {\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.findAvailableLocale)(desiredLocale, availableLocales);\n  }\n  findAvailableLocale(desiredLocale) {\n    if (this._translations[desiredLocale]) {\n      return desiredLocale;\n    }\n    const lang = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.getLang)(desiredLocale);\n    return this._findFallbackLocale(desiredLocale, lang);\n  }\n  getText(key, locale) {\n    let result = key;\n    let lang;\n    if (!locale) {\n      locale = this._locale;\n      lang = this._lang;\n    }\n    let translations = this._translations[locale];\n    if (!translations) {\n      if (!lang) {\n        lang = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.getLang)(locale);\n      }\n      locale = this._findFallbackLocale(locale, lang);\n      translations = this._translations[locale];\n    }\n    if (translations && translations.hasOwnProperty(key)) {\n      result = translations[key];\n      if (Array.isArray(result)) {\n        result = result[0];\n      }\n      if (result === null || result === undefined) {\n        result = key;\n      }\n    }\n    return result;\n  }\n  getPluralText(key, n, locale) {\n    let result = key;\n    let lang;\n    let pluralFn;\n    if (!locale) {\n      locale = this._locale;\n      lang = this._lang;\n      pluralFn = this._pluralFn;\n    } else {\n      lang = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.getLang)(locale);\n      pluralFn = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.getPluralFn)(lang);\n    }\n    let translations = this._translations[locale];\n    if (!translations) {\n      locale = this._findFallbackLocale(locale, lang);\n      lang = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.getLang)(locale);\n      pluralFn = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.getPluralFn)(lang);\n      translations = this._translations[locale];\n    }\n    if (translations && translations[key] && pluralFn) {\n      const index = pluralFn(n);\n      result = translations[key][index];\n      if (result === null || result === undefined) {\n        result = key;\n      }\n    }\n    return result;\n  }\n  addData(data) {\n    let parsed;\n    try {\n      parsed = this._parser.parse(data);\n    } catch (err) {\n      console.error(err);\n      return;\n    }\n    for (let i = 0, len = parsed.length; i < len; i++) {\n      const entry = parsed[i];\n      const locale = entry.info.locale;\n      const messages = entry.messages;\n      if (!this._translations[locale]) {\n        this._translations[locale] = {};\n        const lang = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.getLang)(locale);\n        if (!this._availableLangs[lang]) {\n          this._availableLangs[lang] = locale;\n        }\n      }\n      Object.assign(this._translations[locale], messages);\n      this.fire('data:add', locale, messages);\n    }\n  }\n  removeData(data) {\n    let parsed;\n    try {\n      parsed = this._parser.parse(data);\n    } catch (err) {\n      console.error(err);\n      return;\n    }\n    for (let i = 0, len = parsed.length; i < len; i++) {\n      const entry = parsed[i];\n      const locale = entry.info.locale;\n      const translations = this._translations[locale];\n      if (!translations) continue;\n      const messages = entry.messages;\n      for (const key in messages) {\n        delete translations[key];\n      }\n      if (Object.keys(translations).length === 0) {\n        delete this._translations[locale];\n        delete this._availableLangs[(0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.getLang)(locale)];\n      }\n      this.fire('data:remove', locale, messages);\n    }\n  }\n  destroy() {\n    this._translations = null;\n    this._availableLangs = null;\n    this._assets = null;\n    this._parser = null;\n    this.off();\n  }\n  _findFallbackLocale(locale, lang) {\n    let result = _constants_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_LOCALE_FALLBACKS[locale];\n    if (result && this._translations[result]) {\n      return result;\n    }\n    result = _constants_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_LOCALE_FALLBACKS[lang];\n    if (result && this._translations[result]) {\n      return result;\n    }\n    result = this._availableLangs[lang];\n    if (result && this._translations[result]) {\n      return result;\n    }\n    return _constants_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_LOCALE;\n  }\n  _onAssetAdd(asset) {\n    asset.on('load', this._onAssetLoad, this);\n    asset.on('change', this._onAssetChange, this);\n    asset.on('remove', this._onAssetRemove, this);\n    asset.on('unload', this._onAssetUnload, this);\n    if (asset.resource) {\n      this._onAssetLoad(asset);\n    }\n  }\n  _onAssetLoad(asset) {\n    this.addData(asset.resource);\n  }\n  _onAssetChange(asset) {\n    if (asset.resource) {\n      this.addData(asset.resource);\n    }\n  }\n  _onAssetRemove(asset) {\n    asset.off('load', this._onAssetLoad, this);\n    asset.off('change', this._onAssetChange, this);\n    asset.off('remove', this._onAssetRemove, this);\n    asset.off('unload', this._onAssetUnload, this);\n    if (asset.resource) {\n      this.removeData(asset.resource);\n    }\n    this._app.assets.once('add:' + asset.id, this._onAssetAdd, this);\n  }\n  _onAssetUnload(asset) {\n    if (asset.resource) {\n      this.removeData(asset.resource);\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/i18n/i18n.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/i18n/utils.js":
/*!******************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/i18n/utils.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"findAvailableLocale\": () => (/* binding */ findAvailableLocale),\n/* harmony export */   \"getLang\": () => (/* binding */ getLang),\n/* harmony export */   \"getPluralFn\": () => (/* binding */ getPluralFn),\n/* harmony export */   \"replaceLang\": () => (/* binding */ replaceLang)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/i18n/constants.js\");\n\n\nconst PLURALS = {};\nfunction definePluralFn(locales, fn) {\n  for (let i = 0, len = locales.length; i < len; i++) {\n    PLURALS[locales[i]] = fn;\n  }\n}\nfunction getLang(locale) {\n  const idx = locale.indexOf('-');\n  if (idx !== -1) {\n    return locale.substring(0, idx);\n  }\n  return locale;\n}\nfunction replaceLang(locale, desiredLang) {\n  const idx = locale.indexOf('-');\n  if (idx !== -1) {\n    return desiredLang + locale.substring(idx);\n  }\n  return desiredLang;\n}\nfunction findAvailableLocale(desiredLocale, availableLocales) {\n  if (availableLocales[desiredLocale]) {\n    return desiredLocale;\n  }\n  let fallback = _constants_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_LOCALE_FALLBACKS[desiredLocale];\n  if (fallback && availableLocales[fallback]) {\n    return fallback;\n  }\n  const lang = getLang(desiredLocale);\n  fallback = _constants_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_LOCALE_FALLBACKS[lang];\n  if (availableLocales[fallback]) {\n    return fallback;\n  }\n  if (availableLocales[lang]) {\n    return lang;\n  }\n  return _constants_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_LOCALE;\n}\ndefinePluralFn(['ja', 'ko', 'th', 'vi', 'zh', 'id'], function (n) {\n  return 0;\n});\ndefinePluralFn(['fa', 'hi'], function (n) {\n  if (n >= 0 && n <= 1) {\n    return 0;\n  }\n  return 1;\n});\ndefinePluralFn(['fr', 'pt'], function (n) {\n  if (n >= 0 && n < 2) {\n    return 0;\n  }\n  return 1;\n});\ndefinePluralFn(['da'], function (n) {\n  if (n === 1 || !Number.isInteger(n) && n >= 0 && n <= 1) {\n    return 0;\n  }\n  return 1;\n});\ndefinePluralFn(['de', 'en', 'it', 'el', 'es', 'tr', 'fi', 'sv', 'nb', 'no', 'ur'], function (n) {\n  if (n === 1) {\n    return 0;\n  }\n  return 1;\n});\ndefinePluralFn(['ru', 'uk'], function (n) {\n  if (Number.isInteger(n)) {\n    const mod10 = n % 10;\n    const mod100 = n % 100;\n    if (mod10 === 1 && mod100 !== 11) {\n      return 0;\n    } else if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {\n      return 1;\n    } else if (mod10 === 0 || mod10 >= 5 && mod10 <= 9 || mod100 >= 11 && mod100 <= 14) {\n      return 2;\n    }\n  }\n  return 3;\n});\ndefinePluralFn(['pl'], function (n) {\n  if (Number.isInteger(n)) {\n    if (n === 1) {\n      return 0;\n    }\n    const mod10 = n % 10;\n    const mod100 = n % 100;\n    if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {\n      return 1;\n    } else if (mod10 >= 0 && mod10 <= 1 || mod10 >= 5 && mod10 <= 9 || mod100 >= 12 && mod100 <= 14) {\n      return 2;\n    }\n  }\n  return 3;\n});\ndefinePluralFn(['ar'], function (n) {\n  if (n === 0) {\n    return 0;\n  } else if (n === 1) {\n    return 1;\n  } else if (n === 2) {\n    return 2;\n  }\n  if (Number.isInteger(n)) {\n    const mod100 = n % 100;\n    if (mod100 >= 3 && mod100 <= 10) {\n      return 3;\n    } else if (mod100 >= 11 && mod100 <= 99) {\n      return 4;\n    }\n  }\n  return 5;\n});\nconst DEFAULT_PLURAL_FN = PLURALS[getLang(_constants_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_LOCALE)];\nfunction getPluralFn(lang) {\n  return PLURALS[lang] || DEFAULT_PLURAL_FN;\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/i18n/utils.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/input/element-input.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/input/element-input.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ElementInput\": () => (/* binding */ ElementInput),\n/* harmony export */   \"ElementInputEvent\": () => (/* binding */ ElementInputEvent),\n/* harmony export */   \"ElementMouseEvent\": () => (/* binding */ ElementMouseEvent),\n/* harmony export */   \"ElementSelectEvent\": () => (/* binding */ ElementSelectEvent),\n/* harmony export */   \"ElementTouchEvent\": () => (/* binding */ ElementTouchEvent)\n/* harmony export */ });\n/* harmony import */ var _core_platform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/platform.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/platform.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/math/vec4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec4.js\");\n/* harmony import */ var _core_shape_ray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/shape/ray.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/shape/ray.js\");\n/* harmony import */ var _platform_input_mouse_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../platform/input/mouse.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/input/mouse.js\");\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../globals.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/globals.js\");\n\n\n\n\n\n\n\nlet targetX, targetY;\nconst vecA = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst vecB = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst rayA = new _core_shape_ray_js__WEBPACK_IMPORTED_MODULE_1__.Ray();\nconst rayB = new _core_shape_ray_js__WEBPACK_IMPORTED_MODULE_1__.Ray();\nconst rayC = new _core_shape_ray_js__WEBPACK_IMPORTED_MODULE_1__.Ray();\nrayA.end = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nrayB.end = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nrayC.end = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst _pq = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst _pa = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst _pb = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst _pc = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst _pd = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst _m = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst _au = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst _bv = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst _cw = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst _ir = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst _sct = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst _accumulatedScale = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst _paddingTop = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst _paddingBottom = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst _paddingLeft = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst _paddingRight = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst _cornerBottomLeft = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst _cornerBottomRight = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst _cornerTopRight = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst _cornerTopLeft = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst ZERO_VEC4 = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_2__.Vec4();\nfunction scalarTriple(p1, p2, p3) {\n  return _sct.cross(p1, p2).dot(p3);\n}\nfunction intersectLineQuad(p, q, corners) {\n  _pq.sub2(q, p);\n  _pa.sub2(corners[0], p);\n  _pb.sub2(corners[1], p);\n  _pc.sub2(corners[2], p);\n  _m.cross(_pc, _pq);\n  let v = _pa.dot(_m);\n  let u;\n  let w;\n  if (v >= 0) {\n    u = -_pb.dot(_m);\n    if (u < 0) return -1;\n    w = scalarTriple(_pq, _pb, _pa);\n    if (w < 0) return -1;\n    const denom = 1.0 / (u + v + w);\n    _au.copy(corners[0]).mulScalar(u * denom);\n    _bv.copy(corners[1]).mulScalar(v * denom);\n    _cw.copy(corners[2]).mulScalar(w * denom);\n    _ir.copy(_au).add(_bv).add(_cw);\n  } else {\n    _pd.sub2(corners[3], p);\n    u = _pd.dot(_m);\n    if (u < 0) return -1;\n    w = scalarTriple(_pq, _pa, _pd);\n    if (w < 0) return -1;\n    v = -v;\n    const denom = 1.0 / (u + v + w);\n    _au.copy(corners[0]).mulScalar(u * denom);\n    _bv.copy(corners[3]).mulScalar(v * denom);\n    _cw.copy(corners[2]).mulScalar(w * denom);\n    _ir.copy(_au).add(_bv).add(_cw);\n  }\n  if (_pq.sub2(corners[0], corners[2]).lengthSq() < 0.0001 * 0.0001) return -1;\n  if (_pq.sub2(corners[1], corners[3]).lengthSq() < 0.0001 * 0.0001) return -1;\n  return _ir.sub(p).lengthSq();\n}\nclass ElementInputEvent {\n  constructor(event, element, camera) {\n    this.event = event;\n    this.element = element;\n    this.camera = camera;\n    this._stopPropagation = false;\n  }\n  stopPropagation() {\n    this._stopPropagation = true;\n    if (this.event) {\n      this.event.stopImmediatePropagation();\n      this.event.stopPropagation();\n    }\n  }\n}\nclass ElementMouseEvent extends ElementInputEvent {\n  constructor(event, element, camera, x, y, lastX, lastY) {\n    super(event, element, camera);\n    this.x = x;\n    this.y = y;\n    this.ctrlKey = event.ctrlKey || false;\n    this.altKey = event.altKey || false;\n    this.shiftKey = event.shiftKey || false;\n    this.metaKey = event.metaKey || false;\n    this.button = event.button;\n    if (_platform_input_mouse_js__WEBPACK_IMPORTED_MODULE_3__.Mouse.isPointerLocked()) {\n      this.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;\n      this.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;\n    } else {\n      this.dx = x - lastX;\n      this.dy = y - lastY;\n    }\n    this.wheelDelta = 0;\n    if (event.type === 'wheel') {\n      if (event.deltaY > 0) {\n        this.wheelDelta = 1;\n      } else if (event.deltaY < 0) {\n        this.wheelDelta = -1;\n      }\n    }\n  }\n}\nclass ElementTouchEvent extends ElementInputEvent {\n  constructor(event, element, camera, x, y, touch) {\n    super(event, element, camera);\n    this.touches = event.touches;\n    this.changedTouches = event.changedTouches;\n    this.x = x;\n    this.y = y;\n    this.touch = touch;\n  }\n}\nclass ElementSelectEvent extends ElementInputEvent {\n  constructor(event, element, camera, inputSource) {\n    super(event, element, camera);\n    this.inputSource = inputSource;\n  }\n}\nclass ElementInput {\n  constructor(domElement, options) {\n    this._app = null;\n    this._attached = false;\n    this._target = null;\n    this._enabled = true;\n    this._lastX = 0;\n    this._lastY = 0;\n    this._upHandler = this._handleUp.bind(this);\n    this._downHandler = this._handleDown.bind(this);\n    this._moveHandler = this._handleMove.bind(this);\n    this._wheelHandler = this._handleWheel.bind(this);\n    this._touchstartHandler = this._handleTouchStart.bind(this);\n    this._touchendHandler = this._handleTouchEnd.bind(this);\n    this._touchcancelHandler = this._touchendHandler;\n    this._touchmoveHandler = this._handleTouchMove.bind(this);\n    this._sortHandler = this._sortElements.bind(this);\n    this._elements = [];\n    this._hoveredElement = null;\n    this._pressedElement = null;\n    this._touchedElements = {};\n    this._touchesForWhichTouchLeaveHasFired = {};\n    this._selectedElements = {};\n    this._selectedPressedElements = {};\n    this._useMouse = !options || options.useMouse !== false;\n    this._useTouch = !options || options.useTouch !== false;\n    this._useXr = !options || options.useXr !== false;\n    this._selectEventsAttached = false;\n    if (_core_platform_js__WEBPACK_IMPORTED_MODULE_4__.platform.touch) this._clickedEntities = {};\n    this.attach(domElement);\n  }\n  set enabled(value) {\n    this._enabled = value;\n  }\n  get enabled() {\n    return this._enabled;\n  }\n  set app(value) {\n    this._app = value;\n  }\n  get app() {\n    return this._app || (0,_globals_js__WEBPACK_IMPORTED_MODULE_5__.getApplication)();\n  }\n  attach(domElement) {\n    if (this._attached) {\n      this._attached = false;\n      this.detach();\n    }\n    this._target = domElement;\n    this._attached = true;\n    const opts = _core_platform_js__WEBPACK_IMPORTED_MODULE_4__.platform.passiveEvents ? {\n      passive: true\n    } : false;\n    if (this._useMouse) {\n      window.addEventListener('mouseup', this._upHandler, opts);\n      window.addEventListener('mousedown', this._downHandler, opts);\n      window.addEventListener('mousemove', this._moveHandler, opts);\n      window.addEventListener('wheel', this._wheelHandler, opts);\n    }\n    if (this._useTouch && _core_platform_js__WEBPACK_IMPORTED_MODULE_4__.platform.touch) {\n      this._target.addEventListener('touchstart', this._touchstartHandler, opts);\n      this._target.addEventListener('touchend', this._touchendHandler, false);\n      this._target.addEventListener('touchmove', this._touchmoveHandler, false);\n      this._target.addEventListener('touchcancel', this._touchcancelHandler, false);\n    }\n    this.attachSelectEvents();\n  }\n  attachSelectEvents() {\n    if (!this._selectEventsAttached && this._useXr && this.app && this.app.xr && this.app.xr.supported) {\n      if (!this._clickedEntities) this._clickedEntities = {};\n      this._selectEventsAttached = true;\n      this.app.xr.on('start', this._onXrStart, this);\n    }\n  }\n  detach() {\n    if (!this._attached) return;\n    this._attached = false;\n    const opts = _core_platform_js__WEBPACK_IMPORTED_MODULE_4__.platform.passiveEvents ? {\n      passive: true\n    } : false;\n    if (this._useMouse) {\n      window.removeEventListener('mouseup', this._upHandler, opts);\n      window.removeEventListener('mousedown', this._downHandler, opts);\n      window.removeEventListener('mousemove', this._moveHandler, opts);\n      window.removeEventListener('wheel', this._wheelHandler, opts);\n    }\n    if (this._useTouch) {\n      this._target.removeEventListener('touchstart', this._touchstartHandler, opts);\n      this._target.removeEventListener('touchend', this._touchendHandler, false);\n      this._target.removeEventListener('touchmove', this._touchmoveHandler, false);\n      this._target.removeEventListener('touchcancel', this._touchcancelHandler, false);\n    }\n    if (this._selectEventsAttached) {\n      this._selectEventsAttached = false;\n      this.app.xr.off('start', this._onXrStart, this);\n      this.app.xr.off('end', this._onXrEnd, this);\n      this.app.xr.off('update', this._onXrUpdate, this);\n      this.app.xr.input.off('selectstart', this._onSelectStart, this);\n      this.app.xr.input.off('selectend', this._onSelectEnd, this);\n      this.app.xr.input.off('remove', this._onXrInputRemove, this);\n    }\n    this._target = null;\n  }\n  addElement(element) {\n    if (this._elements.indexOf(element) === -1) this._elements.push(element);\n  }\n  removeElement(element) {\n    const idx = this._elements.indexOf(element);\n    if (idx !== -1) this._elements.splice(idx, 1);\n  }\n  _handleUp(event) {\n    if (!this._enabled) return;\n    if (_platform_input_mouse_js__WEBPACK_IMPORTED_MODULE_3__.Mouse.isPointerLocked()) return;\n    this._calcMouseCoords(event);\n    this._onElementMouseEvent('mouseup', event);\n  }\n  _handleDown(event) {\n    if (!this._enabled) return;\n    if (_platform_input_mouse_js__WEBPACK_IMPORTED_MODULE_3__.Mouse.isPointerLocked()) return;\n    this._calcMouseCoords(event);\n    this._onElementMouseEvent('mousedown', event);\n  }\n  _handleMove(event) {\n    if (!this._enabled) return;\n    this._calcMouseCoords(event);\n    this._onElementMouseEvent('mousemove', event);\n    this._lastX = targetX;\n    this._lastY = targetY;\n  }\n  _handleWheel(event) {\n    if (!this._enabled) return;\n    this._calcMouseCoords(event);\n    this._onElementMouseEvent('mousewheel', event);\n  }\n  _determineTouchedElements(event) {\n    const touchedElements = {};\n    const cameras = this.app.systems.camera.cameras;\n    for (let i = cameras.length - 1; i >= 0; i--) {\n      const camera = cameras[i];\n      let done = 0;\n      const len = event.changedTouches.length;\n      for (let j = 0; j < len; j++) {\n        if (touchedElements[event.changedTouches[j].identifier]) {\n          done++;\n          continue;\n        }\n        const coords = this._calcTouchCoords(event.changedTouches[j]);\n        const element = this._getTargetElementByCoords(camera, coords.x, coords.y);\n        if (element) {\n          done++;\n          touchedElements[event.changedTouches[j].identifier] = {\n            element: element,\n            camera: camera,\n            x: coords.x,\n            y: coords.y\n          };\n        }\n      }\n      if (done === len) {\n        break;\n      }\n    }\n    return touchedElements;\n  }\n  _handleTouchStart(event) {\n    if (!this._enabled) return;\n    const newTouchedElements = this._determineTouchedElements(event);\n    for (let i = 0, len = event.changedTouches.length; i < len; i++) {\n      const touch = event.changedTouches[i];\n      const newTouchInfo = newTouchedElements[touch.identifier];\n      const oldTouchInfo = this._touchedElements[touch.identifier];\n      if (newTouchInfo && (!oldTouchInfo || newTouchInfo.element !== oldTouchInfo.element)) {\n        this._fireEvent(event.type, new ElementTouchEvent(event, newTouchInfo.element, newTouchInfo.camera, newTouchInfo.x, newTouchInfo.y, touch));\n        this._touchesForWhichTouchLeaveHasFired[touch.identifier] = false;\n      }\n    }\n    for (const touchId in newTouchedElements) {\n      this._touchedElements[touchId] = newTouchedElements[touchId];\n    }\n  }\n  _handleTouchEnd(event) {\n    if (!this._enabled) return;\n    const cameras = this.app.systems.camera.cameras;\n    for (const key in this._clickedEntities) {\n      delete this._clickedEntities[key];\n    }\n    for (let i = 0, len = event.changedTouches.length; i < len; i++) {\n      const touch = event.changedTouches[i];\n      const touchInfo = this._touchedElements[touch.identifier];\n      if (!touchInfo) continue;\n      const element = touchInfo.element;\n      const camera = touchInfo.camera;\n      const x = touchInfo.x;\n      const y = touchInfo.y;\n      delete this._touchedElements[touch.identifier];\n      delete this._touchesForWhichTouchLeaveHasFired[touch.identifier];\n      this._fireEvent(event.type, new ElementTouchEvent(event, element, camera, x, y, touch));\n      const coords = this._calcTouchCoords(touch);\n      for (let c = cameras.length - 1; c >= 0; c--) {\n        const hovered = this._getTargetElementByCoords(cameras[c], coords.x, coords.y);\n        if (hovered === element) {\n          if (!this._clickedEntities[element.entity.getGuid()]) {\n            this._fireEvent('click', new ElementTouchEvent(event, element, camera, x, y, touch));\n            this._clickedEntities[element.entity.getGuid()] = Date.now();\n          }\n        }\n      }\n    }\n  }\n  _handleTouchMove(event) {\n    event.preventDefault();\n    if (!this._enabled) return;\n    const newTouchedElements = this._determineTouchedElements(event);\n    for (let i = 0, len = event.changedTouches.length; i < len; i++) {\n      const touch = event.changedTouches[i];\n      const newTouchInfo = newTouchedElements[touch.identifier];\n      const oldTouchInfo = this._touchedElements[touch.identifier];\n      if (oldTouchInfo) {\n        const coords = this._calcTouchCoords(touch);\n        if ((!newTouchInfo || newTouchInfo.element !== oldTouchInfo.element) && !this._touchesForWhichTouchLeaveHasFired[touch.identifier]) {\n          this._fireEvent('touchleave', new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, touch));\n          this._touchesForWhichTouchLeaveHasFired[touch.identifier] = true;\n        }\n        this._fireEvent('touchmove', new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, touch));\n      }\n    }\n  }\n  _onElementMouseEvent(eventType, event) {\n    let element = null;\n    const lastHovered = this._hoveredElement;\n    this._hoveredElement = null;\n    const cameras = this.app.systems.camera.cameras;\n    let camera;\n    for (let i = cameras.length - 1; i >= 0; i--) {\n      camera = cameras[i];\n      element = this._getTargetElementByCoords(camera, targetX, targetY);\n      if (element) break;\n    }\n    this._hoveredElement = element;\n    if ((eventType === 'mousemove' || eventType === 'mouseup') && this._pressedElement) {\n      this._fireEvent(eventType, new ElementMouseEvent(event, this._pressedElement, camera, targetX, targetY, this._lastX, this._lastY));\n    } else if (element) {\n      this._fireEvent(eventType, new ElementMouseEvent(event, element, camera, targetX, targetY, this._lastX, this._lastY));\n      if (eventType === 'mousedown') {\n        this._pressedElement = element;\n      }\n    }\n    if (lastHovered !== this._hoveredElement) {\n      if (lastHovered) {\n        this._fireEvent('mouseleave', new ElementMouseEvent(event, lastHovered, camera, targetX, targetY, this._lastX, this._lastY));\n      }\n      if (this._hoveredElement) {\n        this._fireEvent('mouseenter', new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));\n      }\n    }\n    if (eventType === 'mouseup' && this._pressedElement) {\n      if (this._pressedElement === this._hoveredElement) {\n        const guid = this._hoveredElement.entity.getGuid();\n        let fireClick = !this._clickedEntities;\n        if (this._clickedEntities) {\n          const lastTouchUp = this._clickedEntities[guid] || 0;\n          const dt = Date.now() - lastTouchUp;\n          fireClick = dt > 300;\n          delete this._clickedEntities[guid];\n        }\n        if (fireClick) {\n          this._fireEvent('click', new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));\n        }\n      }\n      this._pressedElement = null;\n    }\n  }\n  _onXrStart() {\n    this.app.xr.on('end', this._onXrEnd, this);\n    this.app.xr.on('update', this._onXrUpdate, this);\n    this.app.xr.input.on('selectstart', this._onSelectStart, this);\n    this.app.xr.input.on('selectend', this._onSelectEnd, this);\n    this.app.xr.input.on('remove', this._onXrInputRemove, this);\n  }\n  _onXrEnd() {\n    this.app.xr.off('update', this._onXrUpdate, this);\n    this.app.xr.input.off('selectstart', this._onSelectStart, this);\n    this.app.xr.input.off('selectend', this._onSelectEnd, this);\n    this.app.xr.input.off('remove', this._onXrInputRemove, this);\n  }\n  _onXrUpdate() {\n    if (!this._enabled) return;\n    const inputSources = this.app.xr.input.inputSources;\n    for (let i = 0; i < inputSources.length; i++) {\n      this._onElementSelectEvent('selectmove', inputSources[i], null);\n    }\n  }\n  _onXrInputRemove(inputSource) {\n    const hovered = this._selectedElements[inputSource.id];\n    if (hovered) {\n      inputSource._elementEntity = null;\n      this._fireEvent('selectleave', new ElementSelectEvent(null, hovered, null, inputSource));\n    }\n    delete this._selectedElements[inputSource.id];\n    delete this._selectedPressedElements[inputSource.id];\n  }\n  _onSelectStart(inputSource, event) {\n    if (!this._enabled) return;\n    this._onElementSelectEvent('selectstart', inputSource, event);\n  }\n  _onSelectEnd(inputSource, event) {\n    if (!this._enabled) return;\n    this._onElementSelectEvent('selectend', inputSource, event);\n  }\n  _onElementSelectEvent(eventType, inputSource, event) {\n    let element;\n    const hoveredBefore = this._selectedElements[inputSource.id];\n    let hoveredNow;\n    const cameras = this.app.systems.camera.cameras;\n    let camera;\n    if (inputSource.elementInput) {\n      rayC.set(inputSource.getOrigin(), inputSource.getDirection());\n      for (let i = cameras.length - 1; i >= 0; i--) {\n        camera = cameras[i];\n        element = this._getTargetElementByRay(rayC, camera);\n        if (element) break;\n      }\n    }\n    inputSource._elementEntity = element || null;\n    if (element) {\n      this._selectedElements[inputSource.id] = element;\n      hoveredNow = element;\n    } else {\n      delete this._selectedElements[inputSource.id];\n    }\n    if (hoveredBefore !== hoveredNow) {\n      if (hoveredBefore) this._fireEvent('selectleave', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));\n      if (hoveredNow) this._fireEvent('selectenter', new ElementSelectEvent(event, hoveredNow, camera, inputSource));\n    }\n    if (eventType === 'selectstart') {\n      this._selectedPressedElements[inputSource.id] = hoveredNow;\n      if (hoveredNow) this._fireEvent('selectstart', new ElementSelectEvent(event, hoveredNow, camera, inputSource));\n    }\n    const pressed = this._selectedPressedElements[inputSource.id];\n    if (!inputSource.elementInput && pressed) {\n      delete this._selectedPressedElements[inputSource.id];\n      if (hoveredBefore) this._fireEvent('selectend', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));\n    }\n    if (eventType === 'selectend' && inputSource.elementInput) {\n      delete this._selectedPressedElements[inputSource.id];\n      if (hoveredBefore) this._fireEvent('selectend', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));\n      if (pressed && pressed === hoveredBefore) {\n        this._fireEvent('click', new ElementSelectEvent(event, pressed, camera, inputSource));\n      }\n    }\n  }\n  _fireEvent(name, evt) {\n    let element = evt.element;\n    while (true) {\n      element.fire(name, evt);\n      if (evt._stopPropagation) break;\n      if (!element.entity.parent) break;\n      element = element.entity.parent.element;\n      if (!element) break;\n    }\n  }\n  _calcMouseCoords(event) {\n    const rect = this._target.getBoundingClientRect();\n    const left = Math.floor(rect.left);\n    const top = Math.floor(rect.top);\n    targetX = event.clientX - left;\n    targetY = event.clientY - top;\n  }\n  _calcTouchCoords(touch) {\n    let totalOffsetX = 0;\n    let totalOffsetY = 0;\n    let target = touch.target;\n    while (!(target instanceof HTMLElement)) {\n      target = target.parentNode;\n    }\n    let currentElement = target;\n    do {\n      totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;\n      totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;\n      currentElement = currentElement.offsetParent;\n    } while (currentElement);\n    return {\n      x: touch.pageX - totalOffsetX,\n      y: touch.pageY - totalOffsetY\n    };\n  }\n  _sortElements(a, b) {\n    const layerOrder = this.app.scene.layers.sortTransparentLayers(a.layers, b.layers);\n    if (layerOrder !== 0) return layerOrder;\n    if (a.screen && !b.screen) return -1;\n    if (!a.screen && b.screen) return 1;\n    if (!a.screen && !b.screen) return 0;\n    if (a.screen.screen.screenSpace && !b.screen.screen.screenSpace) return -1;\n    if (b.screen.screen.screenSpace && !a.screen.screen.screenSpace) return 1;\n    return b.drawOrder - a.drawOrder;\n  }\n  _getTargetElementByCoords(camera, x, y) {\n    const rayScreen = this._calculateRayScreen(x, y, camera, rayA) ? rayA : null;\n    const ray3d = this._calculateRay3d(x, y, camera, rayB) ? rayB : null;\n    return this._getTargetElement(camera, rayScreen, ray3d);\n  }\n  _getTargetElementByRay(ray, camera) {\n    rayA.origin.copy(ray.origin);\n    rayA.direction.copy(ray.direction);\n    rayA.end.copy(rayA.direction).mulScalar(camera.farClip * 2).add(rayA.origin);\n    const ray3d = rayA;\n    const screenPos = camera.worldToScreen(ray3d.origin, vecA);\n    const rayScreen = this._calculateRayScreen(screenPos.x, screenPos.y, camera, rayB) ? rayB : null;\n    return this._getTargetElement(camera, rayScreen, ray3d);\n  }\n  _getTargetElement(camera, rayScreen, ray3d) {\n    let result = null;\n    let closestDistance3d = Infinity;\n    this._elements.sort(this._sortHandler);\n    for (let i = 0, len = this._elements.length; i < len; i++) {\n      const element = this._elements[i];\n      if (!element.layers.some(v => camera.layersSet.has(v))) {\n        continue;\n      }\n      if (element.screen && element.screen.screen.screenSpace) {\n        if (!rayScreen) {\n          continue;\n        }\n        const currentDistance = this._checkElement(rayScreen, element, true);\n        if (currentDistance >= 0) {\n          result = element;\n          break;\n        }\n      } else {\n        if (!ray3d) {\n          continue;\n        }\n        const currentDistance = this._checkElement(ray3d, element, false);\n        if (currentDistance >= 0) {\n          if (currentDistance < closestDistance3d) {\n            result = element;\n            closestDistance3d = currentDistance;\n          }\n          if (element.screen) {\n            result = element;\n            break;\n          }\n        }\n      }\n    }\n    return result;\n  }\n  _calculateRayScreen(x, y, camera, ray) {\n    const sw = this.app.graphicsDevice.width;\n    const sh = this.app.graphicsDevice.height;\n    const cameraWidth = camera.rect.z * sw;\n    const cameraHeight = camera.rect.w * sh;\n    const cameraLeft = camera.rect.x * sw;\n    const cameraRight = cameraLeft + cameraWidth;\n    const cameraBottom = (1 - camera.rect.y) * sh;\n    const cameraTop = cameraBottom - cameraHeight;\n    let _x = x * sw / this._target.clientWidth;\n    let _y = y * sh / this._target.clientHeight;\n    if (_x >= cameraLeft && _x <= cameraRight && _y <= cameraBottom && _y >= cameraTop) {\n      _x = sw * (_x - cameraLeft) / cameraWidth;\n      _y = sh * (_y - cameraTop) / cameraHeight;\n      _y = sh - _y;\n      ray.origin.set(_x, _y, 1);\n      ray.direction.set(0, 0, -1);\n      ray.end.copy(ray.direction).mulScalar(2).add(ray.origin);\n      return true;\n    }\n    return false;\n  }\n  _calculateRay3d(x, y, camera, ray) {\n    const sw = this._target.clientWidth;\n    const sh = this._target.clientHeight;\n    const cameraWidth = camera.rect.z * sw;\n    const cameraHeight = camera.rect.w * sh;\n    const cameraLeft = camera.rect.x * sw;\n    const cameraRight = cameraLeft + cameraWidth;\n    const cameraBottom = (1 - camera.rect.y) * sh;\n    const cameraTop = cameraBottom - cameraHeight;\n    let _x = x;\n    let _y = y;\n    if (x >= cameraLeft && x <= cameraRight && y <= cameraBottom && _y >= cameraTop) {\n      _x = sw * (_x - cameraLeft) / cameraWidth;\n      _y = sh * (_y - cameraTop) / cameraHeight;\n      camera.screenToWorld(_x, _y, camera.nearClip, vecA);\n      camera.screenToWorld(_x, _y, camera.farClip, vecB);\n      ray.origin.copy(vecA);\n      ray.direction.set(0, 0, -1);\n      ray.end.copy(vecB);\n      return true;\n    }\n    return false;\n  }\n  _checkElement(ray, element, screen) {\n    if (element.maskedBy) {\n      if (this._checkElement(ray, element.maskedBy.element, screen) < 0) {\n        return -1;\n      }\n    }\n    let scale;\n    if (screen) {\n      scale = ElementInput.calculateScaleToScreen(element);\n    } else {\n      scale = ElementInput.calculateScaleToWorld(element);\n    }\n    const corners = ElementInput.buildHitCorners(element, screen ? element.screenCorners : element.worldCorners, scale);\n    return intersectLineQuad(ray.origin, ray.end, corners);\n  }\n  static buildHitCorners(element, screenOrWorldCorners, scale) {\n    let hitCorners = screenOrWorldCorners;\n    const button = element.entity && element.entity.button;\n    if (button) {\n      const hitPadding = element.entity.button.hitPadding || ZERO_VEC4;\n      _paddingTop.copy(element.entity.up);\n      _paddingBottom.copy(_paddingTop).mulScalar(-1);\n      _paddingRight.copy(element.entity.right);\n      _paddingLeft.copy(_paddingRight).mulScalar(-1);\n      _paddingTop.mulScalar(hitPadding.w * scale.y);\n      _paddingBottom.mulScalar(hitPadding.y * scale.y);\n      _paddingRight.mulScalar(hitPadding.z * scale.x);\n      _paddingLeft.mulScalar(hitPadding.x * scale.x);\n      _cornerBottomLeft.copy(hitCorners[0]).add(_paddingBottom).add(_paddingLeft);\n      _cornerBottomRight.copy(hitCorners[1]).add(_paddingBottom).add(_paddingRight);\n      _cornerTopRight.copy(hitCorners[2]).add(_paddingTop).add(_paddingRight);\n      _cornerTopLeft.copy(hitCorners[3]).add(_paddingTop).add(_paddingLeft);\n      hitCorners = [_cornerBottomLeft, _cornerBottomRight, _cornerTopRight, _cornerTopLeft];\n    }\n    if (scale.x < 0) {\n      const left = hitCorners[2].x;\n      const right = hitCorners[0].x;\n      hitCorners[0].x = left;\n      hitCorners[1].x = right;\n      hitCorners[2].x = right;\n      hitCorners[3].x = left;\n    }\n    if (scale.y < 0) {\n      const bottom = hitCorners[2].y;\n      const top = hitCorners[0].y;\n      hitCorners[0].y = bottom;\n      hitCorners[1].y = bottom;\n      hitCorners[2].y = top;\n      hitCorners[3].y = top;\n    }\n    if (scale.z < 0) {\n      const x = hitCorners[2].x;\n      const y = hitCorners[2].y;\n      const z = hitCorners[2].z;\n      hitCorners[2].x = hitCorners[0].x;\n      hitCorners[2].y = hitCorners[0].y;\n      hitCorners[2].z = hitCorners[0].z;\n      hitCorners[0].x = x;\n      hitCorners[0].y = y;\n      hitCorners[0].z = z;\n    }\n    return hitCorners;\n  }\n  static calculateScaleToScreen(element) {\n    let current = element.entity;\n    const screenScale = element.screen.screen.scale;\n    _accumulatedScale.set(screenScale, screenScale, screenScale);\n    while (current && !current.screen) {\n      _accumulatedScale.mul(current.getLocalScale());\n      current = current.parent;\n    }\n    return _accumulatedScale;\n  }\n  static calculateScaleToWorld(element) {\n    let current = element.entity;\n    _accumulatedScale.set(1, 1, 1);\n    while (current) {\n      _accumulatedScale.mul(current.getLocalScale());\n      current = current.parent;\n    }\n    return _accumulatedScale;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/input/element-input.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/lightmapper/bake-light-ambient.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/lightmapper/bake-light-ambient.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BakeLightAmbient\": () => (/* binding */ BakeLightAmbient)\n/* harmony export */ });\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_math_random_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/math/random.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/random.js\");\n/* harmony import */ var _core_math_color_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/math/color.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n/* harmony import */ var _entity_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../entity.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/entity.js\");\n/* harmony import */ var _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../scene/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _bake_light_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bake-light.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/lightmapper/bake-light.js\");\n\n\n\n\n\n\n\nconst _tempPoint = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nclass BakeLightAmbient extends _bake_light_js__WEBPACK_IMPORTED_MODULE_1__.BakeLight {\n  constructor(scene) {\n    const lightEntity = new _entity_js__WEBPACK_IMPORTED_MODULE_2__.Entity('AmbientLight');\n    lightEntity.addComponent('light', {\n      type: 'directional',\n      affectDynamic: true,\n      affectLightmapped: false,\n      bake: true,\n      bakeNumSamples: scene.ambientBakeNumSamples,\n      castShadows: true,\n      normalOffsetBias: 0.05,\n      shadowBias: 0.2,\n      shadowDistance: 1,\n      shadowResolution: 2048,\n      shadowType: _scene_constants_js__WEBPACK_IMPORTED_MODULE_3__.SHADOW_PCF3,\n      color: _core_math_color_js__WEBPACK_IMPORTED_MODULE_4__.Color.WHITE,\n      intensity: 1,\n      bakeDir: false\n    });\n    super(scene, lightEntity.light.light);\n  }\n  get numVirtualLights() {\n    return this.light.bakeNumSamples;\n  }\n  prepareVirtualLight(index, numVirtualLights) {\n    _core_math_random_js__WEBPACK_IMPORTED_MODULE_5__.random.spherePointDeterministic(_tempPoint, index, numVirtualLights, 0, this.scene.ambientBakeSpherePart);\n    this.light._node.lookAt(_tempPoint.mulScalar(-1));\n    this.light._node.rotateLocal(90, 0, 0);\n    const gamma = this.scene.gammaCorrection ? 2.2 : 1;\n    const fullIntensity = 2 * Math.PI * this.scene.ambientBakeSpherePart;\n    const linearIntensity = Math.pow(fullIntensity, gamma);\n    this.light.intensity = Math.pow(linearIntensity / numVirtualLights, 1 / gamma);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/lightmapper/bake-light-ambient.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/lightmapper/bake-light-simple.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/lightmapper/bake-light-simple.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BakeLightSimple\": () => (/* binding */ BakeLightSimple)\n/* harmony export */ });\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _core_math_random_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/math/random.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/random.js\");\n/* harmony import */ var _scene_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../scene/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _bake_light_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bake-light.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/lightmapper/bake-light.js\");\n\n\n\n\n\nconst _tempPoint = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_0__.Vec2();\nclass BakeLightSimple extends _bake_light_js__WEBPACK_IMPORTED_MODULE_1__.BakeLight {\n  get numVirtualLights() {\n    if (this.light.type === _scene_constants_js__WEBPACK_IMPORTED_MODULE_2__.LIGHTTYPE_DIRECTIONAL) {\n      return this.light.bakeNumSamples;\n    }\n    return 1;\n  }\n  prepareVirtualLight(index, numVirtualLights) {\n    const light = this.light;\n    light._node.setLocalRotation(this.rotation);\n    if (index > 0) {\n      const directionalSpreadAngle = light.bakeArea;\n      _core_math_random_js__WEBPACK_IMPORTED_MODULE_3__.random.circlePointDeterministic(_tempPoint, index, numVirtualLights);\n      _tempPoint.mulScalar(directionalSpreadAngle * 0.5);\n      light._node.rotateLocal(_tempPoint.x, 0, _tempPoint.y);\n    }\n    light._node.getWorldTransform();\n    const gamma = this.scene.gammaCorrection ? 2.2 : 1;\n    const linearIntensity = Math.pow(this.intensity, gamma);\n    light.intensity = Math.pow(linearIntensity / numVirtualLights, 1 / gamma);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/lightmapper/bake-light-simple.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/lightmapper/bake-light.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/lightmapper/bake-light.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BakeLight\": () => (/* binding */ BakeLight)\n/* harmony export */ });\n/* harmony import */ var _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/shape/bounding-box.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/shape/bounding-box.js\");\n/* harmony import */ var _core_shape_bounding_sphere_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/shape/bounding-sphere.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/shape/bounding-sphere.js\");\n/* harmony import */ var _scene_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../scene/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n\n\n\n\nconst tempSphere = new _core_shape_bounding_sphere_js__WEBPACK_IMPORTED_MODULE_0__.BoundingSphere();\nclass BakeLight {\n  constructor(scene, light) {\n    this.scene = scene;\n    this.light = light;\n    this.store();\n    light.numCascades = 1;\n    if (light.type !== _scene_constants_js__WEBPACK_IMPORTED_MODULE_1__.LIGHTTYPE_DIRECTIONAL) {\n      light._node.getWorldTransform();\n      light.getBoundingSphere(tempSphere);\n      this.lightBounds = new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_2__.BoundingBox();\n      this.lightBounds.center.copy(tempSphere.center);\n      this.lightBounds.halfExtents.set(tempSphere.radius, tempSphere.radius, tempSphere.radius);\n    }\n  }\n  store() {\n    this.mask = this.light.mask;\n    this.shadowUpdateMode = this.light.shadowUpdateMode;\n    this.enabled = this.light.enabled;\n    this.intensity = this.light.intensity;\n    this.rotation = this.light._node.getLocalRotation().clone();\n    this.numCascades = this.light.numCascades;\n  }\n  restore() {\n    const light = this.light;\n    light.mask = this.mask;\n    light.shadowUpdateMode = this.shadowUpdateMode;\n    light.enabled = this.enabled;\n    light.intensity = this.intensity;\n    light._node.setLocalRotation(this.rotation);\n    light.numCascades = this.numCascades;\n  }\n  startBake() {\n    this.light.enabled = true;\n    this.light._destroyShadowMap();\n    this.light.beginFrame();\n  }\n  endBake(shadowMapCache) {\n    const light = this.light;\n    light.enabled = false;\n    if (light.shadowMap) {\n      if (light.shadowMap.cached) shadowMapCache.add(light, light.shadowMap);\n      light.shadowMap = null;\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/lightmapper/bake-light.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/lightmapper/bake-mesh-node.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/lightmapper/bake-mesh-node.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BakeMeshNode\": () => (/* binding */ BakeMeshNode)\n/* harmony export */ });\nclass BakeMeshNode {\n  constructor(node, meshInstances = null) {\n    this.node = node;\n    this.component = node.render || node.model;\n    meshInstances = meshInstances || this.component.meshInstances;\n    this.store();\n    this.meshInstances = meshInstances;\n    this.bounds = null;\n    this.renderTargets = [];\n  }\n  store() {\n    this.castShadows = this.component.castShadows;\n  }\n  restore() {\n    this.component.castShadows = this.castShadows;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/lightmapper/bake-mesh-node.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/lightmapper/lightmap-filters.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/lightmapper/lightmap-filters.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LightmapFilters\": () => (/* binding */ LightmapFilters)\n/* harmony export */ });\n/* harmony import */ var _scene_shader_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../scene/shader-lib/utils.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/utils.js\");\n/* harmony import */ var _scene_shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../scene/shader-lib/chunks/chunks.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/chunks.js\");\n/* harmony import */ var _scene_shader_lib_chunks_chunks_lightmapper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../scene/shader-lib/chunks/chunks-lightmapper.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/chunks-lightmapper.js\");\n\n\n\n\nconst DENOISE_FILTER_SIZE = 15;\nclass LightmapFilters {\n  constructor(device) {\n    this.device = device;\n    this.shaderDilate = (0,_scene_shader_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.createShaderFromCode)(device, _scene_shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_1__.shaderChunks.fullscreenQuadVS, _scene_shader_lib_chunks_chunks_lightmapper_js__WEBPACK_IMPORTED_MODULE_2__.shaderChunksLightmapper.dilatePS, 'lmDilate');\n    this.constantTexSource = device.scope.resolve('source');\n    this.constantPixelOffset = device.scope.resolve('pixelOffset');\n    this.pixelOffset = new Float32Array(2);\n    this.shaderDenoise = null;\n    this.sigmas = null;\n    this.constantSigmas = null;\n    this.kernel = null;\n  }\n  setSourceTexture(texture) {\n    this.constantTexSource.setValue(texture);\n  }\n  prepare(textureWidth, textureHeight) {\n    this.pixelOffset[0] = 1 / textureWidth;\n    this.pixelOffset[1] = 1 / textureHeight;\n    this.constantPixelOffset.setValue(this.pixelOffset);\n  }\n  prepareDenoise(filterRange, filterSmoothness) {\n    if (!this.shaderDenoise) {\n      this.shaderDenoise = (0,_scene_shader_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.createShaderFromCode)(this.device, _scene_shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_1__.shaderChunks.fullscreenQuadVS, _scene_shader_lib_chunks_chunks_lightmapper_js__WEBPACK_IMPORTED_MODULE_2__.shaderChunksLightmapper.bilateralDeNoisePS, 'lmBilateralDeNoise');\n      this.sigmas = new Float32Array(2);\n      this.constantSigmas = this.device.scope.resolve('sigmas');\n      this.constantKernel = this.device.scope.resolve('kernel[0]');\n      this.bZnorm = this.device.scope.resolve('bZnorm');\n    }\n    this.sigmas[0] = filterRange;\n    this.sigmas[1] = filterSmoothness;\n    this.constantSigmas.setValue(this.sigmas);\n    this.evaluateDenoiseUniforms(filterRange, filterSmoothness);\n  }\n  evaluateDenoiseUniforms(filterRange, filterSmoothness) {\n    function normpdf(x, sigma) {\n      return 0.39894 * Math.exp(-0.5 * x * x / (sigma * sigma)) / sigma;\n    }\n    this.kernel = this.kernel || new Float32Array(DENOISE_FILTER_SIZE);\n    const kernel = this.kernel;\n    const kSize = Math.floor((DENOISE_FILTER_SIZE - 1) / 2);\n    for (let j = 0; j <= kSize; ++j) {\n      const value = normpdf(j, filterRange);\n      kernel[kSize + j] = value;\n      kernel[kSize - j] = value;\n    }\n    this.constantKernel.setValue(this.kernel);\n    const bZnorm = 1 / normpdf(0.0, filterSmoothness);\n    this.bZnorm.setValue(bZnorm);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/lightmapper/lightmap-filters.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/lightmapper/lightmapper.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/lightmapper/lightmapper.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Lightmapper\": () => (/* binding */ Lightmapper)\n/* harmony export */ });\n/* harmony import */ var _core_time_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../core/time.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/time.js\");\n/* harmony import */ var _core_math_color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/math/color.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../../core/shape/bounding-box.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/shape/bounding-box.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_render_target_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../platform/graphics/render-target.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/render-target.js\");\n/* harmony import */ var _platform_graphics_simple_post_effect_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../../platform/graphics/simple-post-effect.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/simple-post-effect.js\");\n/* harmony import */ var _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../platform/graphics/texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js\");\n/* harmony import */ var _scene_mesh_instance_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../scene/mesh-instance.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh-instance.js\");\n/* harmony import */ var _scene_lighting_lighting_params_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../scene/lighting/lighting-params.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/lighting/lighting-params.js\");\n/* harmony import */ var _scene_lighting_world_clusters_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../scene/lighting/world-clusters.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/lighting/world-clusters.js\");\n/* harmony import */ var _scene_shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../scene/shader-lib/chunks/chunks.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/chunks.js\");\n/* harmony import */ var _scene_shader_lib_chunks_chunks_lightmapper_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../scene/shader-lib/chunks/chunks-lightmapper.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/chunks-lightmapper.js\");\n/* harmony import */ var _scene_constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../scene/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _scene_camera_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../scene/camera.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/camera.js\");\n/* harmony import */ var _scene_graph_node_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../scene/graph-node.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/graph-node.js\");\n/* harmony import */ var _scene_materials_standard_material_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../scene/materials/standard-material.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material.js\");\n/* harmony import */ var _bake_light_simple_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./bake-light-simple.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/lightmapper/bake-light-simple.js\");\n/* harmony import */ var _bake_light_ambient_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./bake-light-ambient.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/lightmapper/bake-light-ambient.js\");\n/* harmony import */ var _bake_mesh_node_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./bake-mesh-node.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/lightmapper/bake-mesh-node.js\");\n/* harmony import */ var _scene_graphics_lightmap_cache_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../scene/graphics/lightmap-cache.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/graphics/lightmap-cache.js\");\n/* harmony import */ var _lightmap_filters_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lightmap-filters.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/lightmapper/lightmap-filters.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst MAX_LIGHTMAP_SIZE = 2048;\nconst PASS_COLOR = 0;\nconst PASS_DIR = 1;\nconst tempVec = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nclass Lightmapper {\n  constructor(device, root, scene, renderer, assets) {\n    this.device = device;\n    this.root = root;\n    this.scene = scene;\n    this.renderer = renderer;\n    this.assets = assets;\n    this.shadowMapCache = renderer.shadowMapCache;\n    this._tempSet = new Set();\n    this._initCalled = false;\n    this.passMaterials = [];\n    this.ambientAOMaterial = null;\n    this.fog = '';\n    this.ambientLight = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_1__.Color();\n    this.renderTargets = new Map();\n    this.stats = {\n      renderPasses: 0,\n      lightmapCount: 0,\n      totalRenderTime: 0,\n      forwardTime: 0,\n      fboTime: 0,\n      shadowMapTime: 0,\n      compileTime: 0,\n      shadersLinked: 0\n    };\n  }\n  destroy() {\n    _scene_graphics_lightmap_cache_js__WEBPACK_IMPORTED_MODULE_2__.LightmapCache.decRef(this.blackTex);\n    this.blackTex = null;\n    _scene_graphics_lightmap_cache_js__WEBPACK_IMPORTED_MODULE_2__.LightmapCache.destroy();\n    this.device = null;\n    this.root = null;\n    this.scene = null;\n    this.renderer = null;\n    this.assets = null;\n  }\n  initBake(device) {\n    if (!this._initCalled) {\n      this._initCalled = true;\n      this.lightmapFilters = new _lightmap_filters_js__WEBPACK_IMPORTED_MODULE_3__.LightmapFilters(device);\n      this.constantBakeDir = device.scope.resolve('bakeDir');\n      this.materials = [];\n      this.blackTex = new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_4__.Texture(this.device, {\n        width: 4,\n        height: 4,\n        format: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.PIXELFORMAT_RGBA8,\n        type: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.TEXTURETYPE_RGBM,\n        name: 'lightmapBlack'\n      });\n      _scene_graphics_lightmap_cache_js__WEBPACK_IMPORTED_MODULE_2__.LightmapCache.incRef(this.blackTex);\n      const camera = new _scene_camera_js__WEBPACK_IMPORTED_MODULE_6__.Camera();\n      camera.clearColor.set(0, 0, 0, 0);\n      camera.clearColorBuffer = true;\n      camera.clearDepthBuffer = false;\n      camera.clearStencilBuffer = false;\n      camera.frustumCulling = false;\n      camera.projection = _scene_constants_js__WEBPACK_IMPORTED_MODULE_7__.PROJECTION_ORTHOGRAPHIC;\n      camera.aspectRatio = 1;\n      camera.node = new _scene_graph_node_js__WEBPACK_IMPORTED_MODULE_8__.GraphNode();\n      this.camera = camera;\n    }\n    if (this.scene.clusteredLightingEnabled) {\n      const lightingParams = new _scene_lighting_lighting_params_js__WEBPACK_IMPORTED_MODULE_9__.LightingParams(device.supportsAreaLights, device.maxTextureSize, () => {});\n      this.lightingParams = lightingParams;\n      const srcParams = this.scene.lighting;\n      lightingParams.shadowsEnabled = srcParams.shadowsEnabled;\n      lightingParams.shadowAtlasResolution = srcParams.shadowAtlasResolution;\n      lightingParams.cookiesEnabled = srcParams.cookiesEnabled;\n      lightingParams.cookieAtlasResolution = srcParams.cookieAtlasResolution;\n      lightingParams.areaLightsEnabled = srcParams.areaLightsEnabled;\n      lightingParams.cells = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(3, 3, 3);\n      lightingParams.maxLightsPerCell = 4;\n      this.worldClusters = new _scene_lighting_world_clusters_js__WEBPACK_IMPORTED_MODULE_10__.WorldClusters(device);\n      this.worldClusters.name = 'ClusterLightmapper';\n    }\n  }\n  finishBake(bakeNodes) {\n    this.materials = [];\n    function destroyRT(rt) {\n      _scene_graphics_lightmap_cache_js__WEBPACK_IMPORTED_MODULE_2__.LightmapCache.decRef(rt.colorBuffer);\n      rt.destroy();\n    }\n    this.renderTargets.forEach(rt => {\n      destroyRT(rt);\n    });\n    this.renderTargets.clear();\n    bakeNodes.forEach(node => {\n      node.renderTargets.forEach(rt => {\n        destroyRT(rt);\n      });\n      node.renderTargets.length = 0;\n    });\n    this.ambientAOMaterial = null;\n    if (this.worldClusters) {\n      this.worldClusters.destroy();\n      this.worldClusters = null;\n    }\n  }\n  createMaterialForPass(device, scene, pass, addAmbient) {\n    const material = new _scene_materials_standard_material_js__WEBPACK_IMPORTED_MODULE_11__.StandardMaterial();\n    material.name = `lmMaterial-pass:${pass}-ambient:${addAmbient}`;\n    material.chunks.APIVersion = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.CHUNKAPI_1_55;\n    material.chunks.transformVS = '#define UV1LAYOUT\\n' + _scene_shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_12__.shaderChunks.transformVS;\n    if (pass === PASS_COLOR) {\n      let bakeLmEndChunk = _scene_shader_lib_chunks_chunks_lightmapper_js__WEBPACK_IMPORTED_MODULE_13__.shaderChunksLightmapper.bakeLmEndPS;\n      if (addAmbient) {\n        bakeLmEndChunk = `\n                    dDiffuseLight = ((dDiffuseLight - 0.5) * max(${scene.ambientBakeOcclusionContrast.toFixed(1)} + 1.0, 0.0)) + 0.5;\n                    dDiffuseLight += vec3(${scene.ambientBakeOcclusionBrightness.toFixed(1)});\n                    dDiffuseLight = saturate(dDiffuseLight);\n                    dDiffuseLight *= dAmbientLight;\n                ` + bakeLmEndChunk;\n      } else {\n        material.ambient = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_1__.Color(0, 0, 0);\n        material.ambientTint = true;\n      }\n      material.chunks.basePS = _scene_shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_12__.shaderChunks.basePS + (scene.lightmapPixelFormat === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.PIXELFORMAT_RGBA8 ? '\\n#define LIGHTMAP_RGBM\\n' : '');\n      material.chunks.endPS = bakeLmEndChunk;\n      material.lightMap = this.blackTex;\n    } else {\n      material.chunks.basePS = _scene_shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_12__.shaderChunks.basePS + '\\nuniform sampler2D texture_dirLightMap;\\nuniform float bakeDir;\\n';\n      material.chunks.endPS = _scene_shader_lib_chunks_chunks_lightmapper_js__WEBPACK_IMPORTED_MODULE_13__.shaderChunksLightmapper.bakeDirLmEndPS;\n    }\n    material.chunks.outputAlphaPS = '\\n';\n    material.chunks.outputAlphaOpaquePS = '\\n';\n    material.chunks.outputAlphaPremulPS = '\\n';\n    material.cull = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.CULLFACE_NONE;\n    material.forceUv1 = true;\n    material.update();\n    return material;\n  }\n  createMaterials(device, scene, passCount) {\n    for (let pass = 0; pass < passCount; pass++) {\n      if (!this.passMaterials[pass]) {\n        this.passMaterials[pass] = this.createMaterialForPass(device, scene, pass, false);\n      }\n    }\n    if (!this.ambientAOMaterial) {\n      this.ambientAOMaterial = this.createMaterialForPass(device, scene, 0, true);\n      this.ambientAOMaterial.onUpdateShader = function (options) {\n        options.litOptions.lightMapWithoutAmbient = true;\n        options.litOptions.separateAmbient = true;\n        return options;\n      };\n    }\n  }\n  createTexture(size, name) {\n    return new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_4__.Texture(this.device, {\n      width: size,\n      height: size,\n      format: this.scene.lightmapPixelFormat,\n      mipmaps: false,\n      type: this.scene.lightmapPixelFormat === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.PIXELFORMAT_RGBA8 ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.TEXTURETYPE_RGBM : _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.TEXTURETYPE_DEFAULT,\n      minFilter: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.FILTER_NEAREST,\n      magFilter: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.FILTER_NEAREST,\n      addressU: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.ADDRESS_CLAMP_TO_EDGE,\n      addressV: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.ADDRESS_CLAMP_TO_EDGE,\n      name: name\n    });\n  }\n  collectModels(node, bakeNodes, allNodes) {\n    var _node$model, _node$model2, _node$render;\n    if (!node.enabled) return;\n    let meshInstances;\n    if ((_node$model = node.model) != null && _node$model.model && (_node$model2 = node.model) != null && _node$model2.enabled) {\n      if (allNodes) allNodes.push(new _bake_mesh_node_js__WEBPACK_IMPORTED_MODULE_14__.BakeMeshNode(node));\n      if (node.model.lightmapped) {\n        if (bakeNodes) {\n          meshInstances = node.model.model.meshInstances;\n        }\n      }\n    }\n    if ((_node$render = node.render) != null && _node$render.enabled) {\n      if (allNodes) allNodes.push(new _bake_mesh_node_js__WEBPACK_IMPORTED_MODULE_14__.BakeMeshNode(node));\n      if (node.render.lightmapped) {\n        if (bakeNodes) {\n          meshInstances = node.render.meshInstances;\n        }\n      }\n    }\n    if (meshInstances) {\n      let hasUv1 = true;\n      for (let i = 0; i < meshInstances.length; i++) {\n        if (!meshInstances[i].mesh.vertexBuffer.format.hasUv1) {\n          hasUv1 = false;\n          break;\n        }\n      }\n      if (hasUv1) {\n        const notInstancedMeshInstances = [];\n        for (let i = 0; i < meshInstances.length; i++) {\n          const mesh = meshInstances[i].mesh;\n          if (this._tempSet.has(mesh)) {\n            bakeNodes.push(new _bake_mesh_node_js__WEBPACK_IMPORTED_MODULE_14__.BakeMeshNode(node, [meshInstances[i]]));\n          } else {\n            notInstancedMeshInstances.push(meshInstances[i]);\n          }\n          this._tempSet.add(mesh);\n        }\n        this._tempSet.clear();\n        if (notInstancedMeshInstances.length > 0) {\n          bakeNodes.push(new _bake_mesh_node_js__WEBPACK_IMPORTED_MODULE_14__.BakeMeshNode(node, notInstancedMeshInstances));\n        }\n      }\n    }\n    for (let i = 0; i < node._children.length; i++) {\n      this.collectModels(node._children[i], bakeNodes, allNodes);\n    }\n  }\n  prepareShadowCasters(nodes) {\n    const casters = [];\n    for (let n = 0; n < nodes.length; n++) {\n      const component = nodes[n].component;\n      component.castShadows = component.castShadowsLightmap;\n      if (component.castShadowsLightmap) {\n        const meshes = nodes[n].meshInstances;\n        for (let i = 0; i < meshes.length; i++) {\n          meshes[i].visibleThisFrame = true;\n          casters.push(meshes[i]);\n        }\n      }\n    }\n    return casters;\n  }\n  updateTransforms(nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const meshInstances = nodes[i].meshInstances;\n      for (let j = 0; j < meshInstances.length; j++) {\n        meshInstances[j].node.getWorldTransform();\n      }\n    }\n  }\n  calculateLightmapSize(node) {\n    let data;\n    const sizeMult = this.scene.lightmapSizeMultiplier || 16;\n    const scale = tempVec;\n    let srcArea, lightmapSizeMultiplier;\n    if (node.model) {\n      lightmapSizeMultiplier = node.model.lightmapSizeMultiplier;\n      if (node.model.asset) {\n        data = this.assets.get(node.model.asset).data;\n        if (data.area) {\n          srcArea = data.area;\n        }\n      } else if (node.model._area) {\n        data = node.model;\n        if (data._area) {\n          srcArea = data._area;\n        }\n      }\n    } else if (node.render) {\n      lightmapSizeMultiplier = node.render.lightmapSizeMultiplier;\n      if (node.render.type !== 'asset') {\n        if (node.render._area) {\n          data = node.render;\n          if (data._area) {\n            srcArea = data._area;\n          }\n        }\n      }\n    }\n    const area = {\n      x: 1,\n      y: 1,\n      z: 1,\n      uv: 1\n    };\n    if (srcArea) {\n      area.x = srcArea.x;\n      area.y = srcArea.y;\n      area.z = srcArea.z;\n      area.uv = srcArea.uv;\n    }\n    const areaMult = lightmapSizeMultiplier || 1;\n    area.x *= areaMult;\n    area.y *= areaMult;\n    area.z *= areaMult;\n    const component = node.render || node.model;\n    const bounds = this.computeNodeBounds(component.meshInstances);\n    scale.copy(bounds.halfExtents);\n    let totalArea = area.x * scale.y * scale.z + area.y * scale.x * scale.z + area.z * scale.x * scale.y;\n    totalArea /= area.uv;\n    totalArea = Math.sqrt(totalArea);\n    const lightmapSize = Math.min(_core_math_math_js__WEBPACK_IMPORTED_MODULE_15__.math.nextPowerOfTwo(totalArea * sizeMult), this.scene.lightmapMaxResolution || MAX_LIGHTMAP_SIZE);\n    return lightmapSize;\n  }\n  setLightmapping(nodes, value, passCount, shaderDefs) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      const meshInstances = node.meshInstances;\n      for (let j = 0; j < meshInstances.length; j++) {\n        const meshInstance = meshInstances[j];\n        meshInstance.setLightmapped(value);\n        if (value) {\n          if (shaderDefs) {\n            meshInstance._shaderDefs |= shaderDefs;\n          }\n          meshInstance.mask = _scene_constants_js__WEBPACK_IMPORTED_MODULE_7__.MASK_AFFECT_LIGHTMAPPED;\n          for (let pass = 0; pass < passCount; pass++) {\n            const tex = node.renderTargets[pass].colorBuffer;\n            tex.minFilter = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.FILTER_LINEAR;\n            tex.magFilter = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.FILTER_LINEAR;\n            meshInstance.setRealtimeLightmap(_scene_mesh_instance_js__WEBPACK_IMPORTED_MODULE_16__.MeshInstance.lightmapParamNames[pass], tex);\n          }\n        }\n      }\n    }\n  }\n  bake(nodes, mode = _scene_constants_js__WEBPACK_IMPORTED_MODULE_7__.BAKE_COLORDIR) {\n    const device = this.device;\n    const startTime = (0,_core_time_js__WEBPACK_IMPORTED_MODULE_17__.now)();\n    this.scene._updateSky(device);\n    this.stats.renderPasses = 0;\n    this.stats.shadowMapTime = 0;\n    this.stats.forwardTime = 0;\n    const startShaders = device._shaderStats.linked;\n    const startFboTime = device._renderTargetCreationTime;\n    const startCompileTime = device._shaderStats.compileTime;\n    const bakeNodes = [];\n    const allNodes = [];\n    if (nodes) {\n      for (let i = 0; i < nodes.length; i++) {\n        this.collectModels(nodes[i], bakeNodes, null);\n      }\n      this.collectModels(this.root, null, allNodes);\n    } else {\n      this.collectModels(this.root, bakeNodes, allNodes);\n    }\n    if (bakeNodes.length > 0) {\n      const passCount = mode === _scene_constants_js__WEBPACK_IMPORTED_MODULE_7__.BAKE_COLORDIR ? 2 : 1;\n      this.setLightmapping(bakeNodes, false, passCount);\n      this.initBake(device);\n      this.bakeInternal(passCount, bakeNodes, allNodes);\n      let shaderDefs = _scene_constants_js__WEBPACK_IMPORTED_MODULE_7__.SHADERDEF_LM;\n      if (mode === _scene_constants_js__WEBPACK_IMPORTED_MODULE_7__.BAKE_COLORDIR) {\n        shaderDefs |= _scene_constants_js__WEBPACK_IMPORTED_MODULE_7__.SHADERDEF_DIRLM;\n      }\n      if (this.scene.ambientBake) {\n        shaderDefs |= _scene_constants_js__WEBPACK_IMPORTED_MODULE_7__.SHADERDEF_LMAMBIENT;\n      }\n      this.setLightmapping(bakeNodes, true, passCount, shaderDefs);\n      this.finishBake(bakeNodes);\n    }\n    const nowTime = (0,_core_time_js__WEBPACK_IMPORTED_MODULE_17__.now)();\n    this.stats.totalRenderTime = nowTime - startTime;\n    this.stats.shadersLinked = device._shaderStats.linked - startShaders;\n    this.stats.compileTime = device._shaderStats.compileTime - startCompileTime;\n    this.stats.fboTime = device._renderTargetCreationTime - startFboTime;\n    this.stats.lightmapCount = bakeNodes.length;\n  }\n  allocateTextures(bakeNodes, passCount) {\n    for (let i = 0; i < bakeNodes.length; i++) {\n      const bakeNode = bakeNodes[i];\n      const size = this.calculateLightmapSize(bakeNode.node);\n      for (let pass = 0; pass < passCount; pass++) {\n        const tex = this.createTexture(size, 'lightmapper_lightmap_' + i);\n        _scene_graphics_lightmap_cache_js__WEBPACK_IMPORTED_MODULE_2__.LightmapCache.incRef(tex);\n        bakeNode.renderTargets[pass] = new _platform_graphics_render_target_js__WEBPACK_IMPORTED_MODULE_18__.RenderTarget({\n          colorBuffer: tex,\n          depth: false\n        });\n      }\n      if (!this.renderTargets.has(size)) {\n        const tex = this.createTexture(size, 'lightmapper_temp_lightmap_' + size);\n        _scene_graphics_lightmap_cache_js__WEBPACK_IMPORTED_MODULE_2__.LightmapCache.incRef(tex);\n        this.renderTargets.set(size, new _platform_graphics_render_target_js__WEBPACK_IMPORTED_MODULE_18__.RenderTarget({\n          colorBuffer: tex,\n          depth: false\n        }));\n      }\n    }\n  }\n  prepareLightsToBake(layerComposition, allLights, bakeLights) {\n    if (this.scene.ambientBake) {\n      const ambientLight = new _bake_light_ambient_js__WEBPACK_IMPORTED_MODULE_19__.BakeLightAmbient(this.scene);\n      bakeLights.push(ambientLight);\n    }\n    const sceneLights = layerComposition._lights;\n    for (let i = 0; i < sceneLights.length; i++) {\n      const light = sceneLights[i];\n      const bakeLight = new _bake_light_simple_js__WEBPACK_IMPORTED_MODULE_20__.BakeLightSimple(this.scene, light);\n      allLights.push(bakeLight);\n      if (light.enabled && (light.mask & _scene_constants_js__WEBPACK_IMPORTED_MODULE_7__.MASK_BAKE) !== 0) {\n        light.isStatic = false;\n        light.mask = 0xFFFFFFFF;\n        light.shadowUpdateMode = light.type === _scene_constants_js__WEBPACK_IMPORTED_MODULE_7__.LIGHTTYPE_DIRECTIONAL ? _scene_constants_js__WEBPACK_IMPORTED_MODULE_7__.SHADOWUPDATE_REALTIME : _scene_constants_js__WEBPACK_IMPORTED_MODULE_7__.SHADOWUPDATE_THISFRAME;\n        bakeLights.push(bakeLight);\n      }\n    }\n    bakeLights.sort();\n  }\n  restoreLights(allLights) {\n    for (let i = 0; i < allLights.length; i++) {\n      allLights[i].restore();\n    }\n  }\n  setupScene() {\n    this.revertStatic = false;\n    if (this.scene._needsStaticPrepare) {\n      this.scene._needsStaticPrepare = false;\n      this.revertStatic = true;\n    }\n    this.fog = this.scene.fog;\n    this.ambientLight.copy(this.scene.ambientLight);\n    this.scene.fog = _scene_constants_js__WEBPACK_IMPORTED_MODULE_7__.FOG_NONE;\n    if (!this.scene.ambientBake) {\n      this.scene.ambientLight.set(0, 0, 0);\n    }\n    this.renderer.setSceneConstants();\n  }\n  restoreScene() {\n    this.scene.fog = this.fog;\n    this.scene.ambientLight.copy(this.ambientLight);\n    if (this.revertStatic) {\n      this.scene._needsStaticPrepare = true;\n    }\n  }\n  computeNodeBounds(meshInstances) {\n    const bounds = new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_21__.BoundingBox();\n    if (meshInstances.length > 0) {\n      bounds.copy(meshInstances[0].aabb);\n      for (let m = 1; m < meshInstances.length; m++) {\n        bounds.add(meshInstances[m].aabb);\n      }\n    }\n    return bounds;\n  }\n  computeNodesBounds(nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const meshInstances = nodes[i].meshInstances;\n      nodes[i].bounds = this.computeNodeBounds(meshInstances);\n    }\n  }\n  computeBounds(meshInstances) {\n    const bounds = new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_21__.BoundingBox();\n    for (let i = 0; i < meshInstances.length; i++) {\n      bounds.copy(meshInstances[0].aabb);\n      for (let m = 1; m < meshInstances.length; m++) {\n        bounds.add(meshInstances[m].aabb);\n      }\n    }\n    return bounds;\n  }\n  backupMaterials(meshInstances) {\n    for (let i = 0; i < meshInstances.length; i++) {\n      this.materials[i] = meshInstances[i].material;\n    }\n  }\n  restoreMaterials(meshInstances) {\n    for (let i = 0; i < meshInstances.length; i++) {\n      meshInstances[i].material = this.materials[i];\n    }\n  }\n  lightCameraPrepare(device, bakeLight) {\n    const light = bakeLight.light;\n    let shadowCam;\n    if (light.type === _scene_constants_js__WEBPACK_IMPORTED_MODULE_7__.LIGHTTYPE_SPOT) {\n      const lightRenderData = light.getRenderData(null, 0);\n      shadowCam = lightRenderData.shadowCamera;\n      shadowCam._node.setPosition(light._node.getPosition());\n      shadowCam._node.setRotation(light._node.getRotation());\n      shadowCam._node.rotateLocal(-90, 0, 0);\n      shadowCam.projection = _scene_constants_js__WEBPACK_IMPORTED_MODULE_7__.PROJECTION_PERSPECTIVE;\n      shadowCam.nearClip = light.attenuationEnd / 1000;\n      shadowCam.farClip = light.attenuationEnd;\n      shadowCam.aspectRatio = 1;\n      shadowCam.fov = light._outerConeAngle * 2;\n      this.renderer.updateCameraFrustum(shadowCam);\n    }\n    return shadowCam;\n  }\n  lightCameraPrepareAndCull(bakeLight, bakeNode, shadowCam, casterBounds) {\n    const light = bakeLight.light;\n    let lightAffectsNode = true;\n    if (light.type === _scene_constants_js__WEBPACK_IMPORTED_MODULE_7__.LIGHTTYPE_DIRECTIONAL) {\n      tempVec.copy(casterBounds.center);\n      tempVec.y += casterBounds.halfExtents.y;\n      this.camera.node.setPosition(tempVec);\n      this.camera.node.setEulerAngles(-90, 0, 0);\n      this.camera.nearClip = 0;\n      this.camera.farClip = casterBounds.halfExtents.y * 2;\n      const frustumSize = Math.max(casterBounds.halfExtents.x, casterBounds.halfExtents.z);\n      this.camera.orthoHeight = frustumSize;\n    } else {\n      if (!bakeLight.lightBounds.intersects(bakeNode.bounds)) {\n        lightAffectsNode = false;\n      }\n    }\n    if (light.type === _scene_constants_js__WEBPACK_IMPORTED_MODULE_7__.LIGHTTYPE_SPOT) {\n      let nodeVisible = false;\n      const meshInstances = bakeNode.meshInstances;\n      for (let i = 0; i < meshInstances.length; i++) {\n        if (meshInstances[i]._isVisible(shadowCam)) {\n          nodeVisible = true;\n          break;\n        }\n      }\n      if (!nodeVisible) {\n        lightAffectsNode = false;\n      }\n    }\n    return lightAffectsNode;\n  }\n  setupLightArray(lightArray, light) {\n    lightArray[_scene_constants_js__WEBPACK_IMPORTED_MODULE_7__.LIGHTTYPE_DIRECTIONAL].length = 0;\n    lightArray[_scene_constants_js__WEBPACK_IMPORTED_MODULE_7__.LIGHTTYPE_OMNI].length = 0;\n    lightArray[_scene_constants_js__WEBPACK_IMPORTED_MODULE_7__.LIGHTTYPE_SPOT].length = 0;\n    lightArray[light.type][0] = light;\n    light.visibleThisFrame = true;\n  }\n  renderShadowMap(shadowMapRendered, casters, lightArray, bakeLight) {\n    const light = bakeLight.light;\n    if (!shadowMapRendered && light.castShadows) {\n      if (!light.shadowMap && !this.scene.clusteredLightingEnabled) {\n        light.shadowMap = this.shadowMapCache.get(this.device, light);\n      }\n      if (light.type === _scene_constants_js__WEBPACK_IMPORTED_MODULE_7__.LIGHTTYPE_DIRECTIONAL) {\n        this.renderer._shadowRendererDirectional.cull(light, casters, this.camera);\n        this.renderer.shadowRenderer.render(light, this.camera);\n      } else {\n        this.renderer._shadowRendererLocal.cull(light, casters);\n        this.renderer.renderShadowsLocal(lightArray[light.type], this.camera);\n      }\n    }\n    return true;\n  }\n  postprocessTextures(device, bakeNodes, passCount) {\n    const numDilates2x = 1;\n    const dilateShader = this.lightmapFilters.shaderDilate;\n    const filterLightmap = this.scene.lightmapFilterEnabled;\n    if (filterLightmap) {\n      this.lightmapFilters.prepareDenoise(this.scene.lightmapFilterRange, this.scene.lightmapFilterSmoothness);\n    }\n    for (let node = 0; node < bakeNodes.length; node++) {\n      const bakeNode = bakeNodes[node];\n      for (let pass = 0; pass < passCount; pass++) {\n        const nodeRT = bakeNode.renderTargets[pass];\n        const lightmap = nodeRT.colorBuffer;\n        const tempRT = this.renderTargets.get(lightmap.width);\n        const tempTex = tempRT.colorBuffer;\n        this.lightmapFilters.prepare(lightmap.width, lightmap.height);\n        for (let i = 0; i < numDilates2x; i++) {\n          this.lightmapFilters.setSourceTexture(lightmap);\n          const bilateralFilterEnabled = filterLightmap && pass === 0 && i === 0;\n          (0,_platform_graphics_simple_post_effect_js__WEBPACK_IMPORTED_MODULE_22__.drawQuadWithShader)(device, tempRT, bilateralFilterEnabled ? this.lightmapFilters.shaderDenoise : dilateShader);\n          this.lightmapFilters.setSourceTexture(tempTex);\n          (0,_platform_graphics_simple_post_effect_js__WEBPACK_IMPORTED_MODULE_22__.drawQuadWithShader)(device, nodeRT, dilateShader);\n        }\n      }\n    }\n  }\n  bakeInternal(passCount, bakeNodes, allNodes) {\n    const scene = this.scene;\n    const device = this.device;\n    const clusteredLightingEnabled = scene.clusteredLightingEnabled;\n    this.createMaterials(device, scene, passCount);\n    this.setupScene();\n    scene.layers._update();\n    this.computeNodesBounds(bakeNodes);\n    this.allocateTextures(bakeNodes, passCount);\n    const allLights = [],\n      bakeLights = [];\n    this.prepareLightsToBake(scene.layers, allLights, bakeLights);\n    this.updateTransforms(allNodes);\n    const casters = this.prepareShadowCasters(allNodes);\n    this.renderer.updateCpuSkinMatrices(casters);\n    this.renderer.gpuUpdate(casters);\n    const casterBounds = this.computeBounds(casters);\n    let i, j, rcv, m;\n    for (i = 0; i < bakeNodes.length; i++) {\n      const bakeNode = bakeNodes[i];\n      rcv = bakeNode.meshInstances;\n      for (j = 0; j < rcv.length; j++) {\n        m = rcv[j];\n        m.setLightmapped(false);\n        m.mask = _scene_constants_js__WEBPACK_IMPORTED_MODULE_7__.MASK_BAKE;\n        m.setRealtimeLightmap(_scene_mesh_instance_js__WEBPACK_IMPORTED_MODULE_16__.MeshInstance.lightmapParamNames[0], m.material.lightMap ? m.material.lightMap : this.blackTex);\n        m.setRealtimeLightmap(_scene_mesh_instance_js__WEBPACK_IMPORTED_MODULE_16__.MeshInstance.lightmapParamNames[1], this.blackTex);\n      }\n    }\n    for (j = 0; j < bakeLights.length; j++) {\n      bakeLights[j].light.enabled = false;\n    }\n    const lightArray = [[], [], []];\n    let pass, node;\n    let shadersUpdatedOn1stPass = false;\n    for (i = 0; i < bakeLights.length; i++) {\n      const bakeLight = bakeLights[i];\n      const isAmbientLight = bakeLight instanceof _bake_light_ambient_js__WEBPACK_IMPORTED_MODULE_19__.BakeLightAmbient;\n      let numVirtualLights = bakeLight.numVirtualLights;\n      if (passCount > 1 && numVirtualLights > 1 && bakeLight.light.bakeDir) {\n        numVirtualLights = 1;\n      }\n      for (let virtualLightIndex = 0; virtualLightIndex < numVirtualLights; virtualLightIndex++) {\n        if (numVirtualLights > 1) {\n          bakeLight.prepareVirtualLight(virtualLightIndex, numVirtualLights);\n        }\n        bakeLight.startBake();\n        let shadowMapRendered = false;\n        const shadowCam = this.lightCameraPrepare(device, bakeLight);\n        for (node = 0; node < bakeNodes.length; node++) {\n          const bakeNode = bakeNodes[node];\n          rcv = bakeNode.meshInstances;\n          const lightAffectsNode = this.lightCameraPrepareAndCull(bakeLight, bakeNode, shadowCam, casterBounds);\n          if (!lightAffectsNode) {\n            continue;\n          }\n          this.setupLightArray(lightArray, bakeLight.light);\n          if (clusteredLightingEnabled) {\n            this.renderer.lightTextureAtlas.update(lightArray[_scene_constants_js__WEBPACK_IMPORTED_MODULE_7__.LIGHTTYPE_SPOT], lightArray[_scene_constants_js__WEBPACK_IMPORTED_MODULE_7__.LIGHTTYPE_OMNI], this.lightingParams);\n          }\n          shadowMapRendered = this.renderShadowMap(shadowMapRendered, casters, lightArray, bakeLight);\n          if (clusteredLightingEnabled) {\n            const clusterLights = lightArray[_scene_constants_js__WEBPACK_IMPORTED_MODULE_7__.LIGHTTYPE_SPOT].concat(lightArray[_scene_constants_js__WEBPACK_IMPORTED_MODULE_7__.LIGHTTYPE_OMNI]);\n            this.worldClusters.update(clusterLights, this.scene.gammaCorrection, this.lightingParams);\n          }\n          this.backupMaterials(rcv);\n          for (pass = 0; pass < passCount; pass++) {\n            if (pass > 0 && virtualLightIndex > 0) {\n              break;\n            }\n            if (isAmbientLight && pass > 0) {\n              break;\n            }\n            const nodeRT = bakeNode.renderTargets[pass];\n            const lightmapSize = bakeNode.renderTargets[pass].colorBuffer.width;\n            const tempRT = this.renderTargets.get(lightmapSize);\n            const tempTex = tempRT.colorBuffer;\n            if (pass === 0) {\n              shadersUpdatedOn1stPass = scene.updateShaders;\n            } else if (shadersUpdatedOn1stPass) {\n              scene.updateShaders = true;\n            }\n            let passMaterial = this.passMaterials[pass];\n            if (isAmbientLight) {\n              const lastVirtualLightForPass = virtualLightIndex + 1 === numVirtualLights;\n              if (lastVirtualLightForPass && pass === 0) {\n                passMaterial = this.ambientAOMaterial;\n              }\n            }\n            for (j = 0; j < rcv.length; j++) {\n              rcv[j].material = passMaterial;\n            }\n            this.renderer.updateShaders(rcv);\n            this.renderer.setCamera(this.camera, tempRT, true);\n            if (pass === PASS_DIR) {\n              this.constantBakeDir.setValue(bakeLight.light.bakeDir ? 1 : 0);\n            }\n            if (clusteredLightingEnabled) {\n              this.worldClusters.activate(this.renderer.lightTextureAtlas);\n            }\n            this.renderer._forwardTime = 0;\n            this.renderer._shadowMapTime = 0;\n            this.renderer.renderForward(this.camera, rcv, rcv.length, lightArray, _scene_constants_js__WEBPACK_IMPORTED_MODULE_7__.SHADER_FORWARDHDR);\n            device.updateEnd();\n            bakeNode.renderTargets[pass] = tempRT;\n            this.renderTargets.set(lightmapSize, nodeRT);\n            for (j = 0; j < rcv.length; j++) {\n              m = rcv[j];\n              m.setRealtimeLightmap(_scene_mesh_instance_js__WEBPACK_IMPORTED_MODULE_16__.MeshInstance.lightmapParamNames[pass], tempTex);\n              m._shaderDefs |= _scene_constants_js__WEBPACK_IMPORTED_MODULE_7__.SHADERDEF_LM;\n            }\n          }\n          this.restoreMaterials(rcv);\n        }\n        bakeLight.endBake(this.shadowMapCache);\n      }\n    }\n    this.postprocessTextures(device, bakeNodes, passCount);\n    for (node = 0; node < allNodes.length; node++) {\n      allNodes[node].restore();\n    }\n    this.restoreLights(allLights);\n    this.restoreScene();\n    if (!clusteredLightingEnabled) {\n      this.shadowMapCache.clear();\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/lightmapper/lightmapper.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/glb-container-resource.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/glb-container-resource.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GlbContainerResource\": () => (/* binding */ GlbContainerResource)\n/* harmony export */ });\n/* harmony import */ var _scene_mesh_instance_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../scene/mesh-instance.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh-instance.js\");\n/* harmony import */ var _scene_model_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../scene/model.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/model.js\");\n/* harmony import */ var _scene_morph_instance_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../scene/morph-instance.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/morph-instance.js\");\n/* harmony import */ var _scene_skin_instance_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../scene/skin-instance.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/skin-instance.js\");\n/* harmony import */ var _scene_skin_instance_cache_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../scene/skin-instance-cache.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/skin-instance-cache.js\");\n/* harmony import */ var _entity_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../entity.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/entity.js\");\n/* harmony import */ var _asset_asset_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../asset/asset.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset.js\");\n\n\n\n\n\n\n\n\n\nclass GlbContainerResource {\n  constructor(data, asset, assets, defaultMaterial) {\n    const createAsset = function createAsset(type, resource, index) {\n      const subAsset = GlbContainerResource.createAsset(asset.name, type, resource, index);\n      assets.add(subAsset);\n      return subAsset;\n    };\n    const renders = [];\n    for (let i = 0; i < data.renders.length; ++i) {\n      renders.push(createAsset('render', data.renders[i], i));\n    }\n    const materials = [];\n    for (let i = 0; i < data.materials.length; ++i) {\n      materials.push(createAsset('material', data.materials[i], i));\n    }\n    const animations = [];\n    for (let i = 0; i < data.animations.length; ++i) {\n      animations.push(createAsset('animation', data.animations[i], i));\n    }\n    this.data = data;\n    this._model = null;\n    this._assetName = asset.name;\n    this._assets = assets;\n    this._defaultMaterial = defaultMaterial;\n    this.renders = renders;\n    this.materials = materials;\n    this.textures = data.textures;\n    this.animations = animations;\n  }\n  get model() {\n    if (!this._model) {\n      const model = GlbContainerResource.createModel(this.data, this._defaultMaterial);\n      const modelAsset = GlbContainerResource.createAsset(this._assetName, 'model', model, 0);\n      this._assets.add(modelAsset);\n      this._model = modelAsset;\n    }\n    return this._model;\n  }\n  static createAsset(assetName, type, resource, index) {\n    const subAsset = new _asset_asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset(assetName + '/' + type + '/' + index, type, {\n      url: ''\n    });\n    subAsset.resource = resource;\n    subAsset.loaded = true;\n    return subAsset;\n  }\n  instantiateModelEntity(options) {\n    const entity = new _entity_js__WEBPACK_IMPORTED_MODULE_1__.Entity();\n    entity.addComponent('model', Object.assign({\n      type: 'asset',\n      asset: this.model\n    }, options));\n    return entity;\n  }\n  instantiateRenderEntity(options) {\n    const defaultMaterial = this._defaultMaterial;\n    const skinnedMeshInstances = [];\n    const createMeshInstance = function createMeshInstance(root, entity, mesh, materials, meshDefaultMaterials, skins, gltfNode) {\n      const materialIndex = meshDefaultMaterials[mesh.id];\n      const material = materialIndex === undefined ? defaultMaterial : materials[materialIndex];\n      const meshInstance = new _scene_mesh_instance_js__WEBPACK_IMPORTED_MODULE_2__.MeshInstance(mesh, material);\n      if (mesh.morph) {\n        meshInstance.morphInstance = new _scene_morph_instance_js__WEBPACK_IMPORTED_MODULE_3__.MorphInstance(mesh.morph);\n      }\n      if (gltfNode.hasOwnProperty('skin')) {\n        skinnedMeshInstances.push({\n          meshInstance: meshInstance,\n          rootBone: root,\n          entity: entity\n        });\n      }\n      return meshInstance;\n    };\n    const cloneHierarchy = (root, node, glb) => {\n      const entity = new _entity_js__WEBPACK_IMPORTED_MODULE_1__.Entity();\n      node._cloneInternal(entity);\n      if (!root) root = entity;\n      let attachedMi = null;\n      let renderAsset = null;\n      for (let i = 0; i < glb.nodes.length; i++) {\n        const glbNode = glb.nodes[i];\n        if (glbNode === node) {\n          const gltfNode = glb.gltf.nodes[i];\n          if (gltfNode.hasOwnProperty('mesh')) {\n            const meshGroup = glb.renders[gltfNode.mesh].meshes;\n            renderAsset = this.renders[gltfNode.mesh];\n            for (var mi = 0; mi < meshGroup.length; mi++) {\n              const mesh = meshGroup[mi];\n              if (mesh) {\n                const cloneMi = createMeshInstance(root, entity, mesh, glb.materials, glb.meshDefaultMaterials, glb.skins, gltfNode);\n                if (!attachedMi) {\n                  attachedMi = [];\n                }\n                attachedMi.push(cloneMi);\n              }\n            }\n          }\n          if (glb.lights) {\n            const lightEntity = glb.lights.get(gltfNode);\n            if (lightEntity) {\n              entity.addChild(lightEntity.clone());\n            }\n          }\n          if (glb.cameras) {\n            const cameraEntity = glb.cameras.get(gltfNode);\n            if (cameraEntity) {\n              cameraEntity.camera.system.cloneComponent(cameraEntity, entity);\n            }\n          }\n        }\n      }\n      if (attachedMi) {\n        entity.addComponent('render', Object.assign({\n          type: 'asset',\n          meshInstances: attachedMi,\n          rootBone: root\n        }, options));\n        entity.render.assignAsset(renderAsset);\n      }\n      const children = node.children;\n      for (let i = 0; i < children.length; i++) {\n        const childClone = cloneHierarchy(root, children[i], glb);\n        entity.addChild(childClone);\n      }\n      return entity;\n    };\n    const sceneClones = [];\n    for (const scene of this.data.scenes) {\n      sceneClones.push(cloneHierarchy(null, scene, this.data));\n    }\n    skinnedMeshInstances.forEach(data => {\n      data.meshInstance.skinInstance = _scene_skin_instance_cache_js__WEBPACK_IMPORTED_MODULE_4__.SkinInstanceCache.createCachedSkinInstance(data.meshInstance.mesh.skin, data.rootBone, data.entity);\n    });\n    return GlbContainerResource.createSceneHierarchy(sceneClones, 'Entity');\n  }\n  getMaterialVariants() {\n    return this.data.variants ? Object.keys(this.data.variants) : [];\n  }\n  applyMaterialVariant(entity, name) {\n    const variant = name ? this.data.variants[name] : null;\n    if (variant === undefined) {\n      return;\n    }\n    const renders = entity.findComponents(\"render\");\n    for (let i = 0; i < renders.length; i++) {\n      const renderComponent = renders[i];\n      this._applyMaterialVariant(variant, renderComponent.meshInstances);\n    }\n  }\n  applyMaterialVariantInstances(instances, name) {\n    const variant = name ? this.data.variants[name] : null;\n    if (variant === undefined) {\n      return;\n    }\n    this._applyMaterialVariant(variant, instances);\n  }\n  _applyMaterialVariant(variant, instances) {\n    instances.forEach(instance => {\n      if (variant === null) {\n        instance.material = this._defaultMaterial;\n      } else {\n        const meshVariants = this.data.meshVariants[instance.mesh.id];\n        if (meshVariants) {\n          instance.material = this.data.materials[meshVariants[variant]];\n        }\n      }\n    });\n  }\n  static createSceneHierarchy(sceneNodes, nodeType) {\n    let root = null;\n    if (sceneNodes.length === 1) {\n      root = sceneNodes[0];\n    } else {\n      root = new nodeType('SceneGroup');\n      for (const scene of sceneNodes) {\n        root.addChild(scene);\n      }\n    }\n    return root;\n  }\n  static createModel(glb, defaultMaterial) {\n    const createMeshInstance = function createMeshInstance(model, mesh, skins, skinInstances, materials, node, gltfNode) {\n      const materialIndex = glb.meshDefaultMaterials[mesh.id];\n      const material = materialIndex === undefined ? defaultMaterial : materials[materialIndex];\n      const meshInstance = new _scene_mesh_instance_js__WEBPACK_IMPORTED_MODULE_2__.MeshInstance(mesh, material, node);\n      if (mesh.morph) {\n        const morphInstance = new _scene_morph_instance_js__WEBPACK_IMPORTED_MODULE_3__.MorphInstance(mesh.morph);\n        meshInstance.morphInstance = morphInstance;\n        model.morphInstances.push(morphInstance);\n      }\n      if (gltfNode.hasOwnProperty('skin')) {\n        const skinIndex = gltfNode.skin;\n        const skin = skins[skinIndex];\n        mesh.skin = skin;\n        const skinInstance = skinInstances[skinIndex];\n        meshInstance.skinInstance = skinInstance;\n        model.skinInstances.push(skinInstance);\n      }\n      model.meshInstances.push(meshInstance);\n    };\n    const model = new _scene_model_js__WEBPACK_IMPORTED_MODULE_5__.Model();\n    const skinInstances = [];\n    for (const skin of glb.skins) {\n      const skinInstance = new _scene_skin_instance_js__WEBPACK_IMPORTED_MODULE_6__.SkinInstance(skin);\n      skinInstance.bones = skin.bones;\n      skinInstances.push(skinInstance);\n    }\n    model.graph = GlbContainerResource.createSceneHierarchy(glb.scenes, 'GraphNode');\n    for (let i = 0; i < glb.nodes.length; i++) {\n      const node = glb.nodes[i];\n      if (node.root === model.graph) {\n        const gltfNode = glb.gltf.nodes[i];\n        if (gltfNode.hasOwnProperty('mesh')) {\n          const meshGroup = glb.renders[gltfNode.mesh].meshes;\n          for (var mi = 0; mi < meshGroup.length; mi++) {\n            const mesh = meshGroup[mi];\n            if (mesh) {\n              createMeshInstance(model, mesh, glb.skins, skinInstances, glb.materials, node, gltfNode);\n            }\n          }\n        }\n      }\n    }\n    return model;\n  }\n  destroy() {\n    const registry = this._assets;\n    const destroyAsset = function destroyAsset(asset) {\n      registry.remove(asset);\n      asset.unload();\n    };\n    const destroyAssets = function destroyAssets(assets) {\n      assets.forEach(function (asset) {\n        destroyAsset(asset);\n      });\n    };\n    if (this.animations) {\n      destroyAssets(this.animations);\n      this.animations = null;\n    }\n    if (this.textures) {\n      destroyAssets(this.textures);\n      this.textures = null;\n    }\n    if (this.materials) {\n      destroyAssets(this.materials);\n      this.materials = null;\n    }\n    if (this.renders) {\n      destroyAssets(this.renders);\n      this.renders = null;\n    }\n    if (this._model) {\n      destroyAsset(this._model);\n      this._model = null;\n    }\n    this.data = null;\n    this.assets = null;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/glb-container-resource.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/glb-model.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/glb-model.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GlbModelParser\": () => (/* binding */ GlbModelParser)\n/* harmony export */ });\n/* harmony import */ var _glb_container_resource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./glb-container-resource.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/glb-container-resource.js\");\n/* harmony import */ var _glb_parser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./glb-parser.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/glb-parser.js\");\n\n\n\nclass GlbModelParser {\n  constructor(device, defaultMaterial) {\n    this._device = device;\n    this._defaultMaterial = defaultMaterial;\n  }\n  parse(data) {\n    const glbResources = _glb_parser_js__WEBPACK_IMPORTED_MODULE_0__.GlbParser.parse('filename.glb', data, this._device);\n    if (glbResources) {\n      const model = _glb_container_resource_js__WEBPACK_IMPORTED_MODULE_1__.GlbContainerResource.createModel(glbResources, this._defaultMaterial);\n      glbResources.destroy();\n      return model;\n    }\n    return null;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/glb-model.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/glb-parser.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/glb-parser.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GlbParser\": () => (/* binding */ GlbParser)\n/* harmony export */ });\n/* harmony import */ var _core_path_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../../core/path.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/path.js\");\n/* harmony import */ var _core_wasm_module_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ../../core/wasm-module.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/wasm-module.js\");\n/* harmony import */ var _core_math_color_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../../core/math/color.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n/* harmony import */ var _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/math/mat4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js\");\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/shape/bounding-box.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/shape/bounding-box.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_index_buffer_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../platform/graphics/index-buffer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/index-buffer.js\");\n/* harmony import */ var _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../platform/graphics/texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js\");\n/* harmony import */ var _platform_graphics_vertex_buffer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../platform/graphics/vertex-buffer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/vertex-buffer.js\");\n/* harmony import */ var _platform_graphics_vertex_format_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../platform/graphics/vertex-format.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/vertex-format.js\");\n/* harmony import */ var _platform_net_http_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../../platform/net/http.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/net/http.js\");\n/* harmony import */ var _scene_constants_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../scene/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _scene_graph_node_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../../scene/graph-node.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/graph-node.js\");\n/* harmony import */ var _scene_light_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../../scene/light.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/light.js\");\n/* harmony import */ var _scene_mesh_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../scene/mesh.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh.js\");\n/* harmony import */ var _scene_morph_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../scene/morph.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/morph.js\");\n/* harmony import */ var _scene_morph_target_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../scene/morph-target.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/morph-target.js\");\n/* harmony import */ var _scene_procedural_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../scene/procedural.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/procedural.js\");\n/* harmony import */ var _scene_render_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../../scene/render.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/render.js\");\n/* harmony import */ var _scene_skin_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../scene/skin.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/skin.js\");\n/* harmony import */ var _scene_materials_standard_material_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../scene/materials/standard-material.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material.js\");\n/* harmony import */ var _entity_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../entity.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/entity.js\");\n/* harmony import */ var _anim_constants_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../anim/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/constants.js\");\n/* harmony import */ var _anim_evaluator_anim_curve_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../anim/evaluator/anim-curve.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-curve.js\");\n/* harmony import */ var _anim_evaluator_anim_data_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../anim/evaluator/anim-data.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-data.js\");\n/* harmony import */ var _anim_evaluator_anim_track_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../anim/evaluator/anim-track.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/anim/evaluator/anim-track.js\");\n/* harmony import */ var _asset_asset_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../asset/asset.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset.js\");\n/* harmony import */ var _glb_container_resource_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./glb-container-resource.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/glb-container-resource.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlet dracoDecoderInstance = null;\nconst getGlobalDracoDecoderModule = () => {\n  return typeof window !== 'undefined' && window.DracoDecoderModule;\n};\nclass GlbResources {\n  constructor(gltf) {\n    this.gltf = gltf;\n    this.nodes = null;\n    this.scenes = null;\n    this.animations = null;\n    this.textures = null;\n    this.materials = null;\n    this.variants = null;\n    this.meshVariants = null;\n    this.meshDefaultMaterials = null;\n    this.renders = null;\n    this.skins = null;\n    this.lights = null;\n    this.cameras = null;\n  }\n  destroy() {\n    if (this.renders) {\n      this.renders.forEach(render => {\n        render.meshes = null;\n      });\n    }\n  }\n}\nconst isDataURI = function isDataURI(uri) {\n  return /^data:.*,.*$/i.test(uri);\n};\nconst getDataURIMimeType = function getDataURIMimeType(uri) {\n  return uri.substring(uri.indexOf(':') + 1, uri.indexOf(';'));\n};\nconst getNumComponents = function getNumComponents(accessorType) {\n  switch (accessorType) {\n    case 'SCALAR':\n      return 1;\n    case 'VEC2':\n      return 2;\n    case 'VEC3':\n      return 3;\n    case 'VEC4':\n      return 4;\n    case 'MAT2':\n      return 4;\n    case 'MAT3':\n      return 9;\n    case 'MAT4':\n      return 16;\n    default:\n      return 3;\n  }\n};\nconst getComponentType = function getComponentType(componentType) {\n  switch (componentType) {\n    case 5120:\n      return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_INT8;\n    case 5121:\n      return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_UINT8;\n    case 5122:\n      return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_INT16;\n    case 5123:\n      return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_UINT16;\n    case 5124:\n      return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_INT32;\n    case 5125:\n      return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_UINT32;\n    case 5126:\n      return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_FLOAT32;\n    default:\n      return 0;\n  }\n};\nconst getComponentSizeInBytes = function getComponentSizeInBytes(componentType) {\n  switch (componentType) {\n    case 5120:\n      return 1;\n    case 5121:\n      return 1;\n    case 5122:\n      return 2;\n    case 5123:\n      return 2;\n    case 5124:\n      return 4;\n    case 5125:\n      return 4;\n    case 5126:\n      return 4;\n    default:\n      return 0;\n  }\n};\nconst getComponentDataType = function getComponentDataType(componentType) {\n  switch (componentType) {\n    case 5120:\n      return Int8Array;\n    case 5121:\n      return Uint8Array;\n    case 5122:\n      return Int16Array;\n    case 5123:\n      return Uint16Array;\n    case 5124:\n      return Int32Array;\n    case 5125:\n      return Uint32Array;\n    case 5126:\n      return Float32Array;\n    default:\n      return null;\n  }\n};\nconst gltfToEngineSemanticMap = {\n  'POSITION': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_POSITION,\n  'NORMAL': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_NORMAL,\n  'TANGENT': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TANGENT,\n  'COLOR_0': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_COLOR,\n  'JOINTS_0': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_BLENDINDICES,\n  'WEIGHTS_0': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_BLENDWEIGHT,\n  'TEXCOORD_0': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD0,\n  'TEXCOORD_1': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD1,\n  'TEXCOORD_2': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD2,\n  'TEXCOORD_3': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD3,\n  'TEXCOORD_4': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD4,\n  'TEXCOORD_5': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD5,\n  'TEXCOORD_6': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD6,\n  'TEXCOORD_7': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD7\n};\nconst getDequantizeFunc = srcType => {\n  switch (srcType) {\n    case _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_INT8:\n      return x => Math.max(x / 127.0, -1.0);\n    case _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_UINT8:\n      return x => x / 255.0;\n    case _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_INT16:\n      return x => Math.max(x / 32767.0, -1.0);\n    case _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_UINT16:\n      return x => x / 65535.0;\n    default:\n      return x => x;\n  }\n};\nconst dequantizeArray = function dequantizeArray(dstArray, srcArray, srcType) {\n  const convFunc = getDequantizeFunc(srcType);\n  const len = srcArray.length;\n  for (let i = 0; i < len; ++i) {\n    dstArray[i] = convFunc(srcArray[i]);\n  }\n  return dstArray;\n};\nconst getAccessorData = function getAccessorData(gltfAccessor, bufferViews, flatten = false) {\n  const numComponents = getNumComponents(gltfAccessor.type);\n  const dataType = getComponentDataType(gltfAccessor.componentType);\n  if (!dataType) {\n    return null;\n  }\n  const bufferView = bufferViews[gltfAccessor.bufferView];\n  let result;\n  if (gltfAccessor.sparse) {\n    const sparse = gltfAccessor.sparse;\n    const indicesAccessor = {\n      count: sparse.count,\n      type: 'SCALAR'\n    };\n    const indices = getAccessorData(Object.assign(indicesAccessor, sparse.indices), bufferViews, true);\n    const valuesAccessor = {\n      count: sparse.count,\n      type: gltfAccessor.scalar,\n      componentType: gltfAccessor.componentType\n    };\n    const values = getAccessorData(Object.assign(valuesAccessor, sparse.values), bufferViews, true);\n    if (gltfAccessor.hasOwnProperty('bufferView')) {\n      const baseAccessor = {\n        bufferView: gltfAccessor.bufferView,\n        byteOffset: gltfAccessor.byteOffset,\n        componentType: gltfAccessor.componentType,\n        count: gltfAccessor.count,\n        type: gltfAccessor.type\n      };\n      result = getAccessorData(baseAccessor, bufferViews, true).slice();\n    } else {\n      result = new dataType(gltfAccessor.count * numComponents);\n    }\n    for (let i = 0; i < sparse.count; ++i) {\n      const targetIndex = indices[i];\n      for (let j = 0; j < numComponents; ++j) {\n        result[targetIndex * numComponents + j] = values[i * numComponents + j];\n      }\n    }\n  } else if (flatten && bufferView.hasOwnProperty('byteStride')) {\n    const bytesPerElement = numComponents * dataType.BYTES_PER_ELEMENT;\n    const storage = new ArrayBuffer(gltfAccessor.count * bytesPerElement);\n    const tmpArray = new Uint8Array(storage);\n    let dstOffset = 0;\n    for (let i = 0; i < gltfAccessor.count; ++i) {\n      let srcOffset = (gltfAccessor.byteOffset || 0) + i * bufferView.byteStride;\n      for (let b = 0; b < bytesPerElement; ++b) {\n        tmpArray[dstOffset++] = bufferView[srcOffset++];\n      }\n    }\n    result = new dataType(storage);\n  } else {\n    result = new dataType(bufferView.buffer, bufferView.byteOffset + (gltfAccessor.byteOffset || 0), gltfAccessor.count * numComponents);\n  }\n  return result;\n};\nconst getAccessorDataFloat32 = function getAccessorDataFloat32(gltfAccessor, bufferViews) {\n  const data = getAccessorData(gltfAccessor, bufferViews, true);\n  if (data instanceof Float32Array || !gltfAccessor.normalized) {\n    return data;\n  }\n  const float32Data = new Float32Array(data.length);\n  dequantizeArray(float32Data, data, getComponentType(gltfAccessor.componentType));\n  return float32Data;\n};\nconst getAccessorBoundingBox = function getAccessorBoundingBox(gltfAccessor) {\n  let min = gltfAccessor.min;\n  let max = gltfAccessor.max;\n  if (!min || !max) {\n    return null;\n  }\n  if (gltfAccessor.normalized) {\n    const ctype = getComponentType(gltfAccessor.componentType);\n    min = dequantizeArray([], min, ctype);\n    max = dequantizeArray([], max, ctype);\n  }\n  return new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_1__.BoundingBox(new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_2__.Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_2__.Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));\n};\nconst getPrimitiveType = function getPrimitiveType(primitive) {\n  if (!primitive.hasOwnProperty('mode')) {\n    return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PRIMITIVE_TRIANGLES;\n  }\n  switch (primitive.mode) {\n    case 0:\n      return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PRIMITIVE_POINTS;\n    case 1:\n      return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PRIMITIVE_LINES;\n    case 2:\n      return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PRIMITIVE_LINELOOP;\n    case 3:\n      return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PRIMITIVE_LINESTRIP;\n    case 4:\n      return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PRIMITIVE_TRIANGLES;\n    case 5:\n      return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PRIMITIVE_TRISTRIP;\n    case 6:\n      return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PRIMITIVE_TRIFAN;\n    default:\n      return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PRIMITIVE_TRIANGLES;\n  }\n};\nconst generateIndices = function generateIndices(numVertices) {\n  const dummyIndices = new Uint16Array(numVertices);\n  for (let i = 0; i < numVertices; i++) {\n    dummyIndices[i] = i;\n  }\n  return dummyIndices;\n};\nconst generateNormals = function generateNormals(sourceDesc, indices) {\n  const p = sourceDesc[_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_POSITION];\n  if (!p || p.components !== 3) {\n    return;\n  }\n  let positions;\n  if (p.size !== p.stride) {\n    const srcStride = p.stride / _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.typedArrayTypesByteSize[p.type];\n    const src = new _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.typedArrayTypes[p.type](p.buffer, p.offset, p.count * srcStride);\n    positions = new _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.typedArrayTypes[p.type](p.count * 3);\n    for (let i = 0; i < p.count; ++i) {\n      positions[i * 3 + 0] = src[i * srcStride + 0];\n      positions[i * 3 + 1] = src[i * srcStride + 1];\n      positions[i * 3 + 2] = src[i * srcStride + 2];\n    }\n  } else {\n    positions = new _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.typedArrayTypes[p.type](p.buffer, p.offset, p.count * 3);\n  }\n  const numVertices = p.count;\n  if (!indices) {\n    indices = generateIndices(numVertices);\n  }\n  const normalsTemp = (0,_scene_procedural_js__WEBPACK_IMPORTED_MODULE_3__.calculateNormals)(positions, indices);\n  const normals = new Float32Array(normalsTemp.length);\n  normals.set(normalsTemp);\n  sourceDesc[_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_NORMAL] = {\n    buffer: normals.buffer,\n    size: 12,\n    offset: 0,\n    stride: 12,\n    count: numVertices,\n    components: 3,\n    type: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_FLOAT32\n  };\n};\nconst flipTexCoordVs = function flipTexCoordVs(vertexBuffer) {\n  let i, j;\n  const floatOffsets = [];\n  const shortOffsets = [];\n  const byteOffsets = [];\n  for (i = 0; i < vertexBuffer.format.elements.length; ++i) {\n    const element = vertexBuffer.format.elements[i];\n    if (element.name === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD0 || element.name === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD1) {\n      switch (element.dataType) {\n        case _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_FLOAT32:\n          floatOffsets.push({\n            offset: element.offset / 4 + 1,\n            stride: element.stride / 4\n          });\n          break;\n        case _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_UINT16:\n          shortOffsets.push({\n            offset: element.offset / 2 + 1,\n            stride: element.stride / 2\n          });\n          break;\n        case _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_UINT8:\n          byteOffsets.push({\n            offset: element.offset + 1,\n            stride: element.stride\n          });\n          break;\n      }\n    }\n  }\n  const flip = function flip(offsets, type, one) {\n    const typedArray = new type(vertexBuffer.storage);\n    for (i = 0; i < offsets.length; ++i) {\n      let index = offsets[i].offset;\n      const stride = offsets[i].stride;\n      for (j = 0; j < vertexBuffer.numVertices; ++j) {\n        typedArray[index] = one - typedArray[index];\n        index += stride;\n      }\n    }\n  };\n  if (floatOffsets.length > 0) {\n    flip(floatOffsets, Float32Array, 1.0);\n  }\n  if (shortOffsets.length > 0) {\n    flip(shortOffsets, Uint16Array, 65535);\n  }\n  if (byteOffsets.length > 0) {\n    flip(byteOffsets, Uint8Array, 255);\n  }\n};\nconst cloneTexture = function cloneTexture(texture) {\n  const shallowCopyLevels = function shallowCopyLevels(texture) {\n    const result = [];\n    for (let mip = 0; mip < texture._levels.length; ++mip) {\n      let level = [];\n      if (texture.cubemap) {\n        for (let face = 0; face < 6; ++face) {\n          level.push(texture._levels[mip][face]);\n        }\n      } else {\n        level = texture._levels[mip];\n      }\n      result.push(level);\n    }\n    return result;\n  };\n  const result = new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_4__.Texture(texture.device, texture);\n  result._levels = shallowCopyLevels(texture);\n  return result;\n};\nconst cloneTextureAsset = function cloneTextureAsset(src) {\n  const result = new _asset_asset_js__WEBPACK_IMPORTED_MODULE_5__.Asset(src.name + '_clone', src.type, src.file, src.data, src.options);\n  result.loaded = true;\n  result.resource = cloneTexture(src.resource);\n  src.registry.add(result);\n  return result;\n};\nconst createVertexBufferInternal = function createVertexBufferInternal(device, sourceDesc, flipV) {\n  const positionDesc = sourceDesc[_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_POSITION];\n  if (!positionDesc) {\n    return null;\n  }\n  const numVertices = positionDesc.count;\n  const vertexDesc = [];\n  for (const semantic in sourceDesc) {\n    if (sourceDesc.hasOwnProperty(semantic)) {\n      vertexDesc.push({\n        semantic: semantic,\n        components: sourceDesc[semantic].components,\n        type: sourceDesc[semantic].type,\n        normalize: !!sourceDesc[semantic].normalize\n      });\n    }\n  }\n  const elementOrder = [_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_POSITION, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_NORMAL, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TANGENT, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_COLOR, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_BLENDINDICES, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_BLENDWEIGHT, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD0, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD1];\n  vertexDesc.sort(function (lhs, rhs) {\n    const lhsOrder = elementOrder.indexOf(lhs.semantic);\n    const rhsOrder = elementOrder.indexOf(rhs.semantic);\n    return lhsOrder < rhsOrder ? -1 : rhsOrder < lhsOrder ? 1 : 0;\n  });\n  let i, j, k;\n  let source, target, sourceOffset;\n  const vertexFormat = new _platform_graphics_vertex_format_js__WEBPACK_IMPORTED_MODULE_6__.VertexFormat(device, vertexDesc);\n  let isCorrectlyInterleaved = true;\n  for (i = 0; i < vertexFormat.elements.length; ++i) {\n    target = vertexFormat.elements[i];\n    source = sourceDesc[target.name];\n    sourceOffset = source.offset - positionDesc.offset;\n    if (source.buffer !== positionDesc.buffer || source.stride !== target.stride || source.size !== target.size || sourceOffset !== target.offset) {\n      isCorrectlyInterleaved = false;\n      break;\n    }\n  }\n  const vertexBuffer = new _platform_graphics_vertex_buffer_js__WEBPACK_IMPORTED_MODULE_7__.VertexBuffer(device, vertexFormat, numVertices, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BUFFER_STATIC);\n  const vertexData = vertexBuffer.lock();\n  const targetArray = new Uint32Array(vertexData);\n  let sourceArray;\n  if (isCorrectlyInterleaved) {\n    sourceArray = new Uint32Array(positionDesc.buffer, positionDesc.offset, numVertices * vertexBuffer.format.size / 4);\n    targetArray.set(sourceArray);\n  } else {\n    let targetStride, sourceStride;\n    for (i = 0; i < vertexBuffer.format.elements.length; ++i) {\n      target = vertexBuffer.format.elements[i];\n      targetStride = target.stride / 4;\n      source = sourceDesc[target.name];\n      sourceStride = source.stride / 4;\n      sourceArray = new Uint32Array(source.buffer, source.offset, (source.count - 1) * sourceStride + (source.size + 3) / 4);\n      let src = 0;\n      let dst = target.offset / 4;\n      const kend = Math.floor((source.size + 3) / 4);\n      for (j = 0; j < numVertices; ++j) {\n        for (k = 0; k < kend; ++k) {\n          targetArray[dst + k] = sourceArray[src + k];\n        }\n        src += sourceStride;\n        dst += targetStride;\n      }\n    }\n  }\n  if (flipV) {\n    flipTexCoordVs(vertexBuffer);\n  }\n  vertexBuffer.unlock();\n  return vertexBuffer;\n};\nconst createVertexBuffer = function createVertexBuffer(device, attributes, indices, accessors, bufferViews, flipV, vertexBufferDict) {\n  const useAttributes = {};\n  const attribIds = [];\n  for (const attrib in attributes) {\n    if (attributes.hasOwnProperty(attrib) && gltfToEngineSemanticMap.hasOwnProperty(attrib)) {\n      useAttributes[attrib] = attributes[attrib];\n      attribIds.push(attrib + ':' + attributes[attrib]);\n    }\n  }\n  attribIds.sort();\n  const vbKey = attribIds.join();\n  let vb = vertexBufferDict[vbKey];\n  if (!vb) {\n    const sourceDesc = {};\n    for (const attrib in useAttributes) {\n      const accessor = accessors[attributes[attrib]];\n      const accessorData = getAccessorData(accessor, bufferViews);\n      const bufferView = bufferViews[accessor.bufferView];\n      const semantic = gltfToEngineSemanticMap[attrib];\n      const size = getNumComponents(accessor.type) * getComponentSizeInBytes(accessor.componentType);\n      const stride = bufferView.hasOwnProperty('byteStride') ? bufferView.byteStride : size;\n      sourceDesc[semantic] = {\n        buffer: accessorData.buffer,\n        size: size,\n        offset: accessorData.byteOffset,\n        stride: stride,\n        count: accessor.count,\n        components: getNumComponents(accessor.type),\n        type: getComponentType(accessor.componentType),\n        normalize: accessor.normalized\n      };\n    }\n    if (!sourceDesc.hasOwnProperty(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_NORMAL)) {\n      generateNormals(sourceDesc, indices);\n    }\n    vb = createVertexBufferInternal(device, sourceDesc, flipV);\n    vertexBufferDict[vbKey] = vb;\n  }\n  return vb;\n};\nconst createVertexBufferDraco = function createVertexBufferDraco(device, outputGeometry, extDraco, decoder, decoderModule, indices, flipV) {\n  const numPoints = outputGeometry.num_points();\n  const extractDracoAttributeInfo = function extractDracoAttributeInfo(uniqueId, semantic) {\n    const attribute = decoder.GetAttributeByUniqueId(outputGeometry, uniqueId);\n    const numValues = numPoints * attribute.num_components();\n    const dracoFormat = attribute.data_type();\n    let ptr, values, componentSizeInBytes, storageType;\n    switch (dracoFormat) {\n      case decoderModule.DT_UINT8:\n        storageType = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_UINT8;\n        componentSizeInBytes = 1;\n        ptr = decoderModule._malloc(numValues * componentSizeInBytes);\n        decoder.GetAttributeDataArrayForAllPoints(outputGeometry, attribute, decoderModule.DT_UINT8, numValues * componentSizeInBytes, ptr);\n        values = new Uint8Array(decoderModule.HEAPU8.buffer, ptr, numValues).slice();\n        break;\n      case decoderModule.DT_UINT16:\n        storageType = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_UINT16;\n        componentSizeInBytes = 2;\n        ptr = decoderModule._malloc(numValues * componentSizeInBytes);\n        decoder.GetAttributeDataArrayForAllPoints(outputGeometry, attribute, decoderModule.DT_UINT16, numValues * componentSizeInBytes, ptr);\n        values = new Uint16Array(decoderModule.HEAPU16.buffer, ptr, numValues).slice();\n        break;\n      case decoderModule.DT_FLOAT32:\n      default:\n        storageType = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_FLOAT32;\n        componentSizeInBytes = 4;\n        ptr = decoderModule._malloc(numValues * componentSizeInBytes);\n        decoder.GetAttributeDataArrayForAllPoints(outputGeometry, attribute, decoderModule.DT_FLOAT32, numValues * componentSizeInBytes, ptr);\n        values = new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues).slice();\n        break;\n    }\n    decoderModule._free(ptr);\n    return {\n      values: values,\n      numComponents: attribute.num_components(),\n      componentSizeInBytes: componentSizeInBytes,\n      storageType: storageType,\n      normalized: semantic === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_COLOR && storageType === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_UINT8 ? true : attribute.normalized()\n    };\n  };\n  const sourceDesc = {};\n  const attributes = extDraco.attributes;\n  for (const attrib in attributes) {\n    if (attributes.hasOwnProperty(attrib) && gltfToEngineSemanticMap.hasOwnProperty(attrib)) {\n      const semantic = gltfToEngineSemanticMap[attrib];\n      const attributeInfo = extractDracoAttributeInfo(attributes[attrib], semantic);\n      const size = attributeInfo.numComponents * attributeInfo.componentSizeInBytes;\n      sourceDesc[semantic] = {\n        values: attributeInfo.values,\n        buffer: attributeInfo.values.buffer,\n        size: size,\n        offset: 0,\n        stride: size,\n        count: numPoints,\n        components: attributeInfo.numComponents,\n        type: attributeInfo.storageType,\n        normalize: attributeInfo.normalized\n      };\n    }\n  }\n  if (!sourceDesc.hasOwnProperty(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_NORMAL)) {\n    generateNormals(sourceDesc, indices);\n  }\n  return createVertexBufferInternal(device, sourceDesc, flipV);\n};\nconst createSkin = function createSkin(device, gltfSkin, accessors, bufferViews, nodes, glbSkins) {\n  let i, j, bindMatrix;\n  const joints = gltfSkin.joints;\n  const numJoints = joints.length;\n  const ibp = [];\n  if (gltfSkin.hasOwnProperty('inverseBindMatrices')) {\n    const inverseBindMatrices = gltfSkin.inverseBindMatrices;\n    const ibmData = getAccessorData(accessors[inverseBindMatrices], bufferViews, true);\n    const ibmValues = [];\n    for (i = 0; i < numJoints; i++) {\n      for (j = 0; j < 16; j++) {\n        ibmValues[j] = ibmData[i * 16 + j];\n      }\n      bindMatrix = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_8__.Mat4();\n      bindMatrix.set(ibmValues);\n      ibp.push(bindMatrix);\n    }\n  } else {\n    for (i = 0; i < numJoints; i++) {\n      bindMatrix = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_8__.Mat4();\n      ibp.push(bindMatrix);\n    }\n  }\n  const boneNames = [];\n  for (i = 0; i < numJoints; i++) {\n    boneNames[i] = nodes[joints[i]].name;\n  }\n  const key = boneNames.join('#');\n  let skin = glbSkins.get(key);\n  if (!skin) {\n    skin = new _scene_skin_js__WEBPACK_IMPORTED_MODULE_9__.Skin(device, ibp, boneNames);\n    glbSkins.set(key, skin);\n  }\n  return skin;\n};\nconst tempMat = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_8__.Mat4();\nconst tempVec = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_2__.Vec3();\nconst createMesh = function createMesh(device, gltfMesh, accessors, bufferViews, callback, flipV, vertexBufferDict, meshVariants, meshDefaultMaterials, assetOptions) {\n  const meshes = [];\n  gltfMesh.primitives.forEach(function (primitive) {\n    let primitiveType, vertexBuffer, numIndices;\n    let indices = null;\n    let canUseMorph = true;\n    if (primitive.hasOwnProperty('extensions')) {\n      const extensions = primitive.extensions;\n      if (extensions.hasOwnProperty('KHR_draco_mesh_compression')) {\n        const decoderModule = dracoDecoderInstance || getGlobalDracoDecoderModule();\n        if (decoderModule) {\n          const extDraco = extensions.KHR_draco_mesh_compression;\n          if (extDraco.hasOwnProperty('attributes')) {\n            const uint8Buffer = bufferViews[extDraco.bufferView];\n            const buffer = new decoderModule.DecoderBuffer();\n            buffer.Init(uint8Buffer, uint8Buffer.length);\n            const decoder = new decoderModule.Decoder();\n            const geometryType = decoder.GetEncodedGeometryType(buffer);\n            let outputGeometry, status;\n            switch (geometryType) {\n              case decoderModule.POINT_CLOUD:\n                primitiveType = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PRIMITIVE_POINTS;\n                outputGeometry = new decoderModule.PointCloud();\n                status = decoder.DecodeBufferToPointCloud(buffer, outputGeometry);\n                break;\n              case decoderModule.TRIANGULAR_MESH:\n                primitiveType = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PRIMITIVE_TRIANGLES;\n                outputGeometry = new decoderModule.Mesh();\n                status = decoder.DecodeBufferToMesh(buffer, outputGeometry);\n                break;\n              case decoderModule.INVALID_GEOMETRY_TYPE:\n            }\n            if (!status || !status.ok() || outputGeometry.ptr === 0) {\n              callback('Failed to decode draco compressed asset: ' + (status ? status.error_msg() : 'Mesh asset - invalid draco compressed geometry type: ' + geometryType));\n              return;\n            }\n            const numFaces = outputGeometry.num_faces();\n            if (geometryType === decoderModule.TRIANGULAR_MESH) {\n              const bit32 = outputGeometry.num_points() > 65535;\n              numIndices = numFaces * 3;\n              const dataSize = numIndices * (bit32 ? 4 : 2);\n              const ptr = decoderModule._malloc(dataSize);\n              if (bit32) {\n                decoder.GetTrianglesUInt32Array(outputGeometry, dataSize, ptr);\n                indices = new Uint32Array(decoderModule.HEAPU32.buffer, ptr, numIndices).slice();\n              } else {\n                decoder.GetTrianglesUInt16Array(outputGeometry, dataSize, ptr);\n                indices = new Uint16Array(decoderModule.HEAPU16.buffer, ptr, numIndices).slice();\n              }\n              decoderModule._free(ptr);\n            }\n            vertexBuffer = createVertexBufferDraco(device, outputGeometry, extDraco, decoder, decoderModule, indices, flipV);\n            decoderModule.destroy(outputGeometry);\n            decoderModule.destroy(decoder);\n            decoderModule.destroy(buffer);\n            canUseMorph = false;\n          }\n        }\n      }\n    }\n    if (!vertexBuffer) {\n      indices = primitive.hasOwnProperty('indices') ? getAccessorData(accessors[primitive.indices], bufferViews, true) : null;\n      vertexBuffer = createVertexBuffer(device, primitive.attributes, indices, accessors, bufferViews, flipV, vertexBufferDict);\n      primitiveType = getPrimitiveType(primitive);\n    }\n    let mesh = null;\n    if (vertexBuffer) {\n      mesh = new _scene_mesh_js__WEBPACK_IMPORTED_MODULE_10__.Mesh(device);\n      mesh.vertexBuffer = vertexBuffer;\n      mesh.primitive[0].type = primitiveType;\n      mesh.primitive[0].base = 0;\n      mesh.primitive[0].indexed = indices !== null;\n      if (indices !== null) {\n        let indexFormat;\n        if (indices instanceof Uint8Array) {\n          indexFormat = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.INDEXFORMAT_UINT8;\n        } else if (indices instanceof Uint16Array) {\n          indexFormat = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.INDEXFORMAT_UINT16;\n        } else {\n          indexFormat = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.INDEXFORMAT_UINT32;\n        }\n        if (indexFormat === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.INDEXFORMAT_UINT32 && !device.extUintElement) {\n          indexFormat = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.INDEXFORMAT_UINT16;\n          indices = new Uint16Array(indices);\n        }\n        const indexBuffer = new _platform_graphics_index_buffer_js__WEBPACK_IMPORTED_MODULE_11__.IndexBuffer(device, indexFormat, indices.length, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BUFFER_STATIC, indices);\n        mesh.indexBuffer[0] = indexBuffer;\n        mesh.primitive[0].count = indices.length;\n      } else {\n        mesh.primitive[0].count = vertexBuffer.numVertices;\n      }\n      if (primitive.hasOwnProperty(\"extensions\") && primitive.extensions.hasOwnProperty(\"KHR_materials_variants\")) {\n        const variants = primitive.extensions.KHR_materials_variants;\n        const tempMapping = {};\n        variants.mappings.forEach(mapping => {\n          mapping.variants.forEach(variant => {\n            tempMapping[variant] = mapping.material;\n          });\n        });\n        meshVariants[mesh.id] = tempMapping;\n      }\n      meshDefaultMaterials[mesh.id] = primitive.material;\n      let accessor = accessors[primitive.attributes.POSITION];\n      mesh.aabb = getAccessorBoundingBox(accessor);\n      if (canUseMorph && primitive.hasOwnProperty('targets')) {\n        const targets = [];\n        primitive.targets.forEach(function (target, index) {\n          const options = {};\n          if (target.hasOwnProperty('POSITION')) {\n            accessor = accessors[target.POSITION];\n            options.deltaPositions = getAccessorDataFloat32(accessor, bufferViews);\n            options.deltaPositionsType = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_FLOAT32;\n            options.aabb = getAccessorBoundingBox(accessor);\n          }\n          if (target.hasOwnProperty('NORMAL')) {\n            accessor = accessors[target.NORMAL];\n            options.deltaNormals = getAccessorDataFloat32(accessor, bufferViews);\n            options.deltaNormalsType = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_FLOAT32;\n          }\n          if (gltfMesh.hasOwnProperty('extras') && gltfMesh.extras.hasOwnProperty('targetNames')) {\n            options.name = gltfMesh.extras.targetNames[index];\n          } else {\n            options.name = index.toString(10);\n          }\n          if (gltfMesh.hasOwnProperty('weights')) {\n            options.defaultWeight = gltfMesh.weights[index];\n          }\n          options.preserveData = assetOptions.morphPreserveData;\n          targets.push(new _scene_morph_target_js__WEBPACK_IMPORTED_MODULE_12__.MorphTarget(options));\n        });\n        mesh.morph = new _scene_morph_js__WEBPACK_IMPORTED_MODULE_13__.Morph(targets, device);\n      }\n    }\n    meshes.push(mesh);\n  });\n  return meshes;\n};\nconst extractTextureTransform = function extractTextureTransform(source, material, maps) {\n  var _source$extensions;\n  let map;\n  const texCoord = source.texCoord;\n  if (texCoord) {\n    for (map = 0; map < maps.length; ++map) {\n      material[maps[map] + 'MapUv'] = texCoord;\n    }\n  }\n  const zeros = [0, 0];\n  const ones = [1, 1];\n  const textureTransform = (_source$extensions = source.extensions) == null ? void 0 : _source$extensions.KHR_texture_transform;\n  if (textureTransform) {\n    const offset = textureTransform.offset || zeros;\n    const scale = textureTransform.scale || ones;\n    const rotation = textureTransform.rotation ? -textureTransform.rotation * _core_math_math_js__WEBPACK_IMPORTED_MODULE_14__.math.RAD_TO_DEG : 0;\n    const tilingVec = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_15__.Vec2(scale[0], scale[1]);\n    const offsetVec = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_15__.Vec2(offset[0], 1.0 - scale[1] - offset[1]);\n    for (map = 0; map < maps.length; ++map) {\n      material[`${maps[map]}MapTiling`] = tilingVec;\n      material[`${maps[map]}MapOffset`] = offsetVec;\n      material[`${maps[map]}MapRotation`] = rotation;\n    }\n  }\n};\nconst extensionPbrSpecGlossiness = function extensionPbrSpecGlossiness(data, material, textures) {\n  let color, texture;\n  if (data.hasOwnProperty('diffuseFactor')) {\n    color = data.diffuseFactor;\n    material.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));\n    material.opacity = color[3];\n  } else {\n    material.diffuse.set(1, 1, 1);\n    material.opacity = 1;\n  }\n  if (data.hasOwnProperty('diffuseTexture')) {\n    const diffuseTexture = data.diffuseTexture;\n    texture = textures[diffuseTexture.index];\n    material.diffuseMap = texture;\n    material.diffuseMapChannel = 'rgb';\n    material.opacityMap = texture;\n    material.opacityMapChannel = 'a';\n    extractTextureTransform(diffuseTexture, material, ['diffuse', 'opacity']);\n  }\n  material.useMetalness = false;\n  if (data.hasOwnProperty('specularFactor')) {\n    color = data.specularFactor;\n    material.specular.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));\n  } else {\n    material.specular.set(1, 1, 1);\n  }\n  if (data.hasOwnProperty('glossinessFactor')) {\n    material.gloss = data.glossinessFactor;\n  } else {\n    material.gloss = 1.0;\n  }\n  if (data.hasOwnProperty('specularGlossinessTexture')) {\n    const specularGlossinessTexture = data.specularGlossinessTexture;\n    material.specularEncoding = 'srgb';\n    material.specularMap = material.glossMap = textures[specularGlossinessTexture.index];\n    material.specularMapChannel = 'rgb';\n    material.glossMapChannel = 'a';\n    extractTextureTransform(specularGlossinessTexture, material, ['gloss', 'metalness']);\n  }\n};\nconst extensionClearCoat = function extensionClearCoat(data, material, textures) {\n  if (data.hasOwnProperty('clearcoatFactor')) {\n    material.clearCoat = data.clearcoatFactor * 0.25;\n  } else {\n    material.clearCoat = 0;\n  }\n  if (data.hasOwnProperty('clearcoatTexture')) {\n    const clearcoatTexture = data.clearcoatTexture;\n    material.clearCoatMap = textures[clearcoatTexture.index];\n    material.clearCoatMapChannel = 'r';\n    extractTextureTransform(clearcoatTexture, material, ['clearCoat']);\n  }\n  if (data.hasOwnProperty('clearcoatRoughnessFactor')) {\n    material.clearCoatGloss = data.clearcoatRoughnessFactor;\n  } else {\n    material.clearCoatGloss = 0;\n  }\n  if (data.hasOwnProperty('clearcoatRoughnessTexture')) {\n    const clearcoatRoughnessTexture = data.clearcoatRoughnessTexture;\n    material.clearCoatGlossMap = textures[clearcoatRoughnessTexture.index];\n    material.clearCoatGlossMapChannel = 'g';\n    extractTextureTransform(clearcoatRoughnessTexture, material, ['clearCoatGloss']);\n  }\n  if (data.hasOwnProperty('clearcoatNormalTexture')) {\n    const clearcoatNormalTexture = data.clearcoatNormalTexture;\n    material.clearCoatNormalMap = textures[clearcoatNormalTexture.index];\n    extractTextureTransform(clearcoatNormalTexture, material, ['clearCoatNormal']);\n    if (clearcoatNormalTexture.hasOwnProperty('scale')) {\n      material.clearCoatBumpiness = clearcoatNormalTexture.scale;\n    }\n  }\n  material.clearCoatGlossInvert = true;\n};\nconst extensionUnlit = function extensionUnlit(data, material, textures) {\n  material.useLighting = false;\n  material.emissive.copy(material.diffuse);\n  material.emissiveTint = material.diffuseTint;\n  material.emissiveMap = material.diffuseMap;\n  material.emissiveMapUv = material.diffuseMapUv;\n  material.emissiveMapTiling.copy(material.diffuseMapTiling);\n  material.emissiveMapOffset.copy(material.diffuseMapOffset);\n  material.emissiveMapRotation = material.diffuseMapRotation;\n  material.emissiveMapChannel = material.diffuseMapChannel;\n  material.emissiveVertexColor = material.diffuseVertexColor;\n  material.emissiveVertexColorChannel = material.diffuseVertexColorChannel;\n  material.diffuse.set(0, 0, 0);\n  material.diffuseTint = false;\n  material.diffuseMap = null;\n  material.diffuseVertexColor = false;\n};\nconst extensionSpecular = function extensionSpecular(data, material, textures) {\n  material.useMetalnessSpecularColor = true;\n  if (data.hasOwnProperty('specularColorTexture')) {\n    material.specularEncoding = 'srgb';\n    material.specularMap = textures[data.specularColorTexture.index];\n    material.specularMapChannel = 'rgb';\n    extractTextureTransform(data.specularColorTexture, material, ['specular']);\n  }\n  if (data.hasOwnProperty('specularColorFactor')) {\n    const color = data.specularColorFactor;\n    material.specular.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));\n  } else {\n    material.specular.set(1, 1, 1);\n  }\n  if (data.hasOwnProperty('specularFactor')) {\n    material.specularityFactor = data.specularFactor;\n  } else {\n    material.specularityFactor = 1;\n  }\n  if (data.hasOwnProperty('specularTexture')) {\n    material.specularityFactorMapChannel = 'a';\n    material.specularityFactorMap = textures[data.specularTexture.index];\n    extractTextureTransform(data.specularTexture, material, ['specularityFactor']);\n  }\n};\nconst extensionIor = function extensionIor(data, material, textures) {\n  if (data.hasOwnProperty('ior')) {\n    material.refractionIndex = 1.0 / data.ior;\n  }\n};\nconst extensionTransmission = function extensionTransmission(data, material, textures) {\n  material.blendType = _scene_constants_js__WEBPACK_IMPORTED_MODULE_16__.BLEND_NORMAL;\n  material.useDynamicRefraction = true;\n  if (data.hasOwnProperty('transmissionFactor')) {\n    material.refraction = data.transmissionFactor;\n  }\n  if (data.hasOwnProperty('transmissionTexture')) {\n    material.refractionMapChannel = 'r';\n    material.refractionMap = textures[data.transmissionTexture.index];\n    extractTextureTransform(data.transmissionTexture, material, ['refraction']);\n  }\n};\nconst extensionSheen = function extensionSheen(data, material, textures) {\n  material.useSheen = true;\n  if (data.hasOwnProperty('sheenColorFactor')) {\n    const color = data.sheenColorFactor;\n    material.sheen.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));\n  } else {\n    material.sheen.set(1, 1, 1);\n  }\n  if (data.hasOwnProperty('sheenColorTexture')) {\n    material.sheenMap = textures[data.sheenColorTexture.index];\n    material.sheenEncoding = 'srgb';\n    extractTextureTransform(data.sheenColorTexture, material, ['sheen']);\n  }\n  if (data.hasOwnProperty('sheenRoughnessFactor')) {\n    material.sheenGloss = data.sheenRoughnessFactor;\n  } else {\n    material.sheenGloss = 0.0;\n  }\n  if (data.hasOwnProperty('sheenRoughnessTexture')) {\n    material.sheenGlossMap = textures[data.sheenRoughnessTexture.index];\n    material.sheenGlossMapChannel = 'a';\n    extractTextureTransform(data.sheenRoughnessTexture, material, ['sheenGloss']);\n  }\n  material.sheenGlossInvert = true;\n};\nconst extensionVolume = function extensionVolume(data, material, textures) {\n  material.blendType = _scene_constants_js__WEBPACK_IMPORTED_MODULE_16__.BLEND_NORMAL;\n  material.useDynamicRefraction = true;\n  if (data.hasOwnProperty('thicknessFactor')) {\n    material.thickness = data.thicknessFactor;\n  }\n  if (data.hasOwnProperty('thicknessTexture')) {\n    material.thicknessMap = textures[data.thicknessTexture.index];\n    material.thicknessMapChannel = 'g';\n    extractTextureTransform(data.thicknessTexture, material, ['thickness']);\n  }\n  if (data.hasOwnProperty('attenuationDistance')) {\n    material.attenuationDistance = data.attenuationDistance;\n  }\n  if (data.hasOwnProperty('attenuationColor')) {\n    const color = data.attenuationColor;\n    material.attenuation.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));\n  }\n};\nconst extensionEmissiveStrength = function extensionEmissiveStrength(data, material, textures) {\n  if (data.hasOwnProperty('emissiveStrength')) {\n    material.emissiveIntensity = data.emissiveStrength;\n  }\n};\nconst extensionIridescence = function extensionIridescence(data, material, textures) {\n  material.useIridescence = true;\n  if (data.hasOwnProperty('iridescenceFactor')) {\n    material.iridescence = data.iridescenceFactor;\n  }\n  if (data.hasOwnProperty('iridescenceTexture')) {\n    material.iridescenceMapChannel = 'r';\n    material.iridescenceMap = textures[data.iridescenceTexture.index];\n    extractTextureTransform(data.iridescenceTexture, material, ['iridescence']);\n  }\n  if (data.hasOwnProperty('iridescenceIor')) {\n    material.iridescenceRefractionIndex = data.iridescenceIor;\n  }\n  if (data.hasOwnProperty('iridescenceThicknessMinimum')) {\n    material.iridescenceThicknessMin = data.iridescenceThicknessMinimum;\n  }\n  if (data.hasOwnProperty('iridescenceThicknessMaximum')) {\n    material.iridescenceThicknessMax = data.iridescenceThicknessMaximum;\n  }\n  if (data.hasOwnProperty('iridescenceThicknessTexture')) {\n    material.iridescenceThicknessMapChannel = 'g';\n    material.iridescenceThicknessMap = textures[data.iridescenceThicknessTexture.index];\n    extractTextureTransform(data.iridescenceThicknessTexture, material, ['iridescenceThickness']);\n  }\n};\nconst createMaterial = function createMaterial(gltfMaterial, textures, flipV) {\n  const material = new _scene_materials_standard_material_js__WEBPACK_IMPORTED_MODULE_17__.StandardMaterial();\n  material.occludeSpecular = _scene_constants_js__WEBPACK_IMPORTED_MODULE_16__.SPECOCC_AO;\n  material.diffuseTint = true;\n  material.diffuseVertexColor = true;\n  material.specularTint = true;\n  material.specularVertexColor = true;\n  if (gltfMaterial.hasOwnProperty('name')) {\n    material.name = gltfMaterial.name;\n  }\n  let color, texture;\n  if (gltfMaterial.hasOwnProperty('pbrMetallicRoughness')) {\n    const pbrData = gltfMaterial.pbrMetallicRoughness;\n    if (pbrData.hasOwnProperty('baseColorFactor')) {\n      color = pbrData.baseColorFactor;\n      material.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));\n      material.opacity = color[3];\n    } else {\n      material.diffuse.set(1, 1, 1);\n      material.opacity = 1;\n    }\n    if (pbrData.hasOwnProperty('baseColorTexture')) {\n      const baseColorTexture = pbrData.baseColorTexture;\n      texture = textures[baseColorTexture.index];\n      material.diffuseMap = texture;\n      material.diffuseMapChannel = 'rgb';\n      material.opacityMap = texture;\n      material.opacityMapChannel = 'a';\n      extractTextureTransform(baseColorTexture, material, ['diffuse', 'opacity']);\n    }\n    material.useMetalness = true;\n    material.specular.set(1, 1, 1);\n    if (pbrData.hasOwnProperty('metallicFactor')) {\n      material.metalness = pbrData.metallicFactor;\n    } else {\n      material.metalness = 1;\n    }\n    if (pbrData.hasOwnProperty('roughnessFactor')) {\n      material.gloss = pbrData.roughnessFactor;\n    } else {\n      material.gloss = 1;\n    }\n    material.glossInvert = true;\n    if (pbrData.hasOwnProperty('metallicRoughnessTexture')) {\n      const metallicRoughnessTexture = pbrData.metallicRoughnessTexture;\n      material.metalnessMap = material.glossMap = textures[metallicRoughnessTexture.index];\n      material.metalnessMapChannel = 'b';\n      material.glossMapChannel = 'g';\n      extractTextureTransform(metallicRoughnessTexture, material, ['gloss', 'metalness']);\n    }\n  }\n  if (gltfMaterial.hasOwnProperty('normalTexture')) {\n    const normalTexture = gltfMaterial.normalTexture;\n    material.normalMap = textures[normalTexture.index];\n    extractTextureTransform(normalTexture, material, ['normal']);\n    if (normalTexture.hasOwnProperty('scale')) {\n      material.bumpiness = normalTexture.scale;\n    }\n  }\n  if (gltfMaterial.hasOwnProperty('occlusionTexture')) {\n    const occlusionTexture = gltfMaterial.occlusionTexture;\n    material.aoMap = textures[occlusionTexture.index];\n    material.aoMapChannel = 'r';\n    extractTextureTransform(occlusionTexture, material, ['ao']);\n  }\n  if (gltfMaterial.hasOwnProperty('emissiveFactor')) {\n    color = gltfMaterial.emissiveFactor;\n    material.emissive.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));\n    material.emissiveTint = true;\n  } else {\n    material.emissive.set(0, 0, 0);\n    material.emissiveTint = false;\n  }\n  if (gltfMaterial.hasOwnProperty('emissiveTexture')) {\n    const emissiveTexture = gltfMaterial.emissiveTexture;\n    material.emissiveMap = textures[emissiveTexture.index];\n    extractTextureTransform(emissiveTexture, material, ['emissive']);\n  }\n  if (gltfMaterial.hasOwnProperty('alphaMode')) {\n    switch (gltfMaterial.alphaMode) {\n      case 'MASK':\n        material.blendType = _scene_constants_js__WEBPACK_IMPORTED_MODULE_16__.BLEND_NONE;\n        if (gltfMaterial.hasOwnProperty('alphaCutoff')) {\n          material.alphaTest = gltfMaterial.alphaCutoff;\n        } else {\n          material.alphaTest = 0.5;\n        }\n        break;\n      case 'BLEND':\n        material.blendType = _scene_constants_js__WEBPACK_IMPORTED_MODULE_16__.BLEND_NORMAL;\n        material.depthWrite = false;\n        break;\n      default:\n      case 'OPAQUE':\n        material.blendType = _scene_constants_js__WEBPACK_IMPORTED_MODULE_16__.BLEND_NONE;\n        break;\n    }\n  } else {\n    material.blendType = _scene_constants_js__WEBPACK_IMPORTED_MODULE_16__.BLEND_NONE;\n  }\n  if (gltfMaterial.hasOwnProperty('doubleSided')) {\n    material.twoSidedLighting = gltfMaterial.doubleSided;\n    material.cull = gltfMaterial.doubleSided ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.CULLFACE_NONE : _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.CULLFACE_BACK;\n  } else {\n    material.twoSidedLighting = false;\n    material.cull = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.CULLFACE_BACK;\n  }\n  const extensions = {\n    \"KHR_materials_clearcoat\": extensionClearCoat,\n    \"KHR_materials_emissive_strength\": extensionEmissiveStrength,\n    \"KHR_materials_ior\": extensionIor,\n    \"KHR_materials_iridescence\": extensionIridescence,\n    \"KHR_materials_pbrSpecularGlossiness\": extensionPbrSpecGlossiness,\n    \"KHR_materials_sheen\": extensionSheen,\n    \"KHR_materials_specular\": extensionSpecular,\n    \"KHR_materials_transmission\": extensionTransmission,\n    \"KHR_materials_unlit\": extensionUnlit,\n    \"KHR_materials_volume\": extensionVolume\n  };\n  if (gltfMaterial.hasOwnProperty('extensions')) {\n    for (const key in gltfMaterial.extensions) {\n      const extensionFunc = extensions[key];\n      if (extensionFunc !== undefined) {\n        extensionFunc(gltfMaterial.extensions[key], material, textures);\n      }\n    }\n  }\n  material.update();\n  return material;\n};\nconst createAnimation = function createAnimation(gltfAnimation, animationIndex, gltfAccessors, bufferViews, nodes, meshes) {\n  const createAnimData = function createAnimData(gltfAccessor) {\n    return new _anim_evaluator_anim_data_js__WEBPACK_IMPORTED_MODULE_18__.AnimData(getNumComponents(gltfAccessor.type), getAccessorDataFloat32(gltfAccessor, bufferViews));\n  };\n  const interpMap = {\n    'STEP': _anim_constants_js__WEBPACK_IMPORTED_MODULE_19__.INTERPOLATION_STEP,\n    'LINEAR': _anim_constants_js__WEBPACK_IMPORTED_MODULE_19__.INTERPOLATION_LINEAR,\n    'CUBICSPLINE': _anim_constants_js__WEBPACK_IMPORTED_MODULE_19__.INTERPOLATION_CUBIC\n  };\n  const inputMap = {};\n  const outputMap = {};\n  const curveMap = {};\n  let outputCounter = 1;\n  let i;\n  for (i = 0; i < gltfAnimation.samplers.length; ++i) {\n    const sampler = gltfAnimation.samplers[i];\n    if (!inputMap.hasOwnProperty(sampler.input)) {\n      inputMap[sampler.input] = createAnimData(gltfAccessors[sampler.input]);\n    }\n    if (!outputMap.hasOwnProperty(sampler.output)) {\n      outputMap[sampler.output] = createAnimData(gltfAccessors[sampler.output]);\n    }\n    const interpolation = sampler.hasOwnProperty('interpolation') && interpMap.hasOwnProperty(sampler.interpolation) ? interpMap[sampler.interpolation] : _anim_constants_js__WEBPACK_IMPORTED_MODULE_19__.INTERPOLATION_LINEAR;\n    const curve = {\n      paths: [],\n      input: sampler.input,\n      output: sampler.output,\n      interpolation: interpolation\n    };\n    curveMap[i] = curve;\n  }\n  const quatArrays = [];\n  const transformSchema = {\n    'translation': 'localPosition',\n    'rotation': 'localRotation',\n    'scale': 'localScale'\n  };\n  const constructNodePath = node => {\n    const path = [];\n    while (node) {\n      path.unshift(node.name);\n      node = node.parent;\n    }\n    return path;\n  };\n  const retrieveWeightName = (nodeName, weightIndex) => {\n    if (!meshes) return weightIndex;\n    for (let i = 0; i < meshes.length; i++) {\n      const mesh = meshes[i];\n      if (mesh.name === nodeName && mesh.hasOwnProperty('extras') && mesh.extras.hasOwnProperty('targetNames') && mesh.extras.targetNames[weightIndex]) {\n        return `name.${mesh.extras.targetNames[weightIndex]}`;\n      }\n    }\n    return weightIndex;\n  };\n  const createMorphTargetCurves = (curve, node, entityPath) => {\n    if (!outputMap[curve.output]) {\n      return;\n    }\n    const morphTargetCount = outputMap[curve.output].data.length / inputMap[curve.input].data.length;\n    const keyframeCount = outputMap[curve.output].data.length / morphTargetCount;\n    for (let j = 0; j < morphTargetCount; j++) {\n      const morphTargetOutput = new Float32Array(keyframeCount);\n      for (let k = 0; k < keyframeCount; k++) {\n        morphTargetOutput[k] = outputMap[curve.output].data[k * morphTargetCount + j];\n      }\n      const output = new _anim_evaluator_anim_data_js__WEBPACK_IMPORTED_MODULE_18__.AnimData(1, morphTargetOutput);\n      outputMap[-outputCounter] = output;\n      const morphCurve = {\n        paths: [{\n          entityPath: entityPath,\n          component: 'graph',\n          propertyPath: [`weight.${retrieveWeightName(node.name, j)}`]\n        }],\n        input: curve.input,\n        output: -outputCounter,\n        interpolation: curve.interpolation\n      };\n      outputCounter++;\n      curveMap[`morphCurve-${i}-${j}`] = morphCurve;\n    }\n  };\n  for (i = 0; i < gltfAnimation.channels.length; ++i) {\n    const channel = gltfAnimation.channels[i];\n    const target = channel.target;\n    const curve = curveMap[channel.sampler];\n    const node = nodes[target.node];\n    const entityPath = constructNodePath(node);\n    if (target.path.startsWith('weights')) {\n      createMorphTargetCurves(curve, node, entityPath);\n      curveMap[channel.sampler].morphCurve = true;\n    } else {\n      curve.paths.push({\n        entityPath: entityPath,\n        component: 'graph',\n        propertyPath: [transformSchema[target.path]]\n      });\n    }\n  }\n  const inputs = [];\n  const outputs = [];\n  const curves = [];\n  for (const inputKey in inputMap) {\n    inputs.push(inputMap[inputKey]);\n    inputMap[inputKey] = inputs.length - 1;\n  }\n  for (const outputKey in outputMap) {\n    outputs.push(outputMap[outputKey]);\n    outputMap[outputKey] = outputs.length - 1;\n  }\n  for (const curveKey in curveMap) {\n    const curveData = curveMap[curveKey];\n    if (curveData.morphCurve) {\n      continue;\n    }\n    curves.push(new _anim_evaluator_anim_curve_js__WEBPACK_IMPORTED_MODULE_20__.AnimCurve(curveData.paths, inputMap[curveData.input], outputMap[curveData.output], curveData.interpolation));\n    if (curveData.paths.length > 0 && curveData.paths[0].propertyPath[0] === 'localRotation' && curveData.interpolation !== _anim_constants_js__WEBPACK_IMPORTED_MODULE_19__.INTERPOLATION_CUBIC) {\n      quatArrays.push(curves[curves.length - 1].output);\n    }\n  }\n  quatArrays.sort();\n  let prevIndex = null;\n  let data;\n  for (i = 0; i < quatArrays.length; ++i) {\n    const index = quatArrays[i];\n    if (i === 0 || index !== prevIndex) {\n      data = outputs[index];\n      if (data.components === 4) {\n        const d = data.data;\n        const len = d.length - 4;\n        for (let j = 0; j < len; j += 4) {\n          const dp = d[j + 0] * d[j + 4] + d[j + 1] * d[j + 5] + d[j + 2] * d[j + 6] + d[j + 3] * d[j + 7];\n          if (dp < 0) {\n            d[j + 4] *= -1;\n            d[j + 5] *= -1;\n            d[j + 6] *= -1;\n            d[j + 7] *= -1;\n          }\n        }\n      }\n      prevIndex = index;\n    }\n  }\n  let duration = 0;\n  for (i = 0; i < inputs.length; i++) {\n    data = inputs[i]._data;\n    duration = Math.max(duration, data.length === 0 ? 0 : data[data.length - 1]);\n  }\n  return new _anim_evaluator_anim_track_js__WEBPACK_IMPORTED_MODULE_21__.AnimTrack(gltfAnimation.hasOwnProperty('name') ? gltfAnimation.name : 'animation_' + animationIndex, duration, inputs, outputs, curves);\n};\nconst createNode = function createNode(gltfNode, nodeIndex) {\n  const entity = new _scene_graph_node_js__WEBPACK_IMPORTED_MODULE_22__.GraphNode();\n  if (gltfNode.hasOwnProperty('name') && gltfNode.name.length > 0) {\n    entity.name = gltfNode.name;\n  } else {\n    entity.name = 'node_' + nodeIndex;\n  }\n  if (gltfNode.hasOwnProperty('matrix')) {\n    tempMat.data.set(gltfNode.matrix);\n    tempMat.getTranslation(tempVec);\n    entity.setLocalPosition(tempVec);\n    tempMat.getEulerAngles(tempVec);\n    entity.setLocalEulerAngles(tempVec);\n    tempMat.getScale(tempVec);\n    entity.setLocalScale(tempVec);\n  }\n  if (gltfNode.hasOwnProperty('rotation')) {\n    const r = gltfNode.rotation;\n    entity.setLocalRotation(r[0], r[1], r[2], r[3]);\n  }\n  if (gltfNode.hasOwnProperty('translation')) {\n    const t = gltfNode.translation;\n    entity.setLocalPosition(t[0], t[1], t[2]);\n  }\n  if (gltfNode.hasOwnProperty('scale')) {\n    const s = gltfNode.scale;\n    entity.setLocalScale(s[0], s[1], s[2]);\n  }\n  return entity;\n};\nconst createCamera = function createCamera(gltfCamera, node) {\n  const projection = gltfCamera.type === 'orthographic' ? _scene_constants_js__WEBPACK_IMPORTED_MODULE_16__.PROJECTION_ORTHOGRAPHIC : _scene_constants_js__WEBPACK_IMPORTED_MODULE_16__.PROJECTION_PERSPECTIVE;\n  const gltfProperties = projection === _scene_constants_js__WEBPACK_IMPORTED_MODULE_16__.PROJECTION_ORTHOGRAPHIC ? gltfCamera.orthographic : gltfCamera.perspective;\n  const componentData = {\n    enabled: false,\n    projection: projection,\n    nearClip: gltfProperties.znear,\n    aspectRatioMode: _scene_constants_js__WEBPACK_IMPORTED_MODULE_16__.ASPECT_AUTO\n  };\n  if (gltfProperties.zfar) {\n    componentData.farClip = gltfProperties.zfar;\n  }\n  if (projection === _scene_constants_js__WEBPACK_IMPORTED_MODULE_16__.PROJECTION_ORTHOGRAPHIC) {\n    componentData.orthoHeight = 0.5 * gltfProperties.ymag;\n    if (gltfProperties.ymag) {\n      componentData.aspectRatioMode = _scene_constants_js__WEBPACK_IMPORTED_MODULE_16__.ASPECT_MANUAL;\n      componentData.aspectRatio = gltfProperties.xmag / gltfProperties.ymag;\n    }\n  } else {\n    componentData.fov = gltfProperties.yfov * _core_math_math_js__WEBPACK_IMPORTED_MODULE_14__.math.RAD_TO_DEG;\n    if (gltfProperties.aspectRatio) {\n      componentData.aspectRatioMode = _scene_constants_js__WEBPACK_IMPORTED_MODULE_16__.ASPECT_MANUAL;\n      componentData.aspectRatio = gltfProperties.aspectRatio;\n    }\n  }\n  const cameraEntity = new _entity_js__WEBPACK_IMPORTED_MODULE_23__.Entity(gltfCamera.name);\n  cameraEntity.addComponent('camera', componentData);\n  return cameraEntity;\n};\nconst createLight = function createLight(gltfLight, node) {\n  const lightProps = {\n    enabled: false,\n    type: gltfLight.type === 'point' ? 'omni' : gltfLight.type,\n    color: gltfLight.hasOwnProperty('color') ? new _core_math_color_js__WEBPACK_IMPORTED_MODULE_24__.Color(gltfLight.color) : _core_math_color_js__WEBPACK_IMPORTED_MODULE_24__.Color.WHITE,\n    range: gltfLight.hasOwnProperty('range') ? gltfLight.range : 9999,\n    falloffMode: _scene_constants_js__WEBPACK_IMPORTED_MODULE_16__.LIGHTFALLOFF_INVERSESQUARED,\n    intensity: gltfLight.hasOwnProperty('intensity') ? _core_math_math_js__WEBPACK_IMPORTED_MODULE_14__.math.clamp(gltfLight.intensity, 0, 2) : 1\n  };\n  if (gltfLight.hasOwnProperty('spot')) {\n    lightProps.innerConeAngle = gltfLight.spot.hasOwnProperty('innerConeAngle') ? gltfLight.spot.innerConeAngle * _core_math_math_js__WEBPACK_IMPORTED_MODULE_14__.math.RAD_TO_DEG : 0;\n    lightProps.outerConeAngle = gltfLight.spot.hasOwnProperty('outerConeAngle') ? gltfLight.spot.outerConeAngle * _core_math_math_js__WEBPACK_IMPORTED_MODULE_14__.math.RAD_TO_DEG : Math.PI / 4;\n  }\n  if (gltfLight.hasOwnProperty(\"intensity\")) {\n    lightProps.luminance = gltfLight.intensity * _scene_light_js__WEBPACK_IMPORTED_MODULE_25__.Light.getLightUnitConversion(_scene_light_js__WEBPACK_IMPORTED_MODULE_25__.lightTypes[lightProps.type], lightProps.outerConeAngle, lightProps.innerConeAngle);\n  }\n  const lightEntity = new _entity_js__WEBPACK_IMPORTED_MODULE_23__.Entity(node.name);\n  lightEntity.rotateLocal(90, 0, 0);\n  lightEntity.addComponent('light', lightProps);\n  return lightEntity;\n};\nconst createSkins = function createSkins(device, gltf, nodes, bufferViews) {\n  if (!gltf.hasOwnProperty('skins') || gltf.skins.length === 0) {\n    return [];\n  }\n  const glbSkins = new Map();\n  return gltf.skins.map(function (gltfSkin) {\n    return createSkin(device, gltfSkin, gltf.accessors, bufferViews, nodes, glbSkins);\n  });\n};\nconst createMeshes = function createMeshes(device, gltf, bufferViews, callback, flipV, meshVariants, meshDefaultMaterials, options) {\n  if (!gltf.hasOwnProperty('meshes') || gltf.meshes.length === 0 || !gltf.hasOwnProperty('accessors') || gltf.accessors.length === 0 || !gltf.hasOwnProperty('bufferViews') || gltf.bufferViews.length === 0) {\n    return [];\n  }\n  const vertexBufferDict = {};\n  return gltf.meshes.map(function (gltfMesh) {\n    return createMesh(device, gltfMesh, gltf.accessors, bufferViews, callback, flipV, vertexBufferDict, meshVariants, meshDefaultMaterials, options);\n  });\n};\nconst createMaterials = function createMaterials(gltf, textures, options, flipV) {\n  if (!gltf.hasOwnProperty('materials') || gltf.materials.length === 0) {\n    return [];\n  }\n  const preprocess = options && options.material && options.material.preprocess;\n  const process = options && options.material && options.material.process || createMaterial;\n  const postprocess = options && options.material && options.material.postprocess;\n  return gltf.materials.map(function (gltfMaterial) {\n    if (preprocess) {\n      preprocess(gltfMaterial);\n    }\n    const material = process(gltfMaterial, textures, flipV);\n    if (postprocess) {\n      postprocess(gltfMaterial, material);\n    }\n    return material;\n  });\n};\nconst createVariants = function createVariants(gltf) {\n  if (!gltf.hasOwnProperty(\"extensions\") || !gltf.extensions.hasOwnProperty(\"KHR_materials_variants\")) return null;\n  const data = gltf.extensions.KHR_materials_variants.variants;\n  const variants = {};\n  for (let i = 0; i < data.length; i++) {\n    variants[data[i].name] = i;\n  }\n  return variants;\n};\nconst createAnimations = function createAnimations(gltf, nodes, bufferViews, options) {\n  if (!gltf.hasOwnProperty('animations') || gltf.animations.length === 0) {\n    return [];\n  }\n  const preprocess = options && options.animation && options.animation.preprocess;\n  const postprocess = options && options.animation && options.animation.postprocess;\n  return gltf.animations.map(function (gltfAnimation, index) {\n    if (preprocess) {\n      preprocess(gltfAnimation);\n    }\n    const animation = createAnimation(gltfAnimation, index, gltf.accessors, bufferViews, nodes, gltf.meshes);\n    if (postprocess) {\n      postprocess(gltfAnimation, animation);\n    }\n    return animation;\n  });\n};\nconst createNodes = function createNodes(gltf, options) {\n  if (!gltf.hasOwnProperty('nodes') || gltf.nodes.length === 0) {\n    return [];\n  }\n  const preprocess = options && options.node && options.node.preprocess;\n  const process = options && options.node && options.node.process || createNode;\n  const postprocess = options && options.node && options.node.postprocess;\n  const nodes = gltf.nodes.map(function (gltfNode, index) {\n    if (preprocess) {\n      preprocess(gltfNode);\n    }\n    const node = process(gltfNode, index);\n    if (postprocess) {\n      postprocess(gltfNode, node);\n    }\n    return node;\n  });\n  for (let i = 0; i < gltf.nodes.length; ++i) {\n    const gltfNode = gltf.nodes[i];\n    if (gltfNode.hasOwnProperty('children')) {\n      const parent = nodes[i];\n      const uniqueNames = {};\n      for (let j = 0; j < gltfNode.children.length; ++j) {\n        const child = nodes[gltfNode.children[j]];\n        if (!child.parent) {\n          if (uniqueNames.hasOwnProperty(child.name)) {\n            child.name += uniqueNames[child.name]++;\n          } else {\n            uniqueNames[child.name] = 1;\n          }\n          parent.addChild(child);\n        }\n      }\n    }\n  }\n  return nodes;\n};\nconst createScenes = function createScenes(gltf, nodes) {\n  var _gltf$scenes$0$nodes;\n  const scenes = [];\n  const count = gltf.scenes.length;\n  if (count === 1 && ((_gltf$scenes$0$nodes = gltf.scenes[0].nodes) == null ? void 0 : _gltf$scenes$0$nodes.length) === 1) {\n    const nodeIndex = gltf.scenes[0].nodes[0];\n    scenes.push(nodes[nodeIndex]);\n  } else {\n    for (let i = 0; i < count; i++) {\n      const scene = gltf.scenes[i];\n      if (scene.nodes) {\n        const sceneRoot = new _scene_graph_node_js__WEBPACK_IMPORTED_MODULE_22__.GraphNode(scene.name);\n        for (let n = 0; n < scene.nodes.length; n++) {\n          const childNode = nodes[scene.nodes[n]];\n          sceneRoot.addChild(childNode);\n        }\n        scenes.push(sceneRoot);\n      }\n    }\n  }\n  return scenes;\n};\nconst createCameras = function createCameras(gltf, nodes, options) {\n  let cameras = null;\n  if (gltf.hasOwnProperty('nodes') && gltf.hasOwnProperty('cameras') && gltf.cameras.length > 0) {\n    const preprocess = options && options.camera && options.camera.preprocess;\n    const process = options && options.camera && options.camera.process || createCamera;\n    const postprocess = options && options.camera && options.camera.postprocess;\n    gltf.nodes.forEach(function (gltfNode, nodeIndex) {\n      if (gltfNode.hasOwnProperty('camera')) {\n        const gltfCamera = gltf.cameras[gltfNode.camera];\n        if (gltfCamera) {\n          if (preprocess) {\n            preprocess(gltfCamera);\n          }\n          const camera = process(gltfCamera, nodes[nodeIndex]);\n          if (postprocess) {\n            postprocess(gltfCamera, camera);\n          }\n          if (camera) {\n            if (!cameras) cameras = new Map();\n            cameras.set(gltfNode, camera);\n          }\n        }\n      }\n    });\n  }\n  return cameras;\n};\nconst createLights = function createLights(gltf, nodes, options) {\n  let lights = null;\n  if (gltf.hasOwnProperty('nodes') && gltf.hasOwnProperty('extensions') && gltf.extensions.hasOwnProperty('KHR_lights_punctual') && gltf.extensions.KHR_lights_punctual.hasOwnProperty('lights')) {\n    const gltfLights = gltf.extensions.KHR_lights_punctual.lights;\n    if (gltfLights.length) {\n      const preprocess = options && options.light && options.light.preprocess;\n      const process = options && options.light && options.light.process || createLight;\n      const postprocess = options && options.light && options.light.postprocess;\n      gltf.nodes.forEach(function (gltfNode, nodeIndex) {\n        if (gltfNode.hasOwnProperty('extensions') && gltfNode.extensions.hasOwnProperty('KHR_lights_punctual') && gltfNode.extensions.KHR_lights_punctual.hasOwnProperty('light')) {\n          const lightIndex = gltfNode.extensions.KHR_lights_punctual.light;\n          const gltfLight = gltfLights[lightIndex];\n          if (gltfLight) {\n            if (preprocess) {\n              preprocess(gltfLight);\n            }\n            const light = process(gltfLight, nodes[nodeIndex]);\n            if (postprocess) {\n              postprocess(gltfLight, light);\n            }\n            if (light) {\n              if (!lights) lights = new Map();\n              lights.set(gltfNode, light);\n            }\n          }\n        }\n      });\n    }\n  }\n  return lights;\n};\nconst linkSkins = function linkSkins(gltf, renders, skins) {\n  gltf.nodes.forEach(gltfNode => {\n    if (gltfNode.hasOwnProperty('mesh') && gltfNode.hasOwnProperty('skin')) {\n      const meshGroup = renders[gltfNode.mesh].meshes;\n      meshGroup.forEach(mesh => {\n        mesh.skin = skins[gltfNode.skin];\n      });\n    }\n  });\n};\nconst createResources = function createResources(device, gltf, bufferViews, textureAssets, options, callback) {\n  const preprocess = options && options.global && options.global.preprocess;\n  const postprocess = options && options.global && options.global.postprocess;\n  if (preprocess) {\n    preprocess(gltf);\n  }\n  const flipV = gltf.asset && gltf.asset.generator === 'PlayCanvas';\n  const nodes = createNodes(gltf, options);\n  const scenes = createScenes(gltf, nodes);\n  const lights = createLights(gltf, nodes, options);\n  const cameras = createCameras(gltf, nodes, options);\n  const animations = createAnimations(gltf, nodes, bufferViews, options);\n  const materials = createMaterials(gltf, textureAssets.map(function (textureAsset) {\n    return textureAsset.resource;\n  }), options, flipV);\n  const variants = createVariants(gltf);\n  const meshVariants = {};\n  const meshDefaultMaterials = {};\n  const meshes = createMeshes(device, gltf, bufferViews, callback, flipV, meshVariants, meshDefaultMaterials, options);\n  const skins = createSkins(device, gltf, nodes, bufferViews);\n  const renders = [];\n  for (let i = 0; i < meshes.length; i++) {\n    renders[i] = new _scene_render_js__WEBPACK_IMPORTED_MODULE_26__.Render();\n    renders[i].meshes = meshes[i];\n  }\n  linkSkins(gltf, renders, skins);\n  const result = new GlbResources(gltf);\n  result.nodes = nodes;\n  result.scenes = scenes;\n  result.animations = animations;\n  result.textures = textureAssets;\n  result.materials = materials;\n  result.variants = variants;\n  result.meshVariants = meshVariants;\n  result.meshDefaultMaterials = meshDefaultMaterials;\n  result.renders = renders;\n  result.skins = skins;\n  result.lights = lights;\n  result.cameras = cameras;\n  if (postprocess) {\n    postprocess(gltf, result);\n  }\n  callback(null, result);\n};\nconst applySampler = function applySampler(texture, gltfSampler) {\n  const getFilter = function getFilter(filter, defaultValue) {\n    switch (filter) {\n      case 9728:\n        return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_NEAREST;\n      case 9729:\n        return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_LINEAR;\n      case 9984:\n        return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_NEAREST_MIPMAP_NEAREST;\n      case 9985:\n        return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_LINEAR_MIPMAP_NEAREST;\n      case 9986:\n        return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_NEAREST_MIPMAP_LINEAR;\n      case 9987:\n        return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_LINEAR_MIPMAP_LINEAR;\n      default:\n        return defaultValue;\n    }\n  };\n  const getWrap = function getWrap(wrap, defaultValue) {\n    switch (wrap) {\n      case 33071:\n        return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_CLAMP_TO_EDGE;\n      case 33648:\n        return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_MIRRORED_REPEAT;\n      case 10497:\n        return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_REPEAT;\n      default:\n        return defaultValue;\n    }\n  };\n  if (texture) {\n    gltfSampler = gltfSampler || {};\n    texture.minFilter = getFilter(gltfSampler.minFilter, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_LINEAR_MIPMAP_LINEAR);\n    texture.magFilter = getFilter(gltfSampler.magFilter, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_LINEAR);\n    texture.addressU = getWrap(gltfSampler.wrapS, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_REPEAT);\n    texture.addressV = getWrap(gltfSampler.wrapT, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_REPEAT);\n  }\n};\nlet gltfTextureUniqueId = 0;\nconst loadImageAsync = function loadImageAsync(gltfImage, index, bufferViews, urlBase, registry, options, callback) {\n  const preprocess = options && options.image && options.image.preprocess;\n  const processAsync = options && options.image && options.image.processAsync || function (gltfImage, callback) {\n    callback(null, null);\n  };\n  const postprocess = options && options.image && options.image.postprocess;\n  const onLoad = function onLoad(textureAsset) {\n    if (postprocess) {\n      postprocess(gltfImage, textureAsset);\n    }\n    callback(null, textureAsset);\n  };\n  const mimeTypeFileExtensions = {\n    'image/png': 'png',\n    'image/jpeg': 'jpg',\n    'image/basis': 'basis',\n    'image/ktx': 'ktx',\n    'image/ktx2': 'ktx2',\n    'image/vnd-ms.dds': 'dds'\n  };\n  const loadTexture = function loadTexture(url, bufferView, mimeType, options) {\n    const name = (gltfImage.name || 'gltf-texture') + '-' + gltfTextureUniqueId++;\n    const file = {\n      url: url || name\n    };\n    if (bufferView) {\n      file.contents = bufferView.slice(0).buffer;\n    }\n    if (mimeType) {\n      const extension = mimeTypeFileExtensions[mimeType];\n      if (extension) {\n        file.filename = file.url + '.' + extension;\n      }\n    }\n    const asset = new _asset_asset_js__WEBPACK_IMPORTED_MODULE_5__.Asset(name, 'texture', file, null, options);\n    asset.on('load', onLoad);\n    asset.on('error', callback);\n    registry.add(asset);\n    registry.load(asset);\n  };\n  if (preprocess) {\n    preprocess(gltfImage);\n  }\n  processAsync(gltfImage, function (err, textureAsset) {\n    if (err) {\n      callback(err);\n    } else if (textureAsset) {\n      onLoad(textureAsset);\n    } else {\n      if (gltfImage.hasOwnProperty('uri')) {\n        if (isDataURI(gltfImage.uri)) {\n          loadTexture(gltfImage.uri, null, getDataURIMimeType(gltfImage.uri), null);\n        } else {\n          loadTexture(_core_path_js__WEBPACK_IMPORTED_MODULE_27__.path.join(urlBase, gltfImage.uri), null, null, {\n            crossOrigin: 'anonymous'\n          });\n        }\n      } else if (gltfImage.hasOwnProperty('bufferView') && gltfImage.hasOwnProperty('mimeType')) {\n        loadTexture(null, bufferViews[gltfImage.bufferView], gltfImage.mimeType, null);\n      } else {\n        callback('Invalid image found in gltf (neither uri or bufferView found). index=' + index);\n      }\n    }\n  });\n};\nconst loadTexturesAsync = function loadTexturesAsync(gltf, bufferViews, urlBase, registry, options, callback) {\n  if (!gltf.hasOwnProperty('images') || gltf.images.length === 0 || !gltf.hasOwnProperty('textures') || gltf.textures.length === 0) {\n    callback(null, []);\n    return;\n  }\n  const preprocess = options && options.texture && options.texture.preprocess;\n  const processAsync = options && options.texture && options.texture.processAsync || function (gltfTexture, gltfImages, callback) {\n    callback(null, null);\n  };\n  const postprocess = options && options.texture && options.texture.postprocess;\n  const assets = [];\n  const textures = [];\n  let remaining = gltf.textures.length;\n  const onLoad = function onLoad(textureIndex, imageIndex) {\n    if (!textures[imageIndex]) {\n      textures[imageIndex] = [];\n    }\n    textures[imageIndex].push(textureIndex);\n    if (--remaining === 0) {\n      const result = [];\n      textures.forEach(function (textureList, imageIndex) {\n        textureList.forEach(function (textureIndex, index) {\n          const textureAsset = index === 0 ? assets[imageIndex] : cloneTextureAsset(assets[imageIndex]);\n          applySampler(textureAsset.resource, (gltf.samplers || [])[gltf.textures[textureIndex].sampler]);\n          result[textureIndex] = textureAsset;\n          if (postprocess) {\n            postprocess(gltf.textures[textureIndex], textureAsset);\n          }\n        });\n      });\n      callback(null, result);\n    }\n  };\n  for (let i = 0; i < gltf.textures.length; ++i) {\n    const gltfTexture = gltf.textures[i];\n    if (preprocess) {\n      preprocess(gltfTexture);\n    }\n    processAsync(gltfTexture, gltf.images, function (i, gltfTexture, err, gltfImageIndex) {\n      if (err) {\n        callback(err);\n      } else {\n        if (gltfImageIndex === undefined || gltfImageIndex === null) {\n          var _gltfTexture$extensio, _gltfTexture$extensio2;\n          gltfImageIndex = gltfTexture == null ? void 0 : (_gltfTexture$extensio = gltfTexture.extensions) == null ? void 0 : (_gltfTexture$extensio2 = _gltfTexture$extensio.KHR_texture_basisu) == null ? void 0 : _gltfTexture$extensio2.source;\n          if (gltfImageIndex === undefined) {\n            gltfImageIndex = gltfTexture.source;\n          }\n        }\n        if (assets[gltfImageIndex]) {\n          onLoad(i, gltfImageIndex);\n        } else {\n          const gltfImage = gltf.images[gltfImageIndex];\n          loadImageAsync(gltfImage, i, bufferViews, urlBase, registry, options, function (err, textureAsset) {\n            if (err) {\n              callback(err);\n            } else {\n              assets[gltfImageIndex] = textureAsset;\n              onLoad(i, gltfImageIndex);\n            }\n          });\n        }\n      }\n    }.bind(null, i, gltfTexture));\n  }\n};\nconst loadBuffersAsync = function loadBuffersAsync(gltf, binaryChunk, urlBase, options, callback) {\n  const result = [];\n  if (!gltf.buffers || gltf.buffers.length === 0) {\n    callback(null, result);\n    return;\n  }\n  const preprocess = options && options.buffer && options.buffer.preprocess;\n  const processAsync = options && options.buffer && options.buffer.processAsync || function (gltfBuffer, callback) {\n    callback(null, null);\n  };\n  const postprocess = options && options.buffer && options.buffer.postprocess;\n  let remaining = gltf.buffers.length;\n  const onLoad = function onLoad(index, buffer) {\n    result[index] = buffer;\n    if (postprocess) {\n      postprocess(gltf.buffers[index], buffer);\n    }\n    if (--remaining === 0) {\n      callback(null, result);\n    }\n  };\n  for (let i = 0; i < gltf.buffers.length; ++i) {\n    const gltfBuffer = gltf.buffers[i];\n    if (preprocess) {\n      preprocess(gltfBuffer);\n    }\n    processAsync(gltfBuffer, function (i, gltfBuffer, err, arrayBuffer) {\n      if (err) {\n        callback(err);\n      } else if (arrayBuffer) {\n        onLoad(i, new Uint8Array(arrayBuffer));\n      } else {\n        if (gltfBuffer.hasOwnProperty('uri')) {\n          if (isDataURI(gltfBuffer.uri)) {\n            const byteString = atob(gltfBuffer.uri.split(',')[1]);\n            const binaryArray = new Uint8Array(byteString.length);\n            for (let j = 0; j < byteString.length; j++) {\n              binaryArray[j] = byteString.charCodeAt(j);\n            }\n            onLoad(i, binaryArray);\n          } else {\n            _platform_net_http_js__WEBPACK_IMPORTED_MODULE_28__.http.get(_core_path_js__WEBPACK_IMPORTED_MODULE_27__.path.join(urlBase, gltfBuffer.uri), {\n              cache: true,\n              responseType: 'arraybuffer',\n              retry: false\n            }, function (i, err, result) {\n              if (err) {\n                callback(err);\n              } else {\n                onLoad(i, new Uint8Array(result));\n              }\n            }.bind(null, i));\n          }\n        } else {\n          onLoad(i, binaryChunk);\n        }\n      }\n    }.bind(null, i, gltfBuffer));\n  }\n};\nconst parseGltf = function parseGltf(gltfChunk, callback) {\n  const decodeBinaryUtf8 = function decodeBinaryUtf8(array) {\n    if (typeof TextDecoder !== 'undefined') {\n      return new TextDecoder().decode(array);\n    }\n    let str = '';\n    for (let i = 0; i < array.length; i++) {\n      str += String.fromCharCode(array[i]);\n    }\n    return decodeURIComponent(escape(str));\n  };\n  const gltf = JSON.parse(decodeBinaryUtf8(gltfChunk));\n  if (gltf.asset && gltf.asset.version && parseFloat(gltf.asset.version) < 2) {\n    callback(`Invalid gltf version. Expected version 2.0 or above but found version '${gltf.asset.version}'.`);\n    return;\n  }\n  const extensionsRequired = (gltf == null ? void 0 : gltf.extensionsRequired) || [];\n  if (!dracoDecoderInstance && !getGlobalDracoDecoderModule() && extensionsRequired.indexOf('KHR_draco_mesh_compression') !== -1) {\n    _core_wasm_module_js__WEBPACK_IMPORTED_MODULE_29__.WasmModule.getInstance('DracoDecoderModule', instance => {\n      dracoDecoderInstance = instance;\n      callback(null, gltf);\n    });\n  } else {\n    callback(null, gltf);\n  }\n};\nconst parseGlb = function parseGlb(glbData, callback) {\n  const data = glbData instanceof ArrayBuffer ? new DataView(glbData) : new DataView(glbData.buffer, glbData.byteOffset, glbData.byteLength);\n  const magic = data.getUint32(0, true);\n  const version = data.getUint32(4, true);\n  const length = data.getUint32(8, true);\n  if (magic !== 0x46546C67) {\n    callback('Invalid magic number found in glb header. Expected 0x46546C67, found 0x' + magic.toString(16));\n    return;\n  }\n  if (version !== 2) {\n    callback('Invalid version number found in glb header. Expected 2, found ' + version);\n    return;\n  }\n  if (length <= 0 || length > data.byteLength) {\n    callback('Invalid length found in glb header. Found ' + length);\n    return;\n  }\n  const chunks = [];\n  let offset = 12;\n  while (offset < length) {\n    const chunkLength = data.getUint32(offset, true);\n    if (offset + chunkLength + 8 > data.byteLength) {\n      throw new Error('Invalid chunk length found in glb. Found ' + chunkLength);\n    }\n    const chunkType = data.getUint32(offset + 4, true);\n    const chunkData = new Uint8Array(data.buffer, data.byteOffset + offset + 8, chunkLength);\n    chunks.push({\n      length: chunkLength,\n      type: chunkType,\n      data: chunkData\n    });\n    offset += chunkLength + 8;\n  }\n  if (chunks.length !== 1 && chunks.length !== 2) {\n    callback('Invalid number of chunks found in glb file.');\n    return;\n  }\n  if (chunks[0].type !== 0x4E4F534A) {\n    callback('Invalid chunk type found in glb file. Expected 0x4E4F534A, found 0x' + chunks[0].type.toString(16));\n    return;\n  }\n  if (chunks.length > 1 && chunks[1].type !== 0x004E4942) {\n    callback('Invalid chunk type found in glb file. Expected 0x004E4942, found 0x' + chunks[1].type.toString(16));\n    return;\n  }\n  callback(null, {\n    gltfChunk: chunks[0].data,\n    binaryChunk: chunks.length === 2 ? chunks[1].data : null\n  });\n};\nconst parseChunk = function parseChunk(filename, data, callback) {\n  const hasGlbHeader = () => {\n    const u8 = new Uint8Array(data);\n    return u8[0] === 103 && u8[1] === 108 && u8[2] === 84 && u8[3] === 70;\n  };\n  if (filename && filename.toLowerCase().endsWith('.glb') || hasGlbHeader()) {\n    parseGlb(data, callback);\n  } else {\n    callback(null, {\n      gltfChunk: data,\n      binaryChunk: null\n    });\n  }\n};\nconst parseBufferViewsAsync = function parseBufferViewsAsync(gltf, buffers, options, callback) {\n  const result = [];\n  const preprocess = options && options.bufferView && options.bufferView.preprocess;\n  const processAsync = options && options.bufferView && options.bufferView.processAsync || function (gltfBufferView, buffers, callback) {\n    callback(null, null);\n  };\n  const postprocess = options && options.bufferView && options.bufferView.postprocess;\n  let remaining = gltf.bufferViews ? gltf.bufferViews.length : 0;\n  if (!remaining) {\n    callback(null, null);\n    return;\n  }\n  const onLoad = function onLoad(index, bufferView) {\n    const gltfBufferView = gltf.bufferViews[index];\n    if (gltfBufferView.hasOwnProperty('byteStride')) {\n      bufferView.byteStride = gltfBufferView.byteStride;\n    }\n    result[index] = bufferView;\n    if (postprocess) {\n      postprocess(gltfBufferView, bufferView);\n    }\n    if (--remaining === 0) {\n      callback(null, result);\n    }\n  };\n  for (let i = 0; i < gltf.bufferViews.length; ++i) {\n    const gltfBufferView = gltf.bufferViews[i];\n    if (preprocess) {\n      preprocess(gltfBufferView);\n    }\n    processAsync(gltfBufferView, buffers, function (i, gltfBufferView, err, result) {\n      if (err) {\n        callback(err);\n      } else if (result) {\n        onLoad(i, result);\n      } else {\n        const buffer = buffers[gltfBufferView.buffer];\n        const typedArray = new Uint8Array(buffer.buffer, buffer.byteOffset + (gltfBufferView.byteOffset || 0), gltfBufferView.byteLength);\n        onLoad(i, typedArray);\n      }\n    }.bind(null, i, gltfBufferView));\n  }\n};\nclass GlbParser {\n  static parseAsync(filename, urlBase, data, device, registry, options, callback) {\n    parseChunk(filename, data, function (err, chunks) {\n      if (err) {\n        callback(err);\n        return;\n      }\n      parseGltf(chunks.gltfChunk, function (err, gltf) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        loadBuffersAsync(gltf, chunks.binaryChunk, urlBase, options, function (err, buffers) {\n          if (err) {\n            callback(err);\n            return;\n          }\n          parseBufferViewsAsync(gltf, buffers, options, function (err, bufferViews) {\n            if (err) {\n              callback(err);\n              return;\n            }\n            loadTexturesAsync(gltf, bufferViews, urlBase, registry, options, function (err, textureAssets) {\n              if (err) {\n                callback(err);\n                return;\n              }\n              createResources(device, gltf, bufferViews, textureAssets, options, callback);\n            });\n          });\n        });\n      });\n    });\n  }\n  static parse(filename, data, device, options) {\n    let result = null;\n    options = options || {};\n    parseChunk(filename, data, function (err, chunks) {\n      if (err) {\n        console.error(err);\n      } else {\n        parseGltf(chunks.gltfChunk, function (err, gltf) {\n          if (err) {\n            console.error(err);\n          } else {\n            parseBufferViewsAsync(gltf, [chunks.binaryChunk], options, function (err, bufferViews) {\n              if (err) {\n                console.error(err);\n              } else {\n                createResources(device, gltf, bufferViews, [], options, function (err, result_) {\n                  if (err) {\n                    console.error(err);\n                  } else {\n                    result = result_;\n                  }\n                });\n              }\n            });\n          }\n        });\n      }\n    });\n    return result;\n  }\n  constructor(device, assets, maxRetries) {\n    this._device = device;\n    this._assets = assets;\n    this._defaultMaterial = createMaterial({\n      name: 'defaultGlbMaterial'\n    }, []);\n    this.maxRetries = maxRetries;\n  }\n  _getUrlWithoutParams(url) {\n    return url.indexOf('?') >= 0 ? url.split('?')[0] : url;\n  }\n  load(url, callback, asset) {\n    _asset_asset_js__WEBPACK_IMPORTED_MODULE_5__.Asset.fetchArrayBuffer(url.load, (err, result) => {\n      if (err) {\n        callback(err);\n      } else {\n        GlbParser.parseAsync(this._getUrlWithoutParams(url.original), _core_path_js__WEBPACK_IMPORTED_MODULE_27__.path.extractPath(url.load), result, this._device, asset.registry, asset.options, (err, result) => {\n          if (err) {\n            callback(err);\n          } else {\n            callback(null, new _glb_container_resource_js__WEBPACK_IMPORTED_MODULE_30__.GlbContainerResource(result, asset, this._assets, this._defaultMaterial));\n          }\n        });\n      }\n    }, asset, this.maxRetries);\n  }\n  open(url, data, asset) {\n    return data;\n  }\n  patch(asset, assets) {}\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/glb-parser.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/json-model.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/json-model.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"JsonModelParser\": () => (/* binding */ JsonModelParser)\n/* harmony export */ });\n/* harmony import */ var _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/math/mat4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/shape/bounding-box.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/shape/bounding-box.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_index_buffer_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../platform/graphics/index-buffer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/index-buffer.js\");\n/* harmony import */ var _platform_graphics_vertex_buffer_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../platform/graphics/vertex-buffer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/vertex-buffer.js\");\n/* harmony import */ var _platform_graphics_vertex_format_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../platform/graphics/vertex-format.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/vertex-format.js\");\n/* harmony import */ var _platform_graphics_vertex_iterator_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../platform/graphics/vertex-iterator.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/vertex-iterator.js\");\n/* harmony import */ var _scene_skin_partition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../scene/skin-partition.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/skin-partition.js\");\n/* harmony import */ var _scene_graph_node_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../scene/graph-node.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/graph-node.js\");\n/* harmony import */ var _scene_mesh_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../scene/mesh.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh.js\");\n/* harmony import */ var _scene_mesh_instance_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../scene/mesh-instance.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh-instance.js\");\n/* harmony import */ var _scene_model_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../scene/model.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/model.js\");\n/* harmony import */ var _scene_morph_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../scene/morph.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/morph.js\");\n/* harmony import */ var _scene_morph_instance_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../scene/morph-instance.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/morph-instance.js\");\n/* harmony import */ var _scene_morph_target_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../scene/morph-target.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/morph-target.js\");\n/* harmony import */ var _scene_skin_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../scene/skin.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/skin.js\");\n/* harmony import */ var _scene_skin_instance_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../scene/skin-instance.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/skin-instance.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst JSON_PRIMITIVE_TYPE = {\n  'points': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PRIMITIVE_POINTS,\n  'lines': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PRIMITIVE_LINES,\n  'lineloop': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PRIMITIVE_LINELOOP,\n  'linestrip': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PRIMITIVE_LINESTRIP,\n  'triangles': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PRIMITIVE_TRIANGLES,\n  'trianglestrip': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PRIMITIVE_TRISTRIP,\n  'trianglefan': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PRIMITIVE_TRIFAN\n};\nconst JSON_VERTEX_ELEMENT_TYPE = {\n  'int8': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_INT8,\n  'uint8': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_UINT8,\n  'int16': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_INT16,\n  'uint16': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_UINT16,\n  'int32': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_INT32,\n  'uint32': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_UINT32,\n  'float32': _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_FLOAT32\n};\nclass JsonModelParser {\n  constructor(device, defaultMaterial) {\n    this._device = device;\n    this._defaultMaterial = defaultMaterial;\n  }\n  parse(data) {\n    const modelData = data.model;\n    if (!modelData) {\n      return null;\n    }\n    if (modelData.version <= 1) {\n      return null;\n    }\n    const nodes = this._parseNodes(data);\n    const skins = this._parseSkins(data, nodes);\n    const vertexBuffers = this._parseVertexBuffers(data);\n    const indices = this._parseIndexBuffers(data, vertexBuffers);\n    const morphs = this._parseMorphs(data, nodes, vertexBuffers);\n    const meshes = this._parseMeshes(data, skins.skins, morphs.morphs, vertexBuffers, indices.buffer, indices.data);\n    const meshInstances = this._parseMeshInstances(data, nodes, meshes, skins.skins, skins.instances, morphs.morphs, morphs.instances);\n    const model = new _scene_model_js__WEBPACK_IMPORTED_MODULE_1__.Model();\n    model.graph = nodes[0];\n    model.meshInstances = meshInstances;\n    model.skinInstances = skins.instances;\n    model.morphInstances = morphs.instances;\n    model.getGraph().syncHierarchy();\n    return model;\n  }\n  _parseNodes(data) {\n    const modelData = data.model;\n    const nodes = [];\n    let i;\n    for (i = 0; i < modelData.nodes.length; i++) {\n      const nodeData = modelData.nodes[i];\n      const node = new _scene_graph_node_js__WEBPACK_IMPORTED_MODULE_2__.GraphNode(nodeData.name);\n      node.setLocalPosition(nodeData.position[0], nodeData.position[1], nodeData.position[2]);\n      node.setLocalEulerAngles(nodeData.rotation[0], nodeData.rotation[1], nodeData.rotation[2]);\n      node.setLocalScale(nodeData.scale[0], nodeData.scale[1], nodeData.scale[2]);\n      node.scaleCompensation = !!nodeData.scaleCompensation;\n      nodes.push(node);\n    }\n    for (i = 1; i < modelData.parents.length; i++) {\n      nodes[modelData.parents[i]].addChild(nodes[i]);\n    }\n    return nodes;\n  }\n  _parseSkins(data, nodes) {\n    const modelData = data.model;\n    const skins = [];\n    const skinInstances = [];\n    let i, j;\n    if (!this._device.supportsBoneTextures && modelData.skins.length > 0) {\n      const boneLimit = this._device.getBoneLimit();\n      (0,_scene_skin_partition_js__WEBPACK_IMPORTED_MODULE_3__.partitionSkin)(modelData, null, boneLimit);\n    }\n    for (i = 0; i < modelData.skins.length; i++) {\n      const skinData = modelData.skins[i];\n      const inverseBindMatrices = [];\n      for (j = 0; j < skinData.inverseBindMatrices.length; j++) {\n        const ibm = skinData.inverseBindMatrices[j];\n        inverseBindMatrices[j] = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_4__.Mat4().set(ibm);\n      }\n      const skin = new _scene_skin_js__WEBPACK_IMPORTED_MODULE_5__.Skin(this._device, inverseBindMatrices, skinData.boneNames);\n      skins.push(skin);\n      const skinInstance = new _scene_skin_instance_js__WEBPACK_IMPORTED_MODULE_6__.SkinInstance(skin);\n      const bones = [];\n      for (j = 0; j < skin.boneNames.length; j++) {\n        const boneName = skin.boneNames[j];\n        const bone = nodes[0].findByName(boneName);\n        bones.push(bone);\n      }\n      skinInstance.bones = bones;\n      skinInstances.push(skinInstance);\n    }\n    return {\n      skins: skins,\n      instances: skinInstances\n    };\n  }\n  _getMorphVertexCount(modelData, morphIndex, vertexBuffers) {\n    for (let i = 0; i < modelData.meshes.length; i++) {\n      const meshData = modelData.meshes[i];\n      if (meshData.morph === morphIndex) {\n        const vertexBuffer = vertexBuffers[meshData.vertices];\n        return vertexBuffer.numVertices;\n      }\n    }\n    return undefined;\n  }\n  _parseMorphs(data, nodes, vertexBuffers) {\n    const modelData = data.model;\n    const morphs = [];\n    const morphInstances = [];\n    let i, j, vertexCount;\n    let targets, morphTarget, morphTargetArray;\n    if (modelData.morphs) {\n      const sparseToFull = function sparseToFull(data, indices, totalCount) {\n        const full = new Float32Array(totalCount * 3);\n        for (let s = 0; s < indices.length; s++) {\n          const dstIndex = indices[s] * 3;\n          full[dstIndex] = data[s * 3];\n          full[dstIndex + 1] = data[s * 3 + 1];\n          full[dstIndex + 2] = data[s * 3 + 2];\n        }\n        return full;\n      };\n      for (i = 0; i < modelData.morphs.length; i++) {\n        targets = modelData.morphs[i].targets;\n        morphTargetArray = [];\n        vertexCount = this._getMorphVertexCount(modelData, i, vertexBuffers);\n        for (j = 0; j < targets.length; j++) {\n          const targetAabb = targets[j].aabb;\n          const min = targetAabb.min;\n          const max = targetAabb.max;\n          const aabb = new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_7__.BoundingBox(new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_8__.Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_8__.Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));\n          const indices = targets[j].indices;\n          let deltaPositions = targets[j].deltaPositions;\n          let deltaNormals = targets[j].deltaNormals;\n          if (indices) {\n            deltaPositions = sparseToFull(deltaPositions, indices, vertexCount);\n            deltaNormals = sparseToFull(deltaNormals, indices, vertexCount);\n          }\n          morphTarget = new _scene_morph_target_js__WEBPACK_IMPORTED_MODULE_9__.MorphTarget({\n            deltaPositions: deltaPositions,\n            deltaNormals: deltaNormals,\n            name: targets[j].name,\n            aabb: aabb\n          });\n          morphTargetArray.push(morphTarget);\n        }\n        const morph = new _scene_morph_js__WEBPACK_IMPORTED_MODULE_10__.Morph(morphTargetArray, this._device);\n        morphs.push(morph);\n        const morphInstance = new _scene_morph_instance_js__WEBPACK_IMPORTED_MODULE_11__.MorphInstance(morph);\n        morphInstances.push(morphInstance);\n      }\n    }\n    return {\n      morphs: morphs,\n      instances: morphInstances\n    };\n  }\n  _parseVertexBuffers(data) {\n    const modelData = data.model;\n    const vertexBuffers = [];\n    const attributeMap = {\n      position: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_POSITION,\n      normal: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_NORMAL,\n      tangent: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TANGENT,\n      blendWeight: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_BLENDWEIGHT,\n      blendIndices: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_BLENDINDICES,\n      color: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_COLOR,\n      texCoord0: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD0,\n      texCoord1: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD1,\n      texCoord2: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD2,\n      texCoord3: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD3,\n      texCoord4: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD4,\n      texCoord5: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD5,\n      texCoord6: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD6,\n      texCoord7: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD7\n    };\n    for (let i = 0; i < modelData.vertices.length; i++) {\n      const vertexData = modelData.vertices[i];\n      const formatDesc = [];\n      for (const attributeName in vertexData) {\n        const attribute = vertexData[attributeName];\n        formatDesc.push({\n          semantic: attributeMap[attributeName],\n          components: attribute.components,\n          type: JSON_VERTEX_ELEMENT_TYPE[attribute.type],\n          normalize: attributeMap[attributeName] === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_COLOR\n        });\n      }\n      const vertexFormat = new _platform_graphics_vertex_format_js__WEBPACK_IMPORTED_MODULE_12__.VertexFormat(this._device, formatDesc);\n      const numVertices = vertexData.position.data.length / vertexData.position.components;\n      const vertexBuffer = new _platform_graphics_vertex_buffer_js__WEBPACK_IMPORTED_MODULE_13__.VertexBuffer(this._device, vertexFormat, numVertices);\n      const iterator = new _platform_graphics_vertex_iterator_js__WEBPACK_IMPORTED_MODULE_14__.VertexIterator(vertexBuffer);\n      for (let j = 0; j < numVertices; j++) {\n        for (const attributeName in vertexData) {\n          const attribute = vertexData[attributeName];\n          switch (attribute.components) {\n            case 1:\n              iterator.element[attributeMap[attributeName]].set(attribute.data[j]);\n              break;\n            case 2:\n              iterator.element[attributeMap[attributeName]].set(attribute.data[j * 2], 1.0 - attribute.data[j * 2 + 1]);\n              break;\n            case 3:\n              iterator.element[attributeMap[attributeName]].set(attribute.data[j * 3], attribute.data[j * 3 + 1], attribute.data[j * 3 + 2]);\n              break;\n            case 4:\n              iterator.element[attributeMap[attributeName]].set(attribute.data[j * 4], attribute.data[j * 4 + 1], attribute.data[j * 4 + 2], attribute.data[j * 4 + 3]);\n              break;\n          }\n        }\n        iterator.next();\n      }\n      iterator.end();\n      vertexBuffers.push(vertexBuffer);\n    }\n    return vertexBuffers;\n  }\n  _parseIndexBuffers(data, vertexBuffers) {\n    const modelData = data.model;\n    let indexBuffer = null;\n    let indexData = null;\n    let i;\n    let numIndices = 0;\n    for (i = 0; i < modelData.meshes.length; i++) {\n      const meshData = modelData.meshes[i];\n      if (meshData.indices !== undefined) {\n        numIndices += meshData.indices.length;\n      }\n    }\n    let maxVerts = 0;\n    for (i = 0; i < vertexBuffers.length; i++) {\n      maxVerts = Math.max(maxVerts, vertexBuffers[i].numVertices);\n    }\n    if (numIndices > 0) {\n      if (maxVerts > 0xFFFF && this._device.extUintElement) {\n        indexBuffer = new _platform_graphics_index_buffer_js__WEBPACK_IMPORTED_MODULE_15__.IndexBuffer(this._device, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.INDEXFORMAT_UINT32, numIndices);\n        indexData = new Uint32Array(indexBuffer.lock());\n      } else {\n        indexBuffer = new _platform_graphics_index_buffer_js__WEBPACK_IMPORTED_MODULE_15__.IndexBuffer(this._device, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.INDEXFORMAT_UINT16, numIndices);\n        indexData = new Uint16Array(indexBuffer.lock());\n      }\n    }\n    return {\n      buffer: indexBuffer,\n      data: indexData\n    };\n  }\n  _parseMeshes(data, skins, morphs, vertexBuffers, indexBuffer, indexData) {\n    const modelData = data.model;\n    const meshes = [];\n    let indexBase = 0;\n    for (let i = 0; i < modelData.meshes.length; i++) {\n      const meshData = modelData.meshes[i];\n      const meshAabb = meshData.aabb;\n      const min = meshAabb.min;\n      const max = meshAabb.max;\n      const aabb = new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_7__.BoundingBox(new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_8__.Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_8__.Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));\n      const indexed = meshData.indices !== undefined;\n      const mesh = new _scene_mesh_js__WEBPACK_IMPORTED_MODULE_16__.Mesh(this._device);\n      mesh.vertexBuffer = vertexBuffers[meshData.vertices];\n      mesh.indexBuffer[0] = indexed ? indexBuffer : null;\n      mesh.primitive[0].type = JSON_PRIMITIVE_TYPE[meshData.type];\n      mesh.primitive[0].base = indexed ? meshData.base + indexBase : meshData.base;\n      mesh.primitive[0].count = meshData.count;\n      mesh.primitive[0].indexed = indexed;\n      mesh.skin = meshData.skin !== undefined ? skins[meshData.skin] : null;\n      mesh.morph = meshData.morph !== undefined ? morphs[meshData.morph] : null;\n      mesh.aabb = aabb;\n      if (indexed) {\n        indexData.set(meshData.indices, indexBase);\n        indexBase += meshData.indices.length;\n      }\n      meshes.push(mesh);\n    }\n    if (indexBuffer !== null) {\n      indexBuffer.unlock();\n    }\n    return meshes;\n  }\n  _parseMeshInstances(data, nodes, meshes, skins, skinInstances, morphs, morphInstances) {\n    const modelData = data.model;\n    const meshInstances = [];\n    let i;\n    for (i = 0; i < modelData.meshInstances.length; i++) {\n      const meshInstanceData = modelData.meshInstances[i];\n      const node = nodes[meshInstanceData.node];\n      const mesh = meshes[meshInstanceData.mesh];\n      const meshInstance = new _scene_mesh_instance_js__WEBPACK_IMPORTED_MODULE_17__.MeshInstance(mesh, this._defaultMaterial, node);\n      if (mesh.skin) {\n        const skinIndex = skins.indexOf(mesh.skin);\n        meshInstance.skinInstance = skinInstances[skinIndex];\n      }\n      if (mesh.morph) {\n        const morphIndex = morphs.indexOf(mesh.morph);\n        meshInstance.morphInstance = morphInstances[morphIndex];\n      }\n      meshInstances.push(meshInstance);\n    }\n    return meshInstances;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/json-model.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/material/json-standard-material.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/material/json-standard-material.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"JsonStandardMaterialParser\": () => (/* binding */ JsonStandardMaterialParser)\n/* harmony export */ });\n/* harmony import */ var _virtual_rollupPluginBabelHelpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../_virtual/_rollupPluginBabelHelpers.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/_virtual/_rollupPluginBabelHelpers.js\");\n/* harmony import */ var _core_math_color_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/math/color.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../platform/graphics/texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js\");\n/* harmony import */ var _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../core/shape/bounding-box.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/shape/bounding-box.js\");\n/* harmony import */ var _scene_constants_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../scene/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _scene_materials_standard_material_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../scene/materials/standard-material.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material.js\");\n/* harmony import */ var _scene_materials_standard_material_validator_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../scene/materials/standard-material-validator.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material-validator.js\");\n/* harmony import */ var _scene_materials_standard_material_parameters_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../scene/materials/standard-material-parameters.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material-parameters.js\");\n\n\n\n\n\n\n\n\n\n\n\nclass JsonStandardMaterialParser {\n  constructor() {\n    this._validator = null;\n  }\n  parse(input) {\n    const migrated = this.migrate(input);\n    const validated = this._validate(migrated);\n    const material = new _scene_materials_standard_material_js__WEBPACK_IMPORTED_MODULE_0__.StandardMaterial();\n    this.initialize(material, validated);\n    return material;\n  }\n  initialize(material, data) {\n    if (!data.validated) {\n      data = this._validate(data);\n    }\n    if (data.chunks) {\n      material.chunks = (0,_virtual_rollupPluginBabelHelpers_js__WEBPACK_IMPORTED_MODULE_1__[\"extends\"])({}, data.chunks);\n    }\n    for (const key in data) {\n      const type = _scene_materials_standard_material_parameters_js__WEBPACK_IMPORTED_MODULE_2__.standardMaterialParameterTypes[key];\n      const value = data[key];\n      if (type === 'vec2') {\n        material[key] = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_3__.Vec2(value[0], value[1]);\n      } else if (type === 'rgb') {\n        material[key] = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_4__.Color(value[0], value[1], value[2]);\n      } else if (type === 'texture') {\n        if (value instanceof _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_5__.Texture) {\n          material[key] = value;\n        } else if (!(material[key] instanceof _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_5__.Texture && typeof value === 'number' && value > 0)) {\n          material[key] = null;\n        }\n      } else if (type === 'cubemap') {\n        if (value instanceof _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_5__.Texture) {\n          material[key] = value;\n        } else if (!(material[key] instanceof _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_5__.Texture && typeof value === 'number' && value > 0)) {\n          material[key] = null;\n        }\n        if (key === 'cubeMap' && !value) {\n          material.prefilteredCubemaps = null;\n        }\n      } else if (type === 'boundingbox') {\n        const center = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_6__.Vec3(value.center[0], value.center[1], value.center[2]);\n        const halfExtents = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_6__.Vec3(value.halfExtents[0], value.halfExtents[1], value.halfExtents[2]);\n        material[key] = new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_7__.BoundingBox(center, halfExtents);\n      } else {\n        material[key] = data[key];\n      }\n    }\n    material.update();\n  }\n  migrate(data) {\n    if (data.shadingModel === undefined) {\n      if (data.shader === 'blinn') {\n        data.shadingModel = _scene_constants_js__WEBPACK_IMPORTED_MODULE_8__.SPECULAR_BLINN;\n      } else {\n        data.shadingModel = _scene_constants_js__WEBPACK_IMPORTED_MODULE_8__.SPECULAR_PHONG;\n      }\n    }\n    if (data.shader) delete data.shader;\n    if (data.mapping_format) {\n      data.mappingFormat = data.mapping_format;\n      delete data.mapping_format;\n    }\n    let i;\n    const RENAMED_PROPERTIES = [['bumpMapFactor', 'bumpiness'], ['aoUvSet', 'aoMapUv'], ['aoMapVertexColor', 'aoVertexColor'], ['diffuseMapVertexColor', 'diffuseVertexColor'], ['emissiveMapVertexColor', 'emissiveVertexColor'], ['specularMapVertexColor', 'specularVertexColor'], ['metalnessMapVertexColor', 'metalnessVertexColor'], ['opacityMapVertexColor', 'opacityVertexColor'], ['glossMapVertexColor', 'glossVertexColor'], ['lightMapVertexColor', 'lightVertexColor'], ['diffuseMapTint', 'diffuseTint'], ['specularMapTint', 'specularTint'], ['emissiveMapTint', 'emissiveTint'], ['metalnessMapTint', 'metalnessTint'], ['clearCoatGlossiness', 'clearCoatGloss']];\n    for (i = 0; i < RENAMED_PROPERTIES.length; i++) {\n      const _old = RENAMED_PROPERTIES[i][0];\n      const _new = RENAMED_PROPERTIES[i][1];\n      if (data[_old] !== undefined && !(data[_new] !== undefined)) {\n        data[_new] = data[_old];\n        delete data[_old];\n      }\n    }\n    const DEPRECATED_PROPERTIES = ['fresnelFactor', 'shadowSampleType'];\n    for (i = 0; i < DEPRECATED_PROPERTIES.length; i++) {\n      const name = DEPRECATED_PROPERTIES[i];\n      if (data.hasOwnProperty(name)) {\n        delete data[name];\n      }\n    }\n    return data;\n  }\n  _validate(data) {\n    if (!data.validated) {\n      if (!this._validator) {\n        this._validator = new _scene_materials_standard_material_validator_js__WEBPACK_IMPORTED_MODULE_9__.StandardMaterialValidator();\n      }\n      this._validator.validate(data);\n    }\n    return data;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/material/json-standard-material.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/scene.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/scene.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SceneParser\": () => (/* binding */ SceneParser)\n/* harmony export */ });\n/* harmony import */ var _entity_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../entity.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/entity.js\");\n/* harmony import */ var _scene_compress_compress_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../scene/compress/compress-utils.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/compress/compress-utils.js\");\n/* harmony import */ var _scene_compress_decompress_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../scene/compress/decompress.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/compress/decompress.js\");\n\n\n\n\n\nclass SceneParser {\n  constructor(app, isTemplate) {\n    this._app = app;\n    this._isTemplate = isTemplate;\n  }\n  parse(data) {\n    const entities = {};\n    let parent = null;\n    const compressed = data.compressedFormat;\n    if (compressed && !data.entDecompressed) {\n      data.entDecompressed = true;\n      data.entities = new _scene_compress_decompress_js__WEBPACK_IMPORTED_MODULE_0__.Decompress(data.entities, compressed).run();\n    }\n    for (const id in data.entities) {\n      const curData = data.entities[id];\n      const curEnt = this._createEntity(curData, compressed);\n      entities[id] = curEnt;\n      if (curData.parent === null) {\n        parent = curEnt;\n      }\n    }\n    for (const id in data.entities) {\n      const curEnt = entities[id];\n      const children = data.entities[id].children;\n      const len = children.length;\n      for (let i = 0; i < len; i++) {\n        const childEnt = entities[children[i]];\n        if (childEnt) {\n          curEnt.addChild(childEnt);\n        }\n      }\n    }\n    this._openComponentData(parent, data.entities);\n    return parent;\n  }\n  _createEntity(data, compressed) {\n    const entity = new _entity_js__WEBPACK_IMPORTED_MODULE_1__.Entity(data.name, this._app);\n    entity.setGuid(data.resource_id);\n    this._setPosRotScale(entity, data, compressed);\n    entity._enabled = data.enabled !== undefined ? data.enabled : true;\n    if (this._isTemplate) {\n      entity._template = true;\n    } else {\n      entity._enabledInHierarchy = entity._enabled;\n    }\n    entity.template = data.template;\n    if (data.tags) {\n      for (let i = 0; i < data.tags.length; i++) {\n        entity.tags.add(data.tags[i]);\n      }\n    }\n    if (data.labels) {\n      data.labels.forEach(function (label) {\n        entity.addLabel(label);\n      });\n    }\n    return entity;\n  }\n  _setPosRotScale(entity, data, compressed) {\n    if (compressed) {\n      _scene_compress_compress_utils_js__WEBPACK_IMPORTED_MODULE_2__.CompressUtils.setCompressedPRS(entity, data, compressed);\n    } else {\n      const p = data.position;\n      const r = data.rotation;\n      const s = data.scale;\n      entity.setLocalPosition(p[0], p[1], p[2]);\n      entity.setLocalEulerAngles(r[0], r[1], r[2]);\n      entity.setLocalScale(s[0], s[1], s[2]);\n    }\n  }\n  _openComponentData(entity, entities) {\n    const systemsList = this._app.systems.list;\n    let len = systemsList.length;\n    const entityData = entities[entity.getGuid()];\n    for (let i = 0; i < len; i++) {\n      const system = systemsList[i];\n      const componentData = entityData.components[system.id];\n      if (componentData) {\n        system.addComponent(entity, componentData);\n      }\n    }\n    len = entityData.children.length;\n    const children = entity._children;\n    for (let i = 0; i < len; i++) {\n      if (children[i]) {\n        children[i] = this._openComponentData(children[i], entities);\n      }\n    }\n    return entity;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/scene.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/texture/basis.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/texture/basis.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BasisParser\": () => (/* binding */ BasisParser)\n/* harmony export */ });\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../platform/graphics/texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js\");\n/* harmony import */ var _asset_asset_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../asset/asset.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset.js\");\n/* harmony import */ var _handlers_basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../handlers/basis.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/basis.js\");\n\n\n\n\n\nclass BasisParser {\n  constructor(registry, device) {\n    this.device = device;\n    this.maxRetries = 0;\n  }\n  load(url, callback, asset) {\n    const device = this.device;\n    const transcode = data => {\n      var _asset$file, _asset$file$variants, _asset$file$variants$;\n      const basisModuleFound = (0,_handlers_basis_js__WEBPACK_IMPORTED_MODULE_0__.basisTranscode)(device, url.load, data, callback, {\n        isGGGR: ((asset == null ? void 0 : (_asset$file = asset.file) == null ? void 0 : (_asset$file$variants = _asset$file.variants) == null ? void 0 : (_asset$file$variants$ = _asset$file$variants.basis) == null ? void 0 : _asset$file$variants$.opt) & 8) !== 0\n      });\n      if (!basisModuleFound) {\n        callback(`Basis module not found. Asset '${asset.name}' basis texture variant will not be loaded.`);\n      }\n    };\n    _asset_asset_js__WEBPACK_IMPORTED_MODULE_1__.Asset.fetchArrayBuffer(url.load, (err, result) => {\n      if (err) {\n        callback(err);\n      } else {\n        transcode(result);\n      }\n    }, asset, this.maxRetries);\n  }\n  open(url, data, device) {\n    const texture = new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_2__.Texture(device, {\n      name: url,\n      addressU: data.cubemap ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.ADDRESS_CLAMP_TO_EDGE : _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.ADDRESS_REPEAT,\n      addressV: data.cubemap ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.ADDRESS_CLAMP_TO_EDGE : _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.ADDRESS_REPEAT,\n      width: data.width,\n      height: data.height,\n      format: data.format,\n      cubemap: data.cubemap,\n      levels: data.levels\n    });\n    texture.upload();\n    return texture;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/texture/basis.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/texture/dds.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/texture/dds.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DdsParser\": () => (/* binding */ DdsParser)\n/* harmony export */ });\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../platform/graphics/texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js\");\n/* harmony import */ var _asset_asset_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../asset/asset.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset.js\");\n\n\n\n\n\nclass DdsParser {\n  constructor(registry) {\n    this.maxRetries = 0;\n  }\n  load(url, callback, asset) {\n    _asset_asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);\n  }\n  open(url, data, device) {\n    const header = new Uint32Array(data, 0, 128 / 4);\n    const width = header[4];\n    const height = header[3];\n    const mips = Math.max(header[7], 1);\n    const isFourCc = header[20] === 4;\n    const fcc = header[21];\n    const bpp = header[22];\n    const isCubemap = header[28] === 65024;\n    const FCC_DXT1 = 827611204;\n    const FCC_DXT5 = 894720068;\n    const FCC_FP16 = 113;\n    const FCC_FP32 = 116;\n    const FCC_ETC1 = 826496069;\n    const FCC_PVRTC_2BPP_RGB_1 = 825438800;\n    const FCC_PVRTC_2BPP_RGBA_1 = 825504336;\n    const FCC_PVRTC_4BPP_RGB_1 = 825439312;\n    const FCC_PVRTC_4BPP_RGBA_1 = 825504848;\n    let compressed = false;\n    let etc1 = false;\n    let pvrtc2 = false;\n    let pvrtc4 = false;\n    let format = null;\n    let componentSize = 1;\n    let texture;\n    if (isFourCc) {\n      if (fcc === FCC_DXT1) {\n        format = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.PIXELFORMAT_DXT1;\n        compressed = true;\n      } else if (fcc === FCC_DXT5) {\n        format = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.PIXELFORMAT_DXT5;\n        compressed = true;\n      } else if (fcc === FCC_FP16) {\n        format = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.PIXELFORMAT_RGBA16F;\n        componentSize = 2;\n      } else if (fcc === FCC_FP32) {\n        format = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.PIXELFORMAT_RGBA32F;\n        componentSize = 4;\n      } else if (fcc === FCC_ETC1) {\n        format = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.PIXELFORMAT_ETC1;\n        compressed = true;\n        etc1 = true;\n      } else if (fcc === FCC_PVRTC_2BPP_RGB_1 || fcc === FCC_PVRTC_2BPP_RGBA_1) {\n        format = fcc === FCC_PVRTC_2BPP_RGB_1 ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.PIXELFORMAT_PVRTC_2BPP_RGB_1 : _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.PIXELFORMAT_PVRTC_2BPP_RGBA_1;\n        compressed = true;\n        pvrtc2 = true;\n      } else if (fcc === FCC_PVRTC_4BPP_RGB_1 || fcc === FCC_PVRTC_4BPP_RGBA_1) {\n        format = fcc === FCC_PVRTC_4BPP_RGB_1 ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.PIXELFORMAT_PVRTC_4BPP_RGB_1 : _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.PIXELFORMAT_PVRTC_4BPP_RGBA_1;\n        compressed = true;\n        pvrtc4 = true;\n      }\n    } else {\n      if (bpp === 32) {\n        format = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.PIXELFORMAT_RGBA8;\n      }\n    }\n    if (!format) {\n      texture = new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_2__.Texture(device, {\n        width: 4,\n        height: 4,\n        format: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.PIXELFORMAT_RGB8,\n        name: 'dds-legacy-empty'\n      });\n      return texture;\n    }\n    texture = new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_2__.Texture(device, {\n      name: url,\n      addressU: isCubemap ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.ADDRESS_CLAMP_TO_EDGE : _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.ADDRESS_REPEAT,\n      addressV: isCubemap ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.ADDRESS_CLAMP_TO_EDGE : _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.ADDRESS_REPEAT,\n      width: width,\n      height: height,\n      format: format,\n      cubemap: isCubemap,\n      mipmaps: mips > 1\n    });\n    let offset = 128;\n    const faces = isCubemap ? 6 : 1;\n    let mipSize;\n    const DXT_BLOCK_WIDTH = 4;\n    const DXT_BLOCK_HEIGHT = 4;\n    const blockSize = fcc === FCC_DXT1 ? 8 : 16;\n    let numBlocksAcross, numBlocksDown, numBlocks;\n    for (let face = 0; face < faces; face++) {\n      let mipWidth = width;\n      let mipHeight = height;\n      for (let i = 0; i < mips; i++) {\n        if (compressed) {\n          if (etc1) {\n            mipSize = Math.floor((mipWidth + 3) / 4) * Math.floor((mipHeight + 3) / 4) * 8;\n          } else if (pvrtc2) {\n            mipSize = Math.max(mipWidth, 16) * Math.max(mipHeight, 8) / 4;\n          } else if (pvrtc4) {\n            mipSize = Math.max(mipWidth, 8) * Math.max(mipHeight, 8) / 2;\n          } else {\n            numBlocksAcross = Math.floor((mipWidth + DXT_BLOCK_WIDTH - 1) / DXT_BLOCK_WIDTH);\n            numBlocksDown = Math.floor((mipHeight + DXT_BLOCK_HEIGHT - 1) / DXT_BLOCK_HEIGHT);\n            numBlocks = numBlocksAcross * numBlocksDown;\n            mipSize = numBlocks * blockSize;\n          }\n        } else {\n          mipSize = mipWidth * mipHeight * 4;\n        }\n        const mipBuff = format === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.PIXELFORMAT_RGBA32F ? new Float32Array(data, offset, mipSize) : format === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.PIXELFORMAT_RGBA16F ? new Uint16Array(data, offset, mipSize) : new Uint8Array(data, offset, mipSize);\n        if (!isCubemap) {\n          texture._levels[i] = mipBuff;\n        } else {\n          if (!texture._levels[i]) texture._levels[i] = [];\n          texture._levels[i][face] = mipBuff;\n        }\n        offset += mipSize * componentSize;\n        mipWidth = Math.max(mipWidth * 0.5, 1);\n        mipHeight = Math.max(mipHeight * 0.5, 1);\n      }\n    }\n    texture.upload();\n    return texture;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/texture/dds.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/texture/hdr.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/texture/hdr.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HdrParser\": () => (/* binding */ HdrParser)\n/* harmony export */ });\n/* harmony import */ var _core_read_stream_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/read-stream.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/read-stream.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../platform/graphics/texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js\");\n/* harmony import */ var _asset_asset_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../asset/asset.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset.js\");\n\n\n\n\n\n\nclass HdrParser {\n  constructor(registry) {\n    this.maxRetries = 0;\n  }\n  load(url, callback, asset) {\n    _asset_asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);\n  }\n  open(url, data, device) {\n    const textureData = this.parse(data);\n    if (!textureData) {\n      return null;\n    }\n    const texture = new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture(device, {\n      name: url,\n      addressU: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.ADDRESS_REPEAT,\n      addressV: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.ADDRESS_CLAMP_TO_EDGE,\n      minFilter: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.FILTER_NEAREST,\n      magFilter: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.FILTER_NEAREST,\n      width: textureData.width,\n      height: textureData.height,\n      levels: textureData.levels,\n      format: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.PIXELFORMAT_RGBA8,\n      type: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.TEXTURETYPE_RGBE,\n      mipmaps: false\n    });\n    texture.upload();\n    return texture;\n  }\n  parse(data) {\n    const readStream = new _core_read_stream_js__WEBPACK_IMPORTED_MODULE_3__.ReadStream(data);\n    const magic = readStream.readLine();\n    if (!magic.startsWith('#?RADIANCE')) {\n      return null;\n    }\n    const variables = {};\n    while (true) {\n      const line = readStream.readLine();\n      if (line.length === 0) {\n        break;\n      } else {\n        const parts = line.split('=');\n        if (parts.length === 2) {\n          variables[parts[0]] = parts[1];\n        }\n      }\n    }\n    if (!variables.hasOwnProperty('FORMAT')) {\n      return null;\n    }\n    const resolution = readStream.readLine().split(' ');\n    if (resolution.length !== 4) {\n      return null;\n    }\n    const height = parseInt(resolution[1], 10);\n    const width = parseInt(resolution[3], 10);\n    const pixels = this._readPixels(readStream, width, height, resolution[0] === '-Y');\n    if (!pixels) {\n      return null;\n    }\n    return {\n      width: width,\n      height: height,\n      levels: [pixels]\n    };\n  }\n  _readPixels(readStream, width, height, flipY) {\n    if (width < 8 || width > 0x7fff) {\n      return this._readPixelsFlat(readStream, width, height);\n    }\n    const rgbe = [0, 0, 0, 0];\n    readStream.readArray(rgbe);\n    if (rgbe[0] !== 2 || rgbe[1] !== 2 || (rgbe[2] & 0x80) !== 0) {\n      readStream.skip(-4);\n      return this._readPixelsFlat(readStream, width, height);\n    }\n    const buffer = new ArrayBuffer(width * height * 4);\n    const view = new Uint8Array(buffer);\n    let scanstart = flipY ? 0 : width * 4 * (height - 1);\n    let x, y, i, channel, count, value;\n    for (y = 0; y < height; ++y) {\n      if (y) {\n        readStream.readArray(rgbe);\n      }\n      if ((rgbe[2] << 8) + rgbe[3] !== width) {\n        return null;\n      }\n      for (channel = 0; channel < 4; ++channel) {\n        x = 0;\n        while (x < width) {\n          count = readStream.readU8();\n          if (count > 128) {\n            count -= 128;\n            if (x + count > width) {\n              return null;\n            }\n            value = readStream.readU8();\n            for (i = 0; i < count; ++i) {\n              view[scanstart + channel + 4 * x++] = value;\n            }\n          } else {\n            if (count === 0 || x + count > width) {\n              return null;\n            }\n            for (i = 0; i < count; ++i) {\n              view[scanstart + channel + 4 * x++] = readStream.readU8();\n            }\n          }\n        }\n      }\n      scanstart += width * 4 * (flipY ? 1 : -1);\n    }\n    return view;\n  }\n  _readPixelsFlat(readStream, width, height) {\n    return readStream.remainingBytes === width * height * 4 ? new Uint8Array(readStream.arraybuffer, readStream.offset) : null;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/texture/hdr.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/texture/img.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/texture/img.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ImgParser\": () => (/* binding */ ImgParser)\n/* harmony export */ });\n/* harmony import */ var _core_path_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/path.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/path.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../platform/graphics/texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js\");\n/* harmony import */ var _platform_net_http_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../platform/net/http.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/net/http.js\");\n/* harmony import */ var _asset_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../asset/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/constants.js\");\n\n\n\n\n\n\nclass ImgParser {\n  constructor(registry, device) {\n    this.crossOrigin = registry.prefix ? 'anonymous' : null;\n    this.maxRetries = 0;\n    this.device = device;\n  }\n  load(url, callback, asset) {\n    var _asset$file;\n    const hasContents = !!(asset != null && (_asset$file = asset.file) != null && _asset$file.contents);\n    if (hasContents) {\n      if (this.device.supportsImageBitmap) {\n        this._loadImageBitmapFromData(asset.file.contents, callback);\n        return;\n      }\n      url = {\n        load: URL.createObjectURL(new Blob([asset.file.contents])),\n        original: url.original\n      };\n    }\n    const handler = (err, result) => {\n      if (hasContents) {\n        URL.revokeObjectURL(url.load);\n      }\n      callback(err, result);\n    };\n    let crossOrigin;\n    if (asset && asset.options && asset.options.hasOwnProperty('crossOrigin')) {\n      crossOrigin = asset.options.crossOrigin;\n    } else if (_asset_constants_js__WEBPACK_IMPORTED_MODULE_0__.ABSOLUTE_URL.test(url.load)) {\n      crossOrigin = this.crossOrigin;\n    }\n    if (this.device.supportsImageBitmap) {\n      this._loadImageBitmap(url.load, url.original, crossOrigin, handler);\n    } else {\n      this._loadImage(url.load, url.original, crossOrigin, handler);\n    }\n  }\n  open(url, data, device) {\n    const ext = _core_path_js__WEBPACK_IMPORTED_MODULE_1__.path.getExtension(url).toLowerCase();\n    const format = ext === '.jpg' || ext === '.jpeg' ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.PIXELFORMAT_RGB8 : _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.PIXELFORMAT_RGBA8;\n    const texture = new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_3__.Texture(device, {\n      name: url,\n      width: data.width,\n      height: data.height,\n      format: format\n    });\n    texture.setSource(data);\n    return texture;\n  }\n  _loadImage(url, originalUrl, crossOrigin, callback) {\n    const image = new Image();\n    if (crossOrigin) {\n      image.crossOrigin = crossOrigin;\n    }\n    let retries = 0;\n    const maxRetries = this.maxRetries;\n    let retryTimeout;\n    image.onload = function () {\n      callback(null, image);\n    };\n    image.onerror = function () {\n      if (retryTimeout) return;\n      if (maxRetries > 0 && ++retries <= maxRetries) {\n        const retryDelay = Math.pow(2, retries) * 100;\n        console.log(`Error loading Texture from: '${originalUrl}' - Retrying in ${retryDelay}ms...`);\n        const idx = url.indexOf('?');\n        const separator = idx >= 0 ? '&' : '?';\n        retryTimeout = setTimeout(function () {\n          image.src = url + separator + 'retry=' + Date.now();\n          retryTimeout = null;\n        }, retryDelay);\n      } else {\n        callback(`Error loading Texture from: '${originalUrl}'`);\n      }\n    };\n    image.src = url;\n  }\n  _loadImageBitmap(url, originalUrl, crossOrigin, callback) {\n    const options = {\n      cache: true,\n      responseType: 'blob',\n      retry: this.maxRetries > 0,\n      maxRetries: this.maxRetries\n    };\n    _platform_net_http_js__WEBPACK_IMPORTED_MODULE_4__.http.get(url, options, function (err, blob) {\n      if (err) {\n        callback(err);\n      } else {\n        createImageBitmap(blob, {\n          premultiplyAlpha: 'none'\n        }).then(imageBitmap => callback(null, imageBitmap)).catch(e => callback(e));\n      }\n    });\n  }\n  _loadImageBitmapFromData(data, callback) {\n    createImageBitmap(new Blob([data]), {\n      premultiplyAlpha: 'none'\n    }).then(imageBitmap => callback(null, imageBitmap)).catch(e => callback(e));\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/texture/img.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/texture/ktx.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/texture/ktx.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"KtxParser\": () => (/* binding */ KtxParser)\n/* harmony export */ });\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../platform/graphics/texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js\");\n/* harmony import */ var _asset_asset_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../asset/asset.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset.js\");\n\n\n\n\n\nconst IDENTIFIER = [0x58544BAB, 0xBB313120, 0x0A1A0A0D];\nconst KNOWN_FORMATS = {\n  0x83F0: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_DXT1,\n  0x83F2: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_DXT3,\n  0x83F3: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_DXT5,\n  0x8D64: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_ETC1,\n  0x9274: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_ETC2_RGB,\n  0x9278: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_ETC2_RGBA,\n  0x8C00: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_PVRTC_4BPP_RGB_1,\n  0x8C01: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_PVRTC_2BPP_RGB_1,\n  0x8C02: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_PVRTC_4BPP_RGBA_1,\n  0x8C03: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_PVRTC_2BPP_RGBA_1,\n  0x8051: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGB8,\n  0x8058: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA8,\n  0x8C41: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_SRGB,\n  0x8C43: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_SRGBA,\n  0x8C3A: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_111110F,\n  0x881B: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGB16F,\n  0x881A: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA16F\n};\nfunction createContainer(pixelFormat, buffer, byteOffset, byteSize) {\n  return pixelFormat === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_111110F ? new Uint32Array(buffer, byteOffset, byteSize / 4) : new Uint8Array(buffer, byteOffset, byteSize);\n}\nclass KtxParser {\n  constructor(registry) {\n    this.maxRetries = 0;\n  }\n  load(url, callback, asset) {\n    _asset_asset_js__WEBPACK_IMPORTED_MODULE_1__.Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);\n  }\n  open(url, data, device) {\n    const textureData = this.parse(data);\n    if (!textureData) {\n      return null;\n    }\n    const texture = new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_2__.Texture(device, {\n      name: url,\n      addressU: textureData.cubemap ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_CLAMP_TO_EDGE : _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_REPEAT,\n      addressV: textureData.cubemap ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_CLAMP_TO_EDGE : _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_REPEAT,\n      width: textureData.width,\n      height: textureData.height,\n      format: textureData.format,\n      cubemap: textureData.cubemap,\n      levels: textureData.levels\n    });\n    texture.upload();\n    return texture;\n  }\n  parse(data) {\n    const dataU32 = new Uint32Array(data);\n    if (IDENTIFIER[0] !== dataU32[0] || IDENTIFIER[1] !== dataU32[1] || IDENTIFIER[2] !== dataU32[2]) {\n      return null;\n    }\n    const header = {\n      endianness: dataU32[3],\n      glType: dataU32[4],\n      glTypeSize: dataU32[5],\n      glFormat: dataU32[6],\n      glInternalFormat: dataU32[7],\n      glBaseInternalFormat: dataU32[8],\n      pixelWidth: dataU32[9],\n      pixelHeight: dataU32[10],\n      pixelDepth: dataU32[11],\n      numberOfArrayElements: dataU32[12],\n      numberOfFaces: dataU32[13],\n      numberOfMipmapLevels: dataU32[14],\n      bytesOfKeyValueData: dataU32[15]\n    };\n    if (header.pixelDepth > 1) {\n      return null;\n    }\n    if (header.numberOfArrayElements !== 0) {\n      return null;\n    }\n    const format = KNOWN_FORMATS[header.glInternalFormat];\n    if (format === undefined) {\n      return null;\n    }\n    let offset = 16 + header.bytesOfKeyValueData / 4;\n    const isCubemap = header.numberOfFaces > 1;\n    const levels = [];\n    for (let mipmapLevel = 0; mipmapLevel < (header.numberOfMipmapLevels || 1); mipmapLevel++) {\n      const imageSizeInBytes = dataU32[offset++];\n      if (isCubemap) {\n        levels.push([]);\n      }\n      const target = isCubemap ? levels[mipmapLevel] : levels;\n      for (let face = 0; face < (isCubemap ? 6 : 1); ++face) {\n        target.push(createContainer(format, data, offset * 4, imageSizeInBytes));\n        offset += imageSizeInBytes + 3 >> 2;\n      }\n    }\n    return {\n      format: format,\n      width: header.pixelWidth,\n      height: header.pixelHeight,\n      levels: levels,\n      cubemap: isCubemap\n    };\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/texture/ktx.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/texture/ktx2.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/texture/ktx2.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Ktx2Parser\": () => (/* binding */ Ktx2Parser)\n/* harmony export */ });\n/* harmony import */ var _core_read_stream_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/read-stream.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/read-stream.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../platform/graphics/texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js\");\n/* harmony import */ var _asset_asset_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../asset/asset.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset.js\");\n/* harmony import */ var _handlers_basis_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../handlers/basis.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/handlers/basis.js\");\n\n\n\n\n\n\n\nconst KHRConstants = {\n  KHR_DF_MODEL_ETC1S: 163,\n  KHR_DF_MODEL_UASTC: 166\n};\nclass Ktx2Parser {\n  constructor(registry, device) {\n    this.maxRetries = 0;\n    this.device = device;\n  }\n  load(url, callback, asset) {\n    _asset_asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset.fetchArrayBuffer(url.load, (err, result) => {\n      if (err) {\n        callback(err, result);\n      } else {\n        this.parse(result, url, callback, asset);\n      }\n    }, asset, this.maxRetries);\n  }\n  open(url, data, device) {\n    const texture = new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture(device, {\n      name: url,\n      addressU: data.cubemap ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.ADDRESS_CLAMP_TO_EDGE : _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.ADDRESS_REPEAT,\n      addressV: data.cubemap ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.ADDRESS_CLAMP_TO_EDGE : _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.ADDRESS_REPEAT,\n      width: data.width,\n      height: data.height,\n      format: data.format,\n      cubemap: data.cubemap,\n      levels: data.levels\n    });\n    texture.upload();\n    return texture;\n  }\n  parse(arraybuffer, url, callback, asset) {\n    const rs = new _core_read_stream_js__WEBPACK_IMPORTED_MODULE_3__.ReadStream(arraybuffer);\n    const magic = [rs.readU32be(), rs.readU32be(), rs.readU32be()];\n    if (magic[0] !== 0xAB4B5458 || magic[1] !== 0x203230BB || magic[2] !== 0x0D0A1A0A) {\n      return null;\n    }\n    const header = {\n      vkFormat: rs.readU32(),\n      typeSize: rs.readU32(),\n      pixelWidth: rs.readU32(),\n      pixelHeight: rs.readU32(),\n      pixelDepth: rs.readU32(),\n      layerCount: rs.readU32(),\n      faceCount: rs.readU32(),\n      levelCount: rs.readU32(),\n      supercompressionScheme: rs.readU32()\n    };\n    const index = {\n      dfdByteOffset: rs.readU32(),\n      dfdByteLength: rs.readU32(),\n      kvdByteOffset: rs.readU32(),\n      kvdByteLength: rs.readU32(),\n      sgdByteOffset: rs.readU64(),\n      sgdByteLength: rs.readU64()\n    };\n    const levels = [];\n    for (let i = 0; i < Math.max(1, header.levelCount); ++i) {\n      levels.push({\n        byteOffset: rs.readU64(),\n        byteLength: rs.readU64(),\n        uncompressedByteLength: rs.readU64()\n      });\n    }\n    const dfdTotalSize = rs.readU32();\n    if (dfdTotalSize !== index.kvdByteOffset - index.dfdByteOffset) {\n      return null;\n    }\n    rs.skip(8);\n    const colorModel = rs.readU8();\n    rs.skip(index.dfdByteLength - 9);\n    rs.skip(index.kvdByteLength);\n    if (header.supercompressionScheme === 1 || colorModel === KHRConstants.KHR_DF_MODEL_UASTC) {\n      var _asset$file, _asset$file$variants, _asset$file$variants$;\n      const basisModuleFound = (0,_handlers_basis_js__WEBPACK_IMPORTED_MODULE_4__.basisTranscode)(this.device, url.load, arraybuffer, callback, {\n        isGGGR: ((asset == null ? void 0 : (_asset$file = asset.file) == null ? void 0 : (_asset$file$variants = _asset$file.variants) == null ? void 0 : (_asset$file$variants$ = _asset$file$variants.basis) == null ? void 0 : _asset$file$variants$.opt) & 8) !== 0,\n        isKTX2: true\n      });\n      if (!basisModuleFound) {\n        callback('Basis module not found. Asset \"' + asset.name + '\" basis texture variant will not be loaded.');\n      }\n    } else {\n      callback('unsupported KTX2 pixel format');\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/texture/ktx2.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/scene-registry-item.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/scene-registry-item.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SceneRegistryItem\": () => (/* binding */ SceneRegistryItem)\n/* harmony export */ });\nclass SceneRegistryItem {\n  constructor(name, url) {\n    this.name = name;\n    this.url = url;\n    this.data = null;\n    this._loading = false;\n    this._onLoadedCallbacks = [];\n  }\n  get loaded() {\n    return !!this.data;\n  }\n  get loading() {\n    return this._loading;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/scene-registry-item.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/scene-registry.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/scene-registry.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SceneRegistry\": () => (/* binding */ SceneRegistry)\n/* harmony export */ });\n/* harmony import */ var _core_path_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/path.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/path.js\");\n/* harmony import */ var _asset_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./asset/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/constants.js\");\n/* harmony import */ var _scene_registry_item_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scene-registry-item.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/scene-registry-item.js\");\n\n\n\n\n\nclass SceneRegistry {\n  constructor(app) {\n    this._app = app;\n    this._list = [];\n    this._index = {};\n    this._urlIndex = {};\n  }\n  destroy() {\n    this._app = null;\n  }\n  list() {\n    return this._list;\n  }\n  add(name, url) {\n    if (this._index.hasOwnProperty(name)) {\n      return false;\n    }\n    const item = new _scene_registry_item_js__WEBPACK_IMPORTED_MODULE_0__.SceneRegistryItem(name, url);\n    const i = this._list.push(item);\n    this._index[item.name] = i - 1;\n    this._urlIndex[item.url] = i - 1;\n    return true;\n  }\n  find(name) {\n    if (this._index.hasOwnProperty(name)) {\n      return this._list[this._index[name]];\n    }\n    return null;\n  }\n  findByUrl(url) {\n    if (this._urlIndex.hasOwnProperty(url)) {\n      return this._list[this._urlIndex[url]];\n    }\n    return null;\n  }\n  remove(name) {\n    if (this._index.hasOwnProperty(name)) {\n      const idx = this._index[name];\n      let item = this._list[idx];\n      delete this._urlIndex[item.url];\n      delete this._index[name];\n      this._list.splice(idx, 1);\n      for (let i = 0; i < this._list.length; i++) {\n        item = this._list[i];\n        this._index[item.name] = i;\n        this._urlIndex[item.url] = i;\n      }\n    }\n  }\n  _loadSceneData(sceneItem, storeInCache, callback) {\n    const app = this._app;\n    let url = sceneItem;\n    if (typeof sceneItem === 'string') {\n      sceneItem = this.findByUrl(url) || this.find(url) || new _scene_registry_item_js__WEBPACK_IMPORTED_MODULE_0__.SceneRegistryItem('Untitled', url);\n    }\n    url = sceneItem.url;\n    if (!url) {\n      callback(\"Cannot find scene to load\");\n      return;\n    }\n    if (sceneItem.loaded) {\n      callback(null, sceneItem);\n      return;\n    }\n    if (app.assets && app.assets.prefix && !_asset_constants_js__WEBPACK_IMPORTED_MODULE_1__.ABSOLUTE_URL.test(url)) {\n      url = _core_path_js__WEBPACK_IMPORTED_MODULE_2__.path.join(app.assets.prefix, url);\n    }\n    sceneItem._onLoadedCallbacks.push(callback);\n    if (!sceneItem._loading) {\n      const handler = app.loader.getHandler(\"hierarchy\");\n      handler.load(url, (err, data) => {\n        sceneItem.data = data;\n        sceneItem._loading = false;\n        for (let i = 0; i < sceneItem._onLoadedCallbacks.length; i++) {\n          sceneItem._onLoadedCallbacks[i](err, sceneItem);\n        }\n        if (!storeInCache) {\n          sceneItem.data = null;\n        }\n        sceneItem._onLoadedCallbacks.length = 0;\n      });\n    }\n    sceneItem._loading = true;\n  }\n  loadSceneData(sceneItem, callback) {\n    this._loadSceneData(sceneItem, true, callback);\n  }\n  unloadSceneData(sceneItem) {\n    if (typeof sceneItem === 'string') {\n      sceneItem = this.findByUrl(sceneItem);\n    }\n    if (sceneItem) {\n      sceneItem.data = null;\n    }\n  }\n  _loadSceneHierarchy(sceneItem, onBeforeAddHierarchy, callback) {\n    this._loadSceneData(sceneItem, false, (err, sceneItem) => {\n      if (err) {\n        if (callback) {\n          callback(err);\n        }\n        return;\n      }\n      if (onBeforeAddHierarchy) {\n        onBeforeAddHierarchy(sceneItem);\n      }\n      const app = this._app;\n      const _loaded = () => {\n        const handler = app.loader.getHandler(\"hierarchy\");\n        app.systems.script.preloading = true;\n        const entity = handler.open(sceneItem.url, sceneItem.data);\n        app.systems.script.preloading = false;\n        app.loader.clearCache(sceneItem.url, \"hierarchy\");\n        app.root.addChild(entity);\n        app.systems.fire('initialize', entity);\n        app.systems.fire('postInitialize', entity);\n        app.systems.fire('postPostInitialize', entity);\n        if (callback) callback(null, entity);\n      };\n      app._preloadScripts(sceneItem.data, _loaded);\n    });\n  }\n  loadSceneHierarchy(sceneItem, callback) {\n    this._loadSceneHierarchy(sceneItem, null, callback);\n  }\n  loadSceneSettings(sceneItem, callback) {\n    this._loadSceneData(sceneItem, false, (err, sceneItem) => {\n      if (!err) {\n        this._app.applySceneSettings(sceneItem.data.settings);\n        if (callback) {\n          callback(null);\n        }\n      } else {\n        if (callback) {\n          callback(err);\n        }\n      }\n    });\n  }\n  changeScene(sceneItem, callback) {\n    const app = this._app;\n    const onBeforeAddHierarchy = sceneItem => {\n      const rootChildren = app.root.children;\n      while (rootChildren.length > 0) {\n        const child = rootChildren[0];\n        child.reparent(null);\n        child.destroy == null ? void 0 : child.destroy();\n      }\n      app.applySceneSettings(sceneItem.data.settings);\n    };\n    this._loadSceneHierarchy(sceneItem, onBeforeAddHierarchy, callback);\n  }\n  loadScene(url, callback) {\n    const app = this._app;\n    const handler = app.loader.getHandler(\"scene\");\n    if (app.assets && app.assets.prefix && !_asset_constants_js__WEBPACK_IMPORTED_MODULE_1__.ABSOLUTE_URL.test(url)) {\n      url = _core_path_js__WEBPACK_IMPORTED_MODULE_2__.path.join(app.assets.prefix, url);\n    }\n    handler.load(url, (err, data) => {\n      if (!err) {\n        const _loaded = () => {\n          app.systems.script.preloading = true;\n          const scene = handler.open(url, data);\n          const sceneItem = this.findByUrl(url);\n          if (sceneItem && !sceneItem.loaded) {\n            sceneItem.data = data;\n          }\n          app.systems.script.preloading = false;\n          app.loader.clearCache(url, \"scene\");\n          app.loader.patch({\n            resource: scene,\n            type: \"scene\"\n          }, app.assets);\n          app.root.addChild(scene.root);\n          if (app.systems.rigidbody && typeof Ammo !== 'undefined') {\n            app.systems.rigidbody.gravity.set(scene._gravity.x, scene._gravity.y, scene._gravity.z);\n          }\n          if (callback) {\n            callback(null, scene);\n          }\n        };\n        app._preloadScripts(data, _loaded);\n      } else {\n        if (callback) {\n          callback(err);\n        }\n      }\n    });\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/scene-registry.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/script.js":
/*!**************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/script.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"script\": () => (/* binding */ script)\n/* harmony export */ });\n/* harmony import */ var _core_events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/events.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/events.js\");\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./globals.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/globals.js\");\n/* harmony import */ var _script_script_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./script/script-types.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/script/script-types.js\");\n\n\n\n\nlet _legacy = false;\nlet _createdLoadingScreen = false;\nconst script = {\n  app: null,\n  create: function (name, callback) {\n    if (!_legacy) return;\n    const ScriptType = callback(script.app);\n    ScriptType._pcScriptName = name;\n    _script_script_types_js__WEBPACK_IMPORTED_MODULE_0__.ScriptTypes.push(ScriptType, _legacy);\n    this.fire(\"created\", name, callback);\n  },\n  attribute: function (name, type, defaultValue, options) {},\n  createLoadingScreen: function (callback) {\n    if (_createdLoadingScreen) return;\n    _createdLoadingScreen = true;\n    const app = (0,_globals_js__WEBPACK_IMPORTED_MODULE_1__.getApplication)();\n    callback(app);\n  }\n};\nObject.defineProperty(script, 'legacy', {\n  get: function () {\n    return _legacy;\n  },\n  set: function (value) {\n    _legacy = value;\n  }\n});\n_core_events_js__WEBPACK_IMPORTED_MODULE_2__.events.attach(script);\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/script.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/script/constants.js":
/*!************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/script/constants.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SCRIPT_INITIALIZE\": () => (/* binding */ SCRIPT_INITIALIZE),\n/* harmony export */   \"SCRIPT_POST_INITIALIZE\": () => (/* binding */ SCRIPT_POST_INITIALIZE),\n/* harmony export */   \"SCRIPT_POST_UPDATE\": () => (/* binding */ SCRIPT_POST_UPDATE),\n/* harmony export */   \"SCRIPT_SWAP\": () => (/* binding */ SCRIPT_SWAP),\n/* harmony export */   \"SCRIPT_UPDATE\": () => (/* binding */ SCRIPT_UPDATE)\n/* harmony export */ });\nconst SCRIPT_INITIALIZE = 'initialize';\nconst SCRIPT_POST_INITIALIZE = 'postInitialize';\nconst SCRIPT_UPDATE = 'update';\nconst SCRIPT_POST_UPDATE = 'postUpdate';\nconst SCRIPT_SWAP = 'swap';\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/script/constants.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/script/script-attributes.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/script/script-attributes.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScriptAttributes\": () => (/* binding */ ScriptAttributes)\n/* harmony export */ });\n/* harmony import */ var _core_math_color_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/math/color.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n/* harmony import */ var _core_math_curve_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/math/curve.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/curve.js\");\n/* harmony import */ var _core_math_curve_set_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/math/curve-set.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/curve-set.js\");\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/math/vec4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec4.js\");\n/* harmony import */ var _scene_graph_node_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../scene/graph-node.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/graph-node.js\");\n/* harmony import */ var _asset_asset_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../asset/asset.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/asset/asset.js\");\n\n\n\n\n\n\n\n\n\n\nconst components = ['x', 'y', 'z', 'w'];\nconst vecLookup = [undefined, undefined, _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_0__.Vec2, _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3, _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_2__.Vec4];\nfunction rawToValue(app, args, value, old) {\n  switch (args.type) {\n    case 'boolean':\n      return !!value;\n    case 'number':\n      if (typeof value === 'number') {\n        return value;\n      } else if (typeof value === 'string') {\n        const v = parseInt(value, 10);\n        if (isNaN(v)) return null;\n        return v;\n      } else if (typeof value === 'boolean') {\n        return 0 + value;\n      }\n      return null;\n    case 'json':\n      {\n        const result = {};\n        if (Array.isArray(args.schema)) {\n          if (!value || typeof value !== 'object') {\n            value = {};\n          }\n          for (let i = 0; i < args.schema.length; i++) {\n            const field = args.schema[i];\n            if (!field.name) continue;\n            if (field.array) {\n              result[field.name] = [];\n              const arr = Array.isArray(value[field.name]) ? value[field.name] : [];\n              for (let j = 0; j < arr.length; j++) {\n                result[field.name].push(rawToValue(app, field, arr[j]));\n              }\n            } else {\n              const val = value.hasOwnProperty(field.name) ? value[field.name] : field.default;\n              result[field.name] = rawToValue(app, field, val);\n            }\n          }\n        }\n        return result;\n      }\n    case 'asset':\n      if (value instanceof _asset_asset_js__WEBPACK_IMPORTED_MODULE_3__.Asset) {\n        return value;\n      } else if (typeof value === 'number') {\n        return app.assets.get(value) || null;\n      } else if (typeof value === 'string') {\n        return app.assets.get(parseInt(value, 10)) || null;\n      }\n      return null;\n    case 'entity':\n      if (value instanceof _scene_graph_node_js__WEBPACK_IMPORTED_MODULE_4__.GraphNode) {\n        return value;\n      } else if (typeof value === 'string') {\n        return app.getEntityFromIndex(value);\n      }\n      return null;\n    case 'rgb':\n    case 'rgba':\n      if (value instanceof _core_math_color_js__WEBPACK_IMPORTED_MODULE_5__.Color) {\n        if (old instanceof _core_math_color_js__WEBPACK_IMPORTED_MODULE_5__.Color) {\n          old.copy(value);\n          return old;\n        }\n        return value.clone();\n      } else if (value instanceof Array && value.length >= 3 && value.length <= 4) {\n        for (let i = 0; i < value.length; i++) {\n          if (typeof value[i] !== 'number') return null;\n        }\n        if (!old) old = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_5__.Color();\n        old.r = value[0];\n        old.g = value[1];\n        old.b = value[2];\n        old.a = value.length === 3 ? 1 : value[3];\n        return old;\n      } else if (typeof value === 'string' && /#([0-9abcdef]{2}){3,4}/i.test(value)) {\n        if (!old) old = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_5__.Color();\n        old.fromString(value);\n        return old;\n      }\n      return null;\n    case 'vec2':\n    case 'vec3':\n    case 'vec4':\n      {\n        const len = parseInt(args.type.slice(3), 10);\n        const vecType = vecLookup[len];\n        if (value instanceof vecType) {\n          if (old instanceof vecType) {\n            old.copy(value);\n            return old;\n          }\n          return value.clone();\n        } else if (value instanceof Array && value.length === len) {\n          for (let i = 0; i < value.length; i++) {\n            if (typeof value[i] !== 'number') return null;\n          }\n          if (!old) old = new vecType();\n          for (let i = 0; i < len; i++) old[components[i]] = value[i];\n          return old;\n        }\n        return null;\n      }\n    case 'curve':\n      if (value) {\n        let curve;\n        if (value instanceof _core_math_curve_js__WEBPACK_IMPORTED_MODULE_6__.Curve || value instanceof _core_math_curve_set_js__WEBPACK_IMPORTED_MODULE_7__.CurveSet) {\n          curve = value.clone();\n        } else {\n          const CurveType = value.keys[0] instanceof Array ? _core_math_curve_set_js__WEBPACK_IMPORTED_MODULE_7__.CurveSet : _core_math_curve_js__WEBPACK_IMPORTED_MODULE_6__.Curve;\n          curve = new CurveType(value.keys);\n          curve.type = value.type;\n        }\n        return curve;\n      }\n      break;\n  }\n  return value;\n}\nclass ScriptAttributes {\n  constructor(scriptType) {\n    this.scriptType = scriptType;\n    this.index = {};\n  }\n  add(name, args) {\n    if (this.index[name]) {\n      return;\n    } else if (ScriptAttributes.reservedNames.has(name)) {\n      return;\n    }\n    this.index[name] = args;\n    Object.defineProperty(this.scriptType.prototype, name, {\n      get: function () {\n        return this.__attributes[name];\n      },\n      set: function (raw) {\n        const evt = 'attr';\n        const evtName = 'attr:' + name;\n        const old = this.__attributes[name];\n        let oldCopy = old;\n        if (old && args.type !== 'json' && old.clone) {\n          if (this._callbacks[evt] || this._callbacks[evtName]) {\n            oldCopy = old.clone();\n          }\n        }\n        if (args.array) {\n          this.__attributes[name] = [];\n          if (raw) {\n            for (let i = 0, len = raw.length; i < len; i++) {\n              this.__attributes[name].push(rawToValue(this.app, args, raw[i], old ? old[i] : null));\n            }\n          }\n        } else {\n          this.__attributes[name] = rawToValue(this.app, args, raw, old);\n        }\n        this.fire(evt, name, this.__attributes[name], oldCopy);\n        this.fire(evtName, this.__attributes[name], oldCopy);\n      }\n    });\n  }\n  remove(name) {\n    if (!this.index[name]) return false;\n    delete this.index[name];\n    delete this.scriptType.prototype[name];\n    return true;\n  }\n  has(name) {\n    return !!this.index[name];\n  }\n  get(name) {\n    return this.index[name] || null;\n  }\n}\nScriptAttributes.reservedNames = new Set(['app', 'entity', 'enabled', '_enabled', '_enabledOld', '_destroyed', '__attributes', '__attributesRaw', '__scriptType', '__executionOrder', '_callbacks', 'has', 'get', 'on', 'off', 'fire', 'once', 'hasEvent']);\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/script/script-attributes.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/script/script-registry.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/script/script-registry.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScriptRegistry\": () => (/* binding */ ScriptRegistry)\n/* harmony export */ });\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n\n\nclass ScriptRegistry extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor(app) {\n    super();\n    this.app = app;\n    this._scripts = {};\n    this._list = [];\n  }\n  destroy() {\n    this.app = null;\n    this.off();\n  }\n  add(script) {\n    const scriptName = script.__name;\n    if (this._scripts.hasOwnProperty(scriptName)) {\n      setTimeout(() => {\n        if (script.prototype.swap) {\n          const old = this._scripts[scriptName];\n          const ind = this._list.indexOf(old);\n          this._list[ind] = script;\n          this._scripts[scriptName] = script;\n          this.fire('swap', scriptName, script);\n          this.fire('swap:' + scriptName, script);\n        } else {\n          console.warn(`script registry already has '${scriptName}' script, define 'swap' method for new script type to enable code hot swapping`);\n        }\n      });\n      return false;\n    }\n    this._scripts[scriptName] = script;\n    this._list.push(script);\n    this.fire('add', scriptName, script);\n    this.fire('add:' + scriptName, script);\n    setTimeout(() => {\n      if (!this._scripts.hasOwnProperty(scriptName)) return;\n      if (!this.app || !this.app.systems || !this.app.systems.script) {\n        return;\n      }\n      const components = this.app.systems.script._components;\n      let attributes;\n      const scriptInstances = [];\n      const scriptInstancesInitialized = [];\n      for (components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++) {\n        const component = components.items[components.loopIndex];\n        if (component._scriptsIndex[scriptName] && component._scriptsIndex[scriptName].awaiting) {\n          if (component._scriptsData && component._scriptsData[scriptName]) attributes = component._scriptsData[scriptName].attributes;\n          const scriptInstance = component.create(scriptName, {\n            preloading: true,\n            ind: component._scriptsIndex[scriptName].ind,\n            attributes: attributes\n          });\n          if (scriptInstance) scriptInstances.push(scriptInstance);\n        }\n      }\n      for (let i = 0; i < scriptInstances.length; i++) scriptInstances[i].__initializeAttributes();\n      for (let i = 0; i < scriptInstances.length; i++) {\n        if (scriptInstances[i].enabled) {\n          scriptInstances[i]._initialized = true;\n          scriptInstancesInitialized.push(scriptInstances[i]);\n          if (scriptInstances[i].initialize) scriptInstances[i].initialize();\n        }\n      }\n      for (let i = 0; i < scriptInstancesInitialized.length; i++) {\n        if (!scriptInstancesInitialized[i].enabled || scriptInstancesInitialized[i]._postInitialized) {\n          continue;\n        }\n        scriptInstancesInitialized[i]._postInitialized = true;\n        if (scriptInstancesInitialized[i].postInitialize) scriptInstancesInitialized[i].postInitialize();\n      }\n    });\n    return true;\n  }\n  remove(nameOrType) {\n    let scriptType = nameOrType;\n    let scriptName = nameOrType;\n    if (typeof scriptName !== 'string') {\n      scriptName = scriptType.__name;\n    } else {\n      scriptType = this.get(scriptName);\n    }\n    if (this.get(scriptName) !== scriptType) return false;\n    delete this._scripts[scriptName];\n    const ind = this._list.indexOf(scriptType);\n    this._list.splice(ind, 1);\n    this.fire('remove', scriptName, scriptType);\n    this.fire('remove:' + scriptName, scriptType);\n    return true;\n  }\n  get(name) {\n    return this._scripts[name] || null;\n  }\n  has(nameOrType) {\n    if (typeof nameOrType === 'string') {\n      return this._scripts.hasOwnProperty(nameOrType);\n    }\n    if (!nameOrType) return false;\n    const scriptName = nameOrType.__name;\n    return this._scripts[scriptName] === nameOrType;\n  }\n  list() {\n    return this._list;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/script/script-registry.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/script/script-types.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/script/script-types.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScriptTypes\": () => (/* binding */ ScriptTypes)\n/* harmony export */ });\nclass ScriptTypes {\n  static push(Type, isLegacy) {\n    if (isLegacy && ScriptTypes._types.length > 0) {\n      console.assert('Script Ordering Error. Contact support@playcanvas.com');\n    } else {\n      ScriptTypes._types.push(Type);\n    }\n  }\n}\nScriptTypes._types = [];\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/script/script-types.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/stats.js":
/*!*************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/stats.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ApplicationStats\": () => (/* binding */ ApplicationStats)\n/* harmony export */ });\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/globals.js\");\n\n\nclass ApplicationStats {\n  constructor(device) {\n    this.frame = {\n      fps: 0,\n      ms: 0,\n      dt: 0,\n      updateStart: 0,\n      updateTime: 0,\n      renderStart: 0,\n      renderTime: 0,\n      physicsStart: 0,\n      physicsTime: 0,\n      cullTime: 0,\n      sortTime: 0,\n      skinTime: 0,\n      morphTime: 0,\n      instancingTime: 0,\n      triangles: 0,\n      otherPrimitives: 0,\n      shaders: 0,\n      materials: 0,\n      cameras: 0,\n      shadowMapUpdates: 0,\n      shadowMapTime: 0,\n      depthMapTime: 0,\n      forwardTime: 0,\n      lightClustersTime: 0,\n      lightClusters: 0,\n      _timeToCountFrames: 0,\n      _fpsAccum: 0\n    };\n    this.drawCalls = {\n      forward: 0,\n      depth: 0,\n      shadow: 0,\n      immediate: 0,\n      misc: 0,\n      total: 0,\n      skinned: 0,\n      instanced: 0,\n      removedByInstancing: 0\n    };\n    this.misc = {\n      renderTargetCreationTime: 0\n    };\n    this.particles = {\n      updatesPerFrame: 0,\n      _updatesPerFrame: 0,\n      frameTime: 0,\n      _frameTime: 0\n    };\n    this.shaders = device._shaderStats;\n    this.vram = device._vram;\n    Object.defineProperty(this.vram, 'totalUsed', {\n      get: function () {\n        return this.tex + this.vb + this.ib;\n      }\n    });\n    Object.defineProperty(this.vram, 'geom', {\n      get: function () {\n        return this.vb + this.ib;\n      }\n    });\n  }\n  get scene() {\n    return (0,_globals_js__WEBPACK_IMPORTED_MODULE_0__.getApplication)().scene._stats;\n  }\n  get lightmapper() {\n    var _getApplication$light;\n    return (_getApplication$light = (0,_globals_js__WEBPACK_IMPORTED_MODULE_0__.getApplication)().lightmapper) == null ? void 0 : _getApplication$light.stats;\n  }\n  get batcher() {\n    const batcher = (0,_globals_js__WEBPACK_IMPORTED_MODULE_0__.getApplication)()._batcher;\n    return batcher ? batcher._stats : null;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/stats.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/template.js":
/*!****************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/template.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Template\": () => (/* binding */ Template)\n/* harmony export */ });\n/* harmony import */ var _parsers_scene_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parsers/scene.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/parsers/scene.js\");\n\n\nclass Template {\n  constructor(app, data) {\n    this._app = app;\n    this._data = data;\n    this._templateRoot = null;\n  }\n  instantiate() {\n    if (!this._templateRoot) {\n      this._parseTemplate();\n    }\n    return this._templateRoot.clone();\n  }\n  _parseTemplate() {\n    const parser = new _parsers_scene_js__WEBPACK_IMPORTED_MODULE_0__.SceneParser(this._app, true);\n    this._templateRoot = parser.parse(this._data);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/template.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/utils/entity-reference.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/utils/entity-reference.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EntityReference\": () => (/* binding */ EntityReference)\n/* harmony export */ });\n/* harmony import */ var _components_component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/component.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/components/component.js\");\n/* harmony import */ var _entity_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../entity.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/entity.js\");\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n\n\n\n\nclass EntityReference extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor(parentComponent, entityPropertyName, eventConfig) {\n    super();\n    if (!parentComponent || !(parentComponent instanceof _components_component_js__WEBPACK_IMPORTED_MODULE_1__.Component)) {\n      throw new Error('The parentComponent argument is required and must be a Component');\n    } else if (!entityPropertyName || typeof entityPropertyName !== 'string') {\n      throw new Error('The propertyName argument is required and must be a string');\n    } else if (eventConfig && typeof eventConfig !== 'object') {\n      throw new Error('If provided, the eventConfig argument must be an object');\n    }\n    this._parentComponent = parentComponent;\n    this._entityPropertyName = entityPropertyName;\n    this._entity = null;\n    this._app = parentComponent.system.app;\n    this._configureEventListeners(eventConfig || {}, {\n      'entity#destroy': this._onEntityDestroy\n    });\n    this._toggleLifecycleListeners('on');\n  }\n  _configureEventListeners(externalEventConfig, internalEventConfig) {\n    const externalEventListenerConfigs = this._parseEventListenerConfig(externalEventConfig, 'external', this._parentComponent);\n    const internalEventListenerConfigs = this._parseEventListenerConfig(internalEventConfig, 'internal', this);\n    this._eventListenerConfigs = externalEventListenerConfigs.concat(internalEventListenerConfigs);\n    this._listenerStatusFlags = {};\n    this._gainListeners = {};\n    this._loseListeners = {};\n  }\n  _parseEventListenerConfig(eventConfig, prefix, scope) {\n    return Object.keys(eventConfig).map(function (listenerDescription, index) {\n      const listenerDescriptionParts = listenerDescription.split('#');\n      const sourceName = listenerDescriptionParts[0];\n      const eventName = listenerDescriptionParts[1];\n      const callback = eventConfig[listenerDescription];\n      if (listenerDescriptionParts.length !== 2 || typeof sourceName !== 'string' || sourceName.length === 0 || typeof eventName !== 'string' || eventName.length === 0) {\n        throw new Error('Invalid event listener description: `' + listenerDescription + '`');\n      }\n      if (typeof callback !== 'function') {\n        throw new Error('Invalid or missing callback for event listener `' + listenerDescription + '`');\n      }\n      return {\n        id: prefix + '_' + index + '_' + listenerDescription,\n        sourceName: sourceName,\n        eventName: eventName,\n        callback: callback,\n        scope: scope\n      };\n    }, this);\n  }\n  _toggleLifecycleListeners(onOrOff) {\n    this._parentComponent[onOrOff]('set_' + this._entityPropertyName, this._onSetEntity, this);\n    this._parentComponent.system[onOrOff]('beforeremove', this._onParentComponentRemove, this);\n    this._app.systems[onOrOff]('postPostInitialize', this._updateEntityReference, this);\n    this._app[onOrOff]('tools:sceneloaded', this._onSceneLoaded, this);\n    const allComponentSystems = [];\n    for (let i = 0; i < this._eventListenerConfigs.length; ++i) {\n      const config = this._eventListenerConfigs[i];\n      const componentSystem = this._app.systems[config.sourceName];\n      if (componentSystem) {\n        if (allComponentSystems.indexOf(componentSystem) === -1) {\n          allComponentSystems.push(componentSystem);\n        }\n        if (componentSystem && config.eventName === 'gain') {\n          this._gainListeners[config.sourceName] = config;\n        }\n        if (componentSystem && config.eventName === 'lose') {\n          this._loseListeners[config.sourceName] = config;\n        }\n      }\n    }\n    for (let i = 0; i < allComponentSystems.length; ++i) {\n      allComponentSystems[i][onOrOff]('add', this._onComponentAdd, this);\n      allComponentSystems[i][onOrOff]('beforeremove', this._onComponentRemove, this);\n    }\n  }\n  _onSetEntity(name, oldValue, newValue) {\n    if (newValue instanceof _entity_js__WEBPACK_IMPORTED_MODULE_2__.Entity) {\n      this._updateEntityReference();\n    } else {\n      if (newValue !== null && newValue !== undefined && typeof newValue !== 'string') {\n        console.warn(\"Entity field `\" + this._entityPropertyName + \"` was set to unexpected type '\" + typeof newValue + \"'\");\n        return;\n      }\n      if (oldValue !== newValue) {\n        this._updateEntityReference();\n      }\n    }\n  }\n  onParentComponentEnable() {\n    if (!this._entity) {\n      this._updateEntityReference();\n    }\n  }\n  _onSceneLoaded() {\n    this._updateEntityReference();\n  }\n  _updateEntityReference() {\n    let nextEntityGuid = this._parentComponent.data[this._entityPropertyName];\n    let nextEntity;\n    if (nextEntityGuid instanceof _entity_js__WEBPACK_IMPORTED_MODULE_2__.Entity) {\n      nextEntity = nextEntityGuid;\n      nextEntityGuid = nextEntity.getGuid();\n      this._parentComponent.data[this._entityPropertyName] = nextEntityGuid;\n    } else {\n      const root = this._parentComponent.system.app.root;\n      const isOnSceneGraph = this._parentComponent.entity.isDescendantOf(root);\n      nextEntity = isOnSceneGraph && nextEntityGuid ? root.findByGuid(nextEntityGuid) : null;\n    }\n    const hasChanged = this._entity !== nextEntity;\n    if (hasChanged) {\n      if (this._entity) {\n        this._onBeforeEntityChange();\n      }\n      this._entity = nextEntity;\n      if (this._entity) {\n        this._onAfterEntityChange();\n      }\n      this.fire('set:entity', this._entity);\n    }\n  }\n  _onBeforeEntityChange() {\n    this._toggleEntityListeners('off');\n    this._callAllGainOrLoseListeners(this._loseListeners);\n  }\n  _onAfterEntityChange() {\n    this._toggleEntityListeners('on');\n    this._callAllGainOrLoseListeners(this._gainListeners);\n  }\n  _onComponentAdd(entity, component) {\n    const componentName = component.system.id;\n    if (entity === this._entity) {\n      this._callGainOrLoseListener(componentName, this._gainListeners);\n      this._toggleComponentListeners('on', componentName);\n    }\n  }\n  _onComponentRemove(entity, component) {\n    const componentName = component.system.id;\n    if (entity === this._entity) {\n      this._callGainOrLoseListener(componentName, this._loseListeners);\n      this._toggleComponentListeners('off', componentName, true);\n    }\n  }\n  _callAllGainOrLoseListeners(listenerMap) {\n    for (const componentName in this._entity.c) {\n      this._callGainOrLoseListener(componentName, listenerMap);\n    }\n  }\n  _callGainOrLoseListener(componentName, listenerMap) {\n    if (this._entity.c.hasOwnProperty(componentName) && listenerMap[componentName]) {\n      const config = listenerMap[componentName];\n      config.callback.call(config.scope);\n    }\n  }\n  _toggleEntityListeners(onOrOff, isDestroying) {\n    if (this._entity) {\n      for (let i = 0; i < this._eventListenerConfigs.length; ++i) {\n        this._safeToggleListener(onOrOff, this._eventListenerConfigs[i], isDestroying);\n      }\n    }\n  }\n  _toggleComponentListeners(onOrOff, componentName, isDestroying) {\n    for (let i = 0; i < this._eventListenerConfigs.length; ++i) {\n      const config = this._eventListenerConfigs[i];\n      if (config.sourceName === componentName) {\n        this._safeToggleListener(onOrOff, config, isDestroying);\n      }\n    }\n  }\n  _safeToggleListener(onOrOff, config, isDestroying) {\n    const isAdding = onOrOff === 'on';\n    if (isAdding && this._listenerStatusFlags[config.id]) {\n      return;\n    }\n    const source = this._getEventSource(config.sourceName, isDestroying);\n    if (source) {\n      source[onOrOff](config.eventName, config.callback, config.scope);\n      this._listenerStatusFlags[config.id] = isAdding;\n    }\n  }\n  _getEventSource(sourceName, isDestroying) {\n    if (sourceName === 'entity') {\n      return this._entity;\n    }\n    const component = this._entity[sourceName];\n    if (component) {\n      return component;\n    }\n    if (!isDestroying) {\n      console.warn('Entity has no component with name ' + sourceName);\n    }\n    return null;\n  }\n  _onEntityDestroy(entity) {\n    if (this._entity === entity) {\n      this._toggleEntityListeners('off', true);\n      this._entity = null;\n    }\n  }\n  _onParentComponentRemove(entity, component) {\n    if (component === this._parentComponent) {\n      this._toggleLifecycleListeners('off');\n      this._toggleEntityListeners('off', true);\n    }\n  }\n  hasComponent(componentName) {\n    return this._entity && this._entity.c ? !!this._entity.c[componentName] : false;\n  }\n  get entity() {\n    return this._entity;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/utils/entity-reference.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/constants.js":
/*!********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/constants.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"XRDEPTHSENSINGFORMAT_F32\": () => (/* binding */ XRDEPTHSENSINGFORMAT_F32),\n/* harmony export */   \"XRDEPTHSENSINGFORMAT_L8A8\": () => (/* binding */ XRDEPTHSENSINGFORMAT_L8A8),\n/* harmony export */   \"XRDEPTHSENSINGUSAGE_CPU\": () => (/* binding */ XRDEPTHSENSINGUSAGE_CPU),\n/* harmony export */   \"XRDEPTHSENSINGUSAGE_GPU\": () => (/* binding */ XRDEPTHSENSINGUSAGE_GPU),\n/* harmony export */   \"XRHAND_LEFT\": () => (/* binding */ XRHAND_LEFT),\n/* harmony export */   \"XRHAND_NONE\": () => (/* binding */ XRHAND_NONE),\n/* harmony export */   \"XRHAND_RIGHT\": () => (/* binding */ XRHAND_RIGHT),\n/* harmony export */   \"XRSPACE_BOUNDEDFLOOR\": () => (/* binding */ XRSPACE_BOUNDEDFLOOR),\n/* harmony export */   \"XRSPACE_LOCAL\": () => (/* binding */ XRSPACE_LOCAL),\n/* harmony export */   \"XRSPACE_LOCALFLOOR\": () => (/* binding */ XRSPACE_LOCALFLOOR),\n/* harmony export */   \"XRSPACE_UNBOUNDED\": () => (/* binding */ XRSPACE_UNBOUNDED),\n/* harmony export */   \"XRSPACE_VIEWER\": () => (/* binding */ XRSPACE_VIEWER),\n/* harmony export */   \"XRTARGETRAY_GAZE\": () => (/* binding */ XRTARGETRAY_GAZE),\n/* harmony export */   \"XRTARGETRAY_POINTER\": () => (/* binding */ XRTARGETRAY_POINTER),\n/* harmony export */   \"XRTARGETRAY_SCREEN\": () => (/* binding */ XRTARGETRAY_SCREEN),\n/* harmony export */   \"XRTRACKABLE_MESH\": () => (/* binding */ XRTRACKABLE_MESH),\n/* harmony export */   \"XRTRACKABLE_PLANE\": () => (/* binding */ XRTRACKABLE_PLANE),\n/* harmony export */   \"XRTRACKABLE_POINT\": () => (/* binding */ XRTRACKABLE_POINT),\n/* harmony export */   \"XRTYPE_AR\": () => (/* binding */ XRTYPE_AR),\n/* harmony export */   \"XRTYPE_INLINE\": () => (/* binding */ XRTYPE_INLINE),\n/* harmony export */   \"XRTYPE_VR\": () => (/* binding */ XRTYPE_VR)\n/* harmony export */ });\nconst XRTYPE_INLINE = 'inline';\nconst XRTYPE_VR = 'immersive-vr';\nconst XRTYPE_AR = 'immersive-ar';\nconst XRSPACE_VIEWER = 'viewer';\nconst XRSPACE_LOCAL = 'local';\nconst XRSPACE_LOCALFLOOR = 'local-floor';\nconst XRSPACE_BOUNDEDFLOOR = 'bounded-floor';\nconst XRSPACE_UNBOUNDED = 'unbounded';\nconst XRTARGETRAY_GAZE = 'gaze';\nconst XRTARGETRAY_SCREEN = 'screen';\nconst XRTARGETRAY_POINTER = 'tracked-pointer';\nconst XRHAND_NONE = 'none';\nconst XRHAND_LEFT = 'left';\nconst XRHAND_RIGHT = 'right';\nconst XRTRACKABLE_POINT = 'point';\nconst XRTRACKABLE_PLANE = 'plane';\nconst XRTRACKABLE_MESH = 'mesh';\nconst XRDEPTHSENSINGUSAGE_CPU = 'cpu-optimized';\nconst XRDEPTHSENSINGUSAGE_GPU = 'gpu-optimized';\nconst XRDEPTHSENSINGFORMAT_L8A8 = 'luminance-alpha';\nconst XRDEPTHSENSINGFORMAT_F32 = 'float32';\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/constants.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-depth-sensing.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-depth-sensing.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"XrDepthSensing\": () => (/* binding */ XrDepthSensing)\n/* harmony export */ });\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _core_platform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/platform.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/platform.js\");\n/* harmony import */ var _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/math/mat4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../platform/graphics/texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/constants.js\");\n\n\n\n\n\n\n\nclass XrDepthSensing extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor(manager) {\n    super();\n    this._manager = void 0;\n    this._available = false;\n    this._depthInfoCpu = null;\n    this._depthInfoGpu = null;\n    this._usage = null;\n    this._dataFormat = null;\n    this._matrixDirty = false;\n    this._matrix = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__.Mat4();\n    this._emptyBuffer = new Uint8Array(32);\n    this._depthBuffer = null;\n    this._texture = void 0;\n    this._manager = manager;\n    this._texture = new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_2__.Texture(this._manager.app.graphicsDevice, {\n      format: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.PIXELFORMAT_LA8,\n      mipmaps: false,\n      addressU: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.ADDRESS_CLAMP_TO_EDGE,\n      addressV: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.ADDRESS_CLAMP_TO_EDGE,\n      minFilter: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.FILTER_LINEAR,\n      magFilter: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.FILTER_LINEAR,\n      name: 'XRDepthSensing'\n    });\n    if (this.supported) {\n      this._manager.on('start', this._onSessionStart, this);\n      this._manager.on('end', this._onSessionEnd, this);\n    }\n  }\n  destroy() {\n    this._texture.destroy();\n    this._texture = null;\n  }\n  _onSessionStart() {\n    const session = this._manager.session;\n    try {\n      this._usage = session.depthUsage;\n      this._dataFormat = session.depthDataFormat;\n    } catch (ex) {\n      this._usage = null;\n      this._dataFormat = null;\n      this._available = false;\n      this.fire('error', ex);\n    }\n  }\n  _onSessionEnd() {\n    this._depthInfoCpu = null;\n    this._depthInfoGpu = null;\n    this._usage = null;\n    this._dataFormat = null;\n    if (this._available) {\n      this._available = false;\n      this.fire('unavailable');\n    }\n    this._depthBuffer = null;\n    this._texture._width = 4;\n    this._texture._height = 4;\n    this._texture._levels[0] = this._emptyBuffer;\n    this._texture.upload();\n  }\n  _updateTexture() {\n    const depthInfo = this._depthInfoCpu || this._depthInfoGpu;\n    if (depthInfo) {\n      let resized = false;\n      if (depthInfo.width !== this._texture.width || depthInfo.height !== this._texture.height) {\n        this._texture._width = depthInfo.width;\n        this._texture._height = depthInfo.height;\n        this._matrixDirty = true;\n        resized = true;\n      }\n      if (this._depthInfoCpu) {\n        const dataBuffer = this._depthInfoCpu.data;\n        this._depthBuffer = new Uint8Array(dataBuffer);\n        this._texture._levels[0] = this._depthBuffer;\n        this._texture.upload();\n      } else if (this._depthInfoGpu) {\n        this._texture._levels[0] = this._depthInfoGpu.texture;\n        this._texture.upload();\n      }\n      if (resized) this.fire('resize', depthInfo.width, depthInfo.height);\n    } else if (this._depthBuffer) {\n      this._depthBuffer = null;\n      this._texture._width = 4;\n      this._texture._height = 4;\n      this._texture._levels[0] = this._emptyBuffer;\n      this._texture.upload();\n    }\n  }\n  update(frame, view) {\n    if (!this._usage) return;\n    let depthInfoCpu = null;\n    let depthInfoGpu = null;\n    if (this._usage === _constants_js__WEBPACK_IMPORTED_MODULE_4__.XRDEPTHSENSINGUSAGE_CPU && view) {\n      depthInfoCpu = frame.getDepthInformation(view);\n    } else if (this._usage === _constants_js__WEBPACK_IMPORTED_MODULE_4__.XRDEPTHSENSINGUSAGE_GPU && view) {\n      depthInfoGpu = frame.getDepthInformation(view);\n    }\n    if (this._depthInfoCpu && !depthInfoCpu || !this._depthInfoCpu && depthInfoCpu || this.depthInfoGpu && !depthInfoGpu || !this._depthInfoGpu && depthInfoGpu) {\n      this._matrixDirty = true;\n    }\n    this._depthInfoCpu = depthInfoCpu;\n    this._depthInfoGpu = depthInfoGpu;\n    this._updateTexture();\n    if (this._matrixDirty) {\n      this._matrixDirty = false;\n      const depthInfo = this._depthInfoCpu || this._depthInfoGpu;\n      if (depthInfo) {\n        this._matrix.data.set(depthInfo.normDepthBufferFromNormView.matrix);\n      } else {\n        this._matrix.setIdentity();\n      }\n    }\n    if ((this._depthInfoCpu || this._depthInfoGpu) && !this._available) {\n      this._available = true;\n      this.fire('available');\n    } else if (!this._depthInfoCpu && !this._depthInfoGpu && this._available) {\n      this._available = false;\n      this.fire('unavailable');\n    }\n  }\n  getDepth(u, v) {\n    if (!this._depthInfoCpu) return null;\n    return this._depthInfoCpu.getDepthInMeters(u, v);\n  }\n  get supported() {\n    return _core_platform_js__WEBPACK_IMPORTED_MODULE_5__.platform.browser && !!window.XRDepthInformation;\n  }\n  get available() {\n    return this._available;\n  }\n  get usage() {\n    return this._usage;\n  }\n  get dataFormat() {\n    return this._dataFormat;\n  }\n  get width() {\n    const depthInfo = this._depthInfoCpu || this._depthInfoGpu;\n    return depthInfo && depthInfo.width || 0;\n  }\n  get height() {\n    const depthInfo = this._depthInfoCpu || this._depthInfoGpu;\n    return depthInfo && depthInfo.height || 0;\n  }\n  get texture() {\n    return this._texture;\n  }\n  get uvMatrix() {\n    return this._matrix;\n  }\n  get rawValueToMeters() {\n    const depthInfo = this._depthInfoCpu || this._depthInfoGpu;\n    return depthInfo && depthInfo.rawValueToMeters || 0;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-depth-sensing.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-dom-overlay.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-dom-overlay.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"XrDomOverlay\": () => (/* binding */ XrDomOverlay)\n/* harmony export */ });\n/* harmony import */ var _core_platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/platform.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/platform.js\");\n\n\nclass XrDomOverlay {\n  constructor(manager) {\n    this._manager = void 0;\n    this._supported = _core_platform_js__WEBPACK_IMPORTED_MODULE_0__.platform.browser && !!window.XRDOMOverlayState;\n    this._root = null;\n    this._manager = manager;\n  }\n  get supported() {\n    return this._supported;\n  }\n  get available() {\n    return this._supported && this._manager.active && this._manager._session.domOverlayState !== null;\n  }\n  get state() {\n    if (!this._supported || !this._manager.active || !this._manager._session.domOverlayState) return null;\n    return this._manager._session.domOverlayState.type;\n  }\n  set root(value) {\n    if (!this._supported || this._manager.active) return;\n    this._root = value;\n  }\n  get root() {\n    return this._root;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-dom-overlay.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-finger.js":
/*!********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-finger.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"XrFinger\": () => (/* binding */ XrFinger)\n/* harmony export */ });\nclass XrFinger {\n  constructor(index, hand) {\n    this._index = void 0;\n    this._hand = void 0;\n    this._joints = [];\n    this._tip = null;\n    this._index = index;\n    this._hand = hand;\n    this._hand._fingers.push(this);\n  }\n  get index() {\n    return this._index;\n  }\n  get hand() {\n    return this._hand;\n  }\n  get joints() {\n    return this._joints;\n  }\n  get tip() {\n    return this._tip;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-finger.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-hand.js":
/*!******************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-hand.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"XrHand\": () => (/* binding */ XrHand)\n/* harmony export */ });\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _core_platform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/platform.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/platform.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/constants.js\");\n/* harmony import */ var _xr_finger_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./xr-finger.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-finger.js\");\n/* harmony import */ var _xr_joint_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./xr-joint.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-joint.js\");\n\n\n\n\n\n\n\nlet fingerJointIds = [];\nconst vecA = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst vecB = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst vecC = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nif (_core_platform_js__WEBPACK_IMPORTED_MODULE_1__.platform.browser && window.XRHand) {\n  fingerJointIds = [['thumb-metacarpal', 'thumb-phalanx-proximal', 'thumb-phalanx-distal', 'thumb-tip'], ['index-finger-metacarpal', 'index-finger-phalanx-proximal', 'index-finger-phalanx-intermediate', 'index-finger-phalanx-distal', 'index-finger-tip'], ['middle-finger-metacarpal', 'middle-finger-phalanx-proximal', 'middle-finger-phalanx-intermediate', 'middle-finger-phalanx-distal', 'middle-finger-tip'], ['ring-finger-metacarpal', 'ring-finger-phalanx-proximal', 'ring-finger-phalanx-intermediate', 'ring-finger-phalanx-distal', 'ring-finger-tip'], ['pinky-finger-metacarpal', 'pinky-finger-phalanx-proximal', 'pinky-finger-phalanx-intermediate', 'pinky-finger-phalanx-distal', 'pinky-finger-tip']];\n}\nclass XrHand extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_2__.EventHandler {\n  constructor(inputSource) {\n    super();\n    this._manager = void 0;\n    this._inputSource = void 0;\n    this._tracking = false;\n    this._fingers = [];\n    this._joints = [];\n    this._jointsById = {};\n    this._tips = [];\n    this._wrist = null;\n    const xrHand = inputSource._xrInputSource.hand;\n    this._manager = inputSource._manager;\n    this._inputSource = inputSource;\n    if (xrHand.get('wrist')) {\n      const joint = new _xr_joint_js__WEBPACK_IMPORTED_MODULE_3__.XrJoint(0, 'wrist', this, null);\n      this._wrist = joint;\n      this._joints.push(joint);\n      this._jointsById.wrist = joint;\n    }\n    for (let f = 0; f < fingerJointIds.length; f++) {\n      const finger = new _xr_finger_js__WEBPACK_IMPORTED_MODULE_4__.XrFinger(f, this);\n      for (let j = 0; j < fingerJointIds[f].length; j++) {\n        const jointId = fingerJointIds[f][j];\n        if (!xrHand.get(jointId)) continue;\n        const joint = new _xr_joint_js__WEBPACK_IMPORTED_MODULE_3__.XrJoint(j, jointId, this, finger);\n        this._joints.push(joint);\n        this._jointsById[jointId] = joint;\n        if (joint.tip) {\n          this._tips.push(joint);\n          finger._tip = joint;\n        }\n        finger._joints.push(joint);\n      }\n    }\n  }\n  update(frame) {\n    const xrInputSource = this._inputSource._xrInputSource;\n    for (let j = 0; j < this._joints.length; j++) {\n      const joint = this._joints[j];\n      const jointSpace = xrInputSource.hand.get(joint._id);\n      if (jointSpace) {\n        let pose;\n        if (frame.session.visibilityState !== 'hidden') pose = frame.getJointPose(jointSpace, this._manager._referenceSpace);\n        if (pose) {\n          joint.update(pose);\n          if (joint.wrist && !this._tracking) {\n            this._tracking = true;\n            this.fire('tracking');\n          }\n        } else if (joint.wrist) {\n          if (this._tracking) {\n            this._tracking = false;\n            this.fire('trackinglost');\n          }\n          break;\n        }\n      }\n    }\n    const j1 = this._jointsById['thumb-metacarpal'];\n    const j4 = this._jointsById['thumb-tip'];\n    const j6 = this._jointsById['index-finger-phalanx-proximal'];\n    const j9 = this._jointsById['index-finger-tip'];\n    const j16 = this._jointsById['ring-finger-phalanx-proximal'];\n    const j21 = this._jointsById['pinky-finger-phalanx-proximal'];\n    if (j1 && j4 && j6 && j9 && j16 && j21) {\n      this._inputSource._dirtyRay = true;\n      this._inputSource._rayLocal.origin.lerp(j4._localPosition, j9._localPosition, 0.5);\n      let jointL = j1;\n      let jointR = j21;\n      if (this._inputSource.handedness === _constants_js__WEBPACK_IMPORTED_MODULE_5__.XRHAND_LEFT) {\n        const t = jointL;\n        jointL = jointR;\n        jointR = t;\n      }\n      vecA.sub2(jointL._localPosition, this._wrist._localPosition);\n      vecB.sub2(jointR._localPosition, this._wrist._localPosition);\n      vecC.cross(vecA, vecB).normalize();\n      vecA.lerp(j6._localPosition, j16._localPosition, 0.5);\n      vecA.sub(this._wrist._localPosition).normalize();\n      this._inputSource._rayLocal.direction.lerp(vecC, vecA, 0.5).normalize();\n    }\n    const squeezing = this._fingerIsClosed(1) && this._fingerIsClosed(2) && this._fingerIsClosed(3) && this._fingerIsClosed(4);\n    if (squeezing) {\n      if (!this._inputSource._squeezing) {\n        this._inputSource._squeezing = true;\n        this._inputSource.fire('squeezestart');\n        this._manager.input.fire('squeezestart', this._inputSource);\n      }\n    } else {\n      if (this._inputSource._squeezing) {\n        this._inputSource._squeezing = false;\n        this._inputSource.fire('squeeze');\n        this._manager.input.fire('squeeze', this._inputSource);\n        this._inputSource.fire('squeezeend');\n        this._manager.input.fire('squeezeend', this._inputSource);\n      }\n    }\n  }\n  _fingerIsClosed(index) {\n    const finger = this._fingers[index];\n    vecA.sub2(finger.joints[0]._localPosition, finger.joints[1]._localPosition).normalize();\n    vecB.sub2(finger.joints[2]._localPosition, finger.joints[3]._localPosition).normalize();\n    return vecA.dot(vecB) < -0.8;\n  }\n  getJointById(id) {\n    return this._jointsById[id] || null;\n  }\n  get fingers() {\n    return this._fingers;\n  }\n  get joints() {\n    return this._joints;\n  }\n  get tips() {\n    return this._tips;\n  }\n  get wrist() {\n    return this._wrist;\n  }\n  get tracking() {\n    return this._tracking;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-hand.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-hit-test-source.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-hit-test-source.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"XrHitTestSource\": () => (/* binding */ XrHitTestSource)\n/* harmony export */ });\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _core_math_quat_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/math/quat.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/quat.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n\n\n\n\nconst poolVec3 = [];\nconst poolQuat = [];\nclass XrHitTestSource extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor(manager, xrHitTestSource, transient) {\n    super();\n    this.manager = void 0;\n    this._xrHitTestSource = void 0;\n    this._transient = void 0;\n    this.manager = manager;\n    this._xrHitTestSource = xrHitTestSource;\n    this._transient = transient;\n  }\n  remove() {\n    if (!this._xrHitTestSource) return;\n    const sources = this.manager.hitTest.sources;\n    const ind = sources.indexOf(this);\n    if (ind !== -1) sources.splice(ind, 1);\n    this.onStop();\n  }\n  onStop() {\n    this._xrHitTestSource.cancel();\n    this._xrHitTestSource = null;\n    this.fire('remove');\n    this.manager.hitTest.fire('remove', this);\n  }\n  update(frame) {\n    if (this._transient) {\n      const transientResults = frame.getHitTestResultsForTransientInput(this._xrHitTestSource);\n      for (let i = 0; i < transientResults.length; i++) {\n        const transientResult = transientResults[i];\n        let inputSource;\n        if (transientResult.inputSource) inputSource = this.manager.input._getByInputSource(transientResult.inputSource);\n        this.updateHitResults(transientResult.results, inputSource);\n      }\n    } else {\n      this.updateHitResults(frame.getHitTestResults(this._xrHitTestSource));\n    }\n  }\n  updateHitResults(results, inputSource) {\n    for (let i = 0; i < results.length; i++) {\n      const pose = results[i].getPose(this.manager._referenceSpace);\n      let position = poolVec3.pop();\n      if (!position) position = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n      position.copy(pose.transform.position);\n      let rotation = poolQuat.pop();\n      if (!rotation) rotation = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_2__.Quat();\n      rotation.copy(pose.transform.orientation);\n      this.fire('result', position, rotation, inputSource);\n      this.manager.hitTest.fire('result', this, position, rotation, inputSource);\n      poolVec3.push(position);\n      poolQuat.push(rotation);\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-hit-test-source.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-hit-test.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-hit-test.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"XrHitTest\": () => (/* binding */ XrHitTest)\n/* harmony export */ });\n/* harmony import */ var _core_platform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/platform.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/platform.js\");\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/constants.js\");\n/* harmony import */ var _xr_hit_test_source_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./xr-hit-test-source.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-hit-test-source.js\");\n\n\n\n\n\nclass XrHitTest extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor(manager) {\n    super();\n    this.manager = void 0;\n    this._supported = _core_platform_js__WEBPACK_IMPORTED_MODULE_1__.platform.browser && !!(window.XRSession && window.XRSession.prototype.requestHitTestSource);\n    this._session = null;\n    this.sources = [];\n    this.manager = manager;\n    if (this._supported) {\n      this.manager.on('start', this._onSessionStart, this);\n      this.manager.on('end', this._onSessionEnd, this);\n    }\n  }\n  _onSessionStart() {\n    if (this.manager.type !== _constants_js__WEBPACK_IMPORTED_MODULE_2__.XRTYPE_AR) return;\n    this._session = this.manager.session;\n  }\n  _onSessionEnd() {\n    if (!this._session) return;\n    this._session = null;\n    for (let i = 0; i < this.sources.length; i++) {\n      this.sources[i].onStop();\n    }\n    this.sources = [];\n  }\n  isAvailable(callback, fireError) {\n    let err;\n    if (!this._supported) err = new Error('XR HitTest is not supported');\n    if (!this._session) err = new Error('XR Session is not started (1)');\n    if (this.manager.type !== _constants_js__WEBPACK_IMPORTED_MODULE_2__.XRTYPE_AR) err = new Error('XR HitTest is available only for AR');\n    if (err) {\n      if (callback) callback(err);\n      if (fireError) fireError.fire('error', err);\n      return false;\n    }\n    return true;\n  }\n  start(options = {}) {\n    if (!this.isAvailable(options.callback, this)) return;\n    if (!options.profile && !options.spaceType) options.spaceType = _constants_js__WEBPACK_IMPORTED_MODULE_2__.XRSPACE_VIEWER;\n    let xrRay;\n    const offsetRay = options.offsetRay;\n    if (offsetRay) {\n      const origin = new DOMPoint(offsetRay.origin.x, offsetRay.origin.y, offsetRay.origin.z, 1.0);\n      const direction = new DOMPoint(offsetRay.direction.x, offsetRay.direction.y, offsetRay.direction.z, 0.0);\n      xrRay = new XRRay(origin, direction);\n    }\n    const callback = options.callback;\n    if (options.spaceType) {\n      this._session.requestReferenceSpace(options.spaceType).then(referenceSpace => {\n        if (!this._session) {\n          const err = new Error('XR Session is not started (2)');\n          if (callback) callback(err);\n          this.fire('error', err);\n          return;\n        }\n        this._session.requestHitTestSource({\n          space: referenceSpace,\n          entityTypes: options.entityTypes || undefined,\n          offsetRay: xrRay\n        }).then(xrHitTestSource => {\n          this._onHitTestSource(xrHitTestSource, false, callback);\n        }).catch(ex => {\n          if (callback) callback(ex);\n          this.fire('error', ex);\n        });\n      }).catch(ex => {\n        if (callback) callback(ex);\n        this.fire('error', ex);\n      });\n    } else {\n      this._session.requestHitTestSourceForTransientInput({\n        profile: options.profile,\n        entityTypes: options.entityTypes || undefined,\n        offsetRay: xrRay\n      }).then(xrHitTestSource => {\n        this._onHitTestSource(xrHitTestSource, true, callback);\n      }).catch(ex => {\n        if (callback) callback(ex);\n        this.fire('error', ex);\n      });\n    }\n  }\n  _onHitTestSource(xrHitTestSource, transient, callback) {\n    if (!this._session) {\n      xrHitTestSource.cancel();\n      const err = new Error('XR Session is not started (3)');\n      if (callback) callback(err);\n      this.fire('error', err);\n      return;\n    }\n    const hitTestSource = new _xr_hit_test_source_js__WEBPACK_IMPORTED_MODULE_3__.XrHitTestSource(this.manager, xrHitTestSource, transient);\n    this.sources.push(hitTestSource);\n    if (callback) callback(null, hitTestSource);\n    this.fire('add', hitTestSource);\n  }\n  update(frame) {\n    for (let i = 0; i < this.sources.length; i++) {\n      this.sources[i].update(frame);\n    }\n  }\n  get supported() {\n    return this._supported;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-hit-test.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-image-tracking.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-image-tracking.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"XrImageTracking\": () => (/* binding */ XrImageTracking)\n/* harmony export */ });\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _core_platform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/platform.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/platform.js\");\n/* harmony import */ var _xr_tracked_image_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./xr-tracked-image.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-tracked-image.js\");\n\n\n\n\nclass XrImageTracking extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor(manager) {\n    super();\n    this._manager = void 0;\n    this._supported = _core_platform_js__WEBPACK_IMPORTED_MODULE_1__.platform.browser && !!window.XRImageTrackingResult;\n    this._available = false;\n    this._images = [];\n    this._manager = manager;\n    if (this._supported) {\n      this._manager.on('start', this._onSessionStart, this);\n      this._manager.on('end', this._onSessionEnd, this);\n    }\n  }\n  add(image, width) {\n    if (!this._supported || this._manager.active) return null;\n    const trackedImage = new _xr_tracked_image_js__WEBPACK_IMPORTED_MODULE_2__.XrTrackedImage(image, width);\n    this._images.push(trackedImage);\n    return trackedImage;\n  }\n  remove(trackedImage) {\n    if (this._manager.active) return;\n    const ind = this._images.indexOf(trackedImage);\n    if (ind !== -1) {\n      trackedImage.destroy();\n      this._images.splice(ind, 1);\n    }\n  }\n  _onSessionStart() {\n    this._manager.session.getTrackedImageScores().then(images => {\n      this._available = true;\n      for (let i = 0; i < images.length; i++) {\n        this._images[i]._trackable = images[i] === 'trackable';\n      }\n    }).catch(err => {\n      this._available = false;\n      this.fire('error', err);\n    });\n  }\n  _onSessionEnd() {\n    this._available = false;\n    for (let i = 0; i < this._images.length; i++) {\n      const image = this._images[i];\n      image._pose = null;\n      image._measuredWidth = 0;\n      if (image._tracking) {\n        image._tracking = false;\n        image.fire('untracked');\n      }\n    }\n  }\n  prepareImages(callback) {\n    if (this._images.length) {\n      Promise.all(this._images.map(function (trackedImage) {\n        return trackedImage.prepare();\n      })).then(function (bitmaps) {\n        callback(null, bitmaps);\n      }).catch(function (err) {\n        callback(err, null);\n      });\n    } else {\n      callback(null, null);\n    }\n  }\n  update(frame) {\n    if (!this._available) return;\n    const results = frame.getImageTrackingResults();\n    const index = {};\n    for (let i = 0; i < results.length; i++) {\n      index[results[i].index] = results[i];\n      const trackedImage = this._images[results[i].index];\n      trackedImage._emulated = results[i].trackingState === 'emulated';\n      trackedImage._measuredWidth = results[i].measuredWidthInMeters;\n      trackedImage._pose = frame.getPose(results[i].imageSpace, this._manager._referenceSpace);\n    }\n    for (let i = 0; i < this._images.length; i++) {\n      if (this._images[i]._tracking && !index[i]) {\n        this._images[i]._tracking = false;\n        this._images[i].fire('untracked');\n      } else if (!this._images[i]._tracking && index[i]) {\n        this._images[i]._tracking = true;\n        this._images[i].fire('tracked');\n      }\n    }\n  }\n  get supported() {\n    return this._supported;\n  }\n  get available() {\n    return this._available;\n  }\n  get images() {\n    return this._images;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-image-tracking.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-input-source.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-input-source.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"XrInputSource\": () => (/* binding */ XrInputSource)\n/* harmony export */ });\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/math/mat4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js\");\n/* harmony import */ var _core_math_quat_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/math/quat.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/quat.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_shape_ray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/shape/ray.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/shape/ray.js\");\n/* harmony import */ var _xr_hand_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./xr-hand.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-hand.js\");\n\n\n\n\n\n\n\nconst quat = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_0__.Quat();\nlet ids = 0;\nclass XrInputSource extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_1__.EventHandler {\n  constructor(manager, xrInputSource) {\n    super();\n    this._id = void 0;\n    this._manager = void 0;\n    this._xrInputSource = void 0;\n    this._ray = new _core_shape_ray_js__WEBPACK_IMPORTED_MODULE_2__.Ray();\n    this._rayLocal = new _core_shape_ray_js__WEBPACK_IMPORTED_MODULE_2__.Ray();\n    this._grip = false;\n    this._hand = null;\n    this._localTransform = null;\n    this._worldTransform = null;\n    this._position = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_3__.Vec3();\n    this._rotation = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_0__.Quat();\n    this._localPosition = null;\n    this._localRotation = null;\n    this._dirtyLocal = true;\n    this._dirtyRay = false;\n    this._selecting = false;\n    this._squeezing = false;\n    this._elementInput = true;\n    this._elementEntity = null;\n    this._hitTestSources = [];\n    this._id = ++ids;\n    this._manager = manager;\n    this._xrInputSource = xrInputSource;\n    if (xrInputSource.hand) this._hand = new _xr_hand_js__WEBPACK_IMPORTED_MODULE_4__.XrHand(this);\n  }\n  get id() {\n    return this._id;\n  }\n  get inputSource() {\n    return this._xrInputSource;\n  }\n  get targetRayMode() {\n    return this._xrInputSource.targetRayMode;\n  }\n  get handedness() {\n    return this._xrInputSource.handedness;\n  }\n  get profiles() {\n    return this._xrInputSource.profiles;\n  }\n  get grip() {\n    return this._grip;\n  }\n  get hand() {\n    return this._hand;\n  }\n  get gamepad() {\n    return this._xrInputSource.gamepad || null;\n  }\n  get selecting() {\n    return this._selecting;\n  }\n  get squeezing() {\n    return this._squeezing;\n  }\n  set elementInput(value) {\n    if (this._elementInput === value) return;\n    this._elementInput = value;\n    if (!this._elementInput) this._elementEntity = null;\n  }\n  get elementInput() {\n    return this._elementInput;\n  }\n  get elementEntity() {\n    return this._elementEntity;\n  }\n  get hitTestSources() {\n    return this._hitTestSources;\n  }\n  update(frame) {\n    if (this._hand) {\n      this._hand.update(frame);\n    } else {\n      if (this._xrInputSource.gripSpace) {\n        const gripPose = frame.getPose(this._xrInputSource.gripSpace, this._manager._referenceSpace);\n        if (gripPose) {\n          if (!this._grip) {\n            this._grip = true;\n            this._localTransform = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_5__.Mat4();\n            this._worldTransform = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_5__.Mat4();\n            this._localPosition = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_3__.Vec3();\n            this._localRotation = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_0__.Quat();\n          }\n          this._dirtyLocal = true;\n          this._localPosition.copy(gripPose.transform.position);\n          this._localRotation.copy(gripPose.transform.orientation);\n        }\n      }\n      const targetRayPose = frame.getPose(this._xrInputSource.targetRaySpace, this._manager._referenceSpace);\n      if (targetRayPose) {\n        this._dirtyRay = true;\n        this._rayLocal.origin.copy(targetRayPose.transform.position);\n        this._rayLocal.direction.set(0, 0, -1);\n        quat.copy(targetRayPose.transform.orientation);\n        quat.transformVector(this._rayLocal.direction, this._rayLocal.direction);\n      }\n    }\n  }\n  _updateTransforms() {\n    if (this._dirtyLocal) {\n      this._dirtyLocal = false;\n      this._localTransform.setTRS(this._localPosition, this._localRotation, _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_3__.Vec3.ONE);\n    }\n    const parent = this._manager.camera.parent;\n    if (parent) {\n      this._worldTransform.mul2(parent.getWorldTransform(), this._localTransform);\n    } else {\n      this._worldTransform.copy(this._localTransform);\n    }\n  }\n  _updateRayTransforms() {\n    const dirty = this._dirtyRay;\n    this._dirtyRay = false;\n    const parent = this._manager.camera.parent;\n    if (parent) {\n      const parentTransform = this._manager.camera.parent.getWorldTransform();\n      parentTransform.getTranslation(this._position);\n      this._rotation.setFromMat4(parentTransform);\n      this._rotation.transformVector(this._rayLocal.origin, this._ray.origin);\n      this._ray.origin.add(this._position);\n      this._rotation.transformVector(this._rayLocal.direction, this._ray.direction);\n    } else if (dirty) {\n      this._ray.origin.copy(this._rayLocal.origin);\n      this._ray.direction.copy(this._rayLocal.direction);\n    }\n  }\n  getPosition() {\n    if (!this._position) return null;\n    this._updateTransforms();\n    this._worldTransform.getTranslation(this._position);\n    return this._position;\n  }\n  getLocalPosition() {\n    return this._localPosition;\n  }\n  getRotation() {\n    if (!this._rotation) return null;\n    this._updateTransforms();\n    this._rotation.setFromMat4(this._worldTransform);\n    return this._rotation;\n  }\n  getLocalRotation() {\n    return this._localRotation;\n  }\n  getOrigin() {\n    this._updateRayTransforms();\n    return this._ray.origin;\n  }\n  getDirection() {\n    this._updateRayTransforms();\n    return this._ray.direction;\n  }\n  hitTestStart(options = {}) {\n    options.profile = this._xrInputSource.profiles[0];\n    const callback = options.callback;\n    options.callback = (err, hitTestSource) => {\n      if (hitTestSource) this.onHitTestSourceAdd(hitTestSource);\n      if (callback) callback(err, hitTestSource);\n    };\n    this._manager.hitTest.start(options);\n  }\n  onHitTestSourceAdd(hitTestSource) {\n    this._hitTestSources.push(hitTestSource);\n    this.fire('hittest:add', hitTestSource);\n    hitTestSource.on('result', function (position, rotation, inputSource) {\n      if (inputSource !== this) return;\n      this.fire('hittest:result', hitTestSource, position, rotation);\n    }, this);\n    hitTestSource.once('remove', function () {\n      this.onHitTestSourceRemove(hitTestSource);\n      this.fire('hittest:remove', hitTestSource);\n    }, this);\n  }\n  onHitTestSourceRemove(hitTestSource) {\n    const ind = this._hitTestSources.indexOf(hitTestSource);\n    if (ind !== -1) this._hitTestSources.splice(ind, 1);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-input-source.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-input.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-input.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"XrInput\": () => (/* binding */ XrInput)\n/* harmony export */ });\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _xr_input_source_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./xr-input-source.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-input-source.js\");\n\n\n\nclass XrInput extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor(manager) {\n    super();\n    this.manager = void 0;\n    this._inputSources = [];\n    this._onInputSourcesChangeEvt = void 0;\n    this.manager = manager;\n    this._onInputSourcesChangeEvt = evt => {\n      this._onInputSourcesChange(evt);\n    };\n    this.manager.on('start', this._onSessionStart, this);\n    this.manager.on('end', this._onSessionEnd, this);\n  }\n  _onSessionStart() {\n    const session = this.manager.session;\n    session.addEventListener('inputsourceschange', this._onInputSourcesChangeEvt);\n    session.addEventListener('select', evt => {\n      const inputSource = this._getByInputSource(evt.inputSource);\n      inputSource.update(evt.frame);\n      inputSource.fire('select', evt);\n      this.fire('select', inputSource, evt);\n    });\n    session.addEventListener('selectstart', evt => {\n      const inputSource = this._getByInputSource(evt.inputSource);\n      inputSource.update(evt.frame);\n      inputSource._selecting = true;\n      inputSource.fire('selectstart', evt);\n      this.fire('selectstart', inputSource, evt);\n    });\n    session.addEventListener('selectend', evt => {\n      const inputSource = this._getByInputSource(evt.inputSource);\n      inputSource.update(evt.frame);\n      inputSource._selecting = false;\n      inputSource.fire('selectend', evt);\n      this.fire('selectend', inputSource, evt);\n    });\n    session.addEventListener('squeeze', evt => {\n      const inputSource = this._getByInputSource(evt.inputSource);\n      inputSource.update(evt.frame);\n      inputSource.fire('squeeze', evt);\n      this.fire('squeeze', inputSource, evt);\n    });\n    session.addEventListener('squeezestart', evt => {\n      const inputSource = this._getByInputSource(evt.inputSource);\n      inputSource.update(evt.frame);\n      inputSource._squeezing = true;\n      inputSource.fire('squeezestart', evt);\n      this.fire('squeezestart', inputSource, evt);\n    });\n    session.addEventListener('squeezeend', evt => {\n      const inputSource = this._getByInputSource(evt.inputSource);\n      inputSource.update(evt.frame);\n      inputSource._squeezing = false;\n      inputSource.fire('squeezeend', evt);\n      this.fire('squeezeend', inputSource, evt);\n    });\n    const inputSources = session.inputSources;\n    for (let i = 0; i < inputSources.length; i++) {\n      this._addInputSource(inputSources[i]);\n    }\n  }\n  _onSessionEnd() {\n    let i = this._inputSources.length;\n    while (i--) {\n      const inputSource = this._inputSources[i];\n      this._inputSources.splice(i, 1);\n      inputSource.fire('remove');\n      this.fire('remove', inputSource);\n    }\n    const session = this.manager.session;\n    session.removeEventListener('inputsourceschange', this._onInputSourcesChangeEvt);\n  }\n  _onInputSourcesChange(evt) {\n    for (let i = 0; i < evt.removed.length; i++) {\n      this._removeInputSource(evt.removed[i]);\n    }\n    for (let i = 0; i < evt.added.length; i++) {\n      this._addInputSource(evt.added[i]);\n    }\n  }\n  _getByInputSource(xrInputSource) {\n    for (let i = 0; i < this._inputSources.length; i++) {\n      if (this._inputSources[i].inputSource === xrInputSource) {\n        return this._inputSources[i];\n      }\n    }\n    return null;\n  }\n  _addInputSource(xrInputSource) {\n    if (this._getByInputSource(xrInputSource)) return;\n    const inputSource = new _xr_input_source_js__WEBPACK_IMPORTED_MODULE_1__.XrInputSource(this.manager, xrInputSource);\n    this._inputSources.push(inputSource);\n    this.fire('add', inputSource);\n  }\n  _removeInputSource(xrInputSource) {\n    for (let i = 0; i < this._inputSources.length; i++) {\n      if (this._inputSources[i].inputSource !== xrInputSource) continue;\n      const inputSource = this._inputSources[i];\n      this._inputSources.splice(i, 1);\n      let h = inputSource.hitTestSources.length;\n      while (h--) {\n        inputSource.hitTestSources[h].remove();\n      }\n      inputSource.fire('remove');\n      this.fire('remove', inputSource);\n      return;\n    }\n  }\n  update(frame) {\n    for (let i = 0; i < this._inputSources.length; i++) {\n      this._inputSources[i].update(frame);\n    }\n  }\n  get inputSources() {\n    return this._inputSources;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-input.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-joint.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-joint.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"XrJoint\": () => (/* binding */ XrJoint)\n/* harmony export */ });\n/* harmony import */ var _core_platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/platform.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/platform.js\");\n/* harmony import */ var _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/math/mat4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js\");\n/* harmony import */ var _core_math_quat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/math/quat.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/quat.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n\n\n\n\n\nconst tipJointIds = _core_platform_js__WEBPACK_IMPORTED_MODULE_0__.platform.browser && window.XRHand ? ['thumb-tip', 'index-finger-tip', 'middle-finger-tip', 'ring-finger-tip', 'pinky-finger-tip'] : [];\nconst tipJointIdsIndex = {};\nfor (let i = 0; i < tipJointIds.length; i++) {\n  tipJointIdsIndex[tipJointIds[i]] = true;\n}\nclass XrJoint {\n  constructor(index, id, hand, finger = null) {\n    this._index = void 0;\n    this._id = void 0;\n    this._hand = void 0;\n    this._finger = void 0;\n    this._wrist = void 0;\n    this._tip = void 0;\n    this._radius = null;\n    this._localTransform = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__.Mat4();\n    this._worldTransform = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__.Mat4();\n    this._localPosition = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_2__.Vec3();\n    this._localRotation = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_3__.Quat();\n    this._position = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_2__.Vec3();\n    this._rotation = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_3__.Quat();\n    this._dirtyLocal = true;\n    this._index = index;\n    this._id = id;\n    this._hand = hand;\n    this._finger = finger;\n    this._wrist = id === 'wrist';\n    this._tip = this._finger && !!tipJointIdsIndex[id];\n  }\n  update(pose) {\n    this._dirtyLocal = true;\n    this._radius = pose.radius;\n    this._localPosition.copy(pose.transform.position);\n    this._localRotation.copy(pose.transform.orientation);\n  }\n  _updateTransforms() {\n    if (this._dirtyLocal) {\n      this._dirtyLocal = false;\n      this._localTransform.setTRS(this._localPosition, this._localRotation, _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_2__.Vec3.ONE);\n    }\n    const manager = this._hand._manager;\n    const parent = manager.camera.parent;\n    if (parent) {\n      this._worldTransform.mul2(parent.getWorldTransform(), this._localTransform);\n    } else {\n      this._worldTransform.copy(this._localTransform);\n    }\n  }\n  getPosition() {\n    this._updateTransforms();\n    this._worldTransform.getTranslation(this._position);\n    return this._position;\n  }\n  getRotation() {\n    this._updateTransforms();\n    this._rotation.setFromMat4(this._worldTransform);\n    return this._rotation;\n  }\n  get index() {\n    return this._index;\n  }\n  get hand() {\n    return this._hand;\n  }\n  get finger() {\n    return this._finger;\n  }\n  get wrist() {\n    return this._wrist;\n  }\n  get tip() {\n    return this._tip;\n  }\n  get radius() {\n    return this._radius || 0.005;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-joint.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-light-estimation.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-light-estimation.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"XrLightEstimation\": () => (/* binding */ XrLightEstimation)\n/* harmony export */ });\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _core_math_color_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/math/color.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n/* harmony import */ var _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/math/mat4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js\");\n/* harmony import */ var _core_math_quat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/math/quat.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/quat.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/constants.js\");\n\n\n\n\n\n\n\nconst vec3A = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst vec3B = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst mat4A = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__.Mat4();\nconst mat4B = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__.Mat4();\nclass XrLightEstimation extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_2__.EventHandler {\n  constructor(manager) {\n    super();\n    this._manager = void 0;\n    this._supported = false;\n    this._available = false;\n    this._lightProbeRequested = false;\n    this._lightProbe = null;\n    this._intensity = 0;\n    this._rotation = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_3__.Quat();\n    this._color = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_4__.Color();\n    this._sphericalHarmonics = new Float32Array(27);\n    this._manager = manager;\n    this._manager.on('start', this._onSessionStart, this);\n    this._manager.on('end', this._onSessionEnd, this);\n  }\n  _onSessionStart() {\n    const supported = !!this._manager.session.requestLightProbe;\n    if (!supported) return;\n    this._supported = true;\n  }\n  _onSessionEnd() {\n    this._supported = false;\n    this._available = false;\n    this._lightProbeRequested = false;\n    this._lightProbe = null;\n  }\n  start() {\n    let err;\n    if (!this._manager.session) err = new Error('XR session is not running');\n    if (!err && this._manager.type !== _constants_js__WEBPACK_IMPORTED_MODULE_5__.XRTYPE_AR) err = new Error('XR session type is not AR');\n    if (!err && !this._supported) err = new Error('light-estimation is not supported');\n    if (!err && this._lightProbe || this._lightProbeRequested) err = new Error('light estimation is already requested');\n    if (err) {\n      this.fire('error', err);\n      return;\n    }\n    this._lightProbeRequested = true;\n    this._manager.session.requestLightProbe().then(lightProbe => {\n      const wasRequested = this._lightProbeRequested;\n      this._lightProbeRequested = false;\n      if (this._manager.active) {\n        if (wasRequested) {\n          this._lightProbe = lightProbe;\n        }\n      } else {\n        this.fire('error', new Error('XR session is not active'));\n      }\n    }).catch(ex => {\n      this._lightProbeRequested = false;\n      this.fire('error', ex);\n    });\n  }\n  end() {\n    this._lightProbeRequested = false;\n    this._lightProbe = null;\n    this._available = false;\n  }\n  update(frame) {\n    if (!this._lightProbe) return;\n    const lightEstimate = frame.getLightEstimate(this._lightProbe);\n    if (!lightEstimate) return;\n    if (!this._available) {\n      this._available = true;\n      this.fire('available');\n    }\n    const pli = lightEstimate.primaryLightIntensity;\n    this._intensity = Math.max(1.0, Math.max(pli.x, Math.max(pli.y, pli.z)));\n    vec3A.copy(pli).mulScalar(1 / this._intensity);\n    this._color.set(vec3A.x, vec3A.y, vec3A.z);\n    vec3A.set(0, 0, 0);\n    vec3B.copy(lightEstimate.primaryLightDirection);\n    mat4A.setLookAt(vec3B, vec3A, _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3.UP);\n    mat4B.setFromAxisAngle(_core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3.RIGHT, 90);\n    mat4A.mul(mat4B);\n    this._rotation.setFromMat4(mat4A);\n    this._sphericalHarmonics.set(lightEstimate.sphericalHarmonicsCoefficients);\n  }\n  get supported() {\n    return this._supported;\n  }\n  get available() {\n    return this._available;\n  }\n  get intensity() {\n    return this._available ? this._intensity : null;\n  }\n  get color() {\n    return this._available ? this._color : null;\n  }\n  get rotation() {\n    return this._available ? this._rotation : null;\n  }\n  get sphericalHarmonics() {\n    return this._available ? this._sphericalHarmonics : null;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-light-estimation.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-manager.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-manager.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"XrManager\": () => (/* binding */ XrManager)\n/* harmony export */ });\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _core_platform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/platform.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/platform.js\");\n/* harmony import */ var _core_math_mat3_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../core/math/mat3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat3.js\");\n/* harmony import */ var _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../core/math/mat4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js\");\n/* harmony import */ var _core_math_quat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/math/quat.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/quat.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../core/math/vec4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec4.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/constants.js\");\n/* harmony import */ var _xr_depth_sensing_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./xr-depth-sensing.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-depth-sensing.js\");\n/* harmony import */ var _xr_dom_overlay_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./xr-dom-overlay.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-dom-overlay.js\");\n/* harmony import */ var _xr_hit_test_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./xr-hit-test.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-hit-test.js\");\n/* harmony import */ var _xr_image_tracking_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./xr-image-tracking.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-image-tracking.js\");\n/* harmony import */ var _xr_input_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./xr-input.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-input.js\");\n/* harmony import */ var _xr_light_estimation_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./xr-light-estimation.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-light-estimation.js\");\n/* harmony import */ var _xr_plane_detection_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./xr-plane-detection.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-plane-detection.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass XrManager extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor(app) {\n    super();\n    this.app = void 0;\n    this._supported = _core_platform_js__WEBPACK_IMPORTED_MODULE_1__.platform.browser && !!navigator.xr;\n    this._available = {};\n    this._type = null;\n    this._spaceType = null;\n    this._session = null;\n    this._baseLayer = null;\n    this._referenceSpace = null;\n    this.depthSensing = void 0;\n    this.domOverlay = void 0;\n    this.hitTest = void 0;\n    this.imageTracking = void 0;\n    this.planeDetection = void 0;\n    this.input = void 0;\n    this.lightEstimation = void 0;\n    this._camera = null;\n    this.views = [];\n    this.viewsPool = [];\n    this._localPosition = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_2__.Vec3();\n    this._localRotation = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_3__.Quat();\n    this._depthNear = 0.1;\n    this._depthFar = 1000;\n    this._width = 0;\n    this._height = 0;\n    this.app = app;\n    this._available[_constants_js__WEBPACK_IMPORTED_MODULE_4__.XRTYPE_INLINE] = false;\n    this._available[_constants_js__WEBPACK_IMPORTED_MODULE_4__.XRTYPE_VR] = false;\n    this._available[_constants_js__WEBPACK_IMPORTED_MODULE_4__.XRTYPE_AR] = false;\n    this.depthSensing = new _xr_depth_sensing_js__WEBPACK_IMPORTED_MODULE_5__.XrDepthSensing(this);\n    this.domOverlay = new _xr_dom_overlay_js__WEBPACK_IMPORTED_MODULE_6__.XrDomOverlay(this);\n    this.hitTest = new _xr_hit_test_js__WEBPACK_IMPORTED_MODULE_7__.XrHitTest(this);\n    this.imageTracking = new _xr_image_tracking_js__WEBPACK_IMPORTED_MODULE_8__.XrImageTracking(this);\n    this.planeDetection = new _xr_plane_detection_js__WEBPACK_IMPORTED_MODULE_9__.XrPlaneDetection(this);\n    this.input = new _xr_input_js__WEBPACK_IMPORTED_MODULE_10__.XrInput(this);\n    this.lightEstimation = new _xr_light_estimation_js__WEBPACK_IMPORTED_MODULE_11__.XrLightEstimation(this);\n    if (this._supported) {\n      navigator.xr.addEventListener('devicechange', () => {\n        this._deviceAvailabilityCheck();\n      });\n      this._deviceAvailabilityCheck();\n    }\n  }\n  destroy() {\n    this.depthSensing.destroy();\n    this.depthSensing = null;\n  }\n  start(camera, type, spaceType, options) {\n    let callback = options;\n    if (typeof options === 'object') callback = options.callback;\n    if (!this._available[type]) {\n      if (callback) callback(new Error('XR is not available'));\n      return;\n    }\n    if (this._session) {\n      if (callback) callback(new Error('XR session is already started'));\n      return;\n    }\n    this._camera = camera;\n    this._camera.camera.xr = this;\n    this._type = type;\n    this._spaceType = spaceType;\n    this._setClipPlanes(camera.nearClip, camera.farClip);\n    const opts = {\n      requiredFeatures: [spaceType],\n      optionalFeatures: []\n    };\n    if (type === _constants_js__WEBPACK_IMPORTED_MODULE_4__.XRTYPE_AR) {\n      opts.optionalFeatures.push('light-estimation');\n      opts.optionalFeatures.push('hit-test');\n      if (options) {\n        if (options.imageTracking && this.imageTracking.supported) opts.optionalFeatures.push('image-tracking');\n        if (options.planeDetection) opts.optionalFeatures.push('plane-detection');\n      }\n      if (this.domOverlay.supported && this.domOverlay.root) {\n        opts.optionalFeatures.push('dom-overlay');\n        opts.domOverlay = {\n          root: this.domOverlay.root\n        };\n      }\n      if (options && options.depthSensing && this.depthSensing.supported) {\n        opts.optionalFeatures.push('depth-sensing');\n        const usagePreference = [_constants_js__WEBPACK_IMPORTED_MODULE_4__.XRDEPTHSENSINGUSAGE_CPU];\n        const dataFormatPreference = [_constants_js__WEBPACK_IMPORTED_MODULE_4__.XRDEPTHSENSINGFORMAT_L8A8];\n        if (options.depthSensing.usagePreference) {\n          const ind = usagePreference.indexOf(options.depthSensing.usagePreference);\n          if (ind !== -1) usagePreference.splice(ind, 1);\n          usagePreference.unshift(options.depthSensing.usagePreference);\n        }\n        if (options.depthSensing.dataFormatPreference) {\n          const ind = dataFormatPreference.indexOf(options.depthSensing.dataFormatPreference);\n          if (ind !== -1) dataFormatPreference.splice(ind, 1);\n          dataFormatPreference.unshift(options.depthSensing.dataFormatPreference);\n        }\n        opts.depthSensing = {\n          usagePreference: usagePreference,\n          dataFormatPreference: dataFormatPreference\n        };\n      }\n    } else if (type === _constants_js__WEBPACK_IMPORTED_MODULE_4__.XRTYPE_VR) {\n      opts.optionalFeatures.push('hand-tracking');\n    }\n    if (options && options.optionalFeatures) opts.optionalFeatures = opts.optionalFeatures.concat(options.optionalFeatures);\n    if (this.imageTracking.supported && this.imageTracking.images.length) {\n      this.imageTracking.prepareImages((err, trackedImages) => {\n        if (err) {\n          if (callback) callback(err);\n          this.fire('error', err);\n          return;\n        }\n        if (trackedImages !== null) opts.trackedImages = trackedImages;\n        this._onStartOptionsReady(type, spaceType, opts, callback);\n      });\n    } else {\n      this._onStartOptionsReady(type, spaceType, opts, callback);\n    }\n  }\n  _onStartOptionsReady(type, spaceType, options, callback) {\n    navigator.xr.requestSession(type, options).then(session => {\n      this._onSessionStart(session, spaceType, callback);\n    }).catch(ex => {\n      this._camera.camera.xr = null;\n      this._camera = null;\n      this._type = null;\n      this._spaceType = null;\n      if (callback) callback(ex);\n      this.fire('error', ex);\n    });\n  }\n  end(callback) {\n    if (!this._session) {\n      if (callback) callback(new Error('XR Session is not initialized'));\n      return;\n    }\n    if (callback) this.once('end', callback);\n    this._session.end();\n  }\n  isAvailable(type) {\n    return this._available[type];\n  }\n  _deviceAvailabilityCheck() {\n    for (const key in this._available) {\n      this._sessionSupportCheck(key);\n    }\n  }\n  _sessionSupportCheck(type) {\n    navigator.xr.isSessionSupported(type).then(available => {\n      if (this._available[type] === available) return;\n      this._available[type] = available;\n      this.fire('available', type, available);\n      this.fire('available:' + type, available);\n    }).catch(ex => {\n      this.fire('error', ex);\n    });\n  }\n  _onSessionStart(session, spaceType, callback) {\n    let failed = false;\n    this._session = session;\n    const onVisibilityChange = () => {\n      this.fire('visibility:change', session.visibilityState);\n    };\n    const onClipPlanesChange = () => {\n      this._setClipPlanes(this._camera.nearClip, this._camera.farClip);\n    };\n    const onEnd = () => {\n      if (this._camera) {\n        this._camera.off('set_nearClip', onClipPlanesChange);\n        this._camera.off('set_farClip', onClipPlanesChange);\n        this._camera.camera.xr = null;\n        this._camera = null;\n      }\n      session.removeEventListener('end', onEnd);\n      session.removeEventListener('visibilitychange', onVisibilityChange);\n      if (!failed) this.fire('end');\n      this._session = null;\n      this._referenceSpace = null;\n      this.views = [];\n      this._width = 0;\n      this._height = 0;\n      this._type = null;\n      this._spaceType = null;\n      this.app.tick();\n    };\n    session.addEventListener('end', onEnd);\n    session.addEventListener('visibilitychange', onVisibilityChange);\n    this._camera.on('set_nearClip', onClipPlanesChange);\n    this._camera.on('set_farClip', onClipPlanesChange);\n    const framebufferScaleFactor = this.app.graphicsDevice.maxPixelRatio / window.devicePixelRatio;\n    this._baseLayer = new XRWebGLLayer(session, this.app.graphicsDevice.gl, {\n      alpha: true,\n      depth: true,\n      stencil: true,\n      framebufferScaleFactor: framebufferScaleFactor\n    });\n    session.updateRenderState({\n      baseLayer: this._baseLayer,\n      depthNear: this._depthNear,\n      depthFar: this._depthFar\n    });\n    session.requestReferenceSpace(spaceType).then(referenceSpace => {\n      this._referenceSpace = referenceSpace;\n      this.app.tick();\n      if (callback) callback(null);\n      this.fire('start');\n    }).catch(ex => {\n      failed = true;\n      session.end();\n      if (callback) callback(ex);\n      this.fire('error', ex);\n    });\n  }\n  _setClipPlanes(near, far) {\n    if (this._depthNear === near && this._depthFar === far) return;\n    this._depthNear = near;\n    this._depthFar = far;\n    if (!this._session) return;\n    this._session.updateRenderState({\n      depthNear: this._depthNear,\n      depthFar: this._depthFar\n    });\n  }\n  update(frame) {\n    if (!this._session) return false;\n    const width = frame.session.renderState.baseLayer.framebufferWidth;\n    const height = frame.session.renderState.baseLayer.framebufferHeight;\n    if (this._width !== width || this._height !== height) {\n      this._width = width;\n      this._height = height;\n      this.app.graphicsDevice.setResolution(width, height);\n    }\n    const pose = frame.getViewerPose(this._referenceSpace);\n    if (!pose) return false;\n    const lengthNew = pose.views.length;\n    if (lengthNew > this.views.length) {\n      for (let i = 0; i <= lengthNew - this.views.length; i++) {\n        let view = this.viewsPool.pop();\n        if (!view) {\n          view = {\n            viewport: new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_12__.Vec4(),\n            projMat: new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_13__.Mat4(),\n            viewMat: new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_13__.Mat4(),\n            viewOffMat: new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_13__.Mat4(),\n            viewInvMat: new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_13__.Mat4(),\n            viewInvOffMat: new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_13__.Mat4(),\n            projViewOffMat: new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_13__.Mat4(),\n            viewMat3: new _core_math_mat3_js__WEBPACK_IMPORTED_MODULE_14__.Mat3(),\n            position: new Float32Array(3),\n            rotation: new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_3__.Quat()\n          };\n        }\n        this.views.push(view);\n      }\n    } else if (lengthNew <= this.views.length) {\n      for (let i = 0; i < this.views.length - lengthNew; i++) {\n        this.viewsPool.push(this.views.pop());\n      }\n    }\n    const posePosition = pose.transform.position;\n    const poseOrientation = pose.transform.orientation;\n    this._localPosition.set(posePosition.x, posePosition.y, posePosition.z);\n    this._localRotation.set(poseOrientation.x, poseOrientation.y, poseOrientation.z, poseOrientation.w);\n    const layer = frame.session.renderState.baseLayer;\n    for (let i = 0; i < pose.views.length; i++) {\n      const viewRaw = pose.views[i];\n      const view = this.views[i];\n      const viewport = layer.getViewport(viewRaw);\n      view.viewport.x = viewport.x;\n      view.viewport.y = viewport.y;\n      view.viewport.z = viewport.width;\n      view.viewport.w = viewport.height;\n      view.projMat.set(viewRaw.projectionMatrix);\n      view.viewMat.set(viewRaw.transform.inverse.matrix);\n      view.viewInvMat.set(viewRaw.transform.matrix);\n    }\n    this._camera.camera._node.setLocalPosition(this._localPosition);\n    this._camera.camera._node.setLocalRotation(this._localRotation);\n    this.input.update(frame);\n    if (this._type === _constants_js__WEBPACK_IMPORTED_MODULE_4__.XRTYPE_AR) {\n      if (this.hitTest.supported) this.hitTest.update(frame);\n      if (this.lightEstimation.supported) this.lightEstimation.update(frame);\n      if (this.depthSensing.supported) this.depthSensing.update(frame, pose && pose.views[0]);\n      if (this.imageTracking.supported) this.imageTracking.update(frame);\n      if (this.planeDetection.supported) this.planeDetection.update(frame);\n    }\n    this.fire('update', frame);\n    return true;\n  }\n  get supported() {\n    return this._supported;\n  }\n  get active() {\n    return !!this._session;\n  }\n  get type() {\n    return this._type;\n  }\n  get spaceType() {\n    return this._spaceType;\n  }\n  get session() {\n    return this._session;\n  }\n  get camera() {\n    return this._camera ? this._camera.entity : null;\n  }\n  get visibilityState() {\n    if (!this._session) return null;\n    return this._session.visibilityState;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-manager.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-plane-detection.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-plane-detection.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"XrPlaneDetection\": () => (/* binding */ XrPlaneDetection)\n/* harmony export */ });\n/* harmony import */ var _core_platform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/platform.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/platform.js\");\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _xr_plane_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./xr-plane.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-plane.js\");\n\n\n\n\nclass XrPlaneDetection extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor(manager) {\n    super();\n    this._manager = void 0;\n    this._supported = _core_platform_js__WEBPACK_IMPORTED_MODULE_1__.platform.browser && !!window.XRPlane;\n    this._available = false;\n    this._planesIndex = new Map();\n    this._planes = null;\n    this._manager = manager;\n    if (this._supported) {\n      this._manager.on('end', this._onSessionEnd, this);\n    }\n  }\n  _onSessionEnd() {\n    if (this._planes) {\n      for (let i = 0; i < this._planes.length; i++) {\n        this._planes[i].destroy();\n      }\n    }\n    this._planesIndex.clear();\n    this._planes = null;\n    if (this._available) {\n      this._available = false;\n      this.fire('unavailable');\n    }\n  }\n  update(frame) {\n    let detectedPlanes;\n    if (!this._available) {\n      try {\n        detectedPlanes = frame.detectedPlanes;\n        this._planes = [];\n        this._available = true;\n        this.fire('available');\n      } catch (ex) {\n        return;\n      }\n    } else {\n      detectedPlanes = frame.detectedPlanes;\n    }\n    for (const [xrPlane, plane] of this._planesIndex) {\n      if (detectedPlanes.has(xrPlane)) continue;\n      this._planesIndex.delete(xrPlane);\n      this._planes.splice(this._planes.indexOf(plane), 1);\n      plane.destroy();\n      this.fire('remove', plane);\n    }\n    for (const xrPlane of detectedPlanes) {\n      let plane = this._planesIndex.get(xrPlane);\n      if (!plane) {\n        plane = new _xr_plane_js__WEBPACK_IMPORTED_MODULE_2__.XrPlane(this, xrPlane);\n        this._planesIndex.set(xrPlane, plane);\n        this._planes.push(plane);\n        plane.update(frame);\n        this.fire('add', plane);\n      } else {\n        plane.update(frame);\n      }\n    }\n  }\n  get supported() {\n    return this._supported;\n  }\n  get available() {\n    return this._available;\n  }\n  get planes() {\n    return this._planes;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-plane-detection.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-plane.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-plane.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"XrPlane\": () => (/* binding */ XrPlane)\n/* harmony export */ });\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _core_math_quat_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/math/quat.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/quat.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n\n\n\n\nlet ids = 0;\nclass XrPlane extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor(planeDetection, xrPlane) {\n    super();\n    this._id = void 0;\n    this._planeDetection = void 0;\n    this._xrPlane = void 0;\n    this._lastChangedTime = void 0;\n    this._orientation = void 0;\n    this._position = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n    this._rotation = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_2__.Quat();\n    this._id = ++ids;\n    this._planeDetection = planeDetection;\n    this._xrPlane = xrPlane;\n    this._lastChangedTime = xrPlane.lastChangedTime;\n    this._orientation = xrPlane.orientation;\n  }\n  destroy() {\n    this.fire('remove');\n  }\n  update(frame) {\n    const manager = this._planeDetection._manager;\n    const pose = frame.getPose(this._xrPlane.planeSpace, manager._referenceSpace);\n    if (pose) {\n      this._position.copy(pose.transform.position);\n      this._rotation.copy(pose.transform.orientation);\n    }\n    if (this._lastChangedTime !== this._xrPlane.lastChangedTime) {\n      this._lastChangedTime = this._xrPlane.lastChangedTime;\n      this.fire('change');\n    }\n  }\n  getPosition() {\n    return this._position;\n  }\n  getRotation() {\n    return this._rotation;\n  }\n  get id() {\n    return this._id;\n  }\n  get orientation() {\n    return this._orientation;\n  }\n  get points() {\n    return this._xrPlane.polygon;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-plane.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-tracked-image.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-tracked-image.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"XrTrackedImage\": () => (/* binding */ XrTrackedImage)\n/* harmony export */ });\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_math_quat_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/math/quat.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/quat.js\");\n\n\n\n\nclass XrTrackedImage extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor(image, width) {\n    super();\n    this._image = void 0;\n    this._width = void 0;\n    this._bitmap = null;\n    this._measuredWidth = 0;\n    this._trackable = false;\n    this._tracking = false;\n    this._emulated = false;\n    this._pose = null;\n    this._position = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n    this._rotation = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_2__.Quat();\n    this._image = image;\n    this._width = width;\n  }\n  get image() {\n    return this._image;\n  }\n  set width(value) {\n    this._width = value;\n  }\n  get width() {\n    return this._width;\n  }\n  get trackable() {\n    return this._trackable;\n  }\n  get tracking() {\n    return this._tracking;\n  }\n  get emulated() {\n    return this._emulated;\n  }\n  prepare() {\n    if (this._bitmap) {\n      return {\n        image: this._bitmap,\n        widthInMeters: this._width\n      };\n    }\n    return createImageBitmap(this._image).then(bitmap => {\n      this._bitmap = bitmap;\n      return {\n        image: this._bitmap,\n        widthInMeters: this._width\n      };\n    });\n  }\n  destroy() {\n    this._image = null;\n    this._pose = null;\n    if (this._bitmap) {\n      this._bitmap.close();\n      this._bitmap = null;\n    }\n  }\n  getPosition() {\n    if (this._pose) this._position.copy(this._pose.transform.position);\n    return this._position;\n  }\n  getRotation() {\n    if (this._pose) this._rotation.copy(this._pose.transform.orientation);\n    return this._rotation;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/framework/xr/xr-tracked-image.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/audio/capabilities.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/audio/capabilities.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"hasAudioContext\": () => (/* binding */ hasAudioContext)\n/* harmony export */ });\nfunction hasAudioContext() {\n  return !!(typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined');\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/audio/capabilities.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/audio/channel.js":
/*!********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/audio/channel.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Channel\": () => (/* binding */ Channel)\n/* harmony export */ });\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _capabilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./capabilities.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/audio/capabilities.js\");\n\n\n\nclass Channel {\n  constructor(manager, sound, options = {}) {\n    this.volume = options.volume === undefined ? 1 : options.volume;\n    this.loop = options.loop === undefined ? false : options.loop;\n    this.pitch = options.pitch === undefined ? 1 : options.pitch;\n    this.sound = sound;\n    this.paused = false;\n    this.suspended = false;\n    this.manager = manager;\n    this.source = null;\n    if ((0,_capabilities_js__WEBPACK_IMPORTED_MODULE_0__.hasAudioContext)()) {\n      this.startTime = 0;\n      this.startOffset = 0;\n      const context = manager.context;\n      this.gain = context.createGain();\n    } else if (sound.audio) {\n      this.source = sound.audio.cloneNode(false);\n      this.source.pause();\n    }\n  }\n  getVolume() {\n    return this.volume;\n  }\n  getLoop() {\n    return this.loop;\n  }\n  setLoop(loop) {\n    this.loop = loop;\n    if (this.source) {\n      this.source.loop = loop;\n    }\n  }\n  getPitch() {\n    return this.pitch;\n  }\n  onManagerVolumeChange() {\n    this.setVolume(this.getVolume());\n  }\n  onManagerSuspend() {\n    if (this.isPlaying() && !this.suspended) {\n      this.suspended = true;\n      this.pause();\n    }\n  }\n  onManagerResume() {\n    if (this.suspended) {\n      this.suspended = false;\n      this.unpause();\n    }\n  }\n  play() {\n    if (this.source) {\n      throw new Error('Call stop() before calling play()');\n    }\n    this._createSource();\n    if (!this.source) {\n      return;\n    }\n    this.startTime = this.manager.context.currentTime;\n    this.source.start(0, this.startOffset % this.source.buffer.duration);\n    this.setVolume(this.volume);\n    this.setLoop(this.loop);\n    this.setPitch(this.pitch);\n    this.manager.on('volumechange', this.onManagerVolumeChange, this);\n    this.manager.on('suspend', this.onManagerSuspend, this);\n    this.manager.on('resume', this.onManagerResume, this);\n    if (this.manager.suspended) this.onManagerSuspend();\n  }\n  pause() {\n    if (this.source) {\n      this.paused = true;\n      this.startOffset += this.manager.context.currentTime - this.startTime;\n      this.source.stop(0);\n      this.source = null;\n    }\n  }\n  unpause() {\n    if (this.source || !this.paused) {\n      console.warn('Call pause() before unpausing.');\n      return;\n    }\n    this._createSource();\n    if (!this.source) {\n      return;\n    }\n    this.startTime = this.manager.context.currentTime;\n    this.source.start(0, this.startOffset % this.source.buffer.duration);\n    this.setVolume(this.volume);\n    this.setLoop(this.loop);\n    this.setPitch(this.pitch);\n    this.paused = false;\n  }\n  stop() {\n    if (this.source) {\n      this.source.stop(0);\n      this.source = null;\n    }\n    this.manager.off('volumechange', this.onManagerVolumeChange, this);\n    this.manager.off('suspend', this.onManagerSuspend, this);\n    this.manager.off('resume', this.onManagerResume, this);\n  }\n  setVolume(volume) {\n    volume = _core_math_math_js__WEBPACK_IMPORTED_MODULE_1__.math.clamp(volume, 0, 1);\n    this.volume = volume;\n    if (this.gain) {\n      this.gain.gain.value = volume * this.manager.volume;\n    }\n  }\n  setPitch(pitch) {\n    this.pitch = pitch;\n    if (this.source) {\n      this.source.playbackRate.value = pitch;\n    }\n  }\n  isPlaying() {\n    return !this.paused && this.source.playbackState === this.source.PLAYING_STATE;\n  }\n  getDuration() {\n    return this.source ? this.source.buffer.duration : 0;\n  }\n  _createSource() {\n    const context = this.manager.context;\n    if (this.sound.buffer) {\n      this.source = context.createBufferSource();\n      this.source.buffer = this.sound.buffer;\n      this.source.connect(this.gain);\n      this.gain.connect(context.destination);\n      if (!this.loop) {\n        this.source.onended = this.pause.bind(this);\n      }\n    }\n  }\n}\nif (!(0,_capabilities_js__WEBPACK_IMPORTED_MODULE_0__.hasAudioContext)()) {\n  Object.assign(Channel.prototype, {\n    play: function () {\n      if (this.source) {\n        this.paused = false;\n        this.setVolume(this.volume);\n        this.setLoop(this.loop);\n        this.setPitch(this.pitch);\n        this.source.play();\n      }\n      this.manager.on('volumechange', this.onManagerVolumeChange, this);\n      this.manager.on('suspend', this.onManagerSuspend, this);\n      this.manager.on('resume', this.onManagerResume, this);\n      if (this.manager.suspended) this.onManagerSuspend();\n    },\n    pause: function () {\n      if (this.source) {\n        this.paused = true;\n        this.source.pause();\n      }\n    },\n    unpause: function () {\n      if (this.source) {\n        this.paused = false;\n        this.source.play();\n      }\n    },\n    stop: function () {\n      if (this.source) {\n        this.source.pause();\n      }\n      this.manager.off('volumechange', this.onManagerVolumeChange, this);\n      this.manager.off('suspend', this.onManagerSuspend, this);\n      this.manager.off('resume', this.onManagerResume, this);\n    },\n    setVolume: function (volume) {\n      volume = _core_math_math_js__WEBPACK_IMPORTED_MODULE_1__.math.clamp(volume, 0, 1);\n      this.volume = volume;\n      if (this.source) {\n        this.source.volume = volume * this.manager.volume;\n      }\n    },\n    setPitch: function (pitch) {\n      this.pitch = pitch;\n      if (this.source) {\n        this.source.playbackRate = pitch;\n      }\n    },\n    getDuration: function () {\n      return this.source && !isNaN(this.source.duration) ? this.source.duration : 0;\n    },\n    isPlaying: function () {\n      return !this.source.paused;\n    }\n  });\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/audio/channel.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/audio/channel3d.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/audio/channel3d.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Channel3d\": () => (/* binding */ Channel3d)\n/* harmony export */ });\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/audio/constants.js\");\n/* harmony import */ var _capabilities_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./capabilities.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/audio/capabilities.js\");\n/* harmony import */ var _channel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./channel.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/audio/channel.js\");\n\n\n\n\n\n\n\nconst MAX_DISTANCE = 10000;\nclass Channel3d extends _channel_js__WEBPACK_IMPORTED_MODULE_0__.Channel {\n  constructor(manager, sound, options) {\n    super(manager, sound, options);\n    this.position = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n    this.velocity = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n    if ((0,_capabilities_js__WEBPACK_IMPORTED_MODULE_2__.hasAudioContext)()) {\n      this.panner = manager.context.createPanner();\n    } else {\n      this.maxDistance = MAX_DISTANCE;\n      this.minDistance = 1;\n      this.rollOffFactor = 1;\n      this.distanceModel = _constants_js__WEBPACK_IMPORTED_MODULE_3__.DISTANCE_INVERSE;\n    }\n  }\n  getPosition() {\n    return this.position;\n  }\n  setPosition(position) {\n    this.position.copy(position);\n    const panner = this.panner;\n    if ('positionX' in panner) {\n      panner.positionX.value = position.x;\n      panner.positionY.value = position.y;\n      panner.positionZ.value = position.z;\n    } else if (panner.setPosition) {\n      panner.setPosition(position.x, position.y, position.z);\n    }\n  }\n  getVelocity() {\n    return this.velocity;\n  }\n  setVelocity(velocity) {\n    this.velocity.copy(velocity);\n  }\n  getMaxDistance() {\n    return this.panner.maxDistance;\n  }\n  setMaxDistance(max) {\n    this.panner.maxDistance = max;\n  }\n  getMinDistance() {\n    return this.panner.refDistance;\n  }\n  setMinDistance(min) {\n    this.panner.refDistance = min;\n  }\n  getRollOffFactor() {\n    return this.panner.rolloffFactor;\n  }\n  setRollOffFactor(factor) {\n    this.panner.rolloffFactor = factor;\n  }\n  getDistanceModel() {\n    return this.panner.distanceModel;\n  }\n  setDistanceModel(distanceModel) {\n    this.panner.distanceModel = distanceModel;\n  }\n  _createSource() {\n    const context = this.manager.context;\n    this.source = context.createBufferSource();\n    this.source.buffer = this.sound.buffer;\n    this.source.connect(this.panner);\n    this.panner.connect(this.gain);\n    this.gain.connect(context.destination);\n    if (!this.loop) {\n      this.source.onended = this.pause.bind(this);\n    }\n  }\n}\nif (!(0,_capabilities_js__WEBPACK_IMPORTED_MODULE_2__.hasAudioContext)()) {\n  let offset = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n  const fallOff = function fallOff(posOne, posTwo, refDistance, maxDistance, rolloffFactor, distanceModel) {\n    offset = offset.sub2(posOne, posTwo);\n    const distance = offset.length();\n    if (distance < refDistance) {\n      return 1;\n    } else if (distance > maxDistance) {\n      return 0;\n    }\n    let result = 0;\n    if (distanceModel === _constants_js__WEBPACK_IMPORTED_MODULE_3__.DISTANCE_LINEAR) {\n      result = 1 - rolloffFactor * (distance - refDistance) / (maxDistance - refDistance);\n    } else if (distanceModel === _constants_js__WEBPACK_IMPORTED_MODULE_3__.DISTANCE_INVERSE) {\n      result = refDistance / (refDistance + rolloffFactor * (distance - refDistance));\n    } else if (distanceModel === _constants_js__WEBPACK_IMPORTED_MODULE_3__.DISTANCE_EXPONENTIAL) {\n      result = Math.pow(distance / refDistance, -rolloffFactor);\n    }\n    return _core_math_math_js__WEBPACK_IMPORTED_MODULE_4__.math.clamp(result, 0, 1);\n  };\n  Object.assign(Channel3d.prototype, {\n    setPosition: function (position) {\n      this.position.copy(position);\n      if (this.source) {\n        const listener = this.manager.listener;\n        const lpos = listener.getPosition();\n        const factor = fallOff(lpos, this.position, this.minDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);\n        const v = this.getVolume();\n        this.source.volume = v * factor;\n      }\n    },\n    getMaxDistance: function () {\n      return this.maxDistance;\n    },\n    setMaxDistance: function (max) {\n      this.maxDistance = max;\n    },\n    getMinDistance: function () {\n      return this.minDistance;\n    },\n    setMinDistance: function (min) {\n      this.minDistance = min;\n    },\n    getRollOffFactor: function () {\n      return this.rollOffFactor;\n    },\n    setRollOffFactor: function (factor) {\n      this.rollOffFactor = factor;\n    },\n    getDistanceModel: function () {\n      return this.distanceModel;\n    },\n    setDistanceModel: function (distanceModel) {\n      this.distanceModel = distanceModel;\n    }\n  });\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/audio/channel3d.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/audio/constants.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/audio/constants.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DISTANCE_EXPONENTIAL\": () => (/* binding */ DISTANCE_EXPONENTIAL),\n/* harmony export */   \"DISTANCE_INVERSE\": () => (/* binding */ DISTANCE_INVERSE),\n/* harmony export */   \"DISTANCE_LINEAR\": () => (/* binding */ DISTANCE_LINEAR)\n/* harmony export */ });\nconst DISTANCE_LINEAR = 'linear';\nconst DISTANCE_INVERSE = 'inverse';\nconst DISTANCE_EXPONENTIAL = 'exponential';\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/audio/constants.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/bind-group-format.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/bind-group-format.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BindBufferFormat\": () => (/* binding */ BindBufferFormat),\n/* harmony export */   \"BindGroupFormat\": () => (/* binding */ BindGroupFormat),\n/* harmony export */   \"BindTextureFormat\": () => (/* binding */ BindTextureFormat)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n\n\n\nlet id = 0;\nconst textureDimensionInfo = {\n  [_constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTUREDIMENSION_2D]: 'texture2D',\n  [_constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTUREDIMENSION_CUBE]: 'textureCube',\n  [_constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTUREDIMENSION_3D]: 'texture3D'\n};\nclass BindBufferFormat {\n  constructor(name, visibility) {\n    this.name = name;\n    this.visibility = visibility;\n  }\n}\nclass BindTextureFormat {\n  constructor(name, visibility, textureDimension = _constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTUREDIMENSION_2D, sampleType = _constants_js__WEBPACK_IMPORTED_MODULE_0__.SAMPLETYPE_FLOAT) {\n    this.scopeId = void 0;\n    this.name = name;\n    this.visibility = visibility;\n    this.textureDimension = textureDimension;\n    this.sampleType = sampleType;\n  }\n}\nclass BindGroupFormat {\n  constructor(graphicsDevice, bufferFormats, textureFormats) {\n    this.id = id++;\n    this.device = graphicsDevice;\n    this.bufferFormats = bufferFormats;\n    this.bufferFormatsMap = new Map();\n    bufferFormats.forEach((bf, i) => this.bufferFormatsMap.set(bf.name, i));\n    this.textureFormats = textureFormats;\n    const scope = graphicsDevice.scope;\n    this.textureFormatsMap = new Map();\n    textureFormats.forEach((tf, i) => {\n      this.textureFormatsMap.set(tf.name, i);\n      tf.scopeId = scope.resolve(tf.name);\n    });\n    this.impl = graphicsDevice.createBindGroupFormatImpl(this);\n  }\n  destroy() {\n    this.impl.destroy();\n  }\n  getTexture(name) {\n    const index = this.textureFormatsMap.get(name);\n    if (index !== undefined) {\n      return this.textureFormats[index];\n    }\n    return null;\n  }\n  getShaderDeclarationTextures(bindGroup) {\n    let code = '';\n    let bindIndex = this.bufferFormats.length;\n    this.textureFormats.forEach(format => {\n      const textureType = textureDimensionInfo[format.textureDimension];\n      code += `layout(set = ${bindGroup}, binding = ${bindIndex++}) uniform ${textureType} ${format.name};\\n` + `layout(set = ${bindGroup}, binding = ${bindIndex++}) uniform sampler ${format.name}_sampler;\\n`;\n    });\n    return code;\n  }\n  loseContext() {}\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/bind-group-format.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/bind-group.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/bind-group.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BindGroup\": () => (/* binding */ BindGroup)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n\n\n\nlet id = 0;\nclass BindGroup {\n  constructor(graphicsDevice, format, defaultUniformBuffer) {\n    this.id = id++;\n    this.device = graphicsDevice;\n    this.format = format;\n    this.dirty = true;\n    this.impl = graphicsDevice.createBindGroupImpl(this);\n    this.textures = [];\n    this.uniformBuffers = [];\n    this.defaultUniformBuffer = defaultUniformBuffer;\n    if (defaultUniformBuffer) {\n      this.setUniformBuffer(_constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORM_BUFFER_DEFAULT_SLOT_NAME, defaultUniformBuffer);\n    }\n  }\n  destroy() {\n    this.impl.destroy();\n    this.impl = null;\n    this.format = null;\n    this.defaultUniformBuffer = null;\n  }\n  setUniformBuffer(name, uniformBuffer) {\n    const index = this.format.bufferFormatsMap.get(name);\n    if (this.uniformBuffers[index] !== uniformBuffer) {\n      this.uniformBuffers[index] = uniformBuffer;\n      this.dirty = true;\n    }\n  }\n  setTexture(name, texture) {\n    const index = this.format.textureFormatsMap.get(name);\n    if (this.textures[index] !== texture) {\n      this.textures[index] = texture;\n      this.dirty = true;\n    }\n  }\n  update() {\n    const textureFormats = this.format.textureFormats;\n    for (let i = 0; i < textureFormats.length; i++) {\n      const textureFormat = textureFormats[i];\n      const value = textureFormat.scopeId.value;\n      this.setTexture(textureFormat.name, value);\n    }\n    if (this.dirty) {\n      this.dirty = false;\n      this.impl.update(this);\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/bind-group.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ADDRESS_CLAMP_TO_EDGE\": () => (/* binding */ ADDRESS_CLAMP_TO_EDGE),\n/* harmony export */   \"ADDRESS_MIRRORED_REPEAT\": () => (/* binding */ ADDRESS_MIRRORED_REPEAT),\n/* harmony export */   \"ADDRESS_REPEAT\": () => (/* binding */ ADDRESS_REPEAT),\n/* harmony export */   \"BINDGROUP_MESH\": () => (/* binding */ BINDGROUP_MESH),\n/* harmony export */   \"BINDGROUP_VIEW\": () => (/* binding */ BINDGROUP_VIEW),\n/* harmony export */   \"BLENDEQUATION_ADD\": () => (/* binding */ BLENDEQUATION_ADD),\n/* harmony export */   \"BLENDEQUATION_MAX\": () => (/* binding */ BLENDEQUATION_MAX),\n/* harmony export */   \"BLENDEQUATION_MIN\": () => (/* binding */ BLENDEQUATION_MIN),\n/* harmony export */   \"BLENDEQUATION_REVERSE_SUBTRACT\": () => (/* binding */ BLENDEQUATION_REVERSE_SUBTRACT),\n/* harmony export */   \"BLENDEQUATION_SUBTRACT\": () => (/* binding */ BLENDEQUATION_SUBTRACT),\n/* harmony export */   \"BLENDMODE_CONSTANT_ALPHA\": () => (/* binding */ BLENDMODE_CONSTANT_ALPHA),\n/* harmony export */   \"BLENDMODE_CONSTANT_COLOR\": () => (/* binding */ BLENDMODE_CONSTANT_COLOR),\n/* harmony export */   \"BLENDMODE_DST_ALPHA\": () => (/* binding */ BLENDMODE_DST_ALPHA),\n/* harmony export */   \"BLENDMODE_DST_COLOR\": () => (/* binding */ BLENDMODE_DST_COLOR),\n/* harmony export */   \"BLENDMODE_ONE\": () => (/* binding */ BLENDMODE_ONE),\n/* harmony export */   \"BLENDMODE_ONE_MINUS_CONSTANT_ALPHA\": () => (/* binding */ BLENDMODE_ONE_MINUS_CONSTANT_ALPHA),\n/* harmony export */   \"BLENDMODE_ONE_MINUS_CONSTANT_COLOR\": () => (/* binding */ BLENDMODE_ONE_MINUS_CONSTANT_COLOR),\n/* harmony export */   \"BLENDMODE_ONE_MINUS_DST_ALPHA\": () => (/* binding */ BLENDMODE_ONE_MINUS_DST_ALPHA),\n/* harmony export */   \"BLENDMODE_ONE_MINUS_DST_COLOR\": () => (/* binding */ BLENDMODE_ONE_MINUS_DST_COLOR),\n/* harmony export */   \"BLENDMODE_ONE_MINUS_SRC_ALPHA\": () => (/* binding */ BLENDMODE_ONE_MINUS_SRC_ALPHA),\n/* harmony export */   \"BLENDMODE_ONE_MINUS_SRC_COLOR\": () => (/* binding */ BLENDMODE_ONE_MINUS_SRC_COLOR),\n/* harmony export */   \"BLENDMODE_SRC_ALPHA\": () => (/* binding */ BLENDMODE_SRC_ALPHA),\n/* harmony export */   \"BLENDMODE_SRC_ALPHA_SATURATE\": () => (/* binding */ BLENDMODE_SRC_ALPHA_SATURATE),\n/* harmony export */   \"BLENDMODE_SRC_COLOR\": () => (/* binding */ BLENDMODE_SRC_COLOR),\n/* harmony export */   \"BLENDMODE_ZERO\": () => (/* binding */ BLENDMODE_ZERO),\n/* harmony export */   \"BUFFER_DYNAMIC\": () => (/* binding */ BUFFER_DYNAMIC),\n/* harmony export */   \"BUFFER_GPUDYNAMIC\": () => (/* binding */ BUFFER_GPUDYNAMIC),\n/* harmony export */   \"BUFFER_STATIC\": () => (/* binding */ BUFFER_STATIC),\n/* harmony export */   \"BUFFER_STREAM\": () => (/* binding */ BUFFER_STREAM),\n/* harmony export */   \"CHUNKAPI_1_51\": () => (/* binding */ CHUNKAPI_1_51),\n/* harmony export */   \"CHUNKAPI_1_55\": () => (/* binding */ CHUNKAPI_1_55),\n/* harmony export */   \"CHUNKAPI_1_56\": () => (/* binding */ CHUNKAPI_1_56),\n/* harmony export */   \"CHUNKAPI_1_57\": () => (/* binding */ CHUNKAPI_1_57),\n/* harmony export */   \"CHUNKAPI_1_58\": () => (/* binding */ CHUNKAPI_1_58),\n/* harmony export */   \"CHUNKAPI_1_60\": () => (/* binding */ CHUNKAPI_1_60),\n/* harmony export */   \"CLEARFLAG_COLOR\": () => (/* binding */ CLEARFLAG_COLOR),\n/* harmony export */   \"CLEARFLAG_DEPTH\": () => (/* binding */ CLEARFLAG_DEPTH),\n/* harmony export */   \"CLEARFLAG_STENCIL\": () => (/* binding */ CLEARFLAG_STENCIL),\n/* harmony export */   \"CUBEFACE_NEGX\": () => (/* binding */ CUBEFACE_NEGX),\n/* harmony export */   \"CUBEFACE_NEGY\": () => (/* binding */ CUBEFACE_NEGY),\n/* harmony export */   \"CUBEFACE_NEGZ\": () => (/* binding */ CUBEFACE_NEGZ),\n/* harmony export */   \"CUBEFACE_POSX\": () => (/* binding */ CUBEFACE_POSX),\n/* harmony export */   \"CUBEFACE_POSY\": () => (/* binding */ CUBEFACE_POSY),\n/* harmony export */   \"CUBEFACE_POSZ\": () => (/* binding */ CUBEFACE_POSZ),\n/* harmony export */   \"CULLFACE_BACK\": () => (/* binding */ CULLFACE_BACK),\n/* harmony export */   \"CULLFACE_FRONT\": () => (/* binding */ CULLFACE_FRONT),\n/* harmony export */   \"CULLFACE_FRONTANDBACK\": () => (/* binding */ CULLFACE_FRONTANDBACK),\n/* harmony export */   \"CULLFACE_NONE\": () => (/* binding */ CULLFACE_NONE),\n/* harmony export */   \"DEVICETYPE_WEBGL\": () => (/* binding */ DEVICETYPE_WEBGL),\n/* harmony export */   \"DEVICETYPE_WEBGPU\": () => (/* binding */ DEVICETYPE_WEBGPU),\n/* harmony export */   \"FILTER_LINEAR\": () => (/* binding */ FILTER_LINEAR),\n/* harmony export */   \"FILTER_LINEAR_MIPMAP_LINEAR\": () => (/* binding */ FILTER_LINEAR_MIPMAP_LINEAR),\n/* harmony export */   \"FILTER_LINEAR_MIPMAP_NEAREST\": () => (/* binding */ FILTER_LINEAR_MIPMAP_NEAREST),\n/* harmony export */   \"FILTER_NEAREST\": () => (/* binding */ FILTER_NEAREST),\n/* harmony export */   \"FILTER_NEAREST_MIPMAP_LINEAR\": () => (/* binding */ FILTER_NEAREST_MIPMAP_LINEAR),\n/* harmony export */   \"FILTER_NEAREST_MIPMAP_NEAREST\": () => (/* binding */ FILTER_NEAREST_MIPMAP_NEAREST),\n/* harmony export */   \"FUNC_ALWAYS\": () => (/* binding */ FUNC_ALWAYS),\n/* harmony export */   \"FUNC_EQUAL\": () => (/* binding */ FUNC_EQUAL),\n/* harmony export */   \"FUNC_GREATER\": () => (/* binding */ FUNC_GREATER),\n/* harmony export */   \"FUNC_GREATEREQUAL\": () => (/* binding */ FUNC_GREATEREQUAL),\n/* harmony export */   \"FUNC_LESS\": () => (/* binding */ FUNC_LESS),\n/* harmony export */   \"FUNC_LESSEQUAL\": () => (/* binding */ FUNC_LESSEQUAL),\n/* harmony export */   \"FUNC_NEVER\": () => (/* binding */ FUNC_NEVER),\n/* harmony export */   \"FUNC_NOTEQUAL\": () => (/* binding */ FUNC_NOTEQUAL),\n/* harmony export */   \"INDEXFORMAT_UINT16\": () => (/* binding */ INDEXFORMAT_UINT16),\n/* harmony export */   \"INDEXFORMAT_UINT32\": () => (/* binding */ INDEXFORMAT_UINT32),\n/* harmony export */   \"INDEXFORMAT_UINT8\": () => (/* binding */ INDEXFORMAT_UINT8),\n/* harmony export */   \"PIXELFORMAT_111110F\": () => (/* binding */ PIXELFORMAT_111110F),\n/* harmony export */   \"PIXELFORMAT_A8\": () => (/* binding */ PIXELFORMAT_A8),\n/* harmony export */   \"PIXELFORMAT_ASTC_4x4\": () => (/* binding */ PIXELFORMAT_ASTC_4x4),\n/* harmony export */   \"PIXELFORMAT_ATC_RGB\": () => (/* binding */ PIXELFORMAT_ATC_RGB),\n/* harmony export */   \"PIXELFORMAT_ATC_RGBA\": () => (/* binding */ PIXELFORMAT_ATC_RGBA),\n/* harmony export */   \"PIXELFORMAT_BGRA8\": () => (/* binding */ PIXELFORMAT_BGRA8),\n/* harmony export */   \"PIXELFORMAT_DEPTH\": () => (/* binding */ PIXELFORMAT_DEPTH),\n/* harmony export */   \"PIXELFORMAT_DEPTHSTENCIL\": () => (/* binding */ PIXELFORMAT_DEPTHSTENCIL),\n/* harmony export */   \"PIXELFORMAT_DXT1\": () => (/* binding */ PIXELFORMAT_DXT1),\n/* harmony export */   \"PIXELFORMAT_DXT3\": () => (/* binding */ PIXELFORMAT_DXT3),\n/* harmony export */   \"PIXELFORMAT_DXT5\": () => (/* binding */ PIXELFORMAT_DXT5),\n/* harmony export */   \"PIXELFORMAT_ETC1\": () => (/* binding */ PIXELFORMAT_ETC1),\n/* harmony export */   \"PIXELFORMAT_ETC2_RGB\": () => (/* binding */ PIXELFORMAT_ETC2_RGB),\n/* harmony export */   \"PIXELFORMAT_ETC2_RGBA\": () => (/* binding */ PIXELFORMAT_ETC2_RGBA),\n/* harmony export */   \"PIXELFORMAT_L8\": () => (/* binding */ PIXELFORMAT_L8),\n/* harmony export */   \"PIXELFORMAT_LA8\": () => (/* binding */ PIXELFORMAT_LA8),\n/* harmony export */   \"PIXELFORMAT_PVRTC_2BPP_RGBA_1\": () => (/* binding */ PIXELFORMAT_PVRTC_2BPP_RGBA_1),\n/* harmony export */   \"PIXELFORMAT_PVRTC_2BPP_RGB_1\": () => (/* binding */ PIXELFORMAT_PVRTC_2BPP_RGB_1),\n/* harmony export */   \"PIXELFORMAT_PVRTC_4BPP_RGBA_1\": () => (/* binding */ PIXELFORMAT_PVRTC_4BPP_RGBA_1),\n/* harmony export */   \"PIXELFORMAT_PVRTC_4BPP_RGB_1\": () => (/* binding */ PIXELFORMAT_PVRTC_4BPP_RGB_1),\n/* harmony export */   \"PIXELFORMAT_R32F\": () => (/* binding */ PIXELFORMAT_R32F),\n/* harmony export */   \"PIXELFORMAT_RGB16F\": () => (/* binding */ PIXELFORMAT_RGB16F),\n/* harmony export */   \"PIXELFORMAT_RGB32F\": () => (/* binding */ PIXELFORMAT_RGB32F),\n/* harmony export */   \"PIXELFORMAT_RGB565\": () => (/* binding */ PIXELFORMAT_RGB565),\n/* harmony export */   \"PIXELFORMAT_RGB8\": () => (/* binding */ PIXELFORMAT_RGB8),\n/* harmony export */   \"PIXELFORMAT_RGBA16F\": () => (/* binding */ PIXELFORMAT_RGBA16F),\n/* harmony export */   \"PIXELFORMAT_RGBA32F\": () => (/* binding */ PIXELFORMAT_RGBA32F),\n/* harmony export */   \"PIXELFORMAT_RGBA4\": () => (/* binding */ PIXELFORMAT_RGBA4),\n/* harmony export */   \"PIXELFORMAT_RGBA5551\": () => (/* binding */ PIXELFORMAT_RGBA5551),\n/* harmony export */   \"PIXELFORMAT_RGBA8\": () => (/* binding */ PIXELFORMAT_RGBA8),\n/* harmony export */   \"PIXELFORMAT_SRGB\": () => (/* binding */ PIXELFORMAT_SRGB),\n/* harmony export */   \"PIXELFORMAT_SRGBA\": () => (/* binding */ PIXELFORMAT_SRGBA),\n/* harmony export */   \"PRIMITIVE_LINELOOP\": () => (/* binding */ PRIMITIVE_LINELOOP),\n/* harmony export */   \"PRIMITIVE_LINES\": () => (/* binding */ PRIMITIVE_LINES),\n/* harmony export */   \"PRIMITIVE_LINESTRIP\": () => (/* binding */ PRIMITIVE_LINESTRIP),\n/* harmony export */   \"PRIMITIVE_POINTS\": () => (/* binding */ PRIMITIVE_POINTS),\n/* harmony export */   \"PRIMITIVE_TRIANGLES\": () => (/* binding */ PRIMITIVE_TRIANGLES),\n/* harmony export */   \"PRIMITIVE_TRIFAN\": () => (/* binding */ PRIMITIVE_TRIFAN),\n/* harmony export */   \"PRIMITIVE_TRISTRIP\": () => (/* binding */ PRIMITIVE_TRISTRIP),\n/* harmony export */   \"SAMPLETYPE_DEPTH\": () => (/* binding */ SAMPLETYPE_DEPTH),\n/* harmony export */   \"SAMPLETYPE_FLOAT\": () => (/* binding */ SAMPLETYPE_FLOAT),\n/* harmony export */   \"SAMPLETYPE_UNFILTERABLE_FLOAT\": () => (/* binding */ SAMPLETYPE_UNFILTERABLE_FLOAT),\n/* harmony export */   \"SEMANTIC_ATTR\": () => (/* binding */ SEMANTIC_ATTR),\n/* harmony export */   \"SEMANTIC_ATTR0\": () => (/* binding */ SEMANTIC_ATTR0),\n/* harmony export */   \"SEMANTIC_ATTR1\": () => (/* binding */ SEMANTIC_ATTR1),\n/* harmony export */   \"SEMANTIC_ATTR10\": () => (/* binding */ SEMANTIC_ATTR10),\n/* harmony export */   \"SEMANTIC_ATTR11\": () => (/* binding */ SEMANTIC_ATTR11),\n/* harmony export */   \"SEMANTIC_ATTR12\": () => (/* binding */ SEMANTIC_ATTR12),\n/* harmony export */   \"SEMANTIC_ATTR13\": () => (/* binding */ SEMANTIC_ATTR13),\n/* harmony export */   \"SEMANTIC_ATTR14\": () => (/* binding */ SEMANTIC_ATTR14),\n/* harmony export */   \"SEMANTIC_ATTR15\": () => (/* binding */ SEMANTIC_ATTR15),\n/* harmony export */   \"SEMANTIC_ATTR2\": () => (/* binding */ SEMANTIC_ATTR2),\n/* harmony export */   \"SEMANTIC_ATTR3\": () => (/* binding */ SEMANTIC_ATTR3),\n/* harmony export */   \"SEMANTIC_ATTR4\": () => (/* binding */ SEMANTIC_ATTR4),\n/* harmony export */   \"SEMANTIC_ATTR5\": () => (/* binding */ SEMANTIC_ATTR5),\n/* harmony export */   \"SEMANTIC_ATTR6\": () => (/* binding */ SEMANTIC_ATTR6),\n/* harmony export */   \"SEMANTIC_ATTR7\": () => (/* binding */ SEMANTIC_ATTR7),\n/* harmony export */   \"SEMANTIC_ATTR8\": () => (/* binding */ SEMANTIC_ATTR8),\n/* harmony export */   \"SEMANTIC_ATTR9\": () => (/* binding */ SEMANTIC_ATTR9),\n/* harmony export */   \"SEMANTIC_BLENDINDICES\": () => (/* binding */ SEMANTIC_BLENDINDICES),\n/* harmony export */   \"SEMANTIC_BLENDWEIGHT\": () => (/* binding */ SEMANTIC_BLENDWEIGHT),\n/* harmony export */   \"SEMANTIC_COLOR\": () => (/* binding */ SEMANTIC_COLOR),\n/* harmony export */   \"SEMANTIC_NORMAL\": () => (/* binding */ SEMANTIC_NORMAL),\n/* harmony export */   \"SEMANTIC_POSITION\": () => (/* binding */ SEMANTIC_POSITION),\n/* harmony export */   \"SEMANTIC_TANGENT\": () => (/* binding */ SEMANTIC_TANGENT),\n/* harmony export */   \"SEMANTIC_TEXCOORD\": () => (/* binding */ SEMANTIC_TEXCOORD),\n/* harmony export */   \"SEMANTIC_TEXCOORD0\": () => (/* binding */ SEMANTIC_TEXCOORD0),\n/* harmony export */   \"SEMANTIC_TEXCOORD1\": () => (/* binding */ SEMANTIC_TEXCOORD1),\n/* harmony export */   \"SEMANTIC_TEXCOORD2\": () => (/* binding */ SEMANTIC_TEXCOORD2),\n/* harmony export */   \"SEMANTIC_TEXCOORD3\": () => (/* binding */ SEMANTIC_TEXCOORD3),\n/* harmony export */   \"SEMANTIC_TEXCOORD4\": () => (/* binding */ SEMANTIC_TEXCOORD4),\n/* harmony export */   \"SEMANTIC_TEXCOORD5\": () => (/* binding */ SEMANTIC_TEXCOORD5),\n/* harmony export */   \"SEMANTIC_TEXCOORD6\": () => (/* binding */ SEMANTIC_TEXCOORD6),\n/* harmony export */   \"SEMANTIC_TEXCOORD7\": () => (/* binding */ SEMANTIC_TEXCOORD7),\n/* harmony export */   \"SHADERSTAGE_COMPUTE\": () => (/* binding */ SHADERSTAGE_COMPUTE),\n/* harmony export */   \"SHADERSTAGE_FRAGMENT\": () => (/* binding */ SHADERSTAGE_FRAGMENT),\n/* harmony export */   \"SHADERSTAGE_VERTEX\": () => (/* binding */ SHADERSTAGE_VERTEX),\n/* harmony export */   \"SHADERTAG_MATERIAL\": () => (/* binding */ SHADERTAG_MATERIAL),\n/* harmony export */   \"STENCILOP_DECREMENT\": () => (/* binding */ STENCILOP_DECREMENT),\n/* harmony export */   \"STENCILOP_DECREMENTWRAP\": () => (/* binding */ STENCILOP_DECREMENTWRAP),\n/* harmony export */   \"STENCILOP_INCREMENT\": () => (/* binding */ STENCILOP_INCREMENT),\n/* harmony export */   \"STENCILOP_INCREMENTWRAP\": () => (/* binding */ STENCILOP_INCREMENTWRAP),\n/* harmony export */   \"STENCILOP_INVERT\": () => (/* binding */ STENCILOP_INVERT),\n/* harmony export */   \"STENCILOP_KEEP\": () => (/* binding */ STENCILOP_KEEP),\n/* harmony export */   \"STENCILOP_REPLACE\": () => (/* binding */ STENCILOP_REPLACE),\n/* harmony export */   \"STENCILOP_ZERO\": () => (/* binding */ STENCILOP_ZERO),\n/* harmony export */   \"TEXHINT_ASSET\": () => (/* binding */ TEXHINT_ASSET),\n/* harmony export */   \"TEXHINT_LIGHTMAP\": () => (/* binding */ TEXHINT_LIGHTMAP),\n/* harmony export */   \"TEXHINT_NONE\": () => (/* binding */ TEXHINT_NONE),\n/* harmony export */   \"TEXHINT_SHADOWMAP\": () => (/* binding */ TEXHINT_SHADOWMAP),\n/* harmony export */   \"TEXTUREDIMENSION_1D\": () => (/* binding */ TEXTUREDIMENSION_1D),\n/* harmony export */   \"TEXTUREDIMENSION_2D\": () => (/* binding */ TEXTUREDIMENSION_2D),\n/* harmony export */   \"TEXTUREDIMENSION_2D_ARRAY\": () => (/* binding */ TEXTUREDIMENSION_2D_ARRAY),\n/* harmony export */   \"TEXTUREDIMENSION_3D\": () => (/* binding */ TEXTUREDIMENSION_3D),\n/* harmony export */   \"TEXTUREDIMENSION_CUBE\": () => (/* binding */ TEXTUREDIMENSION_CUBE),\n/* harmony export */   \"TEXTUREDIMENSION_CUBE_ARRAY\": () => (/* binding */ TEXTUREDIMENSION_CUBE_ARRAY),\n/* harmony export */   \"TEXTURELOCK_READ\": () => (/* binding */ TEXTURELOCK_READ),\n/* harmony export */   \"TEXTURELOCK_WRITE\": () => (/* binding */ TEXTURELOCK_WRITE),\n/* harmony export */   \"TEXTUREPROJECTION_CUBE\": () => (/* binding */ TEXTUREPROJECTION_CUBE),\n/* harmony export */   \"TEXTUREPROJECTION_EQUIRECT\": () => (/* binding */ TEXTUREPROJECTION_EQUIRECT),\n/* harmony export */   \"TEXTUREPROJECTION_NONE\": () => (/* binding */ TEXTUREPROJECTION_NONE),\n/* harmony export */   \"TEXTUREPROJECTION_OCTAHEDRAL\": () => (/* binding */ TEXTUREPROJECTION_OCTAHEDRAL),\n/* harmony export */   \"TEXTURETYPE_DEFAULT\": () => (/* binding */ TEXTURETYPE_DEFAULT),\n/* harmony export */   \"TEXTURETYPE_RGBE\": () => (/* binding */ TEXTURETYPE_RGBE),\n/* harmony export */   \"TEXTURETYPE_RGBM\": () => (/* binding */ TEXTURETYPE_RGBM),\n/* harmony export */   \"TEXTURETYPE_RGBP\": () => (/* binding */ TEXTURETYPE_RGBP),\n/* harmony export */   \"TEXTURETYPE_SWIZZLEGGGR\": () => (/* binding */ TEXTURETYPE_SWIZZLEGGGR),\n/* harmony export */   \"TYPE_FLOAT32\": () => (/* binding */ TYPE_FLOAT32),\n/* harmony export */   \"TYPE_INT16\": () => (/* binding */ TYPE_INT16),\n/* harmony export */   \"TYPE_INT32\": () => (/* binding */ TYPE_INT32),\n/* harmony export */   \"TYPE_INT8\": () => (/* binding */ TYPE_INT8),\n/* harmony export */   \"TYPE_UINT16\": () => (/* binding */ TYPE_UINT16),\n/* harmony export */   \"TYPE_UINT32\": () => (/* binding */ TYPE_UINT32),\n/* harmony export */   \"TYPE_UINT8\": () => (/* binding */ TYPE_UINT8),\n/* harmony export */   \"UNIFORMTYPE_BOOL\": () => (/* binding */ UNIFORMTYPE_BOOL),\n/* harmony export */   \"UNIFORMTYPE_BVEC2\": () => (/* binding */ UNIFORMTYPE_BVEC2),\n/* harmony export */   \"UNIFORMTYPE_BVEC3\": () => (/* binding */ UNIFORMTYPE_BVEC3),\n/* harmony export */   \"UNIFORMTYPE_BVEC4\": () => (/* binding */ UNIFORMTYPE_BVEC4),\n/* harmony export */   \"UNIFORMTYPE_FLOAT\": () => (/* binding */ UNIFORMTYPE_FLOAT),\n/* harmony export */   \"UNIFORMTYPE_FLOATARRAY\": () => (/* binding */ UNIFORMTYPE_FLOATARRAY),\n/* harmony export */   \"UNIFORMTYPE_INT\": () => (/* binding */ UNIFORMTYPE_INT),\n/* harmony export */   \"UNIFORMTYPE_IVEC2\": () => (/* binding */ UNIFORMTYPE_IVEC2),\n/* harmony export */   \"UNIFORMTYPE_IVEC3\": () => (/* binding */ UNIFORMTYPE_IVEC3),\n/* harmony export */   \"UNIFORMTYPE_IVEC4\": () => (/* binding */ UNIFORMTYPE_IVEC4),\n/* harmony export */   \"UNIFORMTYPE_MAT2\": () => (/* binding */ UNIFORMTYPE_MAT2),\n/* harmony export */   \"UNIFORMTYPE_MAT3\": () => (/* binding */ UNIFORMTYPE_MAT3),\n/* harmony export */   \"UNIFORMTYPE_MAT4\": () => (/* binding */ UNIFORMTYPE_MAT4),\n/* harmony export */   \"UNIFORMTYPE_TEXTURE2D\": () => (/* binding */ UNIFORMTYPE_TEXTURE2D),\n/* harmony export */   \"UNIFORMTYPE_TEXTURE2D_SHADOW\": () => (/* binding */ UNIFORMTYPE_TEXTURE2D_SHADOW),\n/* harmony export */   \"UNIFORMTYPE_TEXTURE3D\": () => (/* binding */ UNIFORMTYPE_TEXTURE3D),\n/* harmony export */   \"UNIFORMTYPE_TEXTURECUBE\": () => (/* binding */ UNIFORMTYPE_TEXTURECUBE),\n/* harmony export */   \"UNIFORMTYPE_TEXTURECUBE_SHADOW\": () => (/* binding */ UNIFORMTYPE_TEXTURECUBE_SHADOW),\n/* harmony export */   \"UNIFORMTYPE_VEC2\": () => (/* binding */ UNIFORMTYPE_VEC2),\n/* harmony export */   \"UNIFORMTYPE_VEC2ARRAY\": () => (/* binding */ UNIFORMTYPE_VEC2ARRAY),\n/* harmony export */   \"UNIFORMTYPE_VEC3\": () => (/* binding */ UNIFORMTYPE_VEC3),\n/* harmony export */   \"UNIFORMTYPE_VEC3ARRAY\": () => (/* binding */ UNIFORMTYPE_VEC3ARRAY),\n/* harmony export */   \"UNIFORMTYPE_VEC4\": () => (/* binding */ UNIFORMTYPE_VEC4),\n/* harmony export */   \"UNIFORMTYPE_VEC4ARRAY\": () => (/* binding */ UNIFORMTYPE_VEC4ARRAY),\n/* harmony export */   \"UNIFORM_BUFFER_DEFAULT_SLOT_NAME\": () => (/* binding */ UNIFORM_BUFFER_DEFAULT_SLOT_NAME),\n/* harmony export */   \"bindGroupNames\": () => (/* binding */ bindGroupNames),\n/* harmony export */   \"isCompressedPixelFormat\": () => (/* binding */ isCompressedPixelFormat),\n/* harmony export */   \"semanticToLocation\": () => (/* binding */ semanticToLocation),\n/* harmony export */   \"typedArrayIndexFormats\": () => (/* binding */ typedArrayIndexFormats),\n/* harmony export */   \"typedArrayIndexFormatsByteSize\": () => (/* binding */ typedArrayIndexFormatsByteSize),\n/* harmony export */   \"typedArrayToType\": () => (/* binding */ typedArrayToType),\n/* harmony export */   \"typedArrayTypes\": () => (/* binding */ typedArrayTypes),\n/* harmony export */   \"typedArrayTypesByteSize\": () => (/* binding */ typedArrayTypesByteSize),\n/* harmony export */   \"uniformTypeToName\": () => (/* binding */ uniformTypeToName),\n/* harmony export */   \"vertexTypesNames\": () => (/* binding */ vertexTypesNames)\n/* harmony export */ });\nconst ADDRESS_REPEAT = 0;\nconst ADDRESS_CLAMP_TO_EDGE = 1;\nconst ADDRESS_MIRRORED_REPEAT = 2;\nconst BLENDMODE_ZERO = 0;\nconst BLENDMODE_ONE = 1;\nconst BLENDMODE_SRC_COLOR = 2;\nconst BLENDMODE_ONE_MINUS_SRC_COLOR = 3;\nconst BLENDMODE_DST_COLOR = 4;\nconst BLENDMODE_ONE_MINUS_DST_COLOR = 5;\nconst BLENDMODE_SRC_ALPHA = 6;\nconst BLENDMODE_SRC_ALPHA_SATURATE = 7;\nconst BLENDMODE_ONE_MINUS_SRC_ALPHA = 8;\nconst BLENDMODE_DST_ALPHA = 9;\nconst BLENDMODE_ONE_MINUS_DST_ALPHA = 10;\nconst BLENDMODE_CONSTANT_COLOR = 11;\nconst BLENDMODE_ONE_MINUS_CONSTANT_COLOR = 12;\nconst BLENDMODE_CONSTANT_ALPHA = 13;\nconst BLENDMODE_ONE_MINUS_CONSTANT_ALPHA = 14;\nconst BLENDEQUATION_ADD = 0;\nconst BLENDEQUATION_SUBTRACT = 1;\nconst BLENDEQUATION_REVERSE_SUBTRACT = 2;\nconst BLENDEQUATION_MIN = 3;\nconst BLENDEQUATION_MAX = 4;\nconst BUFFER_STATIC = 0;\nconst BUFFER_DYNAMIC = 1;\nconst BUFFER_STREAM = 2;\nconst BUFFER_GPUDYNAMIC = 3;\nconst CLEARFLAG_COLOR = 1;\nconst CLEARFLAG_DEPTH = 2;\nconst CLEARFLAG_STENCIL = 4;\nconst CUBEFACE_POSX = 0;\nconst CUBEFACE_NEGX = 1;\nconst CUBEFACE_POSY = 2;\nconst CUBEFACE_NEGY = 3;\nconst CUBEFACE_POSZ = 4;\nconst CUBEFACE_NEGZ = 5;\nconst CULLFACE_NONE = 0;\nconst CULLFACE_BACK = 1;\nconst CULLFACE_FRONT = 2;\nconst CULLFACE_FRONTANDBACK = 3;\nconst FILTER_NEAREST = 0;\nconst FILTER_LINEAR = 1;\nconst FILTER_NEAREST_MIPMAP_NEAREST = 2;\nconst FILTER_NEAREST_MIPMAP_LINEAR = 3;\nconst FILTER_LINEAR_MIPMAP_NEAREST = 4;\nconst FILTER_LINEAR_MIPMAP_LINEAR = 5;\nconst FUNC_NEVER = 0;\nconst FUNC_LESS = 1;\nconst FUNC_EQUAL = 2;\nconst FUNC_LESSEQUAL = 3;\nconst FUNC_GREATER = 4;\nconst FUNC_NOTEQUAL = 5;\nconst FUNC_GREATEREQUAL = 6;\nconst FUNC_ALWAYS = 7;\nconst INDEXFORMAT_UINT8 = 0;\nconst INDEXFORMAT_UINT16 = 1;\nconst INDEXFORMAT_UINT32 = 2;\nconst PIXELFORMAT_A8 = 0;\nconst PIXELFORMAT_L8 = 1;\nconst PIXELFORMAT_LA8 = 2;\nconst PIXELFORMAT_RGB565 = 3;\nconst PIXELFORMAT_RGBA5551 = 4;\nconst PIXELFORMAT_RGBA4 = 5;\nconst PIXELFORMAT_RGB8 = 6;\nconst PIXELFORMAT_RGBA8 = 7;\nconst PIXELFORMAT_DXT1 = 8;\nconst PIXELFORMAT_DXT3 = 9;\nconst PIXELFORMAT_DXT5 = 10;\nconst PIXELFORMAT_RGB16F = 11;\nconst PIXELFORMAT_RGBA16F = 12;\nconst PIXELFORMAT_RGB32F = 13;\nconst PIXELFORMAT_RGBA32F = 14;\nconst PIXELFORMAT_R32F = 15;\nconst PIXELFORMAT_DEPTH = 16;\nconst PIXELFORMAT_DEPTHSTENCIL = 17;\nconst PIXELFORMAT_111110F = 18;\nconst PIXELFORMAT_SRGB = 19;\nconst PIXELFORMAT_SRGBA = 20;\nconst PIXELFORMAT_ETC1 = 21;\nconst PIXELFORMAT_ETC2_RGB = 22;\nconst PIXELFORMAT_ETC2_RGBA = 23;\nconst PIXELFORMAT_PVRTC_2BPP_RGB_1 = 24;\nconst PIXELFORMAT_PVRTC_2BPP_RGBA_1 = 25;\nconst PIXELFORMAT_PVRTC_4BPP_RGB_1 = 26;\nconst PIXELFORMAT_PVRTC_4BPP_RGBA_1 = 27;\nconst PIXELFORMAT_ASTC_4x4 = 28;\nconst PIXELFORMAT_ATC_RGB = 29;\nconst PIXELFORMAT_ATC_RGBA = 30;\nconst PIXELFORMAT_BGRA8 = 31;\nfunction isCompressedPixelFormat(format) {\n  return format >= PIXELFORMAT_DXT1 && format <= PIXELFORMAT_DXT5 || format >= PIXELFORMAT_ETC1 && format <= PIXELFORMAT_ATC_RGBA;\n}\nconst PRIMITIVE_POINTS = 0;\nconst PRIMITIVE_LINES = 1;\nconst PRIMITIVE_LINELOOP = 2;\nconst PRIMITIVE_LINESTRIP = 3;\nconst PRIMITIVE_TRIANGLES = 4;\nconst PRIMITIVE_TRISTRIP = 5;\nconst PRIMITIVE_TRIFAN = 6;\nconst SEMANTIC_POSITION = \"POSITION\";\nconst SEMANTIC_NORMAL = \"NORMAL\";\nconst SEMANTIC_TANGENT = \"TANGENT\";\nconst SEMANTIC_BLENDWEIGHT = \"BLENDWEIGHT\";\nconst SEMANTIC_BLENDINDICES = \"BLENDINDICES\";\nconst SEMANTIC_COLOR = \"COLOR\";\nconst SEMANTIC_TEXCOORD = \"TEXCOORD\";\nconst SEMANTIC_TEXCOORD0 = \"TEXCOORD0\";\nconst SEMANTIC_TEXCOORD1 = \"TEXCOORD1\";\nconst SEMANTIC_TEXCOORD2 = \"TEXCOORD2\";\nconst SEMANTIC_TEXCOORD3 = \"TEXCOORD3\";\nconst SEMANTIC_TEXCOORD4 = \"TEXCOORD4\";\nconst SEMANTIC_TEXCOORD5 = \"TEXCOORD5\";\nconst SEMANTIC_TEXCOORD6 = \"TEXCOORD6\";\nconst SEMANTIC_TEXCOORD7 = \"TEXCOORD7\";\nconst SEMANTIC_ATTR = \"ATTR\";\nconst SEMANTIC_ATTR0 = \"ATTR0\";\nconst SEMANTIC_ATTR1 = \"ATTR1\";\nconst SEMANTIC_ATTR2 = \"ATTR2\";\nconst SEMANTIC_ATTR3 = \"ATTR3\";\nconst SEMANTIC_ATTR4 = \"ATTR4\";\nconst SEMANTIC_ATTR5 = \"ATTR5\";\nconst SEMANTIC_ATTR6 = \"ATTR6\";\nconst SEMANTIC_ATTR7 = \"ATTR7\";\nconst SEMANTIC_ATTR8 = \"ATTR8\";\nconst SEMANTIC_ATTR9 = \"ATTR9\";\nconst SEMANTIC_ATTR10 = \"ATTR10\";\nconst SEMANTIC_ATTR11 = \"ATTR11\";\nconst SEMANTIC_ATTR12 = \"ATTR12\";\nconst SEMANTIC_ATTR13 = \"ATTR13\";\nconst SEMANTIC_ATTR14 = \"ATTR14\";\nconst SEMANTIC_ATTR15 = \"ATTR15\";\nconst SHADERTAG_MATERIAL = 1;\nconst STENCILOP_KEEP = 0;\nconst STENCILOP_ZERO = 1;\nconst STENCILOP_REPLACE = 2;\nconst STENCILOP_INCREMENT = 3;\nconst STENCILOP_INCREMENTWRAP = 4;\nconst STENCILOP_DECREMENT = 5;\nconst STENCILOP_DECREMENTWRAP = 6;\nconst STENCILOP_INVERT = 7;\nconst TEXTURELOCK_READ = 1;\nconst TEXTURELOCK_WRITE = 2;\nconst TEXTURETYPE_DEFAULT = 'default';\nconst TEXTURETYPE_RGBM = 'rgbm';\nconst TEXTURETYPE_RGBE = 'rgbe';\nconst TEXTURETYPE_RGBP = 'rgbp';\nconst TEXTURETYPE_SWIZZLEGGGR = 'swizzleGGGR';\nconst TEXHINT_NONE = 0;\nconst TEXHINT_SHADOWMAP = 1;\nconst TEXHINT_ASSET = 2;\nconst TEXHINT_LIGHTMAP = 3;\nconst TEXTUREDIMENSION_1D = '1d';\nconst TEXTUREDIMENSION_2D = '2d';\nconst TEXTUREDIMENSION_2D_ARRAY = '2d-array';\nconst TEXTUREDIMENSION_CUBE = 'cube';\nconst TEXTUREDIMENSION_CUBE_ARRAY = 'cube-array';\nconst TEXTUREDIMENSION_3D = '3d';\nconst SAMPLETYPE_FLOAT = 'float';\nconst SAMPLETYPE_UNFILTERABLE_FLOAT = 'unfilterable-float';\nconst SAMPLETYPE_DEPTH = 'depth';\nconst TEXTUREPROJECTION_NONE = \"none\";\nconst TEXTUREPROJECTION_CUBE = \"cube\";\nconst TEXTUREPROJECTION_EQUIRECT = \"equirect\";\nconst TEXTUREPROJECTION_OCTAHEDRAL = \"octahedral\";\nconst TYPE_INT8 = 0;\nconst TYPE_UINT8 = 1;\nconst TYPE_INT16 = 2;\nconst TYPE_UINT16 = 3;\nconst TYPE_INT32 = 4;\nconst TYPE_UINT32 = 5;\nconst TYPE_FLOAT32 = 6;\nconst UNIFORMTYPE_BOOL = 0;\nconst UNIFORMTYPE_INT = 1;\nconst UNIFORMTYPE_FLOAT = 2;\nconst UNIFORMTYPE_VEC2 = 3;\nconst UNIFORMTYPE_VEC3 = 4;\nconst UNIFORMTYPE_VEC4 = 5;\nconst UNIFORMTYPE_IVEC2 = 6;\nconst UNIFORMTYPE_IVEC3 = 7;\nconst UNIFORMTYPE_IVEC4 = 8;\nconst UNIFORMTYPE_BVEC2 = 9;\nconst UNIFORMTYPE_BVEC3 = 10;\nconst UNIFORMTYPE_BVEC4 = 11;\nconst UNIFORMTYPE_MAT2 = 12;\nconst UNIFORMTYPE_MAT3 = 13;\nconst UNIFORMTYPE_MAT4 = 14;\nconst UNIFORMTYPE_TEXTURE2D = 15;\nconst UNIFORMTYPE_TEXTURECUBE = 16;\nconst UNIFORMTYPE_FLOATARRAY = 17;\nconst UNIFORMTYPE_TEXTURE2D_SHADOW = 18;\nconst UNIFORMTYPE_TEXTURECUBE_SHADOW = 19;\nconst UNIFORMTYPE_TEXTURE3D = 20;\nconst UNIFORMTYPE_VEC2ARRAY = 21;\nconst UNIFORMTYPE_VEC3ARRAY = 22;\nconst UNIFORMTYPE_VEC4ARRAY = 23;\nconst uniformTypeToName = ['bool', 'int', 'float', 'vec2', 'vec3', 'vec4', 'ivec2', 'ivec3', 'ivec4', 'bec2', 'bec3', 'bec4', 'mat2', 'mat3', 'mat4', 'sampler2D', 'samplerCube', '', 'sampler2DShadow', 'samplerCubeShadow', 'sampler3D', '', '', ''];\nconst DEVICETYPE_WEBGL = 'webgl';\nconst DEVICETYPE_WEBGPU = 'webgpu';\nconst SHADERSTAGE_VERTEX = 1;\nconst SHADERSTAGE_FRAGMENT = 2;\nconst SHADERSTAGE_COMPUTE = 4;\nconst BINDGROUP_VIEW = 0;\nconst BINDGROUP_MESH = 1;\nconst UNIFORM_BUFFER_DEFAULT_SLOT_NAME = 'default';\nconst bindGroupNames = ['view', 'mesh'];\nconst typedArrayTypes = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array];\nconst typedArrayTypesByteSize = [1, 1, 2, 2, 4, 4, 4];\nconst vertexTypesNames = ['INT8', 'UINT8', 'INT16', 'UINT16', 'INT32', 'UINT32', 'FLOAT32'];\nconst typedArrayToType = {\n  \"Int8Array\": TYPE_INT8,\n  \"Uint8Array\": TYPE_UINT8,\n  \"Int16Array\": TYPE_INT16,\n  \"Uint16Array\": TYPE_UINT16,\n  \"Int32Array\": TYPE_INT32,\n  \"Uint32Array\": TYPE_UINT32,\n  \"Float32Array\": TYPE_FLOAT32\n};\nconst typedArrayIndexFormats = [Uint8Array, Uint16Array, Uint32Array];\nconst typedArrayIndexFormatsByteSize = [1, 2, 4];\nconst semanticToLocation = {};\nsemanticToLocation[SEMANTIC_POSITION] = 0;\nsemanticToLocation[SEMANTIC_NORMAL] = 1;\nsemanticToLocation[SEMANTIC_BLENDWEIGHT] = 2;\nsemanticToLocation[SEMANTIC_BLENDINDICES] = 3;\nsemanticToLocation[SEMANTIC_COLOR] = 4;\nsemanticToLocation[SEMANTIC_TEXCOORD0] = 5;\nsemanticToLocation[SEMANTIC_TEXCOORD1] = 6;\nsemanticToLocation[SEMANTIC_TEXCOORD2] = 7;\nsemanticToLocation[SEMANTIC_TEXCOORD3] = 8;\nsemanticToLocation[SEMANTIC_TEXCOORD4] = 9;\nsemanticToLocation[SEMANTIC_TEXCOORD5] = 10;\nsemanticToLocation[SEMANTIC_TEXCOORD6] = 11;\nsemanticToLocation[SEMANTIC_TEXCOORD7] = 12;\nsemanticToLocation[SEMANTIC_TANGENT] = 13;\nsemanticToLocation[SEMANTIC_ATTR0] = 0;\nsemanticToLocation[SEMANTIC_ATTR1] = 1;\nsemanticToLocation[SEMANTIC_ATTR2] = 2;\nsemanticToLocation[SEMANTIC_ATTR3] = 3;\nsemanticToLocation[SEMANTIC_ATTR4] = 4;\nsemanticToLocation[SEMANTIC_ATTR5] = 5;\nsemanticToLocation[SEMANTIC_ATTR6] = 6;\nsemanticToLocation[SEMANTIC_ATTR7] = 7;\nsemanticToLocation[SEMANTIC_ATTR8] = 8;\nsemanticToLocation[SEMANTIC_ATTR9] = 9;\nsemanticToLocation[SEMANTIC_ATTR10] = 10;\nsemanticToLocation[SEMANTIC_ATTR11] = 11;\nsemanticToLocation[SEMANTIC_ATTR12] = 12;\nsemanticToLocation[SEMANTIC_ATTR13] = 13;\nsemanticToLocation[SEMANTIC_ATTR14] = 14;\nsemanticToLocation[SEMANTIC_ATTR15] = 15;\nconst CHUNKAPI_1_51 = '1.51';\nconst CHUNKAPI_1_55 = '1.55';\nconst CHUNKAPI_1_56 = '1.56';\nconst CHUNKAPI_1_57 = '1.57';\nconst CHUNKAPI_1_58 = '1.58';\nconst CHUNKAPI_1_60 = '1.60';\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/device-cache.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/device-cache.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DeviceCache\": () => (/* binding */ DeviceCache)\n/* harmony export */ });\nclass DeviceCache {\n  constructor() {\n    this._cache = new Map();\n  }\n  get(device, onCreate) {\n    if (!this._cache.has(device)) {\n      this._cache.set(device, onCreate());\n      device.on('destroy', () => {\n        this.remove(device);\n      });\n      device.on('devicelost', () => {\n        var _this$_cache$get;\n        (_this$_cache$get = this._cache.get(device)) == null ? void 0 : _this$_cache$get.loseContext == null ? void 0 : _this$_cache$get.loseContext(device);\n      });\n    }\n    return this._cache.get(device);\n  }\n  remove(device) {\n    var _this$_cache$get2;\n    (_this$_cache$get2 = this._cache.get(device)) == null ? void 0 : _this$_cache$get2.destroy(device);\n    this._cache.delete(device);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/device-cache.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/graphics-device-access.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/graphics-device-access.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GraphicsDeviceAccess\": () => (/* binding */ GraphicsDeviceAccess)\n/* harmony export */ });\nclass GraphicsDeviceAccess {\n  static set(graphicsDevice) {\n    GraphicsDeviceAccess._graphicsDevice = graphicsDevice;\n  }\n  static get() {\n    return GraphicsDeviceAccess._graphicsDevice;\n  }\n}\nGraphicsDeviceAccess._graphicsDevice = null;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/graphics-device-access.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/graphics-device.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/graphics-device.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GraphicsDevice\": () => (/* binding */ GraphicsDevice)\n/* harmony export */ });\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _core_platform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/platform.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/platform.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _scope_space_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scope-space.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/scope-space.js\");\n\n\n\n\n\n\n\nconst EVENT_RESIZE = 'resizecanvas';\nclass GraphicsDevice extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor(canvas) {\n    super();\n    this.canvas = void 0;\n    this.deviceType = void 0;\n    this.scope = void 0;\n    this.boneLimit = void 0;\n    this.maxAnisotropy = void 0;\n    this.maxCubeMapSize = void 0;\n    this.maxTextureSize = void 0;\n    this.maxVolumeSize = void 0;\n    this.precision = void 0;\n    this.renderTarget = null;\n    this.insideRenderPass = false;\n    this.supportsInstancing = void 0;\n    this.supportsUniformBuffers = false;\n    this.textureFloatRenderable = void 0;\n    this.textureHalfFloatRenderable = void 0;\n    this.canvas = canvas;\n    this._width = 0;\n    this._height = 0;\n    this._maxPixelRatio = _core_platform_js__WEBPACK_IMPORTED_MODULE_1__.platform.browser ? Math.min(1, window.devicePixelRatio) : 1;\n    this.shaders = [];\n    this.buffers = [];\n    this.textures = [];\n    this.targets = [];\n    this._vram = {\n      tex: 0,\n      vb: 0,\n      ib: 0,\n      ub: 0\n    };\n    this._shaderStats = {\n      vsCompiled: 0,\n      fsCompiled: 0,\n      linked: 0,\n      materialShaders: 0,\n      compileTime: 0\n    };\n    this.initializeContextCaches();\n    this._drawCallsPerFrame = 0;\n    this._shaderSwitchesPerFrame = 0;\n    this._primsPerFrame = [];\n    for (let i = _constants_js__WEBPACK_IMPORTED_MODULE_2__.PRIMITIVE_POINTS; i <= _constants_js__WEBPACK_IMPORTED_MODULE_2__.PRIMITIVE_TRIFAN; i++) {\n      this._primsPerFrame[i] = 0;\n    }\n    this._renderTargetCreationTime = 0;\n    this.scope = new _scope_space_js__WEBPACK_IMPORTED_MODULE_3__.ScopeSpace(\"Device\");\n    this.textureBias = this.scope.resolve(\"textureBias\");\n    this.textureBias.setValue(0.0);\n  }\n  destroy() {\n    this.fire('destroy');\n  }\n  onDestroyShader(shader) {\n    this.fire('destroy:shader', shader);\n    const idx = this.shaders.indexOf(shader);\n    if (idx !== -1) {\n      this.shaders.splice(idx, 1);\n    }\n  }\n  postDestroy() {\n    this.scope = null;\n    this.canvas = null;\n  }\n  toJSON(key) {\n    return undefined;\n  }\n  initializeContextCaches() {\n    this.indexBuffer = null;\n    this.vertexBuffers = [];\n    this.shader = null;\n    this.renderTarget = null;\n  }\n  setRenderTarget(renderTarget) {\n    this.renderTarget = renderTarget;\n  }\n  setIndexBuffer(indexBuffer) {\n    this.indexBuffer = indexBuffer;\n  }\n  setVertexBuffer(vertexBuffer) {\n    if (vertexBuffer) {\n      this.vertexBuffers.push(vertexBuffer);\n    }\n  }\n  getRenderTarget() {\n    return this.renderTarget;\n  }\n  initRenderTarget(target) {\n    if (target.initialized) return;\n    target.init();\n    this.targets.push(target);\n  }\n  _isBrowserInterface(texture) {\n    return this._isImageBrowserInterface(texture) || typeof HTMLCanvasElement !== 'undefined' && texture instanceof HTMLCanvasElement || typeof HTMLVideoElement !== 'undefined' && texture instanceof HTMLVideoElement;\n  }\n  _isImageBrowserInterface(texture) {\n    return typeof ImageBitmap !== 'undefined' && texture instanceof ImageBitmap || typeof HTMLImageElement !== 'undefined' && texture instanceof HTMLImageElement;\n  }\n  resizeCanvas(width, height) {\n    this._width = width;\n    this._height = height;\n    const ratio = Math.min(this._maxPixelRatio, _core_platform_js__WEBPACK_IMPORTED_MODULE_1__.platform.browser ? window.devicePixelRatio : 1);\n    width = Math.floor(width * ratio);\n    height = Math.floor(height * ratio);\n    if (this.canvas.width !== width || this.canvas.height !== height) {\n      this.canvas.width = width;\n      this.canvas.height = height;\n      this.fire(EVENT_RESIZE, width, height);\n    }\n  }\n  setResolution(width, height) {\n    this._width = width;\n    this._height = height;\n    this.canvas.width = width;\n    this.canvas.height = height;\n    this.fire(EVENT_RESIZE, width, height);\n  }\n  updateClientRect() {\n    this.clientRect = this.canvas.getBoundingClientRect();\n  }\n  get width() {\n    return this.canvas.width;\n  }\n  get height() {\n    return this.canvas.height;\n  }\n  set fullscreen(fullscreen) {}\n  get fullscreen() {\n    return false;\n  }\n  set maxPixelRatio(ratio) {\n    this._maxPixelRatio = ratio;\n    this.resizeCanvas(this._width, this._height);\n  }\n  get maxPixelRatio() {\n    return this._maxPixelRatio;\n  }\n  getBoneLimit() {\n    return this.boneLimit;\n  }\n  setBoneLimit(maxBones) {\n    this.boneLimit = maxBones;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/graphics-device.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/index-buffer.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/index-buffer.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IndexBuffer\": () => (/* binding */ IndexBuffer)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n\n\n\nlet id = 0;\nclass IndexBuffer {\n  constructor(graphicsDevice, format, numIndices, usage = _constants_js__WEBPACK_IMPORTED_MODULE_0__.BUFFER_STATIC, initialData) {\n    this.device = graphicsDevice;\n    this.format = format;\n    this.numIndices = numIndices;\n    this.usage = usage;\n    this.id = id++;\n    this.impl = graphicsDevice.createIndexBufferImpl(this);\n    const bytesPerIndex = _constants_js__WEBPACK_IMPORTED_MODULE_0__.typedArrayIndexFormatsByteSize[format];\n    this.bytesPerIndex = bytesPerIndex;\n    this.numBytes = this.numIndices * bytesPerIndex;\n    if (initialData) {\n      this.setData(initialData);\n    } else {\n      this.storage = new ArrayBuffer(this.numBytes);\n    }\n    this.adjustVramSizeTracking(graphicsDevice._vram, this.numBytes);\n    this.device.buffers.push(this);\n  }\n  destroy() {\n    const device = this.device;\n    const idx = device.buffers.indexOf(this);\n    if (idx !== -1) {\n      device.buffers.splice(idx, 1);\n    }\n    if (this.device.indexBuffer === this) {\n      this.device.indexBuffer = null;\n    }\n    if (this.impl.initialized) {\n      this.impl.destroy(device);\n      this.adjustVramSizeTracking(device._vram, -this.storage.byteLength);\n    }\n  }\n  adjustVramSizeTracking(vram, size) {\n    vram.ib += size;\n  }\n  loseContext() {\n    this.impl.loseContext();\n  }\n  getFormat() {\n    return this.format;\n  }\n  getNumIndices() {\n    return this.numIndices;\n  }\n  lock() {\n    return this.storage;\n  }\n  unlock() {\n    this.impl.unlock(this);\n  }\n  setData(data) {\n    if (data.byteLength !== this.numBytes) {\n      return false;\n    }\n    this.storage = data;\n    this.unlock();\n    return true;\n  }\n  _lockTypedArray() {\n    const lock = this.lock();\n    const indices = this.format === _constants_js__WEBPACK_IMPORTED_MODULE_0__.INDEXFORMAT_UINT32 ? new Uint32Array(lock) : this.format === _constants_js__WEBPACK_IMPORTED_MODULE_0__.INDEXFORMAT_UINT16 ? new Uint16Array(lock) : new Uint8Array(lock);\n    return indices;\n  }\n  writeData(data, count) {\n    const indices = this._lockTypedArray();\n    if (data.length > count) {\n      if (ArrayBuffer.isView(data)) {\n        data = data.subarray(0, count);\n        indices.set(data);\n      } else {\n        for (let i = 0; i < count; i++) indices[i] = data[i];\n      }\n    } else {\n      indices.set(data);\n    }\n    this.unlock();\n  }\n  readData(data) {\n    const indices = this._lockTypedArray();\n    const count = this.numIndices;\n    if (ArrayBuffer.isView(data)) {\n      data.set(indices);\n    } else {\n      data.length = 0;\n      for (let i = 0; i < count; i++) data[i] = indices[i];\n    }\n    return count;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/index-buffer.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/render-pass.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/render-pass.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ColorAttachmentOps\": () => (/* binding */ ColorAttachmentOps),\n/* harmony export */   \"DepthStencilAttachmentOps\": () => (/* binding */ DepthStencilAttachmentOps),\n/* harmony export */   \"RenderPass\": () => (/* binding */ RenderPass)\n/* harmony export */ });\n/* harmony import */ var _core_math_color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/math/color.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n\n\nclass ColorAttachmentOps {\n  constructor() {\n    this.clearValue = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0, 1);\n    this.clear = false;\n    this.store = false;\n    this.resolve = true;\n    this.mipmaps = false;\n  }\n}\nclass DepthStencilAttachmentOps {\n  constructor() {\n    this.clearDepthValue = 1;\n    this.clearStencilValue = 0;\n    this.clearDepth = false;\n    this.clearStencil = false;\n    this.storeDepth = false;\n    this.storeStencil = false;\n  }\n}\nclass RenderPass {\n  constructor(graphicsDevice, execute, after = null) {\n    this.name = void 0;\n    this.renderTarget = void 0;\n    this.samples = 0;\n    this.colorOps = void 0;\n    this.depthStencilOps = void 0;\n    this.requiresCubemaps = true;\n    this.fullSizeClearRect = true;\n    this.device = graphicsDevice;\n    this.execute = execute;\n    this.after = after;\n  }\n  init(renderTarget) {\n    var _this$renderTarget, _this$renderTarget$co;\n    this.renderTarget = renderTarget || null;\n    this.colorOps = new ColorAttachmentOps();\n    this.depthStencilOps = new DepthStencilAttachmentOps();\n    this.samples = Math.max(this.renderTarget ? this.renderTarget.samples : this.device.samples, 1);\n    if (this.samples === 1) {\n      this.colorOps.store = true;\n      this.colorOps.resolve = false;\n    }\n    if ((_this$renderTarget = this.renderTarget) != null && (_this$renderTarget$co = _this$renderTarget.colorBuffer) != null && _this$renderTarget$co.mipmaps) {\n      this.colorOps.mipmaps = true;\n    }\n  }\n  setClearColor(color) {\n    this.colorOps.clearValue.copy(color);\n    this.colorOps.clear = true;\n  }\n  setClearDepth(depthValue) {\n    this.depthStencilOps.clearDepthValue = depthValue;\n    this.depthStencilOps.clearDepth = true;\n  }\n  setClearStencil(stencilValue) {\n    this.depthStencilOps.clearStencilValue = stencilValue;\n    this.depthStencilOps.clearStencil = true;\n  }\n  render() {\n    var _this$after;\n    const device = this.device;\n    const realPass = this.renderTarget !== undefined;\n    if (realPass) {\n      device.startPass(this);\n    }\n    this.execute();\n    if (realPass) {\n      device.endPass(this);\n    }\n    (_this$after = this.after) == null ? void 0 : _this$after.call(this);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/render-pass.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/render-target.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/render-target.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RenderTarget\": () => (/* binding */ RenderTarget)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _graphics_device_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graphics-device.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/graphics-device.js\");\n\n\n\n\nconst defaultOptions = {\n  depth: true,\n  face: 0\n};\nlet id = 0;\nclass RenderTarget {\n  constructor(options) {\n    var _this$_colorBuffer, _this$_depthBuffer;\n    this.id = id++;\n    const _arg2 = arguments[1];\n    const _arg3 = arguments[2];\n    if (options instanceof _graphics_device_js__WEBPACK_IMPORTED_MODULE_0__.GraphicsDevice) {\n      this._colorBuffer = _arg2;\n      options = _arg3;\n    } else {\n      this._colorBuffer = options.colorBuffer;\n    }\n    if (this._colorBuffer) {\n      this._colorBuffer._isRenderTarget = true;\n    }\n    options = options !== undefined ? options : defaultOptions;\n    this._depthBuffer = options.depthBuffer;\n    this._face = options.face !== undefined ? options.face : 0;\n    if (this._depthBuffer) {\n      const format = this._depthBuffer._format;\n      if (format === _constants_js__WEBPACK_IMPORTED_MODULE_1__.PIXELFORMAT_DEPTH) {\n        this._depth = true;\n        this._stencil = false;\n      } else if (format === _constants_js__WEBPACK_IMPORTED_MODULE_1__.PIXELFORMAT_DEPTHSTENCIL) {\n        this._depth = true;\n        this._stencil = true;\n      } else {\n        this._depth = false;\n        this._stencil = false;\n      }\n    } else {\n      this._depth = options.depth !== undefined ? options.depth : true;\n      this._stencil = options.stencil !== undefined ? options.stencil : false;\n    }\n    const device = ((_this$_colorBuffer = this._colorBuffer) == null ? void 0 : _this$_colorBuffer.device) || ((_this$_depthBuffer = this._depthBuffer) == null ? void 0 : _this$_depthBuffer.device) || options.graphicsDevice;\n    this._device = device;\n    this._samples = options.samples !== undefined ? Math.min(options.samples, this._device.maxSamples) : 1;\n    this.autoResolve = options.autoResolve !== undefined ? options.autoResolve : true;\n    this.name = options.name;\n    if (!this.name) {\n      var _this$_colorBuffer2;\n      this.name = (_this$_colorBuffer2 = this._colorBuffer) == null ? void 0 : _this$_colorBuffer2.name;\n    }\n    if (!this.name) {\n      var _this$_depthBuffer2;\n      this.name = (_this$_depthBuffer2 = this._depthBuffer) == null ? void 0 : _this$_depthBuffer2.name;\n    }\n    if (!this.name) {\n      this.name = \"Untitled\";\n    }\n    this.flipY = !!options.flipY;\n    this.impl = device.createRenderTargetImpl(this);\n  }\n  destroy() {\n    const device = this._device;\n    if (device) {\n      const idx = device.targets.indexOf(this);\n      if (idx !== -1) {\n        device.targets.splice(idx, 1);\n      }\n      if (device.renderTarget === this) {\n        device.setRenderTarget(null);\n      }\n      this.destroyFrameBuffers();\n    }\n  }\n  destroyFrameBuffers() {\n    const device = this._device;\n    if (device) {\n      this.impl.destroy(device);\n    }\n  }\n  destroyTextureBuffers() {\n    if (this._depthBuffer) {\n      this._depthBuffer.destroy();\n      this._depthBuffer = null;\n    }\n    if (this._colorBuffer) {\n      this._colorBuffer.destroy();\n      this._colorBuffer = null;\n    }\n  }\n  init() {\n    this.impl.init(this._device, this);\n  }\n  get initialized() {\n    return this.impl.initialized;\n  }\n  loseContext() {\n    this.impl.loseContext();\n  }\n  resolve(color = true, depth = !!this._depthBuffer) {\n    if (this._device && this._samples > 1) {\n      this.impl.resolve(this._device, this, color, depth);\n    }\n  }\n  copy(source, color, depth) {\n    if (!this._device) {\n      if (source._device) {\n        this._device = source._device;\n      } else {\n        return false;\n      }\n    }\n    const success = this._device.copyRenderTarget(source, this, color, depth);\n    return success;\n  }\n  get samples() {\n    return this._samples;\n  }\n  get depth() {\n    return this._depth;\n  }\n  get stencil() {\n    return this._stencil;\n  }\n  get colorBuffer() {\n    return this._colorBuffer;\n  }\n  get depthBuffer() {\n    return this._depthBuffer;\n  }\n  get face() {\n    return this._face;\n  }\n  get width() {\n    var _this$_colorBuffer3, _this$_depthBuffer3;\n    return ((_this$_colorBuffer3 = this._colorBuffer) == null ? void 0 : _this$_colorBuffer3.width) || ((_this$_depthBuffer3 = this._depthBuffer) == null ? void 0 : _this$_depthBuffer3.width) || this._device.width;\n  }\n  get height() {\n    var _this$_colorBuffer4, _this$_depthBuffer4;\n    return ((_this$_colorBuffer4 = this._colorBuffer) == null ? void 0 : _this$_colorBuffer4.height) || ((_this$_depthBuffer4 = this._depthBuffer) == null ? void 0 : _this$_depthBuffer4.height) || this._device.height;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/render-target.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/scope-id.js":
/*!************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/scope-id.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScopeId\": () => (/* binding */ ScopeId)\n/* harmony export */ });\n/* harmony import */ var _versioned_object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./versioned-object.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/versioned-object.js\");\n\n\nclass ScopeId {\n  constructor(name) {\n    this.name = name;\n    this.value = null;\n    this.versionObject = new _versioned_object_js__WEBPACK_IMPORTED_MODULE_0__.VersionedObject();\n  }\n  toJSON(key) {\n    return undefined;\n  }\n  setValue(value) {\n    this.value = value;\n    this.versionObject.increment();\n  }\n  getValue() {\n    return this.value;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/scope-id.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/scope-space.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/scope-space.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScopeSpace\": () => (/* binding */ ScopeSpace)\n/* harmony export */ });\n/* harmony import */ var _scope_id_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scope-id.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/scope-id.js\");\n\n\nclass ScopeSpace {\n  constructor(name) {\n    this.name = name;\n    this.variables = new Map();\n  }\n  resolve(name) {\n    if (!this.variables.has(name)) {\n      this.variables.set(name, new _scope_id_js__WEBPACK_IMPORTED_MODULE_0__.ScopeId(name));\n    }\n    return this.variables.get(name);\n  }\n  removeValue(value) {\n    for (const uniformName in this.variables) {\n      const uniform = this.variables[uniformName];\n      if (uniform.value === value) {\n        uniform.value = null;\n      }\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/scope-space.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-chunks/frag/gles2.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-chunks/frag/gles2.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ gles2PS)\n/* harmony export */ });\nvar gles2PS = `\n#define texture2DBias texture2D\n\n// pass / accept shadow map as a function parameter, on webgl this is simply passsed as is and this is\n// needed for ebGPU\n#define SHADOWMAP_PASS(name) name\n#define SHADOWMAP_ACCEPT(name) sampler2D name\n\n#ifndef SUPPORTS_TEXLOD\n\n// fallback for lod instructions\n#define texture2DLodEXT texture2D\n#define texture2DProjLodEXT textureProj\n#define textureCubeLodEXT textureCube\n#define textureShadow texture2D\n\n#else\n\n#define textureShadow(res, uv) texture2DGradEXT(res, uv, vec2(1, 1), vec2(1, 1))\n\n#endif\n\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-chunks/frag/gles2.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-chunks/frag/gles3.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-chunks/frag/gles3.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ gles3PS)\n/* harmony export */ });\nvar gles3PS = `\n#define varying in\nout highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define texture2D texture\n#define texture2DBias texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\n\n// sample shadows using textureGrad to remove derivates in the dynamic loops (which are used by\n// clustered lighting) - as DirectX shader compiler tries to unroll the loops and takes long time\n// to compile the shader. Using textureLod would be even better, but WebGl does not translate it to\n// lod instruction for DirectX correctly and uses SampleCmp instead of SampleCmpLevelZero or similar.\n#define textureShadow(res, uv) textureGrad(res, uv, vec2(1, 1), vec2(1, 1))\n\n// pass / accept shadow map as a function parameter, on webgl this is simply passsed as is and this is\n// needed for ebGPU\n#define SHADOWMAP_PASS(name) name\n#define SHADOWMAP_ACCEPT(name) sampler2DShadow name\n\n#define GL2\n#define SUPPORTS_TEXLOD\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-chunks/frag/gles3.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-chunks/frag/shared.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-chunks/frag/shared.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ sharedFS)\n/* harmony export */ });\nvar sharedFS = `\n\n// convert clip space position into texture coordinates to sample scene grab textures\nvec2 getGrabScreenPos(vec4 clipPos) {\n    vec2 uv = (clipPos.xy / clipPos.w) * 0.5 + 0.5;\n\n    #ifdef WEBGPU\n        uv.y = 1.0 - uv.y;\n    #endif\n\n    return uv;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-chunks/frag/shared.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-chunks/frag/webgpu.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-chunks/frag/webgpu.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ webgpuPS)\n/* harmony export */ });\nvar webgpuPS = `\n\n// texelFetch support and others\n#extension GL_EXT_samplerless_texture_functions : require\n\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n\n#define texture2D(res, uv) texture(sampler2D(res, res ## _sampler), uv)\n#define texture2DBias(res, uv, bias) texture(sampler2D(res, res ## _sampler), uv, bias)\n#define texture2DLodEXT(res, uv, lod) textureLod(sampler2D(res, res ## _sampler), uv, lod)\n#define textureCube(res, uv) texture(samplerCube(res, res ## _sampler), uv)\n#define textureShadow(res, uv) texture(sampler2DShadow(res, res ## _sampler), uv)\n\n// TODO: implement other texture sampling macros\n// #define texture2DProj textureProj\n// #define texture2DProjLodEXT textureProjLod\n// #define textureCubeLodEXT textureLod\n// #define texture2DGradEXT textureGrad\n// #define texture2DProjGradEXT textureProjGrad\n// #define textureCubeGradEXT textureGrad\n\n// pass / accept shadow map as a function parameter, passes both the texture as well as sampler\n// as the combined sampler can be only created at a point of use\n#define SHADOWMAP_PASS(name) name, name ## _sampler\n#define SHADOWMAP_ACCEPT(name) texture2D name, sampler name ## _sampler\n\n#define GL2\n#define WEBGPU\n#define SUPPORTS_TEXLOD\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-chunks/frag/webgpu.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-chunks/vert/gles3.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-chunks/vert/gles3.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ gles3VS)\n/* harmony export */ });\nvar gles3VS = `\n#define attribute in\n#define varying out\n#define texture2D texture\n#define GL2\n#define VERTEXSHADER\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-chunks/vert/gles3.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-chunks/vert/webgpu.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-chunks/vert/webgpu.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ webgpuVS)\n/* harmony export */ });\nvar webgpuVS = `\n#define texture2D(res, uv) texture(sampler2D(res, res ## _sampler), uv)\n\n#define GL2\n#define WEBGPU\n#define VERTEXSHADER\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-chunks/vert/webgpu.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-processor-options.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-processor-options.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ShaderProcessorOptions\": () => (/* binding */ ShaderProcessorOptions)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n\n\nclass ShaderProcessorOptions {\n  constructor(viewUniformFormat, viewBindGroupFormat) {\n    this.uniformFormats = [];\n    this.bindGroupFormats = [];\n    this.uniformFormats[_constants_js__WEBPACK_IMPORTED_MODULE_0__.BINDGROUP_VIEW] = viewUniformFormat;\n    this.bindGroupFormats[_constants_js__WEBPACK_IMPORTED_MODULE_0__.BINDGROUP_VIEW] = viewBindGroupFormat;\n  }\n  hasUniform(name) {\n    for (let i = 0; i < this.uniformFormats.length; i++) {\n      const uniformFormat = this.uniformFormats[i];\n      if (uniformFormat.get(name)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  hasTexture(name) {\n    for (let i = 0; i < this.bindGroupFormats.length; i++) {\n      const groupFormat = this.bindGroupFormats[i];\n      if (groupFormat.getTexture(name)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-processor-options.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-utils.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-utils.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ShaderUtils\": () => (/* binding */ ShaderUtils)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _shader_chunks_frag_gles2_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shader-chunks/frag/gles2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-chunks/frag/gles2.js\");\n/* harmony import */ var _shader_chunks_frag_gles3_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shader-chunks/frag/gles3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-chunks/frag/gles3.js\");\n/* harmony import */ var _shader_chunks_vert_gles3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shader-chunks/vert/gles3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-chunks/vert/gles3.js\");\n/* harmony import */ var _shader_chunks_frag_webgpu_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shader-chunks/frag/webgpu.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-chunks/frag/webgpu.js\");\n/* harmony import */ var _shader_chunks_vert_webgpu_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shader-chunks/vert/webgpu.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-chunks/vert/webgpu.js\");\n/* harmony import */ var _shader_chunks_frag_shared_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./shader-chunks/frag/shared.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-chunks/frag/shared.js\");\n\n\n\n\n\n\n\n\n\nconst _attrib2Semantic = {\n  vertex_position: _constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_POSITION,\n  vertex_normal: _constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_NORMAL,\n  vertex_tangent: _constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TANGENT,\n  vertex_texCoord0: _constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD0,\n  vertex_texCoord1: _constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD1,\n  vertex_texCoord2: _constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD2,\n  vertex_texCoord3: _constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD3,\n  vertex_texCoord4: _constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD4,\n  vertex_texCoord5: _constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD5,\n  vertex_texCoord6: _constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD6,\n  vertex_texCoord7: _constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD7,\n  vertex_color: _constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_COLOR,\n  vertex_boneIndices: _constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_BLENDINDICES,\n  vertex_boneWeights: _constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_BLENDWEIGHT\n};\nclass ShaderUtils {\n  static createDefinition(device, options) {\n    var _options$name, _options$attributes;\n    const getDefines = (gpu, gl2, gl1, isVertex) => {\n      return device.deviceType === _constants_js__WEBPACK_IMPORTED_MODULE_0__.DEVICETYPE_WEBGPU ? gpu : device.webgl2 ? gl2 : ShaderUtils.gl1Extensions(device, options) + gl1;\n    };\n    const name = (_options$name = options.name) != null ? _options$name : 'Untitled';\n    const vertDefines = options.vertexDefines || getDefines(_shader_chunks_vert_webgpu_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"], _shader_chunks_vert_gles3_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"], '');\n    const vertCode = ShaderUtils.versionCode(device) + vertDefines + ShaderUtils.getShaderNameCode(name) + options.vertexCode;\n    const fragDefines = options.fragmentDefines || getDefines(_shader_chunks_frag_webgpu_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"], _shader_chunks_frag_gles3_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"], _shader_chunks_frag_gles2_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]);\n    const fragCode = (options.fragmentPreamble || '') + ShaderUtils.versionCode(device) + ShaderUtils.precisionCode(device) + '\\n' + fragDefines + _shader_chunks_frag_shared_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"] + ShaderUtils.getShaderNameCode(name) + (options.fragmentCode || ShaderUtils.dummyFragmentCode());\n    const attribs = (_options$attributes = options.attributes) != null ? _options$attributes : ShaderUtils.collectAttributes(options.vertexCode);\n    return {\n      name: name,\n      attributes: attribs,\n      vshader: vertCode,\n      fshader: fragCode,\n      useTransformFeedback: options.useTransformFeedback\n    };\n  }\n  static getShaderNameCode(name) {\n    return `#define SHADER_NAME ${name}\\n`;\n  }\n  static gl1Extensions(device, options, isVertex) {\n    let code;\n    if (isVertex) {\n      code = options.vertexExtensions ? `${options.vertexExtensions}\\n` : '';\n    } else {\n      code = options.fragmentExtensions ? `${options.fragmentExtensions}\\n` : '';\n      if (device.extStandardDerivatives) {\n        code += \"#extension GL_OES_standard_derivatives : enable\\n\";\n      }\n      if (device.extTextureLod) {\n        code += \"#extension GL_EXT_shader_texture_lod : enable\\n\";\n        code += \"#define SUPPORTS_TEXLOD\\n\";\n      }\n    }\n    return code;\n  }\n  static dummyFragmentCode() {\n    return \"void main(void) {gl_FragColor = vec4(0.0);}\";\n  }\n  static versionCode(device) {\n    if (device.deviceType === _constants_js__WEBPACK_IMPORTED_MODULE_0__.DEVICETYPE_WEBGPU) {\n      return '#version 450\\n';\n    }\n    return device.webgl2 ? \"#version 300 es\\n\" : \"\";\n  }\n  static precisionCode(device, forcePrecision) {\n    let code = '';\n    if (forcePrecision && forcePrecision !== 'highp' && forcePrecision !== 'mediump' && forcePrecision !== 'lowp') {\n      forcePrecision = null;\n    }\n    if (forcePrecision) {\n      if (forcePrecision === 'highp' && device.maxPrecision !== 'highp') {\n        forcePrecision = 'mediump';\n      }\n      if (forcePrecision === 'mediump' && device.maxPrecision === 'lowp') {\n        forcePrecision = 'lowp';\n      }\n    }\n    const precision = forcePrecision ? forcePrecision : device.precision;\n    if (device.deviceType === _constants_js__WEBPACK_IMPORTED_MODULE_0__.DEVICETYPE_WEBGL) {\n      code = `precision ${precision} float;\\n`;\n      if (device.webgl2) {\n        code += `precision ${precision} sampler2DShadow;\\n`;\n      }\n    } else {\n      code = `precision ${precision} float;\\nprecision ${precision} int;\\n`;\n    }\n    return code;\n  }\n  static collectAttributes(vsCode) {\n    const attribs = {};\n    let attrs = 0;\n    let found = vsCode.indexOf(\"attribute\");\n    while (found >= 0) {\n      if (found > 0 && vsCode[found - 1] === \"/\") break;\n      const endOfLine = vsCode.indexOf(';', found);\n      const startOfAttribName = vsCode.lastIndexOf(' ', endOfLine);\n      const attribName = vsCode.substring(startOfAttribName + 1, endOfLine);\n      const semantic = _attrib2Semantic[attribName];\n      if (semantic !== undefined) {\n        attribs[attribName] = semantic;\n      } else {\n        attribs[attribName] = \"ATTR\" + attrs;\n        attrs++;\n      }\n      found = vsCode.indexOf(\"attribute\", found + 1);\n    }\n    return attribs;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-utils.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Shader\": () => (/* binding */ Shader)\n/* harmony export */ });\n/* harmony import */ var _core_preprocessor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/preprocessor.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/preprocessor.js\");\n\n\n\nlet id = 0;\nclass Shader {\n  constructor(graphicsDevice, definition) {\n    this.meshUniformBufferFormat = void 0;\n    this.meshBindGroupFormat = void 0;\n    this.id = id++;\n    this.device = graphicsDevice;\n    this.definition = definition;\n    this.name = definition.name || 'Untitled';\n    definition.vshader = _core_preprocessor_js__WEBPACK_IMPORTED_MODULE_0__.Preprocessor.run(definition.vshader);\n    definition.fshader = _core_preprocessor_js__WEBPACK_IMPORTED_MODULE_0__.Preprocessor.run(definition.fshader);\n    this.init();\n    this.impl = graphicsDevice.createShaderImpl(this);\n  }\n  init() {\n    this.ready = false;\n    this.failed = false;\n  }\n  get label() {\n    return `Shader Id ${this.id} ${this.name}`;\n  }\n  destroy() {\n    this.device.onDestroyShader(this);\n    this.impl.destroy(this);\n  }\n  loseContext() {\n    this.init();\n    this.impl.loseContext();\n  }\n  restoreContext() {\n    this.impl.restoreContext(this.device, this);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/simple-post-effect.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/simple-post-effect.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawQuadWithShader\": () => (/* binding */ drawQuadWithShader),\n/* harmony export */   \"drawTexture\": () => (/* binding */ drawTexture)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _vertex_buffer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vertex-buffer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/vertex-buffer.js\");\n/* harmony import */ var _vertex_format_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vertex-format.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/vertex-format.js\");\n/* harmony import */ var _device_cache_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./device-cache.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/device-cache.js\");\n\n\n\n\n\nconst _postEffectQuadDraw = {\n  type: _constants_js__WEBPACK_IMPORTED_MODULE_0__.PRIMITIVE_TRISTRIP,\n  base: 0,\n  count: 4,\n  indexed: false\n};\nconst postEffectDeviceCache = new _device_cache_js__WEBPACK_IMPORTED_MODULE_1__.DeviceCache();\nfunction getPostEffectQuadVB(device) {\n  return postEffectDeviceCache.get(device, () => {\n    const vertexFormat = new _vertex_format_js__WEBPACK_IMPORTED_MODULE_2__.VertexFormat(device, [{\n      semantic: _constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_POSITION,\n      components: 2,\n      type: _constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_FLOAT32\n    }]);\n    const positions = new Float32Array(8);\n    positions.set([-1, -1, 1, -1, -1, 1, 1, 1]);\n    return new _vertex_buffer_js__WEBPACK_IMPORTED_MODULE_3__.VertexBuffer(device, vertexFormat, 4, _constants_js__WEBPACK_IMPORTED_MODULE_0__.BUFFER_STATIC, positions);\n  });\n}\nfunction drawQuadWithShader(device, target, shader, rect, scissorRect, useBlend = false) {\n  const oldRt = device.renderTarget;\n  device.setRenderTarget(target);\n  device.updateBegin();\n  let x, y, w, h;\n  let sx, sy, sw, sh;\n  if (!rect) {\n    w = target ? target.width : device.width;\n    h = target ? target.height : device.height;\n    x = 0;\n    y = 0;\n  } else {\n    x = rect.x;\n    y = rect.y;\n    w = rect.z;\n    h = rect.w;\n  }\n  if (!scissorRect) {\n    sx = x;\n    sy = y;\n    sw = w;\n    sh = h;\n  } else {\n    sx = scissorRect.x;\n    sy = scissorRect.y;\n    sw = scissorRect.z;\n    sh = scissorRect.w;\n  }\n  const oldVx = device.vx;\n  const oldVy = device.vy;\n  const oldVw = device.vw;\n  const oldVh = device.vh;\n  device.setViewport(x, y, w, h);\n  const oldSx = device.sx;\n  const oldSy = device.sy;\n  const oldSw = device.sw;\n  const oldSh = device.sh;\n  device.setScissor(sx, sy, sw, sh);\n  const oldDepthTest = device.getDepthTest();\n  const oldDepthWrite = device.getDepthWrite();\n  const oldCullMode = device.getCullMode();\n  const oldWR = device.writeRed;\n  const oldWG = device.writeGreen;\n  const oldWB = device.writeBlue;\n  const oldWA = device.writeAlpha;\n  device.setDepthTest(false);\n  device.setDepthWrite(false);\n  device.setCullMode(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CULLFACE_NONE);\n  device.setColorWrite(true, true, true, true);\n  if (!useBlend) device.setBlending(false);\n  device.setVertexBuffer(getPostEffectQuadVB(device), 0);\n  device.setShader(shader);\n  device.draw(_postEffectQuadDraw);\n  device.setDepthTest(oldDepthTest);\n  device.setDepthWrite(oldDepthWrite);\n  device.setCullMode(oldCullMode);\n  device.setColorWrite(oldWR, oldWG, oldWB, oldWA);\n  device.updateEnd();\n  device.setRenderTarget(oldRt);\n  device.updateBegin();\n  device.setViewport(oldVx, oldVy, oldVw, oldVh);\n  device.setScissor(oldSx, oldSy, oldSw, oldSh);\n}\nfunction drawTexture(device, texture, target, shader, rect, scissorRect, useBlend = false) {\n  shader = shader || device.getCopyShader();\n  device.constantTexSource.setValue(texture);\n  drawQuadWithShader(device, target, shader, rect, scissorRect, useBlend);\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/simple-post-effect.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Texture\": () => (/* binding */ Texture)\n/* harmony export */ });\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n\n\n\n\nlet _pixelSizeTable = null;\nlet _blockSizeTable = null;\nlet id = 0;\nclass Texture {\n  constructor(graphicsDevice, options) {\n    this.id = id++;\n    this.device = graphicsDevice;\n    this.name = null;\n    this._width = 4;\n    this._height = 4;\n    this._depth = 1;\n    this._format = _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA8;\n    this.type = _constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTURETYPE_DEFAULT;\n    this.projection = _constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTUREPROJECTION_NONE;\n    this._cubemap = false;\n    this._volume = false;\n    this.fixCubemapSeams = false;\n    this._flipY = false;\n    this._premultiplyAlpha = false;\n    this._isRenderTarget = false;\n    this._mipmaps = true;\n    this._minFilter = _constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_LINEAR_MIPMAP_LINEAR;\n    this._magFilter = _constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_LINEAR;\n    this._anisotropy = 1;\n    this._addressU = _constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_REPEAT;\n    this._addressV = _constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_REPEAT;\n    this._addressW = _constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_REPEAT;\n    this._compareOnRead = false;\n    this._compareFunc = _constants_js__WEBPACK_IMPORTED_MODULE_0__.FUNC_LESS;\n    if (options !== undefined) {\n      if (options.name !== undefined) {\n        this.name = options.name;\n      }\n      this._width = options.width !== undefined ? options.width : this._width;\n      this._height = options.height !== undefined ? options.height : this._height;\n      this._format = options.format !== undefined ? options.format : this._format;\n      if (options.hasOwnProperty('type')) {\n        this.type = options.type;\n      } else if (options.hasOwnProperty('rgbm')) {\n        this.type = options.rgbm ? _constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTURETYPE_RGBM : _constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTURETYPE_DEFAULT;\n      } else if (options.hasOwnProperty('swizzleGGGR')) {\n        this.type = options.swizzleGGGR ? _constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTURETYPE_SWIZZLEGGGR : _constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTURETYPE_DEFAULT;\n      }\n      if (options.mipmaps !== undefined) {\n        this._mipmaps = options.mipmaps;\n      } else {\n        this._mipmaps = options.autoMipmap !== undefined ? options.autoMipmap : this._mipmaps;\n      }\n      this._levels = options.levels;\n      this._cubemap = options.cubemap !== undefined ? options.cubemap : this._cubemap;\n      this.fixCubemapSeams = options.fixCubemapSeams !== undefined ? options.fixCubemapSeams : this.fixCubemapSeams;\n      if (this._cubemap) {\n        this.projection = _constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTUREPROJECTION_CUBE;\n      } else if (options.projection && options.projection !== _constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTUREPROJECTION_CUBE) {\n        this.projection = options.projection;\n      }\n      this._minFilter = options.minFilter !== undefined ? options.minFilter : this._minFilter;\n      this._magFilter = options.magFilter !== undefined ? options.magFilter : this._magFilter;\n      this._anisotropy = options.anisotropy !== undefined ? options.anisotropy : this._anisotropy;\n      this._addressU = options.addressU !== undefined ? options.addressU : this._addressU;\n      this._addressV = options.addressV !== undefined ? options.addressV : this._addressV;\n      this._compareOnRead = options.compareOnRead !== undefined ? options.compareOnRead : this._compareOnRead;\n      this._compareFunc = options._compareFunc !== undefined ? options._compareFunc : this._compareFunc;\n      this._flipY = options.flipY !== undefined ? options.flipY : this._flipY;\n      this._premultiplyAlpha = options.premultiplyAlpha !== undefined ? options.premultiplyAlpha : this._premultiplyAlpha;\n      if (graphicsDevice.webgl2) {\n        this._depth = options.depth !== undefined ? options.depth : this._depth;\n        this._volume = options.volume !== undefined ? options.volume : this._volume;\n        this._addressW = options.addressW !== undefined ? options.addressW : this._addressW;\n      }\n    }\n    this._compressed = (0,_constants_js__WEBPACK_IMPORTED_MODULE_0__.isCompressedPixelFormat)(this._format);\n    this._invalid = false;\n    this._lockedLevel = -1;\n    if (!this._levels) {\n      this._levels = this._cubemap ? [[null, null, null, null, null, null]] : [null];\n    }\n    this.dirtyAll();\n    this._gpuSize = 0;\n    this.impl = graphicsDevice.createTextureImpl(this);\n    graphicsDevice.textures.push(this);\n  }\n  destroy() {\n    if (this.device) {\n      const device = this.device;\n      const idx = device.textures.indexOf(this);\n      if (idx !== -1) {\n        device.textures.splice(idx, 1);\n      }\n      device.scope.removeValue(this);\n      this.impl.destroy(device);\n      this.adjustVramSizeTracking(device._vram, -this._gpuSize);\n      this._levels = null;\n      this.device = null;\n    }\n  }\n  loseContext() {\n    this.impl.loseContext();\n    this.dirtyAll();\n  }\n  adjustVramSizeTracking(vram, size) {\n    vram.tex += size;\n  }\n  set minFilter(v) {\n    if (this._minFilter !== v) {\n      this._minFilter = v;\n      this._parameterFlags |= 1;\n    }\n  }\n  get minFilter() {\n    return this._minFilter;\n  }\n  set magFilter(v) {\n    if (this._magFilter !== v) {\n      this._magFilter = v;\n      this._parameterFlags |= 2;\n    }\n  }\n  get magFilter() {\n    return this._magFilter;\n  }\n  set addressU(v) {\n    if (this._addressU !== v) {\n      this._addressU = v;\n      this._parameterFlags |= 4;\n    }\n  }\n  get addressU() {\n    return this._addressU;\n  }\n  set addressV(v) {\n    if (this._addressV !== v) {\n      this._addressV = v;\n      this._parameterFlags |= 8;\n    }\n  }\n  get addressV() {\n    return this._addressV;\n  }\n  set addressW(addressW) {\n    if (!this.device.webgl2) return;\n    if (!this._volume) {\n      return;\n    }\n    if (addressW !== this._addressW) {\n      this._addressW = addressW;\n      this._parameterFlags |= 16;\n    }\n  }\n  get addressW() {\n    return this._addressW;\n  }\n  set compareOnRead(v) {\n    if (this._compareOnRead !== v) {\n      this._compareOnRead = v;\n      this._parameterFlags |= 32;\n    }\n  }\n  get compareOnRead() {\n    return this._compareOnRead;\n  }\n  set compareFunc(v) {\n    if (this._compareFunc !== v) {\n      this._compareFunc = v;\n      this._parameterFlags |= 64;\n    }\n  }\n  get compareFunc() {\n    return this._compareFunc;\n  }\n  set anisotropy(v) {\n    if (this._anisotropy !== v) {\n      this._anisotropy = v;\n      this._parameterFlags |= 128;\n    }\n  }\n  get anisotropy() {\n    return this._anisotropy;\n  }\n  set autoMipmap(v) {\n    this._mipmaps = v;\n  }\n  get autoMipmap() {\n    return this._mipmaps;\n  }\n  set mipmaps(v) {\n    if (this._mipmaps !== v) {\n      this._mipmaps = v;\n      if (v) this._needsMipmapsUpload = true;\n    }\n  }\n  get mipmaps() {\n    return this._mipmaps;\n  }\n  get width() {\n    return this._width;\n  }\n  get height() {\n    return this._height;\n  }\n  get depth() {\n    return this._depth;\n  }\n  get format() {\n    return this._format;\n  }\n  get cubemap() {\n    return this._cubemap;\n  }\n  get gpuSize() {\n    const mips = this.pot && this._mipmaps && !(this._compressed && this._levels.length === 1);\n    return Texture.calcGpuSize(this._width, this._height, this._depth, this._format, mips, this._cubemap);\n  }\n  get volume() {\n    return this._volume;\n  }\n  set flipY(flipY) {\n    if (this._flipY !== flipY) {\n      this._flipY = flipY;\n      this._needsUpload = true;\n    }\n  }\n  get flipY() {\n    return this._flipY;\n  }\n  set premultiplyAlpha(premultiplyAlpha) {\n    if (this._premultiplyAlpha !== premultiplyAlpha) {\n      this._premultiplyAlpha = premultiplyAlpha;\n      this._needsUpload = true;\n    }\n  }\n  get premultiplyAlpha() {\n    return this._premultiplyAlpha;\n  }\n  get pot() {\n    return _core_math_math_js__WEBPACK_IMPORTED_MODULE_1__.math.powerOfTwo(this._width) && _core_math_math_js__WEBPACK_IMPORTED_MODULE_1__.math.powerOfTwo(this._height);\n  }\n  get encoding() {\n    switch (this.type) {\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTURETYPE_RGBM:\n        return 'rgbm';\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTURETYPE_RGBE:\n        return 'rgbe';\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTURETYPE_RGBP:\n        return 'rgbp';\n      default:\n        return this.format === _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGB16F || this.format === _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGB32F || this.format === _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA16F || this.format === _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA32F ? 'linear' : 'srgb';\n    }\n  }\n  static calcGpuSize(width, height, depth, format, mipmaps, cubemap) {\n    if (!_pixelSizeTable) {\n      _pixelSizeTable = [];\n      _pixelSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_A8] = 1;\n      _pixelSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_L8] = 1;\n      _pixelSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_LA8] = 2;\n      _pixelSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGB565] = 2;\n      _pixelSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA5551] = 2;\n      _pixelSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA4] = 2;\n      _pixelSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGB8] = 4;\n      _pixelSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA8] = 4;\n      _pixelSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGB16F] = 8;\n      _pixelSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA16F] = 8;\n      _pixelSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGB32F] = 16;\n      _pixelSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA32F] = 16;\n      _pixelSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_R32F] = 4;\n      _pixelSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_DEPTH] = 4;\n      _pixelSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_DEPTHSTENCIL] = 4;\n      _pixelSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_111110F] = 4;\n      _pixelSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_SRGB] = 4;\n      _pixelSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_SRGBA] = 4;\n    }\n    if (!_blockSizeTable) {\n      _blockSizeTable = [];\n      _blockSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_ETC1] = 8;\n      _blockSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_ETC2_RGB] = 8;\n      _blockSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_PVRTC_2BPP_RGB_1] = 8;\n      _blockSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_PVRTC_2BPP_RGBA_1] = 8;\n      _blockSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_PVRTC_4BPP_RGB_1] = 8;\n      _blockSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_PVRTC_4BPP_RGBA_1] = 8;\n      _blockSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_DXT1] = 8;\n      _blockSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_ATC_RGB] = 8;\n      _blockSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_ETC2_RGBA] = 16;\n      _blockSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_DXT3] = 16;\n      _blockSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_DXT5] = 16;\n      _blockSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_ASTC_4x4] = 16;\n      _blockSizeTable[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_ATC_RGBA] = 16;\n    }\n    const pixelSize = _pixelSizeTable.hasOwnProperty(format) ? _pixelSizeTable[format] : 0;\n    const blockSize = _blockSizeTable.hasOwnProperty(format) ? _blockSizeTable[format] : 0;\n    let result = 0;\n    while (1) {\n      if (pixelSize > 0) {\n        result += width * height * depth * pixelSize;\n      } else {\n        let blockWidth = Math.floor((width + 3) / 4);\n        const blockHeight = Math.floor((height + 3) / 4);\n        const blockDepth = Math.floor((depth + 3) / 4);\n        if (format === _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_PVRTC_2BPP_RGB_1 || format === _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_PVRTC_2BPP_RGBA_1) {\n          blockWidth = Math.max(Math.floor(blockWidth / 2), 1);\n        }\n        result += blockWidth * blockHeight * blockDepth * blockSize;\n      }\n      if (!mipmaps || width === 1 && height === 1 && depth === 1) {\n        break;\n      }\n      width = Math.max(Math.floor(width / 2), 1);\n      height = Math.max(Math.floor(height / 2), 1);\n      depth = Math.max(Math.floor(depth / 2), 1);\n    }\n    return result * (cubemap ? 6 : 1);\n  }\n  dirtyAll() {\n    this._levelsUpdated = this._cubemap ? [[true, true, true, true, true, true]] : [true];\n    this._needsUpload = true;\n    this._needsMipmapsUpload = this._mipmaps;\n    this._mipmapsUploaded = false;\n    this._parameterFlags = 255;\n  }\n  lock(options = {}) {\n    if (options.level === undefined) {\n      options.level = 0;\n    }\n    if (options.face === undefined) {\n      options.face = 0;\n    }\n    if (options.mode === undefined) {\n      options.mode = _constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTURELOCK_WRITE;\n    }\n    this._lockedLevel = options.level;\n    if (this._levels[options.level] === null) {\n      switch (this._format) {\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_A8:\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_L8:\n          this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth);\n          break;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_LA8:\n          this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 2);\n          break;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGB565:\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA5551:\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA4:\n          this._levels[options.level] = new Uint16Array(this._width * this._height * this._depth);\n          break;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGB8:\n          this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 3);\n          break;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA8:\n          this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 4);\n          break;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_DXT1:\n          this._levels[options.level] = new Uint8Array(Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4) * 8 * this._depth);\n          break;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_DXT3:\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_DXT5:\n          this._levels[options.level] = new Uint8Array(Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4) * 16 * this._depth);\n          break;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGB16F:\n          this._levels[options.level] = new Uint16Array(this._width * this._height * this._depth * 3);\n          break;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGB32F:\n          this._levels[options.level] = new Float32Array(this._width * this._height * this._depth * 3);\n          break;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA16F:\n          this._levels[options.level] = new Uint16Array(this._width * this._height * this._depth * 4);\n          break;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA32F:\n          this._levels[options.level] = new Float32Array(this._width * this._height * this._depth * 4);\n          break;\n      }\n    }\n    return this._levels[options.level];\n  }\n  setSource(source, mipLevel = 0) {\n    let invalid = false;\n    let width, height;\n    if (this._cubemap) {\n      if (source[0]) {\n        width = source[0].width || 0;\n        height = source[0].height || 0;\n        for (let i = 0; i < 6; i++) {\n          const face = source[i];\n          if (!face || face.width !== width || face.height !== height || !this.device._isBrowserInterface(face)) {\n            invalid = true;\n            break;\n          }\n        }\n      } else {\n        invalid = true;\n      }\n      if (!invalid) {\n        for (let i = 0; i < 6; i++) {\n          if (this._levels[mipLevel][i] !== source[i]) this._levelsUpdated[mipLevel][i] = true;\n        }\n      }\n    } else {\n      if (!this.device._isBrowserInterface(source)) invalid = true;\n      if (!invalid) {\n        if (source !== this._levels[mipLevel]) this._levelsUpdated[mipLevel] = true;\n        width = source.width;\n        height = source.height;\n      }\n    }\n    if (invalid) {\n      this._width = 4;\n      this._height = 4;\n      if (this._cubemap) {\n        for (let i = 0; i < 6; i++) {\n          this._levels[mipLevel][i] = null;\n          this._levelsUpdated[mipLevel][i] = true;\n        }\n      } else {\n        this._levels[mipLevel] = null;\n        this._levelsUpdated[mipLevel] = true;\n      }\n    } else {\n      if (mipLevel === 0) {\n        this._width = width;\n        this._height = height;\n      }\n      this._levels[mipLevel] = source;\n    }\n    if (this._invalid !== invalid || !invalid) {\n      this._invalid = invalid;\n      this.upload();\n    }\n  }\n  getSource(mipLevel = 0) {\n    return this._levels[mipLevel];\n  }\n  unlock() {\n    if (this._lockedLevel === -1) ;\n    this.upload();\n    this._lockedLevel = -1;\n  }\n  upload() {\n    var _this$impl$uploadImme, _this$impl;\n    this._needsUpload = true;\n    this._needsMipmapsUpload = this._mipmaps;\n    (_this$impl$uploadImme = (_this$impl = this.impl).uploadImmediate) == null ? void 0 : _this$impl$uploadImme.call(_this$impl, this.device, this);\n  }\n  getDds() {\n    let fsize = 128;\n    let idx = 0;\n    while (this._levels[idx]) {\n      if (!this.cubemap) {\n        const mipSize = this._levels[idx].length;\n        if (!mipSize) {\n          return undefined;\n        }\n        fsize += mipSize;\n      } else {\n        for (let face = 0; face < 6; face++) {\n          if (!this._levels[idx][face]) {\n            return undefined;\n          }\n          const mipSize = this._levels[idx][face].length;\n          if (!mipSize) {\n            return undefined;\n          }\n          fsize += mipSize;\n        }\n      }\n      fsize += this._levels[idx].length;\n      idx++;\n    }\n    const buff = new ArrayBuffer(fsize);\n    const header = new Uint32Array(buff, 0, 128 / 4);\n    const DDS_MAGIC = 542327876;\n    const DDS_HEADER_SIZE = 124;\n    const DDS_FLAGS_REQUIRED = 0x01 | 0x02 | 0x04 | 0x1000 | 0x80000;\n    const DDS_FLAGS_MIPMAP = 0x20000;\n    const DDS_PIXELFORMAT_SIZE = 32;\n    const DDS_PIXELFLAGS_RGBA8 = 0x01 | 0x40;\n    const DDS_CAPS_REQUIRED = 0x1000;\n    const DDS_CAPS_MIPMAP = 0x400000;\n    const DDS_CAPS_COMPLEX = 0x8;\n    const DDS_CAPS2_CUBEMAP = 0x200 | 0x400 | 0x800 | 0x1000 | 0x2000 | 0x4000 | 0x8000;\n    let flags = DDS_FLAGS_REQUIRED;\n    if (this._levels.length > 1) flags |= DDS_FLAGS_MIPMAP;\n    let caps = DDS_CAPS_REQUIRED;\n    if (this._levels.length > 1) caps |= DDS_CAPS_MIPMAP;\n    if (this._levels.length > 1 || this.cubemap) caps |= DDS_CAPS_COMPLEX;\n    const caps2 = this.cubemap ? DDS_CAPS2_CUBEMAP : 0;\n    header[0] = DDS_MAGIC;\n    header[1] = DDS_HEADER_SIZE;\n    header[2] = flags;\n    header[3] = this.height;\n    header[4] = this.width;\n    header[5] = this.width * this.height * 4;\n    header[6] = 0;\n    header[7] = this._levels.length;\n    for (let i = 0; i < 11; i++) {\n      header[8 + i] = 0;\n    }\n    header[19] = DDS_PIXELFORMAT_SIZE;\n    header[20] = DDS_PIXELFLAGS_RGBA8;\n    header[21] = 0;\n    header[22] = 32;\n    header[23] = 0x00FF0000;\n    header[24] = 0x0000FF00;\n    header[25] = 0x000000FF;\n    header[26] = 0xFF000000;\n    header[27] = caps;\n    header[28] = caps2;\n    header[29] = 0;\n    header[30] = 0;\n    header[31] = 0;\n    let offset = 128;\n    if (!this.cubemap) {\n      for (let i = 0; i < this._levels.length; i++) {\n        const level = this._levels[i];\n        const mip = new Uint8Array(buff, offset, level.length);\n        for (let j = 0; j < level.length; j++) {\n          mip[j] = level[j];\n        }\n        offset += level.length;\n      }\n    } else {\n      for (let face = 0; face < 6; face++) {\n        for (let i = 0; i < this._levels.length; i++) {\n          const level = this._levels[i][face];\n          const mip = new Uint8Array(buff, offset, level.length);\n          for (let j = 0; j < level.length; j++) {\n            mip[j] = level[j];\n          }\n          offset += level.length;\n        }\n      }\n    }\n    return buff;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/uniform-buffer-format.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/uniform-buffer-format.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UniformBufferFormat\": () => (/* binding */ UniformBufferFormat),\n/* harmony export */   \"UniformFormat\": () => (/* binding */ UniformFormat)\n/* harmony export */ });\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n\n\n\n\nconst uniformTypeToNumElements = [];\nuniformTypeToNumElements[_constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_FLOAT] = 1;\nuniformTypeToNumElements[_constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_VEC2] = 2;\nuniformTypeToNumElements[_constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_VEC3] = 3;\nuniformTypeToNumElements[_constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_VEC4] = 4;\nuniformTypeToNumElements[_constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_INT] = 1;\nuniformTypeToNumElements[_constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_IVEC2] = 2;\nuniformTypeToNumElements[_constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_IVEC3] = 3;\nuniformTypeToNumElements[_constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_IVEC4] = 4;\nuniformTypeToNumElements[_constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_BOOL] = 1;\nuniformTypeToNumElements[_constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_BVEC2] = 2;\nuniformTypeToNumElements[_constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_BVEC3] = 3;\nuniformTypeToNumElements[_constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_BVEC4] = 4;\nuniformTypeToNumElements[_constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_MAT2] = 8;\nuniformTypeToNumElements[_constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_MAT3] = 12;\nuniformTypeToNumElements[_constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_MAT4] = 16;\nclass UniformFormat {\n  constructor(name, type, count = 1) {\n    this.name = void 0;\n    this.type = void 0;\n    this.byteSize = void 0;\n    this.offset = void 0;\n    this.scopeId = void 0;\n    this.count = void 0;\n    this.shortName = name;\n    this.name = count > 1 ? `${name}[0]` : name;\n    this.type = type;\n    this.updateType = type;\n    if (count > 1) {\n      switch (type) {\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_FLOAT:\n          this.updateType = _constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_FLOATARRAY;\n          break;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_VEC2:\n          this.updateType = _constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_VEC2ARRAY;\n          break;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_VEC3:\n          this.updateType = _constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_VEC3ARRAY;\n          break;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_VEC4:\n          this.updateType = _constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_VEC4ARRAY;\n          break;\n      }\n    }\n    this.count = count;\n    let elementSize = uniformTypeToNumElements[type];\n    if (count > 1) elementSize = _core_math_math_js__WEBPACK_IMPORTED_MODULE_1__.math.roundUp(elementSize, 4);\n    this.byteSize = count * elementSize * 4;\n  }\n  calculateOffset(offset) {\n    let alignment = this.byteSize <= 8 ? this.byteSize : 16;\n    if (this.count > 1) alignment = 16;\n    offset = _core_math_math_js__WEBPACK_IMPORTED_MODULE_1__.math.roundUp(offset, alignment);\n    this.offset = offset / 4;\n  }\n}\nclass UniformBufferFormat {\n  constructor(graphicsDevice, uniforms) {\n    this.byteSize = 0;\n    this.map = new Map();\n    this.scope = graphicsDevice.scope;\n    this.uniforms = uniforms;\n    let offset = 0;\n    for (let i = 0; i < uniforms.length; i++) {\n      const uniform = uniforms[i];\n      uniform.calculateOffset(offset);\n      offset = uniform.offset * 4 + uniform.byteSize;\n      uniform.scopeId = this.scope.resolve(uniform.name);\n      this.map.set(uniform.name, uniform);\n    }\n    this.byteSize = _core_math_math_js__WEBPACK_IMPORTED_MODULE_1__.math.roundUp(offset, 16);\n  }\n  get(name) {\n    return this.map.get(name);\n  }\n  getShaderDeclaration(bindGroup, bindIndex) {\n    const name = _constants_js__WEBPACK_IMPORTED_MODULE_0__.bindGroupNames[bindGroup];\n    let code = `layout(set = ${bindGroup}, binding = ${bindIndex}, std140) uniform ub_${name} {\\n`;\n    this.uniforms.forEach(uniform => {\n      const typeString = _constants_js__WEBPACK_IMPORTED_MODULE_0__.uniformTypeToName[uniform.type];\n      code += `    ${typeString} ${uniform.shortName}${uniform.count !== 1 ? `[${uniform.count}]` : ''};\\n`;\n    });\n    return code + '};\\n';\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/uniform-buffer-format.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/uniform-buffer.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/uniform-buffer.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UniformBuffer\": () => (/* binding */ UniformBuffer)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n\n\n\nconst _updateFunctions = [];\n_updateFunctions[_constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_FLOAT] = function (uniformBuffer, value, offset) {\n  const dst = uniformBuffer.storageFloat32;\n  dst[offset] = value;\n};\n_updateFunctions[_constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_VEC2] = (uniformBuffer, value, offset) => {\n  const dst = uniformBuffer.storageFloat32;\n  dst[offset] = value[0];\n  dst[offset + 1] = value[1];\n};\n_updateFunctions[_constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_VEC3] = (uniformBuffer, value, offset) => {\n  const dst = uniformBuffer.storageFloat32;\n  dst[offset] = value[0];\n  dst[offset + 1] = value[1];\n  dst[offset + 2] = value[2];\n};\n_updateFunctions[_constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_VEC4] = (uniformBuffer, value, offset) => {\n  const dst = uniformBuffer.storageFloat32;\n  dst[offset] = value[0];\n  dst[offset + 1] = value[1];\n  dst[offset + 2] = value[2];\n  dst[offset + 3] = value[3];\n};\n_updateFunctions[_constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_INT] = function (uniformBuffer, value, offset) {\n  const dst = uniformBuffer.storageInt32;\n  dst[offset] = value;\n};\n_updateFunctions[_constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_IVEC2] = function (uniformBuffer, value, offset) {\n  const dst = uniformBuffer.storageInt32;\n  dst[offset] = value[0];\n  dst[offset + 1] = value[1];\n};\n_updateFunctions[_constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_IVEC3] = function (uniformBuffer, value, offset) {\n  const dst = uniformBuffer.storageInt32;\n  dst[offset] = value[0];\n  dst[offset + 1] = value[1];\n  dst[offset + 2] = value[2];\n};\n_updateFunctions[_constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_IVEC4] = function (uniformBuffer, value, offset) {\n  const dst = uniformBuffer.storageInt32;\n  dst[offset] = value[0];\n  dst[offset + 1] = value[1];\n  dst[offset + 2] = value[2];\n  dst[offset + 3] = value[3];\n};\n_updateFunctions[_constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_MAT2] = (uniformBuffer, value, offset) => {\n  const dst = uniformBuffer.storageFloat32;\n  dst[offset] = value[0];\n  dst[offset + 1] = value[1];\n  dst[offset + 4] = value[2];\n  dst[offset + 5] = value[3];\n  dst[offset + 8] = value[4];\n  dst[offset + 9] = value[5];\n};\n_updateFunctions[_constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_MAT3] = (uniformBuffer, value, offset) => {\n  const dst = uniformBuffer.storageFloat32;\n  dst[offset] = value[0];\n  dst[offset + 1] = value[1];\n  dst[offset + 2] = value[2];\n  dst[offset + 4] = value[3];\n  dst[offset + 5] = value[4];\n  dst[offset + 6] = value[5];\n  dst[offset + 8] = value[6];\n  dst[offset + 9] = value[7];\n  dst[offset + 10] = value[8];\n};\n_updateFunctions[_constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_FLOATARRAY] = function (uniformBuffer, value, offset, count) {\n  const dst = uniformBuffer.storageFloat32;\n  for (let i = 0; i < count; i++) {\n    dst[offset + i * 4] = value[i];\n  }\n};\n_updateFunctions[_constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_VEC2ARRAY] = (uniformBuffer, value, offset, count) => {\n  const dst = uniformBuffer.storageFloat32;\n  for (let i = 0; i < count; i++) {\n    dst[offset + i * 4] = value[i * 2];\n    dst[offset + i * 4 + 1] = value[i * 2 + 1];\n  }\n};\n_updateFunctions[_constants_js__WEBPACK_IMPORTED_MODULE_0__.UNIFORMTYPE_VEC3ARRAY] = (uniformBuffer, value, offset, count) => {\n  const dst = uniformBuffer.storageFloat32;\n  for (let i = 0; i < count; i++) {\n    dst[offset + i * 4] = value[i * 3];\n    dst[offset + i * 4 + 1] = value[i * 3 + 1];\n    dst[offset + i * 4 + 2] = value[i * 3 + 2];\n  }\n};\nclass UniformBuffer {\n  constructor(graphicsDevice, format) {\n    this.device = graphicsDevice;\n    this.format = format;\n    this.impl = graphicsDevice.createUniformBufferImpl(this);\n    this.storage = new ArrayBuffer(format.byteSize);\n    this.storageFloat32 = new Float32Array(this.storage);\n    this.storageInt32 = new Int32Array(this.storage);\n    graphicsDevice._vram.ub += this.format.byteSize;\n  }\n  destroy() {\n    const device = this.device;\n    this.impl.destroy(device);\n    device._vram.ub -= this.format.byteSize;\n  }\n  loseContext() {\n    this.impl.loseContext();\n  }\n  setUniform(uniformFormat) {\n    const offset = uniformFormat.offset;\n    const value = uniformFormat.scopeId.value;\n    if (value !== null && value !== undefined) {\n      const updateFunction = _updateFunctions[uniformFormat.updateType];\n      if (updateFunction) {\n        updateFunction(this, value, offset, uniformFormat.count);\n      } else {\n        this.storageFloat32.set(value, offset);\n      }\n    }\n  }\n  set(name) {\n    const uniformFormat = this.format.map.get(name);\n    if (uniformFormat) {\n      this.setUniform(uniformFormat);\n    }\n  }\n  update() {\n    const uniforms = this.format.uniforms;\n    for (let i = 0; i < uniforms.length; i++) {\n      this.setUniform(uniforms[i]);\n    }\n    this.impl.unlock(this);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/uniform-buffer.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/version.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/version.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Version\": () => (/* binding */ Version)\n/* harmony export */ });\nclass Version {\n  constructor() {\n    this.globalId = 0;\n    this.revision = 0;\n  }\n  equals(other) {\n    return this.globalId === other.globalId && this.revision === other.revision;\n  }\n  copy(other) {\n    this.globalId = other.globalId;\n    this.revision = other.revision;\n  }\n  reset() {\n    this.globalId = 0;\n    this.revision = 0;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/version.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/versioned-object.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/versioned-object.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VersionedObject\": () => (/* binding */ VersionedObject)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/version.js\");\n\n\nlet idCounter = 0;\nclass VersionedObject {\n  constructor() {\n    idCounter++;\n    this.version = new _version_js__WEBPACK_IMPORTED_MODULE_0__.Version();\n    this.version.globalId = idCounter;\n  }\n  increment() {\n    this.version.revision++;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/versioned-object.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/vertex-buffer.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/vertex-buffer.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VertexBuffer\": () => (/* binding */ VertexBuffer)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n\n\n\nlet id = 0;\nclass VertexBuffer {\n  constructor(graphicsDevice, format, numVertices, usage = _constants_js__WEBPACK_IMPORTED_MODULE_0__.BUFFER_STATIC, initialData) {\n    this.device = graphicsDevice;\n    this.format = format;\n    this.numVertices = numVertices;\n    this.usage = usage;\n    this.id = id++;\n    this.impl = graphicsDevice.createVertexBufferImpl(this, format);\n    this.numBytes = format.verticesByteSize ? format.verticesByteSize : format.size * numVertices;\n    this.adjustVramSizeTracking(graphicsDevice._vram, this.numBytes);\n    if (initialData) {\n      this.setData(initialData);\n    } else {\n      this.storage = new ArrayBuffer(this.numBytes);\n    }\n    this.device.buffers.push(this);\n  }\n  destroy() {\n    const device = this.device;\n    const idx = device.buffers.indexOf(this);\n    if (idx !== -1) {\n      device.buffers.splice(idx, 1);\n    }\n    if (this.impl.initialized) {\n      this.impl.destroy(device);\n      this.adjustVramSizeTracking(device._vram, -this.storage.byteLength);\n    }\n  }\n  adjustVramSizeTracking(vram, size) {\n    vram.vb += size;\n  }\n  loseContext() {\n    this.impl.loseContext();\n  }\n  getFormat() {\n    return this.format;\n  }\n  getUsage() {\n    return this.usage;\n  }\n  getNumVertices() {\n    return this.numVertices;\n  }\n  lock() {\n    return this.storage;\n  }\n  unlock() {\n    this.impl.unlock(this);\n  }\n  setData(data) {\n    if (data.byteLength !== this.numBytes) {\n      return false;\n    }\n    this.storage = data;\n    this.unlock();\n    return true;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/vertex-buffer.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/vertex-format.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/vertex-format.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VertexFormat\": () => (/* binding */ VertexFormat)\n/* harmony export */ });\n/* harmony import */ var _core_hash_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/hash.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/hash.js\");\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n\n\n\n\n\nclass VertexFormat {\n  constructor(graphicsDevice, description, vertexCount) {\n    this.device = graphicsDevice;\n    this._elements = [];\n    this.hasUv0 = false;\n    this.hasUv1 = false;\n    this.hasColor = false;\n    this.hasTangents = false;\n    this.verticesByteSize = 0;\n    this.vertexCount = vertexCount;\n    this.interleaved = vertexCount === undefined;\n    this.instancing = false;\n    this.size = description.reduce((total, desc) => {\n      return total + Math.ceil(desc.components * _constants_js__WEBPACK_IMPORTED_MODULE_0__.typedArrayTypesByteSize[desc.type] / 4) * 4;\n    }, 0);\n    let offset = 0,\n      elementSize;\n    for (let i = 0, len = description.length; i < len; i++) {\n      const elementDesc = description[i];\n      elementSize = elementDesc.components * _constants_js__WEBPACK_IMPORTED_MODULE_0__.typedArrayTypesByteSize[elementDesc.type];\n      if (vertexCount) {\n        offset = _core_math_math_js__WEBPACK_IMPORTED_MODULE_1__.math.roundUp(offset, elementSize);\n      }\n      const element = {\n        name: elementDesc.semantic,\n        offset: vertexCount ? offset : elementDesc.hasOwnProperty('offset') ? elementDesc.offset : offset,\n        stride: vertexCount ? elementSize : elementDesc.hasOwnProperty('stride') ? elementDesc.stride : this.size,\n        dataType: elementDesc.type,\n        numComponents: elementDesc.components,\n        normalize: elementDesc.normalize === undefined ? false : elementDesc.normalize,\n        size: elementSize\n      };\n      this._elements.push(element);\n      if (vertexCount) {\n        offset += elementSize * vertexCount;\n      } else {\n        offset += Math.ceil(elementSize / 4) * 4;\n      }\n      if (elementDesc.semantic === _constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD0) {\n        this.hasUv0 = true;\n      } else if (elementDesc.semantic === _constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD1) {\n        this.hasUv1 = true;\n      } else if (elementDesc.semantic === _constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_COLOR) {\n        this.hasColor = true;\n      } else if (elementDesc.semantic === _constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TANGENT) {\n        this.hasTangents = true;\n      }\n    }\n    if (vertexCount) {\n      this.verticesByteSize = offset;\n    }\n    this._evaluateHash();\n  }\n  get elements() {\n    return this._elements;\n  }\n  static getDefaultInstancingFormat(graphicsDevice) {\n    if (!VertexFormat._defaultInstancingFormat) {\n      VertexFormat._defaultInstancingFormat = new VertexFormat(graphicsDevice, [{\n        semantic: _constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR12,\n        components: 4,\n        type: _constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_FLOAT32\n      }, {\n        semantic: _constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR13,\n        components: 4,\n        type: _constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_FLOAT32\n      }, {\n        semantic: _constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR14,\n        components: 4,\n        type: _constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_FLOAT32\n      }, {\n        semantic: _constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR15,\n        components: 4,\n        type: _constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_FLOAT32\n      }]);\n    }\n    return VertexFormat._defaultInstancingFormat;\n  }\n  update() {\n    this._evaluateHash();\n  }\n  _evaluateHash() {\n    let stringElementBatch;\n    const stringElementsBatch = [];\n    let stringElementRender;\n    const stringElementsRender = [];\n    const len = this._elements.length;\n    for (let i = 0; i < len; i++) {\n      const element = this._elements[i];\n      stringElementBatch = element.name;\n      stringElementBatch += element.dataType;\n      stringElementBatch += element.numComponents;\n      stringElementBatch += element.normalize;\n      stringElementsBatch.push(stringElementBatch);\n      stringElementRender = stringElementBatch;\n      stringElementRender += element.offset;\n      stringElementRender += element.stride;\n      stringElementRender += element.size;\n      stringElementsRender.push(stringElementRender);\n    }\n    stringElementsBatch.sort();\n    this.batchingHash = (0,_core_hash_js__WEBPACK_IMPORTED_MODULE_2__.hashCode)(stringElementsBatch.join());\n    this.renderingingHashString = stringElementsRender.join('_');\n    this.renderingingHash = (0,_core_hash_js__WEBPACK_IMPORTED_MODULE_2__.hashCode)(this.renderingingHashString);\n  }\n}\nVertexFormat._defaultInstancingFormat = null;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/vertex-format.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/vertex-iterator.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/vertex-iterator.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VertexIterator\": () => (/* binding */ VertexIterator),\n/* harmony export */   \"VertexIteratorAccessor\": () => (/* binding */ VertexIteratorAccessor)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n\n\n\nfunction set1(a) {\n  this.array[this.index] = a;\n}\nfunction set2(a, b) {\n  this.array[this.index] = a;\n  this.array[this.index + 1] = b;\n}\nfunction set3(a, b, c) {\n  this.array[this.index] = a;\n  this.array[this.index + 1] = b;\n  this.array[this.index + 2] = c;\n}\nfunction set4(a, b, c, d) {\n  this.array[this.index] = a;\n  this.array[this.index + 1] = b;\n  this.array[this.index + 2] = c;\n  this.array[this.index + 3] = d;\n}\nfunction arraySet1(index, inputArray, inputIndex) {\n  this.array[index] = inputArray[inputIndex];\n}\nfunction arraySet2(index, inputArray, inputIndex) {\n  this.array[index] = inputArray[inputIndex];\n  this.array[index + 1] = inputArray[inputIndex + 1];\n}\nfunction arraySet3(index, inputArray, inputIndex) {\n  this.array[index] = inputArray[inputIndex];\n  this.array[index + 1] = inputArray[inputIndex + 1];\n  this.array[index + 2] = inputArray[inputIndex + 2];\n}\nfunction arraySet4(index, inputArray, inputIndex) {\n  this.array[index] = inputArray[inputIndex];\n  this.array[index + 1] = inputArray[inputIndex + 1];\n  this.array[index + 2] = inputArray[inputIndex + 2];\n  this.array[index + 3] = inputArray[inputIndex + 3];\n}\nfunction arrayGet1(offset, outputArray, outputIndex) {\n  outputArray[outputIndex] = this.array[offset];\n}\nfunction arrayGet2(offset, outputArray, outputIndex) {\n  outputArray[outputIndex] = this.array[offset];\n  outputArray[outputIndex + 1] = this.array[offset + 1];\n}\nfunction arrayGet3(offset, outputArray, outputIndex) {\n  outputArray[outputIndex] = this.array[offset];\n  outputArray[outputIndex + 1] = this.array[offset + 1];\n  outputArray[outputIndex + 2] = this.array[offset + 2];\n}\nfunction arrayGet4(offset, outputArray, outputIndex) {\n  outputArray[outputIndex] = this.array[offset];\n  outputArray[outputIndex + 1] = this.array[offset + 1];\n  outputArray[outputIndex + 2] = this.array[offset + 2];\n  outputArray[outputIndex + 3] = this.array[offset + 3];\n}\nclass VertexIteratorAccessor {\n  constructor(buffer, vertexElement, vertexFormat) {\n    this.index = 0;\n    this.numComponents = vertexElement.numComponents;\n    if (vertexFormat.interleaved) {\n      this.array = new _constants_js__WEBPACK_IMPORTED_MODULE_0__.typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset);\n    } else {\n      this.array = new _constants_js__WEBPACK_IMPORTED_MODULE_0__.typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset, vertexFormat.vertexCount * vertexElement.numComponents);\n    }\n    this.stride = vertexElement.stride / this.array.constructor.BYTES_PER_ELEMENT;\n    switch (vertexElement.numComponents) {\n      case 1:\n        this.set = set1;\n        this.getToArray = arrayGet1;\n        this.setFromArray = arraySet1;\n        break;\n      case 2:\n        this.set = set2;\n        this.getToArray = arrayGet2;\n        this.setFromArray = arraySet2;\n        break;\n      case 3:\n        this.set = set3;\n        this.getToArray = arrayGet3;\n        this.setFromArray = arraySet3;\n        break;\n      case 4:\n        this.set = set4;\n        this.getToArray = arrayGet4;\n        this.setFromArray = arraySet4;\n        break;\n    }\n  }\n  get(offset) {\n    return this.array[this.index + offset];\n  }\n  set(a, b, c, d) {}\n  getToArray(offset, outputArray, outputIndex) {}\n  setFromArray(index, inputArray, inputIndex) {}\n}\nclass VertexIterator {\n  constructor(vertexBuffer) {\n    this.vertexBuffer = vertexBuffer;\n    this.vertexFormatSize = vertexBuffer.getFormat().size;\n    this.buffer = this.vertexBuffer.lock();\n    this.accessors = [];\n    this.element = {};\n    const vertexFormat = this.vertexBuffer.getFormat();\n    for (let i = 0; i < vertexFormat.elements.length; i++) {\n      const vertexElement = vertexFormat.elements[i];\n      this.accessors[i] = new VertexIteratorAccessor(this.buffer, vertexElement, vertexFormat);\n      this.element[vertexElement.name] = this.accessors[i];\n    }\n  }\n  next(count = 1) {\n    let i = 0;\n    const accessors = this.accessors;\n    const numAccessors = this.accessors.length;\n    while (i < numAccessors) {\n      const accessor = accessors[i++];\n      accessor.index += count * accessor.stride;\n    }\n  }\n  end() {\n    this.vertexBuffer.unlock();\n  }\n  writeData(semantic, data, numVertices) {\n    const element = this.element[semantic];\n    if (element) {\n      if (numVertices > this.vertexBuffer.numVertices) {\n        numVertices = this.vertexBuffer.numVertices;\n      }\n      const numComponents = element.numComponents;\n      if (this.vertexBuffer.getFormat().interleaved) {\n        let index = 0;\n        for (let i = 0; i < numVertices; i++) {\n          element.setFromArray(index, data, i * numComponents);\n          index += element.stride;\n        }\n      } else {\n        if (data.length > numVertices * numComponents) {\n          const copyCount = numVertices * numComponents;\n          if (ArrayBuffer.isView(data)) {\n            data = data.subarray(0, copyCount);\n            element.array.set(data);\n          } else {\n            for (let i = 0; i < copyCount; i++) element.array[i] = data[i];\n          }\n        } else {\n          element.array.set(data);\n        }\n      }\n    }\n  }\n  readData(semantic, data) {\n    const element = this.element[semantic];\n    let count = 0;\n    if (element) {\n      count = this.vertexBuffer.numVertices;\n      let i;\n      const numComponents = element.numComponents;\n      if (this.vertexBuffer.getFormat().interleaved) {\n        if (Array.isArray(data)) data.length = 0;\n        element.index = 0;\n        let offset = 0;\n        for (i = 0; i < count; i++) {\n          element.getToArray(offset, data, i * numComponents);\n          offset += element.stride;\n        }\n      } else {\n        if (ArrayBuffer.isView(data)) {\n          data.set(element.array);\n        } else {\n          data.length = 0;\n          const copyCount = count * numComponents;\n          for (i = 0; i < copyCount; i++) data[i] = element.array[i];\n        }\n      }\n    }\n    return count;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/vertex-iterator.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-buffer.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-buffer.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WebglBuffer\": () => (/* binding */ WebglBuffer)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n\n\nclass WebglBuffer {\n  constructor() {\n    this.bufferId = null;\n  }\n  destroy(device) {\n    if (this.bufferId) {\n      device.gl.deleteBuffer(this.bufferId);\n      this.bufferId = null;\n    }\n  }\n  get initialized() {\n    return !!this.bufferId;\n  }\n  loseContext() {\n    this.bufferId = null;\n  }\n  unlock(device, usage, target, storage) {\n    const gl = device.gl;\n    if (!this.bufferId) {\n      this.bufferId = gl.createBuffer();\n    }\n    let glUsage;\n    switch (usage) {\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.BUFFER_STATIC:\n        glUsage = gl.STATIC_DRAW;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.BUFFER_DYNAMIC:\n        glUsage = gl.DYNAMIC_DRAW;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.BUFFER_STREAM:\n        glUsage = gl.STREAM_DRAW;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.BUFFER_GPUDYNAMIC:\n        if (device.webgl2) {\n          glUsage = gl.DYNAMIC_COPY;\n        } else {\n          glUsage = gl.STATIC_DRAW;\n        }\n        break;\n    }\n    gl.bindBuffer(target, this.bufferId);\n    gl.bufferData(target, storage, glUsage);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-buffer.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-graphics-device.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-graphics-device.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WebglGraphicsDevice\": () => (/* binding */ WebglGraphicsDevice)\n/* harmony export */ });\n/* harmony import */ var _polyfill_OESVertexArrayObject_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../polyfill/OESVertexArrayObject.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/polyfill/OESVertexArrayObject.js\");\n/* harmony import */ var _core_platform_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../core/platform.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/platform.js\");\n/* harmony import */ var _core_math_color_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../../core/math/color.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _graphics_device_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../graphics-device.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/graphics-device.js\");\n/* harmony import */ var _simple_post_effect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../simple-post-effect.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/simple-post-effect.js\");\n/* harmony import */ var _render_target_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../render-target.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/render-target.js\");\n/* harmony import */ var _texture_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js\");\n/* harmony import */ var _webgl_vertex_buffer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./webgl-vertex-buffer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-vertex-buffer.js\");\n/* harmony import */ var _webgl_index_buffer_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./webgl-index-buffer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-index-buffer.js\");\n/* harmony import */ var _webgl_shader_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./webgl-shader.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-shader.js\");\n/* harmony import */ var _webgl_texture_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./webgl-texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-texture.js\");\n/* harmony import */ var _webgl_render_target_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./webgl-render-target.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-render-target.js\");\n/* harmony import */ var _shader_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shader-utils.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-utils.js\");\n/* harmony import */ var _shader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shader.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst invalidateAttachments = [];\nconst _fullScreenQuadVS = `\nattribute vec2 vertex_position;\nvarying vec2 vUv0;\nvoid main(void)\n{\n    gl_Position = vec4(vertex_position, 0.5, 1.0);\n    vUv0 = vertex_position.xy*0.5+0.5;\n}\n`;\nconst _precisionTest1PS = `\nvoid main(void) { \n    gl_FragColor = vec4(2147483648.0);\n}\n`;\nconst _precisionTest2PS = `\nuniform sampler2D source;\nvec4 packFloat(float depth) {\n    const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n    const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n    vec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n    res -= res.xxyz * bit_mask;\n    return res;\n}\nvoid main(void) {\n    float c = texture2D(source, vec2(0.0)).r;\n    float diff = abs(c - 2147483648.0) / 2147483648.0;\n    gl_FragColor = packFloat(diff);\n}\n`;\nconst _outputTexture2D = `\nvarying vec2 vUv0;\nuniform sampler2D source;\nvoid main(void) {\n    gl_FragColor = texture2D(source, vUv0);\n}\n`;\nfunction testRenderable(gl, pixelFormat) {\n  let result = true;\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, pixelFormat, null);\n  const framebuffer = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n  if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {\n    result = false;\n  }\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.deleteTexture(texture);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  gl.deleteFramebuffer(framebuffer);\n  return result;\n}\nfunction testTextureHalfFloatUpdatable(gl, pixelFormat) {\n  let result = true;\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  const data = new Uint16Array(4 * 2 * 2);\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, pixelFormat, data);\n  if (gl.getError() !== gl.NO_ERROR) {\n    result = false;\n    console.log(\"Above error related to HALF_FLOAT_OES can be ignored, it was triggered by testing half float texture support\");\n  }\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.deleteTexture(texture);\n  return result;\n}\nfunction testTextureFloatHighPrecision(device) {\n  if (!device.textureFloatRenderable) return false;\n  const shader1 = new _shader_js__WEBPACK_IMPORTED_MODULE_0__.Shader(device, _shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.ShaderUtils.createDefinition(device, {\n    name: 'ptest1',\n    vertexCode: _fullScreenQuadVS,\n    fragmentCode: _precisionTest1PS\n  }));\n  const shader2 = new _shader_js__WEBPACK_IMPORTED_MODULE_0__.Shader(device, _shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.ShaderUtils.createDefinition(device, {\n    name: 'ptest2',\n    vertexCode: _fullScreenQuadVS,\n    fragmentCode: _precisionTest2PS\n  }));\n  const textureOptions = {\n    format: _constants_js__WEBPACK_IMPORTED_MODULE_2__.PIXELFORMAT_RGBA32F,\n    width: 1,\n    height: 1,\n    mipmaps: false,\n    minFilter: _constants_js__WEBPACK_IMPORTED_MODULE_2__.FILTER_NEAREST,\n    magFilter: _constants_js__WEBPACK_IMPORTED_MODULE_2__.FILTER_NEAREST,\n    name: 'testFHP'\n  };\n  const tex1 = new _texture_js__WEBPACK_IMPORTED_MODULE_3__.Texture(device, textureOptions);\n  const targ1 = new _render_target_js__WEBPACK_IMPORTED_MODULE_4__.RenderTarget({\n    colorBuffer: tex1,\n    depth: false\n  });\n  (0,_simple_post_effect_js__WEBPACK_IMPORTED_MODULE_5__.drawQuadWithShader)(device, targ1, shader1);\n  textureOptions.format = _constants_js__WEBPACK_IMPORTED_MODULE_2__.PIXELFORMAT_RGBA8;\n  const tex2 = new _texture_js__WEBPACK_IMPORTED_MODULE_3__.Texture(device, textureOptions);\n  const targ2 = new _render_target_js__WEBPACK_IMPORTED_MODULE_4__.RenderTarget({\n    colorBuffer: tex2,\n    depth: false\n  });\n  device.constantTexSource.setValue(tex1);\n  (0,_simple_post_effect_js__WEBPACK_IMPORTED_MODULE_5__.drawQuadWithShader)(device, targ2, shader2);\n  const prevFramebuffer = device.activeFramebuffer;\n  device.setFramebuffer(targ2.impl._glFrameBuffer);\n  const pixels = new Uint8Array(4);\n  device.readPixels(0, 0, 1, 1, pixels);\n  device.setFramebuffer(prevFramebuffer);\n  const x = pixels[0] / 255;\n  const y = pixels[1] / 255;\n  const z = pixels[2] / 255;\n  const w = pixels[3] / 255;\n  const f = x / (256 * 256 * 256) + y / (256 * 256) + z / 256 + w;\n  tex1.destroy();\n  targ1.destroy();\n  tex2.destroy();\n  targ2.destroy();\n  shader1.destroy();\n  shader2.destroy();\n  return f === 0;\n}\nfunction testImageBitmap(device) {\n  const pngBytes = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82, 0, 0, 0, 1, 0, 0, 0, 1, 8, 6, 0, 0, 0, 31, 21, 196, 137, 0, 0, 0, 13, 73, 68, 65, 84, 120, 218, 99, 100, 100, 98, 182, 7, 0, 0, 89, 0, 71, 67, 133, 148, 237, 0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130]);\n  return createImageBitmap(new Blob([pngBytes], {\n    type: 'image/png'\n  }), {\n    premultiplyAlpha: 'none'\n  }).then(image => {\n    const texture = new _texture_js__WEBPACK_IMPORTED_MODULE_3__.Texture(device, {\n      width: 1,\n      height: 1,\n      format: _constants_js__WEBPACK_IMPORTED_MODULE_2__.PIXELFORMAT_RGBA8,\n      mipmaps: false,\n      levels: [image]\n    });\n    const rt = new _render_target_js__WEBPACK_IMPORTED_MODULE_4__.RenderTarget({\n      colorBuffer: texture,\n      depth: false\n    });\n    device.setFramebuffer(rt.impl._glFrameBuffer);\n    device.initRenderTarget(rt);\n    const data = new Uint8ClampedArray(4);\n    device.gl.readPixels(0, 0, 1, 1, device.gl.RGBA, device.gl.UNSIGNED_BYTE, data);\n    rt.destroy();\n    texture.destroy();\n    return data[0] === 1 && data[1] === 2 && data[2] === 3 && data[3] === 63;\n  }).catch(e => false);\n}\nclass WebglGraphicsDevice extends _graphics_device_js__WEBPACK_IMPORTED_MODULE_6__.GraphicsDevice {\n  constructor(canvas, options = {}) {\n    super(canvas);\n    this.gl = void 0;\n    this.webgl2 = void 0;\n    this.deviceType = _constants_js__WEBPACK_IMPORTED_MODULE_2__.DEVICETYPE_WEBGL;\n    this.defaultFramebuffer = null;\n    this.updateClientRect();\n    this.contextLost = false;\n    this._contextLostHandler = event => {\n      event.preventDefault();\n      this.contextLost = true;\n      this.loseContext();\n      this.fire('devicelost');\n    };\n    this._contextRestoredHandler = () => {\n      this.restoreContext();\n      this.contextLost = false;\n      this.fire('devicerestored');\n    };\n    options.stencil = true;\n    if (!options.powerPreference) {\n      options.powerPreference = 'high-performance';\n    }\n    const ua = typeof navigator !== 'undefined' && navigator.userAgent;\n    this.forceDisableMultisampling = ua && ua.includes('AppleWebKit') && (ua.includes('15.4') || ua.includes('15_4'));\n    if (this.forceDisableMultisampling) {\n      options.antialias = false;\n    }\n    const preferWebGl2 = options.preferWebGl2 !== undefined ? options.preferWebGl2 : true;\n    const names = preferWebGl2 ? [\"webgl2\", \"webgl\", \"experimental-webgl\"] : [\"webgl\", \"experimental-webgl\"];\n    let gl = null;\n    for (let i = 0; i < names.length; i++) {\n      gl = canvas.getContext(names[i], options);\n      if (gl) {\n        this.webgl2 = names[i] === 'webgl2';\n        break;\n      }\n    }\n    this.gl = gl;\n    if (!gl) {\n      throw new Error(\"WebGL not supported\");\n    }\n    const alphaBits = gl.getParameter(gl.ALPHA_BITS);\n    this.framebufferFormat = alphaBits ? _constants_js__WEBPACK_IMPORTED_MODULE_2__.PIXELFORMAT_RGBA8 : _constants_js__WEBPACK_IMPORTED_MODULE_2__.PIXELFORMAT_RGB8;\n    const isChrome = _core_platform_js__WEBPACK_IMPORTED_MODULE_7__.platform.browser && !!window.chrome;\n    const isMac = _core_platform_js__WEBPACK_IMPORTED_MODULE_7__.platform.browser && navigator.appVersion.indexOf(\"Mac\") !== -1;\n    this._tempEnableSafariTextureUnitWorkaround = _core_platform_js__WEBPACK_IMPORTED_MODULE_7__.platform.browser && !!window.safari;\n    this._tempMacChromeBlitFramebufferWorkaround = isMac && isChrome && !options.alpha;\n    if (!this.webgl2) {\n      (0,_polyfill_OESVertexArrayObject_js__WEBPACK_IMPORTED_MODULE_8__.setupVertexArrayObject)(gl);\n    }\n    canvas.addEventListener(\"webglcontextlost\", this._contextLostHandler, false);\n    canvas.addEventListener(\"webglcontextrestored\", this._contextRestoredHandler, false);\n    this.initializeExtensions();\n    this.initializeCapabilities();\n    this.initializeRenderState();\n    this.initializeContextCaches();\n    this.supportsImageBitmap = null;\n    if (typeof ImageBitmap !== 'undefined') {\n      testImageBitmap(this).then(result => {\n        this.supportsImageBitmap = result;\n      });\n    }\n    this.defaultClearOptions = {\n      color: [0, 0, 0, 1],\n      depth: 1,\n      stencil: 0,\n      flags: _constants_js__WEBPACK_IMPORTED_MODULE_2__.CLEARFLAG_COLOR | _constants_js__WEBPACK_IMPORTED_MODULE_2__.CLEARFLAG_DEPTH\n    };\n    this.glAddress = [gl.REPEAT, gl.CLAMP_TO_EDGE, gl.MIRRORED_REPEAT];\n    this.glBlendEquation = [gl.FUNC_ADD, gl.FUNC_SUBTRACT, gl.FUNC_REVERSE_SUBTRACT, this.webgl2 ? gl.MIN : this.extBlendMinmax ? this.extBlendMinmax.MIN_EXT : gl.FUNC_ADD, this.webgl2 ? gl.MAX : this.extBlendMinmax ? this.extBlendMinmax.MAX_EXT : gl.FUNC_ADD];\n    this.glBlendFunction = [gl.ZERO, gl.ONE, gl.SRC_COLOR, gl.ONE_MINUS_SRC_COLOR, gl.DST_COLOR, gl.ONE_MINUS_DST_COLOR, gl.SRC_ALPHA, gl.SRC_ALPHA_SATURATE, gl.ONE_MINUS_SRC_ALPHA, gl.DST_ALPHA, gl.ONE_MINUS_DST_ALPHA, gl.CONSTANT_COLOR, gl.ONE_MINUS_CONSTANT_COLOR, gl.CONSTANT_ALPHA, gl.ONE_MINUS_CONSTANT_ALPHA];\n    this.glComparison = [gl.NEVER, gl.LESS, gl.EQUAL, gl.LEQUAL, gl.GREATER, gl.NOTEQUAL, gl.GEQUAL, gl.ALWAYS];\n    this.glStencilOp = [gl.KEEP, gl.ZERO, gl.REPLACE, gl.INCR, gl.INCR_WRAP, gl.DECR, gl.DECR_WRAP, gl.INVERT];\n    this.glClearFlag = [0, gl.COLOR_BUFFER_BIT, gl.DEPTH_BUFFER_BIT, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.STENCIL_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT];\n    this.glCull = [0, gl.BACK, gl.FRONT, gl.FRONT_AND_BACK];\n    this.glFilter = [gl.NEAREST, gl.LINEAR, gl.NEAREST_MIPMAP_NEAREST, gl.NEAREST_MIPMAP_LINEAR, gl.LINEAR_MIPMAP_NEAREST, gl.LINEAR_MIPMAP_LINEAR];\n    this.glPrimitive = [gl.POINTS, gl.LINES, gl.LINE_LOOP, gl.LINE_STRIP, gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN];\n    this.glType = [gl.BYTE, gl.UNSIGNED_BYTE, gl.SHORT, gl.UNSIGNED_SHORT, gl.INT, gl.UNSIGNED_INT, gl.FLOAT];\n    this.pcUniformType = {};\n    this.pcUniformType[gl.BOOL] = _constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_BOOL;\n    this.pcUniformType[gl.INT] = _constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_INT;\n    this.pcUniformType[gl.FLOAT] = _constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_FLOAT;\n    this.pcUniformType[gl.FLOAT_VEC2] = _constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_VEC2;\n    this.pcUniformType[gl.FLOAT_VEC3] = _constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_VEC3;\n    this.pcUniformType[gl.FLOAT_VEC4] = _constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_VEC4;\n    this.pcUniformType[gl.INT_VEC2] = _constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_IVEC2;\n    this.pcUniformType[gl.INT_VEC3] = _constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_IVEC3;\n    this.pcUniformType[gl.INT_VEC4] = _constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_IVEC4;\n    this.pcUniformType[gl.BOOL_VEC2] = _constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_BVEC2;\n    this.pcUniformType[gl.BOOL_VEC3] = _constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_BVEC3;\n    this.pcUniformType[gl.BOOL_VEC4] = _constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_BVEC4;\n    this.pcUniformType[gl.FLOAT_MAT2] = _constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_MAT2;\n    this.pcUniformType[gl.FLOAT_MAT3] = _constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_MAT3;\n    this.pcUniformType[gl.FLOAT_MAT4] = _constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_MAT4;\n    this.pcUniformType[gl.SAMPLER_2D] = _constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_TEXTURE2D;\n    this.pcUniformType[gl.SAMPLER_CUBE] = _constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_TEXTURECUBE;\n    if (this.webgl2) {\n      this.pcUniformType[gl.SAMPLER_2D_SHADOW] = _constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_TEXTURE2D_SHADOW;\n      this.pcUniformType[gl.SAMPLER_CUBE_SHADOW] = _constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_TEXTURECUBE_SHADOW;\n      this.pcUniformType[gl.SAMPLER_3D] = _constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_TEXTURE3D;\n    }\n    this.targetToSlot = {};\n    this.targetToSlot[gl.TEXTURE_2D] = 0;\n    this.targetToSlot[gl.TEXTURE_CUBE_MAP] = 1;\n    this.targetToSlot[gl.TEXTURE_3D] = 2;\n    let scopeX, scopeY, scopeZ, scopeW;\n    let uniformValue;\n    this.commitFunction = [];\n    this.commitFunction[_constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_BOOL] = function (uniform, value) {\n      if (uniform.value !== value) {\n        gl.uniform1i(uniform.locationId, value);\n        uniform.value = value;\n      }\n    };\n    this.commitFunction[_constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_INT] = this.commitFunction[_constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_BOOL];\n    this.commitFunction[_constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_FLOAT] = function (uniform, value) {\n      if (uniform.value !== value) {\n        gl.uniform1f(uniform.locationId, value);\n        uniform.value = value;\n      }\n    };\n    this.commitFunction[_constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_VEC2] = function (uniform, value) {\n      uniformValue = uniform.value;\n      scopeX = value[0];\n      scopeY = value[1];\n      if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {\n        gl.uniform2fv(uniform.locationId, value);\n        uniformValue[0] = scopeX;\n        uniformValue[1] = scopeY;\n      }\n    };\n    this.commitFunction[_constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_VEC3] = function (uniform, value) {\n      uniformValue = uniform.value;\n      scopeX = value[0];\n      scopeY = value[1];\n      scopeZ = value[2];\n      if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {\n        gl.uniform3fv(uniform.locationId, value);\n        uniformValue[0] = scopeX;\n        uniformValue[1] = scopeY;\n        uniformValue[2] = scopeZ;\n      }\n    };\n    this.commitFunction[_constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_VEC4] = function (uniform, value) {\n      uniformValue = uniform.value;\n      scopeX = value[0];\n      scopeY = value[1];\n      scopeZ = value[2];\n      scopeW = value[3];\n      if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {\n        gl.uniform4fv(uniform.locationId, value);\n        uniformValue[0] = scopeX;\n        uniformValue[1] = scopeY;\n        uniformValue[2] = scopeZ;\n        uniformValue[3] = scopeW;\n      }\n    };\n    this.commitFunction[_constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_IVEC2] = function (uniform, value) {\n      uniformValue = uniform.value;\n      scopeX = value[0];\n      scopeY = value[1];\n      if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {\n        gl.uniform2iv(uniform.locationId, value);\n        uniformValue[0] = scopeX;\n        uniformValue[1] = scopeY;\n      }\n    };\n    this.commitFunction[_constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_BVEC2] = this.commitFunction[_constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_IVEC2];\n    this.commitFunction[_constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_IVEC3] = function (uniform, value) {\n      uniformValue = uniform.value;\n      scopeX = value[0];\n      scopeY = value[1];\n      scopeZ = value[2];\n      if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {\n        gl.uniform3iv(uniform.locationId, value);\n        uniformValue[0] = scopeX;\n        uniformValue[1] = scopeY;\n        uniformValue[2] = scopeZ;\n      }\n    };\n    this.commitFunction[_constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_BVEC3] = this.commitFunction[_constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_IVEC3];\n    this.commitFunction[_constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_IVEC4] = function (uniform, value) {\n      uniformValue = uniform.value;\n      scopeX = value[0];\n      scopeY = value[1];\n      scopeZ = value[2];\n      scopeW = value[3];\n      if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {\n        gl.uniform4iv(uniform.locationId, value);\n        uniformValue[0] = scopeX;\n        uniformValue[1] = scopeY;\n        uniformValue[2] = scopeZ;\n        uniformValue[3] = scopeW;\n      }\n    };\n    this.commitFunction[_constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_BVEC4] = this.commitFunction[_constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_IVEC4];\n    this.commitFunction[_constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_MAT2] = function (uniform, value) {\n      gl.uniformMatrix2fv(uniform.locationId, false, value);\n    };\n    this.commitFunction[_constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_MAT3] = function (uniform, value) {\n      gl.uniformMatrix3fv(uniform.locationId, false, value);\n    };\n    this.commitFunction[_constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_MAT4] = function (uniform, value) {\n      gl.uniformMatrix4fv(uniform.locationId, false, value);\n    };\n    this.commitFunction[_constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_FLOATARRAY] = function (uniform, value) {\n      gl.uniform1fv(uniform.locationId, value);\n    };\n    this.commitFunction[_constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_VEC2ARRAY] = function (uniform, value) {\n      gl.uniform2fv(uniform.locationId, value);\n    };\n    this.commitFunction[_constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_VEC3ARRAY] = function (uniform, value) {\n      gl.uniform3fv(uniform.locationId, value);\n    };\n    this.commitFunction[_constants_js__WEBPACK_IMPORTED_MODULE_2__.UNIFORMTYPE_VEC4ARRAY] = function (uniform, value) {\n      gl.uniform4fv(uniform.locationId, value);\n    };\n    this.supportsBoneTextures = this.extTextureFloat && this.maxVertexTextures > 0;\n    let numUniforms = this.vertexUniformsCount;\n    numUniforms -= 4 * 4;\n    numUniforms -= 8;\n    numUniforms -= 1;\n    numUniforms -= 4 * 4;\n    this.boneLimit = Math.floor(numUniforms / 3);\n    this.boneLimit = Math.min(this.boneLimit, 128);\n    if (this.unmaskedRenderer === 'Mali-450 MP') {\n      this.boneLimit = 34;\n    }\n    this.constantTexSource = this.scope.resolve(\"source\");\n    if (this.extTextureFloat) {\n      if (this.webgl2) {\n        this.textureFloatRenderable = !!this.extColorBufferFloat;\n      } else {\n        this.textureFloatRenderable = testRenderable(gl, gl.FLOAT);\n      }\n    } else {\n      this.textureFloatRenderable = false;\n    }\n    if (this.extColorBufferHalfFloat) {\n      this.textureHalfFloatRenderable = !!this.extColorBufferHalfFloat;\n    } else if (this.extTextureHalfFloat) {\n      if (this.webgl2) {\n        this.textureHalfFloatRenderable = !!this.extColorBufferFloat;\n      } else {\n        this.textureHalfFloatRenderable = testRenderable(gl, this.extTextureHalfFloat.HALF_FLOAT_OES);\n      }\n    } else {\n      this.textureHalfFloatRenderable = false;\n    }\n    this.supportsMorphTargetTexturesCore = this.maxPrecision === \"highp\" && this.maxVertexTextures >= 2;\n    this.supportsDepthShadow = this.webgl2;\n    this._textureFloatHighPrecision = undefined;\n    this._textureHalfFloatUpdatable = undefined;\n    this.areaLightLutFormat = _constants_js__WEBPACK_IMPORTED_MODULE_2__.PIXELFORMAT_RGBA8;\n    if (this.extTextureHalfFloat && this.textureHalfFloatUpdatable && this.extTextureHalfFloatLinear) {\n      this.areaLightLutFormat = _constants_js__WEBPACK_IMPORTED_MODULE_2__.PIXELFORMAT_RGBA16F;\n    } else if (this.extTextureFloat && this.extTextureFloatLinear) {\n      this.areaLightLutFormat = _constants_js__WEBPACK_IMPORTED_MODULE_2__.PIXELFORMAT_RGBA32F;\n    }\n  }\n  destroy() {\n    super.destroy();\n    const gl = this.gl;\n    if (this.webgl2 && this.feedback) {\n      gl.deleteTransformFeedback(this.feedback);\n    }\n    this.clearVertexArrayObjectCache();\n    this.canvas.removeEventListener('webglcontextlost', this._contextLostHandler, false);\n    this.canvas.removeEventListener('webglcontextrestored', this._contextRestoredHandler, false);\n    this._contextLostHandler = null;\n    this._contextRestoredHandler = null;\n    this.gl = null;\n    super.postDestroy();\n  }\n  createVertexBufferImpl(vertexBuffer, format) {\n    return new _webgl_vertex_buffer_js__WEBPACK_IMPORTED_MODULE_9__.WebglVertexBuffer();\n  }\n  createIndexBufferImpl(indexBuffer) {\n    return new _webgl_index_buffer_js__WEBPACK_IMPORTED_MODULE_10__.WebglIndexBuffer(indexBuffer);\n  }\n  createShaderImpl(shader) {\n    return new _webgl_shader_js__WEBPACK_IMPORTED_MODULE_11__.WebglShader(shader);\n  }\n  createTextureImpl(texture) {\n    return new _webgl_texture_js__WEBPACK_IMPORTED_MODULE_12__.WebglTexture();\n  }\n  createRenderTargetImpl(renderTarget) {\n    return new _webgl_render_target_js__WEBPACK_IMPORTED_MODULE_13__.WebglRenderTarget();\n  }\n  getPrecision() {\n    const gl = this.gl;\n    let precision = \"highp\";\n    if (gl.getShaderPrecisionFormat) {\n      const vertexShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT);\n      const vertexShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT);\n      const fragmentShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n      const fragmentShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);\n      const highpAvailable = vertexShaderPrecisionHighpFloat.precision > 0 && fragmentShaderPrecisionHighpFloat.precision > 0;\n      const mediumpAvailable = vertexShaderPrecisionMediumpFloat.precision > 0 && fragmentShaderPrecisionMediumpFloat.precision > 0;\n      if (!highpAvailable) {\n        if (mediumpAvailable) {\n          precision = \"mediump\";\n        } else {\n          precision = \"lowp\";\n        }\n      }\n    }\n    return precision;\n  }\n  initializeExtensions() {\n    const gl = this.gl;\n    const supportedExtensions = gl.getSupportedExtensions();\n    const getExtension = function getExtension() {\n      for (let i = 0; i < arguments.length; i++) {\n        if (supportedExtensions.indexOf(arguments[i]) !== -1) {\n          return gl.getExtension(arguments[i]);\n        }\n      }\n      return null;\n    };\n    if (this.webgl2) {\n      this.extBlendMinmax = true;\n      this.extDrawBuffers = true;\n      this.extInstancing = true;\n      this.extStandardDerivatives = true;\n      this.extTextureFloat = true;\n      this.extTextureHalfFloat = true;\n      this.extTextureLod = true;\n      this.extUintElement = true;\n      this.extVertexArrayObject = true;\n      this.extColorBufferFloat = getExtension('EXT_color_buffer_float');\n      this.extDisjointTimerQuery = getExtension('EXT_disjoint_timer_query_webgl2', 'EXT_disjoint_timer_query');\n      this.extDepthTexture = true;\n    } else {\n      this.extBlendMinmax = getExtension(\"EXT_blend_minmax\");\n      this.extDrawBuffers = getExtension('EXT_draw_buffers');\n      this.extInstancing = getExtension(\"ANGLE_instanced_arrays\");\n      if (this.extInstancing) {\n        const ext = this.extInstancing;\n        gl.drawArraysInstanced = ext.drawArraysInstancedANGLE.bind(ext);\n        gl.drawElementsInstanced = ext.drawElementsInstancedANGLE.bind(ext);\n        gl.vertexAttribDivisor = ext.vertexAttribDivisorANGLE.bind(ext);\n      }\n      this.extStandardDerivatives = getExtension(\"OES_standard_derivatives\");\n      this.extTextureFloat = getExtension(\"OES_texture_float\");\n      this.extTextureHalfFloat = getExtension(\"OES_texture_half_float\");\n      this.extTextureLod = getExtension('EXT_shader_texture_lod');\n      this.extUintElement = getExtension(\"OES_element_index_uint\");\n      this.extVertexArrayObject = getExtension(\"OES_vertex_array_object\");\n      if (this.extVertexArrayObject) {\n        const ext = this.extVertexArrayObject;\n        gl.createVertexArray = ext.createVertexArrayOES.bind(ext);\n        gl.deleteVertexArray = ext.deleteVertexArrayOES.bind(ext);\n        gl.isVertexArray = ext.isVertexArrayOES.bind(ext);\n        gl.bindVertexArray = ext.bindVertexArrayOES.bind(ext);\n      }\n      this.extColorBufferFloat = null;\n      this.extDisjointTimerQuery = null;\n      this.extDepthTexture = gl.getExtension('WEBGL_depth_texture');\n    }\n    this.extDebugRendererInfo = getExtension('WEBGL_debug_renderer_info');\n    this.extTextureFloatLinear = getExtension(\"OES_texture_float_linear\");\n    this.extTextureHalfFloatLinear = getExtension(\"OES_texture_half_float_linear\");\n    this.extFloatBlend = getExtension(\"EXT_float_blend\");\n    this.extTextureFilterAnisotropic = getExtension('EXT_texture_filter_anisotropic', 'WEBKIT_EXT_texture_filter_anisotropic');\n    this.extCompressedTextureETC1 = getExtension('WEBGL_compressed_texture_etc1');\n    this.extCompressedTextureETC = getExtension('WEBGL_compressed_texture_etc');\n    this.extCompressedTexturePVRTC = getExtension('WEBGL_compressed_texture_pvrtc', 'WEBKIT_WEBGL_compressed_texture_pvrtc');\n    this.extCompressedTextureS3TC = getExtension('WEBGL_compressed_texture_s3tc', 'WEBKIT_WEBGL_compressed_texture_s3tc');\n    this.extCompressedTextureATC = getExtension('WEBGL_compressed_texture_atc');\n    this.extCompressedTextureASTC = getExtension('WEBGL_compressed_texture_astc');\n    this.extParallelShaderCompile = getExtension('KHR_parallel_shader_compile');\n    this.extColorBufferHalfFloat = getExtension(\"EXT_color_buffer_half_float\");\n  }\n  initializeCapabilities() {\n    const gl = this.gl;\n    let ext;\n    const userAgent = typeof navigator !== 'undefined' ? navigator.userAgent : \"\";\n    this.maxPrecision = this.precision = this.getPrecision();\n    const contextAttribs = gl.getContextAttributes();\n    this.supportsMsaa = contextAttribs.antialias;\n    this.supportsStencil = contextAttribs.stencil;\n    this.supportsInstancing = !!this.extInstancing;\n    this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n    this.maxCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);\n    this.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);\n    this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    this.maxCombinedTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);\n    this.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);\n    this.vertexUniformsCount = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);\n    this.fragmentUniformsCount = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);\n    if (this.webgl2) {\n      this.maxDrawBuffers = gl.getParameter(gl.MAX_DRAW_BUFFERS);\n      this.maxColorAttachments = gl.getParameter(gl.MAX_COLOR_ATTACHMENTS);\n      this.maxVolumeSize = gl.getParameter(gl.MAX_3D_TEXTURE_SIZE);\n    } else {\n      ext = this.extDrawBuffers;\n      this.maxDrawBuffers = ext ? gl.getParameter(ext.MAX_DRAW_BUFFERS_EXT) : 1;\n      this.maxColorAttachments = ext ? gl.getParameter(ext.MAX_COLOR_ATTACHMENTS_EXT) : 1;\n      this.maxVolumeSize = 1;\n    }\n    ext = this.extDebugRendererInfo;\n    this.unmaskedRenderer = ext ? gl.getParameter(ext.UNMASKED_RENDERER_WEBGL) : '';\n    this.unmaskedVendor = ext ? gl.getParameter(ext.UNMASKED_VENDOR_WEBGL) : '';\n    const samsungModelRegex = /SM-[a-zA-Z0-9]+/;\n    this.supportsGpuParticles = !(this.unmaskedVendor === 'ARM' && userAgent.match(samsungModelRegex));\n    ext = this.extTextureFilterAnisotropic;\n    this.maxAnisotropy = ext ? gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;\n    this.samples = gl.getParameter(gl.SAMPLES);\n    this.maxSamples = this.webgl2 && !this.forceDisableMultisampling ? gl.getParameter(gl.MAX_SAMPLES) : 1;\n    this.supportsAreaLights = this.webgl2 || !_core_platform_js__WEBPACK_IMPORTED_MODULE_7__.platform.android;\n    this.supportsTextureFetch = this.webgl2;\n    if (this.maxTextures <= 8) {\n      this.supportsAreaLights = false;\n    }\n  }\n  initializeRenderState() {\n    const gl = this.gl;\n    this.blending = false;\n    gl.disable(gl.BLEND);\n    this.blendSrc = _constants_js__WEBPACK_IMPORTED_MODULE_2__.BLENDMODE_ONE;\n    this.blendDst = _constants_js__WEBPACK_IMPORTED_MODULE_2__.BLENDMODE_ZERO;\n    this.blendSrcAlpha = _constants_js__WEBPACK_IMPORTED_MODULE_2__.BLENDMODE_ONE;\n    this.blendDstAlpha = _constants_js__WEBPACK_IMPORTED_MODULE_2__.BLENDMODE_ZERO;\n    this.separateAlphaBlend = false;\n    this.blendEquation = _constants_js__WEBPACK_IMPORTED_MODULE_2__.BLENDEQUATION_ADD;\n    this.blendAlphaEquation = _constants_js__WEBPACK_IMPORTED_MODULE_2__.BLENDEQUATION_ADD;\n    this.separateAlphaEquation = false;\n    gl.blendFunc(gl.ONE, gl.ZERO);\n    gl.blendEquation(gl.FUNC_ADD);\n    this.blendColor = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_14__.Color(0, 0, 0, 0);\n    gl.blendColor(0, 0, 0, 0);\n    this.writeRed = true;\n    this.writeGreen = true;\n    this.writeBlue = true;\n    this.writeAlpha = true;\n    gl.colorMask(true, true, true, true);\n    this.cullMode = _constants_js__WEBPACK_IMPORTED_MODULE_2__.CULLFACE_BACK;\n    gl.enable(gl.CULL_FACE);\n    gl.cullFace(gl.BACK);\n    this.depthTest = true;\n    gl.enable(gl.DEPTH_TEST);\n    this.depthFunc = _constants_js__WEBPACK_IMPORTED_MODULE_2__.FUNC_LESSEQUAL;\n    gl.depthFunc(gl.LEQUAL);\n    this.depthWrite = true;\n    gl.depthMask(true);\n    this.stencil = false;\n    gl.disable(gl.STENCIL_TEST);\n    this.stencilFuncFront = this.stencilFuncBack = _constants_js__WEBPACK_IMPORTED_MODULE_2__.FUNC_ALWAYS;\n    this.stencilRefFront = this.stencilRefBack = 0;\n    this.stencilMaskFront = this.stencilMaskBack = 0xFF;\n    gl.stencilFunc(gl.ALWAYS, 0, 0xFF);\n    this.stencilFailFront = this.stencilFailBack = _constants_js__WEBPACK_IMPORTED_MODULE_2__.STENCILOP_KEEP;\n    this.stencilZfailFront = this.stencilZfailBack = _constants_js__WEBPACK_IMPORTED_MODULE_2__.STENCILOP_KEEP;\n    this.stencilZpassFront = this.stencilZpassBack = _constants_js__WEBPACK_IMPORTED_MODULE_2__.STENCILOP_KEEP;\n    this.stencilWriteMaskFront = 0xFF;\n    this.stencilWriteMaskBack = 0xFF;\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n    gl.stencilMask(0xFF);\n    this.alphaToCoverage = false;\n    this.raster = true;\n    if (this.webgl2) {\n      gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);\n      gl.disable(gl.RASTERIZER_DISCARD);\n    }\n    this.depthBiasEnabled = false;\n    gl.disable(gl.POLYGON_OFFSET_FILL);\n    this.clearDepth = 1;\n    gl.clearDepth(1);\n    this.clearColor = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_14__.Color(0, 0, 0, 0);\n    gl.clearColor(0, 0, 0, 0);\n    this.clearStencil = 0;\n    gl.clearStencil(0);\n    this.vx = this.vy = this.vw = this.vh = 0;\n    this.sx = this.sy = this.sw = this.sh = 0;\n    if (this.webgl2) {\n      gl.hint(gl.FRAGMENT_SHADER_DERIVATIVE_HINT, gl.NICEST);\n    } else {\n      if (this.extStandardDerivatives) {\n        gl.hint(this.extStandardDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, gl.NICEST);\n      }\n    }\n    gl.enable(gl.SCISSOR_TEST);\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n    this.unpackFlipY = false;\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n    this.unpackPremultiplyAlpha = false;\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\n  }\n  initializeContextCaches() {\n    super.initializeContextCaches();\n    this._vaoMap = new Map();\n    this.boundVao = null;\n    this.activeFramebuffer = null;\n    this.feedback = null;\n    this.transformFeedbackBuffer = null;\n    this.textureUnit = 0;\n    this.textureUnits = [];\n    for (let i = 0; i < this.maxCombinedTextures; i++) {\n      this.textureUnits.push([null, null, null]);\n    }\n  }\n  loseContext() {\n    for (const shader of this.shaders) {\n      shader.loseContext();\n    }\n    for (const texture of this.textures) {\n      texture.loseContext();\n    }\n    for (const buffer of this.buffers) {\n      buffer.loseContext();\n    }\n    for (const target of this.targets) {\n      target.loseContext();\n    }\n  }\n  restoreContext() {\n    this.initializeExtensions();\n    this.initializeCapabilities();\n    this.initializeRenderState();\n    this.initializeContextCaches();\n    for (const shader of this.shaders) {\n      shader.restoreContext();\n    }\n    for (const buffer of this.buffers) {\n      buffer.unlock();\n    }\n  }\n  setViewport(x, y, w, h) {\n    if (this.vx !== x || this.vy !== y || this.vw !== w || this.vh !== h) {\n      this.gl.viewport(x, y, w, h);\n      this.vx = x;\n      this.vy = y;\n      this.vw = w;\n      this.vh = h;\n    }\n  }\n  setScissor(x, y, w, h) {\n    if (this.sx !== x || this.sy !== y || this.sw !== w || this.sh !== h) {\n      this.gl.scissor(x, y, w, h);\n      this.sx = x;\n      this.sy = y;\n      this.sw = w;\n      this.sh = h;\n    }\n  }\n  setFramebuffer(fb) {\n    if (this.activeFramebuffer !== fb) {\n      const gl = this.gl;\n      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n      this.activeFramebuffer = fb;\n    }\n  }\n  copyRenderTarget(source, dest, color, depth) {\n    const gl = this.gl;\n    if (!this.webgl2 && depth) {\n      return false;\n    }\n    if (color) {\n      if (!dest) {\n        if (!source._colorBuffer) {\n          return false;\n        }\n      } else if (source) {\n        if (!source._colorBuffer || !dest._colorBuffer) {\n          return false;\n        }\n        if (source._colorBuffer._format !== dest._colorBuffer._format) {\n          return false;\n        }\n      }\n    }\n    if (depth && source) {\n      if (!source._depth) {\n        if (!source._depthBuffer || !dest._depthBuffer) {\n          return false;\n        }\n        if (source._depthBuffer._format !== dest._depthBuffer._format) {\n          return false;\n        }\n      }\n    }\n    if (this.webgl2 && dest) {\n      const prevRt = this.renderTarget;\n      this.renderTarget = dest;\n      this.updateBegin();\n      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, source ? source.impl._glFrameBuffer : null);\n      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dest.impl._glFrameBuffer);\n      const w = source ? source.width : dest.width;\n      const h = source ? source.height : dest.height;\n      gl.blitFramebuffer(0, 0, w, h, 0, 0, w, h, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0), gl.NEAREST);\n      this.renderTarget = prevRt;\n      gl.bindFramebuffer(gl.FRAMEBUFFER, prevRt ? prevRt.impl._glFrameBuffer : null);\n    } else {\n      const shader = this.getCopyShader();\n      this.constantTexSource.setValue(source._colorBuffer);\n      (0,_simple_post_effect_js__WEBPACK_IMPORTED_MODULE_5__.drawQuadWithShader)(this, dest, shader);\n    }\n    return true;\n  }\n  getCopyShader() {\n    if (!this._copyShader) {\n      this._copyShader = new _shader_js__WEBPACK_IMPORTED_MODULE_0__.Shader(this, _shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.ShaderUtils.createDefinition(this, {\n        name: 'outputTex2D',\n        vertexCode: _fullScreenQuadVS,\n        fragmentCode: _outputTexture2D\n      }));\n    }\n    return this._copyShader;\n  }\n  startPass(renderPass) {\n    this.setRenderTarget(renderPass.renderTarget);\n    this.updateBegin();\n    const colorOps = renderPass.colorOps;\n    const depthStencilOps = renderPass.depthStencilOps;\n    if (colorOps.clear || depthStencilOps.clearDepth || depthStencilOps.clearStencil) {\n      const rt = renderPass.renderTarget;\n      const width = rt ? rt.width : this.width;\n      const height = rt ? rt.height : this.height;\n      this.setViewport(0, 0, width, height);\n      this.setScissor(0, 0, width, height);\n      let clearFlags = 0;\n      const clearOptions = {};\n      if (colorOps.clear) {\n        clearFlags |= _constants_js__WEBPACK_IMPORTED_MODULE_2__.CLEARFLAG_COLOR;\n        clearOptions.color = [colorOps.clearValue.r, colorOps.clearValue.g, colorOps.clearValue.b, colorOps.clearValue.a];\n      }\n      if (depthStencilOps.clearDepth) {\n        clearFlags |= _constants_js__WEBPACK_IMPORTED_MODULE_2__.CLEARFLAG_DEPTH;\n        clearOptions.depth = depthStencilOps.clearDepthValue;\n      }\n      if (depthStencilOps.clearStencil) {\n        clearFlags |= _constants_js__WEBPACK_IMPORTED_MODULE_2__.CLEARFLAG_STENCIL;\n        clearOptions.stencil = depthStencilOps.clearStencilValue;\n      }\n      clearOptions.flags = clearFlags;\n      this.clear(clearOptions);\n    }\n    this.insideRenderPass = true;\n  }\n  endPass(renderPass) {\n    this.unbindVertexArray();\n    const target = this.renderTarget;\n    if (target) {\n      if (this.webgl2) {\n        invalidateAttachments.length = 0;\n        const gl = this.gl;\n        if (!(renderPass.colorOps.store || renderPass.colorOps.resolve)) {\n          invalidateAttachments.push(gl.COLOR_ATTACHMENT0);\n        }\n        if (!renderPass.depthStencilOps.storeDepth) {\n          invalidateAttachments.push(gl.DEPTH_ATTACHMENT);\n        }\n        if (!renderPass.depthStencilOps.storeStencil) {\n          invalidateAttachments.push(gl.STENCIL_ATTACHMENT);\n        }\n        if (invalidateAttachments.length > 0) {\n          if (renderPass.fullSizeClearRect) {\n            gl.invalidateFramebuffer(gl.DRAW_FRAMEBUFFER, invalidateAttachments);\n          }\n        }\n      }\n      if (renderPass.colorOps.resolve) {\n        if (this.webgl2 && renderPass.samples > 1 && target.autoResolve) {\n          target.resolve(true, false);\n        }\n      }\n      if (renderPass.colorOps.mipmaps) {\n        const colorBuffer = target._colorBuffer;\n        if (colorBuffer && colorBuffer.impl._glTexture && colorBuffer.mipmaps && (colorBuffer.pot || this.webgl2)) {\n          this.activeTexture(this.maxCombinedTextures - 1);\n          this.bindTexture(colorBuffer);\n          this.gl.generateMipmap(colorBuffer.impl._glTarget);\n        }\n      }\n    }\n    this.insideRenderPass = false;\n  }\n  updateBegin() {\n    this.boundVao = null;\n    if (this._tempEnableSafariTextureUnitWorkaround) {\n      for (let unit = 0; unit < this.textureUnits.length; ++unit) {\n        for (let slot = 0; slot < 3; ++slot) {\n          this.textureUnits[unit][slot] = null;\n        }\n      }\n    }\n    const target = this.renderTarget;\n    if (target) {\n      if (!target.impl.initialized) {\n        this.initRenderTarget(target);\n      } else {\n        this.setFramebuffer(target.impl._glFrameBuffer);\n      }\n    } else {\n      this.setFramebuffer(this.defaultFramebuffer);\n    }\n  }\n  updateEnd() {\n    this.unbindVertexArray();\n    const target = this.renderTarget;\n    if (target) {\n      if (this.webgl2 && target._samples > 1 && target.autoResolve) {\n        target.resolve();\n      }\n      const colorBuffer = target._colorBuffer;\n      if (colorBuffer && colorBuffer.impl._glTexture && colorBuffer.mipmaps && (colorBuffer.pot || this.webgl2)) {\n        this.activeTexture(this.maxCombinedTextures - 1);\n        this.bindTexture(colorBuffer);\n        this.gl.generateMipmap(colorBuffer.impl._glTarget);\n      }\n    }\n  }\n  setUnpackFlipY(flipY) {\n    if (this.unpackFlipY !== flipY) {\n      this.unpackFlipY = flipY;\n      const gl = this.gl;\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\n    }\n  }\n  setUnpackPremultiplyAlpha(premultiplyAlpha) {\n    if (this.unpackPremultiplyAlpha !== premultiplyAlpha) {\n      this.unpackPremultiplyAlpha = premultiplyAlpha;\n      const gl = this.gl;\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);\n    }\n  }\n  activeTexture(textureUnit) {\n    if (this.textureUnit !== textureUnit) {\n      this.gl.activeTexture(this.gl.TEXTURE0 + textureUnit);\n      this.textureUnit = textureUnit;\n    }\n  }\n  bindTexture(texture) {\n    const impl = texture.impl;\n    const textureTarget = impl._glTarget;\n    const textureObject = impl._glTexture;\n    const textureUnit = this.textureUnit;\n    const slot = this.targetToSlot[textureTarget];\n    if (this.textureUnits[textureUnit][slot] !== textureObject) {\n      this.gl.bindTexture(textureTarget, textureObject);\n      this.textureUnits[textureUnit][slot] = textureObject;\n    }\n  }\n  bindTextureOnUnit(texture, textureUnit) {\n    const impl = texture.impl;\n    const textureTarget = impl._glTarget;\n    const textureObject = impl._glTexture;\n    const slot = this.targetToSlot[textureTarget];\n    if (this.textureUnits[textureUnit][slot] !== textureObject) {\n      this.activeTexture(textureUnit);\n      this.gl.bindTexture(textureTarget, textureObject);\n      this.textureUnits[textureUnit][slot] = textureObject;\n    }\n  }\n  setTextureParameters(texture) {\n    const gl = this.gl;\n    const flags = texture._parameterFlags;\n    const target = texture.impl._glTarget;\n    if (flags & 1) {\n      let filter = texture._minFilter;\n      if (!texture.pot && !this.webgl2 || !texture._mipmaps || texture._compressed && texture._levels.length === 1) {\n        if (filter === _constants_js__WEBPACK_IMPORTED_MODULE_2__.FILTER_NEAREST_MIPMAP_NEAREST || filter === _constants_js__WEBPACK_IMPORTED_MODULE_2__.FILTER_NEAREST_MIPMAP_LINEAR) {\n          filter = _constants_js__WEBPACK_IMPORTED_MODULE_2__.FILTER_NEAREST;\n        } else if (filter === _constants_js__WEBPACK_IMPORTED_MODULE_2__.FILTER_LINEAR_MIPMAP_NEAREST || filter === _constants_js__WEBPACK_IMPORTED_MODULE_2__.FILTER_LINEAR_MIPMAP_LINEAR) {\n          filter = _constants_js__WEBPACK_IMPORTED_MODULE_2__.FILTER_LINEAR;\n        }\n      }\n      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, this.glFilter[filter]);\n    }\n    if (flags & 2) {\n      gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, this.glFilter[texture._magFilter]);\n    }\n    if (flags & 4) {\n      if (this.webgl2) {\n        gl.texParameteri(target, gl.TEXTURE_WRAP_S, this.glAddress[texture._addressU]);\n      } else {\n        gl.texParameteri(target, gl.TEXTURE_WRAP_S, this.glAddress[texture.pot ? texture._addressU : _constants_js__WEBPACK_IMPORTED_MODULE_2__.ADDRESS_CLAMP_TO_EDGE]);\n      }\n    }\n    if (flags & 8) {\n      if (this.webgl2) {\n        gl.texParameteri(target, gl.TEXTURE_WRAP_T, this.glAddress[texture._addressV]);\n      } else {\n        gl.texParameteri(target, gl.TEXTURE_WRAP_T, this.glAddress[texture.pot ? texture._addressV : _constants_js__WEBPACK_IMPORTED_MODULE_2__.ADDRESS_CLAMP_TO_EDGE]);\n      }\n    }\n    if (flags & 16) {\n      if (this.webgl2) {\n        gl.texParameteri(target, gl.TEXTURE_WRAP_R, this.glAddress[texture._addressW]);\n      }\n    }\n    if (flags & 32) {\n      if (this.webgl2) {\n        gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, texture._compareOnRead ? gl.COMPARE_REF_TO_TEXTURE : gl.NONE);\n      }\n    }\n    if (flags & 64) {\n      if (this.webgl2) {\n        gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, this.glComparison[texture._compareFunc]);\n      }\n    }\n    if (flags & 128) {\n      const ext = this.extTextureFilterAnisotropic;\n      if (ext) {\n        gl.texParameterf(target, ext.TEXTURE_MAX_ANISOTROPY_EXT, Math.max(1, Math.min(Math.round(texture._anisotropy), this.maxAnisotropy)));\n      }\n    }\n  }\n  setTexture(texture, textureUnit) {\n    if (!texture.impl._glTexture) texture.impl.initialize(this, texture);\n    if (texture._parameterFlags > 0 || texture._needsUpload || texture._needsMipmapsUpload) {\n      this.activeTexture(textureUnit);\n      this.bindTexture(texture);\n      if (texture._parameterFlags) {\n        this.setTextureParameters(texture);\n        texture._parameterFlags = 0;\n      }\n      if (texture._needsUpload || texture._needsMipmapsUpload) {\n        texture.impl.upload(this, texture);\n        texture._needsUpload = false;\n        texture._needsMipmapsUpload = false;\n      }\n    } else {\n      this.bindTextureOnUnit(texture, textureUnit);\n    }\n  }\n  createVertexArray(vertexBuffers) {\n    let key, vao;\n    const useCache = vertexBuffers.length > 1;\n    if (useCache) {\n      key = \"\";\n      for (let i = 0; i < vertexBuffers.length; i++) {\n        const vertexBuffer = vertexBuffers[i];\n        key += vertexBuffer.id + vertexBuffer.format.renderingingHash;\n      }\n      vao = this._vaoMap.get(key);\n    }\n    if (!vao) {\n      const gl = this.gl;\n      vao = gl.createVertexArray();\n      gl.bindVertexArray(vao);\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n      for (let i = 0; i < vertexBuffers.length; i++) {\n        const vertexBuffer = vertexBuffers[i];\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer.impl.bufferId);\n        const elements = vertexBuffer.format.elements;\n        for (let j = 0; j < elements.length; j++) {\n          const e = elements[j];\n          const loc = _constants_js__WEBPACK_IMPORTED_MODULE_2__.semanticToLocation[e.name];\n          gl.vertexAttribPointer(loc, e.numComponents, this.glType[e.dataType], e.normalize, e.stride, e.offset);\n          gl.enableVertexAttribArray(loc);\n          if (vertexBuffer.format.instancing) {\n            gl.vertexAttribDivisor(loc, 1);\n          }\n        }\n      }\n      gl.bindVertexArray(null);\n      gl.bindBuffer(gl.ARRAY_BUFFER, null);\n      if (useCache) {\n        this._vaoMap.set(key, vao);\n      }\n    }\n    return vao;\n  }\n  unbindVertexArray() {\n    if (this.boundVao) {\n      this.boundVao = null;\n      this.gl.bindVertexArray(null);\n    }\n  }\n  setBuffers() {\n    const gl = this.gl;\n    let vao;\n    if (this.vertexBuffers.length === 1) {\n      const vertexBuffer = this.vertexBuffers[0];\n      if (!vertexBuffer.impl.vao) {\n        vertexBuffer.impl.vao = this.createVertexArray(this.vertexBuffers);\n      }\n      vao = vertexBuffer.impl.vao;\n    } else {\n      vao = this.createVertexArray(this.vertexBuffers);\n    }\n    if (this.boundVao !== vao) {\n      this.boundVao = vao;\n      gl.bindVertexArray(vao);\n    }\n    this.vertexBuffers.length = 0;\n    const bufferId = this.indexBuffer ? this.indexBuffer.impl.bufferId : null;\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferId);\n  }\n  draw(primitive, numInstances, keepBuffers) {\n    const gl = this.gl;\n    let sampler, samplerValue, texture, numTextures;\n    let uniform, scopeId, uniformVersion, programVersion;\n    const shader = this.shader;\n    if (!shader) return;\n    const samplers = shader.impl.samplers;\n    const uniforms = shader.impl.uniforms;\n    if (!keepBuffers) {\n      this.setBuffers();\n    }\n    let textureUnit = 0;\n    for (let i = 0, len = samplers.length; i < len; i++) {\n      sampler = samplers[i];\n      samplerValue = sampler.scopeId.value;\n      if (!samplerValue) {\n        return;\n      }\n      if (samplerValue instanceof _texture_js__WEBPACK_IMPORTED_MODULE_3__.Texture) {\n        texture = samplerValue;\n        this.setTexture(texture, textureUnit);\n        if (sampler.slot !== textureUnit) {\n          gl.uniform1i(sampler.locationId, textureUnit);\n          sampler.slot = textureUnit;\n        }\n        textureUnit++;\n      } else {\n        sampler.array.length = 0;\n        numTextures = samplerValue.length;\n        for (let j = 0; j < numTextures; j++) {\n          texture = samplerValue[j];\n          this.setTexture(texture, textureUnit);\n          sampler.array[j] = textureUnit;\n          textureUnit++;\n        }\n        gl.uniform1iv(sampler.locationId, sampler.array);\n      }\n    }\n    for (let i = 0, len = uniforms.length; i < len; i++) {\n      uniform = uniforms[i];\n      scopeId = uniform.scopeId;\n      uniformVersion = uniform.version;\n      programVersion = scopeId.versionObject.version;\n      if (uniformVersion.globalId !== programVersion.globalId || uniformVersion.revision !== programVersion.revision) {\n        uniformVersion.globalId = programVersion.globalId;\n        uniformVersion.revision = programVersion.revision;\n        if (scopeId.value !== null) {\n          this.commitFunction[uniform.dataType](uniform, scopeId.value);\n        }\n      }\n    }\n    if (this.webgl2 && this.transformFeedbackBuffer) {\n      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.transformFeedbackBuffer.impl.bufferId);\n      gl.beginTransformFeedback(gl.POINTS);\n    }\n    const mode = this.glPrimitive[primitive.type];\n    const count = primitive.count;\n    if (primitive.indexed) {\n      const indexBuffer = this.indexBuffer;\n      const format = indexBuffer.impl.glFormat;\n      const offset = primitive.base * indexBuffer.bytesPerIndex;\n      if (numInstances > 0) {\n        gl.drawElementsInstanced(mode, count, format, offset, numInstances);\n      } else {\n        gl.drawElements(mode, count, format, offset);\n      }\n    } else {\n      const first = primitive.base;\n      if (numInstances > 0) {\n        gl.drawArraysInstanced(mode, first, count, numInstances);\n      } else {\n        gl.drawArrays(mode, first, count);\n      }\n    }\n    if (this.webgl2 && this.transformFeedbackBuffer) {\n      gl.endTransformFeedback();\n      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);\n    }\n    this._drawCallsPerFrame++;\n  }\n  clear(options) {\n    const defaultOptions = this.defaultClearOptions;\n    options = options || defaultOptions;\n    const flags = options.flags === undefined ? defaultOptions.flags : options.flags;\n    if (flags !== 0) {\n      const gl = this.gl;\n      if (flags & _constants_js__WEBPACK_IMPORTED_MODULE_2__.CLEARFLAG_COLOR) {\n        const color = options.color === undefined ? defaultOptions.color : options.color;\n        this.setClearColor(color[0], color[1], color[2], color[3]);\n        this.setColorWrite(true, true, true, true);\n      }\n      if (flags & _constants_js__WEBPACK_IMPORTED_MODULE_2__.CLEARFLAG_DEPTH) {\n        const depth = options.depth === undefined ? defaultOptions.depth : options.depth;\n        this.setClearDepth(depth);\n        this.setDepthWrite(true);\n      }\n      if (flags & _constants_js__WEBPACK_IMPORTED_MODULE_2__.CLEARFLAG_STENCIL) {\n        const stencil = options.stencil === undefined ? defaultOptions.stencil : options.stencil;\n        this.setClearStencil(stencil);\n      }\n      gl.clear(this.glClearFlag[flags]);\n    }\n  }\n  readPixels(x, y, w, h, pixels) {\n    const gl = this.gl;\n    gl.readPixels(x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n  }\n  setClearDepth(depth) {\n    if (depth !== this.clearDepth) {\n      this.gl.clearDepth(depth);\n      this.clearDepth = depth;\n    }\n  }\n  setClearColor(r, g, b, a) {\n    const c = this.clearColor;\n    if (r !== c.r || g !== c.g || b !== c.b || a !== c.a) {\n      this.gl.clearColor(r, g, b, a);\n      this.clearColor.set(r, g, b, a);\n    }\n  }\n  setClearStencil(value) {\n    if (value !== this.clearStencil) {\n      this.gl.clearStencil(value);\n      this.clearStencil = value;\n    }\n  }\n  getDepthTest() {\n    return this.depthTest;\n  }\n  setDepthTest(depthTest) {\n    if (this.depthTest !== depthTest) {\n      const gl = this.gl;\n      if (depthTest) {\n        gl.enable(gl.DEPTH_TEST);\n      } else {\n        gl.disable(gl.DEPTH_TEST);\n      }\n      this.depthTest = depthTest;\n    }\n  }\n  setDepthFunc(func) {\n    if (this.depthFunc === func) return;\n    this.gl.depthFunc(this.glComparison[func]);\n    this.depthFunc = func;\n  }\n  getDepthWrite() {\n    return this.depthWrite;\n  }\n  setDepthWrite(writeDepth) {\n    if (this.depthWrite !== writeDepth) {\n      this.gl.depthMask(writeDepth);\n      this.depthWrite = writeDepth;\n    }\n  }\n  setColorWrite(writeRed, writeGreen, writeBlue, writeAlpha) {\n    if (this.writeRed !== writeRed || this.writeGreen !== writeGreen || this.writeBlue !== writeBlue || this.writeAlpha !== writeAlpha) {\n      this.gl.colorMask(writeRed, writeGreen, writeBlue, writeAlpha);\n      this.writeRed = writeRed;\n      this.writeGreen = writeGreen;\n      this.writeBlue = writeBlue;\n      this.writeAlpha = writeAlpha;\n    }\n  }\n  setAlphaToCoverage(state) {\n    if (!this.webgl2) return;\n    if (this.alphaToCoverage === state) return;\n    this.alphaToCoverage = state;\n    if (state) {\n      this.gl.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);\n    } else {\n      this.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);\n    }\n  }\n  setTransformFeedbackBuffer(tf) {\n    if (this.transformFeedbackBuffer === tf) return;\n    this.transformFeedbackBuffer = tf;\n    if (this.webgl2) {\n      const gl = this.gl;\n      if (tf) {\n        if (!this.feedback) {\n          this.feedback = gl.createTransformFeedback();\n        }\n        gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, this.feedback);\n      } else {\n        gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\n      }\n    }\n  }\n  setRaster(on) {\n    if (this.raster === on) return;\n    this.raster = on;\n    if (this.webgl2) {\n      if (on) {\n        this.gl.disable(this.gl.RASTERIZER_DISCARD);\n      } else {\n        this.gl.enable(this.gl.RASTERIZER_DISCARD);\n      }\n    }\n  }\n  setDepthBias(on) {\n    if (this.depthBiasEnabled === on) return;\n    this.depthBiasEnabled = on;\n    if (on) {\n      this.gl.enable(this.gl.POLYGON_OFFSET_FILL);\n    } else {\n      this.gl.disable(this.gl.POLYGON_OFFSET_FILL);\n    }\n  }\n  setDepthBiasValues(constBias, slopeBias) {\n    this.gl.polygonOffset(slopeBias, constBias);\n  }\n  getBlending() {\n    return this.blending;\n  }\n  setBlending(blending) {\n    if (this.blending !== blending) {\n      const gl = this.gl;\n      if (blending) {\n        gl.enable(gl.BLEND);\n      } else {\n        gl.disable(gl.BLEND);\n      }\n      this.blending = blending;\n    }\n  }\n  setStencilTest(enable) {\n    if (this.stencil !== enable) {\n      const gl = this.gl;\n      if (enable) {\n        gl.enable(gl.STENCIL_TEST);\n      } else {\n        gl.disable(gl.STENCIL_TEST);\n      }\n      this.stencil = enable;\n    }\n  }\n  setStencilFunc(func, ref, mask) {\n    if (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask || this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {\n      const gl = this.gl;\n      gl.stencilFunc(this.glComparison[func], ref, mask);\n      this.stencilFuncFront = this.stencilFuncBack = func;\n      this.stencilRefFront = this.stencilRefBack = ref;\n      this.stencilMaskFront = this.stencilMaskBack = mask;\n    }\n  }\n  setStencilFuncFront(func, ref, mask) {\n    if (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask) {\n      const gl = this.gl;\n      gl.stencilFuncSeparate(gl.FRONT, this.glComparison[func], ref, mask);\n      this.stencilFuncFront = func;\n      this.stencilRefFront = ref;\n      this.stencilMaskFront = mask;\n    }\n  }\n  setStencilFuncBack(func, ref, mask) {\n    if (this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {\n      const gl = this.gl;\n      gl.stencilFuncSeparate(gl.BACK, this.glComparison[func], ref, mask);\n      this.stencilFuncBack = func;\n      this.stencilRefBack = ref;\n      this.stencilMaskBack = mask;\n    }\n  }\n  setStencilOperation(fail, zfail, zpass, writeMask) {\n    if (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass || this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {\n      this.gl.stencilOp(this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);\n      this.stencilFailFront = this.stencilFailBack = fail;\n      this.stencilZfailFront = this.stencilZfailBack = zfail;\n      this.stencilZpassFront = this.stencilZpassBack = zpass;\n    }\n    if (this.stencilWriteMaskFront !== writeMask || this.stencilWriteMaskBack !== writeMask) {\n      this.gl.stencilMask(writeMask);\n      this.stencilWriteMaskFront = writeMask;\n      this.stencilWriteMaskBack = writeMask;\n    }\n  }\n  setStencilOperationFront(fail, zfail, zpass, writeMask) {\n    if (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass) {\n      this.gl.stencilOpSeparate(this.gl.FRONT, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);\n      this.stencilFailFront = fail;\n      this.stencilZfailFront = zfail;\n      this.stencilZpassFront = zpass;\n    }\n    if (this.stencilWriteMaskFront !== writeMask) {\n      this.gl.stencilMaskSeparate(this.gl.FRONT, writeMask);\n      this.stencilWriteMaskFront = writeMask;\n    }\n  }\n  setStencilOperationBack(fail, zfail, zpass, writeMask) {\n    if (this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {\n      this.gl.stencilOpSeparate(this.gl.BACK, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);\n      this.stencilFailBack = fail;\n      this.stencilZfailBack = zfail;\n      this.stencilZpassBack = zpass;\n    }\n    if (this.stencilWriteMaskBack !== writeMask) {\n      this.gl.stencilMaskSeparate(this.gl.BACK, writeMask);\n      this.stencilWriteMaskBack = writeMask;\n    }\n  }\n  setBlendFunction(blendSrc, blendDst) {\n    if (this.blendSrc !== blendSrc || this.blendDst !== blendDst || this.separateAlphaBlend) {\n      this.gl.blendFunc(this.glBlendFunction[blendSrc], this.glBlendFunction[blendDst]);\n      this.blendSrc = blendSrc;\n      this.blendDst = blendDst;\n      this.separateAlphaBlend = false;\n    }\n  }\n  setBlendFunctionSeparate(blendSrc, blendDst, blendSrcAlpha, blendDstAlpha) {\n    if (this.blendSrc !== blendSrc || this.blendDst !== blendDst || this.blendSrcAlpha !== blendSrcAlpha || this.blendDstAlpha !== blendDstAlpha || !this.separateAlphaBlend) {\n      this.gl.blendFuncSeparate(this.glBlendFunction[blendSrc], this.glBlendFunction[blendDst], this.glBlendFunction[blendSrcAlpha], this.glBlendFunction[blendDstAlpha]);\n      this.blendSrc = blendSrc;\n      this.blendDst = blendDst;\n      this.blendSrcAlpha = blendSrcAlpha;\n      this.blendDstAlpha = blendDstAlpha;\n      this.separateAlphaBlend = true;\n    }\n  }\n  setBlendEquation(blendEquation) {\n    if (this.blendEquation !== blendEquation || this.separateAlphaEquation) {\n      this.gl.blendEquation(this.glBlendEquation[blendEquation]);\n      this.blendEquation = blendEquation;\n      this.separateAlphaEquation = false;\n    }\n  }\n  setBlendEquationSeparate(blendEquation, blendAlphaEquation) {\n    if (this.blendEquation !== blendEquation || this.blendAlphaEquation !== blendAlphaEquation || !this.separateAlphaEquation) {\n      this.gl.blendEquationSeparate(this.glBlendEquation[blendEquation], this.glBlendEquation[blendAlphaEquation]);\n      this.blendEquation = blendEquation;\n      this.blendAlphaEquation = blendAlphaEquation;\n      this.separateAlphaEquation = true;\n    }\n  }\n  setBlendColor(r, g, b, a) {\n    const c = this.blendColor;\n    if (r !== c.r || g !== c.g || b !== c.b || a !== c.a) {\n      this.gl.blendColor(r, g, b, a);\n      c.set(r, g, b, a);\n    }\n  }\n  setCullMode(cullMode) {\n    if (this.cullMode !== cullMode) {\n      if (cullMode === _constants_js__WEBPACK_IMPORTED_MODULE_2__.CULLFACE_NONE) {\n        this.gl.disable(this.gl.CULL_FACE);\n      } else {\n        if (this.cullMode === _constants_js__WEBPACK_IMPORTED_MODULE_2__.CULLFACE_NONE) {\n          this.gl.enable(this.gl.CULL_FACE);\n        }\n        const mode = this.glCull[cullMode];\n        if (this.cullFace !== mode) {\n          this.gl.cullFace(mode);\n          this.cullFace = mode;\n        }\n      }\n      this.cullMode = cullMode;\n    }\n  }\n  getCullMode() {\n    return this.cullMode;\n  }\n  setShader(shader) {\n    if (shader !== this.shader) {\n      if (shader.failed) {\n        return false;\n      } else if (!shader.ready && !shader.impl.postLink(this, shader)) {\n        shader.failed = true;\n        return false;\n      }\n      this.shader = shader;\n      this.gl.useProgram(shader.impl.glProgram);\n      this.attributesInvalidated = true;\n    }\n    return true;\n  }\n  getHdrFormat(preferLargest, renderable, updatable, filterable) {\n    const f16Valid = this.extTextureHalfFloat && (!renderable || this.textureHalfFloatRenderable) && (!updatable || this.textureHalfFloatUpdatable) && (!filterable || this.extTextureHalfFloatLinear);\n    const f32Valid = this.extTextureFloat && (!renderable || this.textureFloatRenderable) && (!filterable || this.extTextureFloatLinear);\n    if (f16Valid && f32Valid) {\n      return preferLargest ? _constants_js__WEBPACK_IMPORTED_MODULE_2__.PIXELFORMAT_RGBA32F : _constants_js__WEBPACK_IMPORTED_MODULE_2__.PIXELFORMAT_RGBA16F;\n    } else if (f16Valid) {\n      return _constants_js__WEBPACK_IMPORTED_MODULE_2__.PIXELFORMAT_RGBA16F;\n    } else if (f32Valid) {\n      return _constants_js__WEBPACK_IMPORTED_MODULE_2__.PIXELFORMAT_RGBA32F;\n    }\n    return null;\n  }\n  clearVertexArrayObjectCache() {\n    const gl = this.gl;\n    this._vaoMap.forEach((item, key, mapObj) => {\n      gl.deleteVertexArray(item);\n    });\n    this._vaoMap.clear();\n  }\n  get width() {\n    return this.gl.drawingBufferWidth || this.canvas.width;\n  }\n  get height() {\n    return this.gl.drawingBufferHeight || this.canvas.height;\n  }\n  set fullscreen(fullscreen) {\n    if (fullscreen) {\n      const canvas = this.gl.canvas;\n      canvas.requestFullscreen();\n    } else {\n      document.exitFullscreen();\n    }\n  }\n  get fullscreen() {\n    return !!document.fullscreenElement;\n  }\n  get textureFloatHighPrecision() {\n    if (this._textureFloatHighPrecision === undefined) {\n      this._textureFloatHighPrecision = testTextureFloatHighPrecision(this);\n    }\n    return this._textureFloatHighPrecision;\n  }\n  get textureHalfFloatUpdatable() {\n    if (this._textureHalfFloatUpdatable === undefined) {\n      if (this.webgl2) {\n        this._textureHalfFloatUpdatable = true;\n      } else {\n        this._textureHalfFloatUpdatable = testTextureHalfFloatUpdatable(this.gl, this.extTextureHalfFloat.HALF_FLOAT_OES);\n      }\n    }\n    return this._textureHalfFloatUpdatable;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-graphics-device.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-index-buffer.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-index-buffer.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WebglIndexBuffer\": () => (/* binding */ WebglIndexBuffer)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _webgl_buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgl-buffer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-buffer.js\");\n\n\n\nclass WebglIndexBuffer extends _webgl_buffer_js__WEBPACK_IMPORTED_MODULE_0__.WebglBuffer {\n  constructor(indexBuffer) {\n    super();\n    const gl = indexBuffer.device.gl;\n    const format = indexBuffer.format;\n    if (format === _constants_js__WEBPACK_IMPORTED_MODULE_1__.INDEXFORMAT_UINT8) {\n      this.glFormat = gl.UNSIGNED_BYTE;\n    } else if (format === _constants_js__WEBPACK_IMPORTED_MODULE_1__.INDEXFORMAT_UINT16) {\n      this.glFormat = gl.UNSIGNED_SHORT;\n    } else if (format === _constants_js__WEBPACK_IMPORTED_MODULE_1__.INDEXFORMAT_UINT32) {\n      this.glFormat = gl.UNSIGNED_INT;\n    }\n  }\n  unlock(indexBuffer) {\n    const device = indexBuffer.device;\n    super.unlock(device, indexBuffer.usage, device.gl.ELEMENT_ARRAY_BUFFER, indexBuffer.storage);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-index-buffer.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-render-target.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-render-target.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WebglRenderTarget\": () => (/* binding */ WebglRenderTarget)\n/* harmony export */ });\n\n\nclass WebglRenderTarget {\n  constructor() {\n    this._glFrameBuffer = null;\n    this._glDepthBuffer = null;\n    this._glResolveFrameBuffer = null;\n    this._glMsaaColorBuffer = null;\n    this._glMsaaDepthBuffer = null;\n  }\n  destroy(device) {\n    const gl = device.gl;\n    if (this._glFrameBuffer) {\n      gl.deleteFramebuffer(this._glFrameBuffer);\n      this._glFrameBuffer = null;\n    }\n    if (this._glDepthBuffer) {\n      gl.deleteRenderbuffer(this._glDepthBuffer);\n      this._glDepthBuffer = null;\n    }\n    if (this._glResolveFrameBuffer) {\n      gl.deleteFramebuffer(this._glResolveFrameBuffer);\n      this._glResolveFrameBuffer = null;\n    }\n    if (this._glMsaaColorBuffer) {\n      gl.deleteRenderbuffer(this._glMsaaColorBuffer);\n      this._glMsaaColorBuffer = null;\n    }\n    if (this._glMsaaDepthBuffer) {\n      gl.deleteRenderbuffer(this._glMsaaDepthBuffer);\n      this._glMsaaDepthBuffer = null;\n    }\n  }\n  get initialized() {\n    return this._glFrameBuffer !== null;\n  }\n  init(device, target) {\n    const gl = device.gl;\n    this._glFrameBuffer = gl.createFramebuffer();\n    device.setFramebuffer(this._glFrameBuffer);\n    const colorBuffer = target._colorBuffer;\n    if (colorBuffer) {\n      if (!colorBuffer.impl._glTexture) {\n        colorBuffer._width = Math.min(colorBuffer.width, device.maxRenderBufferSize);\n        colorBuffer._height = Math.min(colorBuffer.height, device.maxRenderBufferSize);\n        device.setTexture(colorBuffer, 0);\n      }\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, colorBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, colorBuffer.impl._glTexture, 0);\n    }\n    const depthBuffer = target._depthBuffer;\n    if (depthBuffer) {\n      if (!depthBuffer.impl._glTexture) {\n        depthBuffer._width = Math.min(depthBuffer.width, device.maxRenderBufferSize);\n        depthBuffer._height = Math.min(depthBuffer.height, device.maxRenderBufferSize);\n        device.setTexture(depthBuffer, 0);\n      }\n      if (target._stencil) {\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, target._depthBuffer.impl._glTexture, 0);\n      } else {\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, target._depthBuffer.impl._glTexture, 0);\n      }\n    } else if (target._depth) {\n      const willRenderMsaa = target._samples > 1 && device.webgl2;\n      if (!willRenderMsaa) {\n        if (!this._glDepthBuffer) {\n          this._glDepthBuffer = gl.createRenderbuffer();\n        }\n        gl.bindRenderbuffer(gl.RENDERBUFFER, this._glDepthBuffer);\n        if (target._stencil) {\n          gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, target.width, target.height);\n          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this._glDepthBuffer);\n        } else {\n          const depthFormat = device.webgl2 ? gl.DEPTH_COMPONENT32F : gl.DEPTH_COMPONENT16;\n          gl.renderbufferStorage(gl.RENDERBUFFER, depthFormat, target.width, target.height);\n          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._glDepthBuffer);\n        }\n        gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n      }\n    }\n    if (device.webgl2 && target._samples > 1) {\n      this._glResolveFrameBuffer = this._glFrameBuffer;\n      this._glFrameBuffer = gl.createFramebuffer();\n      device.setFramebuffer(this._glFrameBuffer);\n      if (colorBuffer) {\n        if (!this._glMsaaColorBuffer) {\n          this._glMsaaColorBuffer = gl.createRenderbuffer();\n        }\n        gl.bindRenderbuffer(gl.RENDERBUFFER, this._glMsaaColorBuffer);\n        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, colorBuffer.impl._glInternalFormat, target.width, target.height);\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, this._glMsaaColorBuffer);\n      }\n      if (target._depth) {\n        if (!this._glMsaaDepthBuffer) {\n          this._glMsaaDepthBuffer = gl.createRenderbuffer();\n        }\n        gl.bindRenderbuffer(gl.RENDERBUFFER, this._glMsaaDepthBuffer);\n        if (target._stencil) {\n          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, gl.DEPTH24_STENCIL8, target.width, target.height);\n          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this._glMsaaDepthBuffer);\n        } else {\n          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, gl.DEPTH_COMPONENT32F, target.width, target.height);\n          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._glMsaaDepthBuffer);\n        }\n      }\n    }\n  }\n  _checkFbo(device, target, type = '') {\n    const gl = device.gl;\n    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n    switch (status) {\n      case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n        break;\n      case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n        break;\n      case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n        break;\n      case gl.FRAMEBUFFER_UNSUPPORTED:\n        break;\n    }\n  }\n  loseContext() {\n    this._glFrameBuffer = null;\n    this._glDepthBuffer = null;\n    this._glResolveFrameBuffer = null;\n    this._glMsaaColorBuffer = null;\n    this._glMsaaDepthBuffer = null;\n  }\n  resolve(device, target, color, depth) {\n    if (device.webgl2) {\n      const gl = device.gl;\n      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._glFrameBuffer);\n      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._glResolveFrameBuffer);\n      gl.blitFramebuffer(0, 0, target.width, target.height, 0, 0, target.width, target.height, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0), gl.NEAREST);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, this._glFrameBuffer);\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-render-target.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-shader-input.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-shader-input.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WebglShaderInput\": () => (/* binding */ WebglShaderInput)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../version.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/version.js\");\n\n\n\nclass WebglShaderInput {\n  constructor(graphicsDevice, name, type, locationId) {\n    this.locationId = locationId;\n    this.scopeId = graphicsDevice.scope.resolve(name);\n    this.version = new _version_js__WEBPACK_IMPORTED_MODULE_0__.Version();\n    if (name.substring(name.length - 3) === \"[0]\") {\n      switch (type) {\n        case _constants_js__WEBPACK_IMPORTED_MODULE_1__.UNIFORMTYPE_FLOAT:\n          type = _constants_js__WEBPACK_IMPORTED_MODULE_1__.UNIFORMTYPE_FLOATARRAY;\n          break;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_1__.UNIFORMTYPE_VEC2:\n          type = _constants_js__WEBPACK_IMPORTED_MODULE_1__.UNIFORMTYPE_VEC2ARRAY;\n          break;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_1__.UNIFORMTYPE_VEC3:\n          type = _constants_js__WEBPACK_IMPORTED_MODULE_1__.UNIFORMTYPE_VEC3ARRAY;\n          break;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_1__.UNIFORMTYPE_VEC4:\n          type = _constants_js__WEBPACK_IMPORTED_MODULE_1__.UNIFORMTYPE_VEC4ARRAY;\n          break;\n      }\n    }\n    this.dataType = type;\n    this.value = [null, null, null, null];\n    this.array = [];\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-shader-input.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-shader.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-shader.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WebglShader\": () => (/* binding */ WebglShader)\n/* harmony export */ });\n/* harmony import */ var _webgl_shader_input_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./webgl-shader-input.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-shader-input.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _device_cache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../device-cache.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/device-cache.js\");\n\n\n\n\n\n\nconst _vertexShaderBuiltins = ['gl_VertexID', 'gl_InstanceID', 'gl_DrawID', 'gl_BaseVertex', 'gl_BaseInstance'];\nclass CompiledShaderCache {\n  constructor() {\n    this.map = new Map();\n  }\n  destroy(device) {\n    this.map.forEach(shader => {\n      device.gl.deleteShader(shader);\n    });\n  }\n  loseContext(device) {\n    this.map.clear();\n  }\n}\nconst _vertexShaderCache = new _device_cache_js__WEBPACK_IMPORTED_MODULE_0__.DeviceCache();\nconst _fragmentShaderCache = new _device_cache_js__WEBPACK_IMPORTED_MODULE_0__.DeviceCache();\nclass WebglShader {\n  constructor(shader) {\n    this.compileDuration = 0;\n    this.init();\n    this.compileAndLink(shader.device, shader);\n    shader.device.shaders.push(shader);\n  }\n  destroy(shader) {\n    if (this.glProgram) {\n      shader.device.gl.deleteProgram(this.glProgram);\n      this.glProgram = null;\n    }\n  }\n  init() {\n    this.uniforms = [];\n    this.samplers = [];\n    this.attributes = [];\n    this.glProgram = null;\n    this.glVertexShader = null;\n    this.glFragmentShader = null;\n  }\n  loseContext() {\n    this.init();\n  }\n  restoreContext(device, shader) {\n    this.compileAndLink(device, shader);\n  }\n  compileAndLink(device, shader) {\n    const definition = shader.definition;\n    const glVertexShader = this._compileShaderSource(device, definition.vshader, true);\n    const glFragmentShader = this._compileShaderSource(device, definition.fshader, false);\n    const gl = device.gl;\n    const glProgram = gl.createProgram();\n    gl.attachShader(glProgram, glVertexShader);\n    gl.attachShader(glProgram, glFragmentShader);\n    const attrs = definition.attributes;\n    if (device.webgl2 && definition.useTransformFeedback) {\n      const outNames = [];\n      for (const attr in attrs) {\n        if (attrs.hasOwnProperty(attr)) {\n          outNames.push(\"out_\" + attr);\n        }\n      }\n      gl.transformFeedbackVaryings(glProgram, outNames, gl.INTERLEAVED_ATTRIBS);\n    }\n    for (const attr in attrs) {\n      if (attrs.hasOwnProperty(attr)) {\n        const semantic = attrs[attr];\n        const loc = _constants_js__WEBPACK_IMPORTED_MODULE_1__.semanticToLocation[semantic];\n        gl.bindAttribLocation(glProgram, loc, attr);\n      }\n    }\n    gl.linkProgram(glProgram);\n    this.glVertexShader = glVertexShader;\n    this.glFragmentShader = glFragmentShader;\n    this.glProgram = glProgram;\n  }\n  _compileShaderSource(device, src, isVertexShader) {\n    const gl = device.gl;\n    const shaderDeviceCache = isVertexShader ? _vertexShaderCache : _fragmentShaderCache;\n    const shaderCache = shaderDeviceCache.get(device, () => {\n      return new CompiledShaderCache();\n    });\n    let glShader = shaderCache.map.get(src);\n    if (!glShader) {\n      glShader = gl.createShader(isVertexShader ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);\n      gl.shaderSource(glShader, src);\n      gl.compileShader(glShader);\n      shaderCache.map.set(src, glShader);\n    }\n    return glShader;\n  }\n  postLink(device, shader) {\n    const gl = device.gl;\n    const glProgram = this.glProgram;\n    const definition = shader.definition;\n    if (!this._isCompiled(device, shader, this.glVertexShader, definition.vshader, \"vertex\")) return false;\n    if (!this._isCompiled(device, shader, this.glFragmentShader, definition.fshader, \"fragment\")) return false;\n    if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {\n      const message = \"Failed to link shader program. Error: \" + gl.getProgramInfoLog(glProgram);\n      console.error(message);\n      return false;\n    }\n    let i = 0;\n    const numAttributes = gl.getProgramParameter(glProgram, gl.ACTIVE_ATTRIBUTES);\n    while (i < numAttributes) {\n      const info = gl.getActiveAttrib(glProgram, i++);\n      const location = gl.getAttribLocation(glProgram, info.name);\n      if (_vertexShaderBuiltins.indexOf(info.name) !== -1) continue;\n      if (definition.attributes[info.name] === undefined) {\n        console.error(`Vertex shader attribute \"${info.name}\" is not mapped to a semantic in shader definition.`);\n      }\n      const shaderInput = new _webgl_shader_input_js__WEBPACK_IMPORTED_MODULE_2__.WebglShaderInput(device, definition.attributes[info.name], device.pcUniformType[info.type], location);\n      this.attributes.push(shaderInput);\n    }\n    i = 0;\n    const numUniforms = gl.getProgramParameter(glProgram, gl.ACTIVE_UNIFORMS);\n    while (i < numUniforms) {\n      const info = gl.getActiveUniform(glProgram, i++);\n      const location = gl.getUniformLocation(glProgram, info.name);\n      const shaderInput = new _webgl_shader_input_js__WEBPACK_IMPORTED_MODULE_2__.WebglShaderInput(device, info.name, device.pcUniformType[info.type], location);\n      if (info.type === gl.SAMPLER_2D || info.type === gl.SAMPLER_CUBE || device.webgl2 && (info.type === gl.SAMPLER_2D_SHADOW || info.type === gl.SAMPLER_CUBE_SHADOW || info.type === gl.SAMPLER_3D)) {\n        this.samplers.push(shaderInput);\n      } else {\n        this.uniforms.push(shaderInput);\n      }\n    }\n    shader.ready = true;\n    return true;\n  }\n  _isCompiled(device, shader, glShader, source, shaderType) {\n    const gl = device.gl;\n    if (!gl.getShaderParameter(glShader, gl.COMPILE_STATUS)) {\n      const infoLog = gl.getShaderInfoLog(glShader);\n      const [code, error] = this._processError(source, infoLog);\n      const message = `Failed to compile ${shaderType} shader:\\n\\n${infoLog}\\n${code}`;\n      console.error(message);\n      return false;\n    }\n    return true;\n  }\n  _processError(src, infoLog) {\n    const error = {};\n    let code = '';\n    if (src) {\n      const lines = src.split('\\n');\n      let from = 0;\n      let to = lines.length;\n      if (infoLog && infoLog.startsWith('ERROR:')) {\n        const match = infoLog.match(/^ERROR:\\s([0-9]+):([0-9]+):\\s*(.+)/);\n        if (match) {\n          error.message = match[3];\n          error.line = parseInt(match[2], 10);\n          from = Math.max(0, error.line - 6);\n          to = Math.min(lines.length, error.line + 5);\n        }\n      }\n      for (let i = from; i < to; i++) {\n        code += i + 1 + \":\\t\" + lines[i] + '\\n';\n      }\n      error.source = src;\n    }\n    return [code, error];\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-shader.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-texture.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-texture.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WebglTexture\": () => (/* binding */ WebglTexture)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n\n\n\nfunction downsampleImage(image, size) {\n  const srcW = image.width;\n  const srcH = image.height;\n  if (srcW > size || srcH > size) {\n    const scale = size / Math.max(srcW, srcH);\n    const dstW = Math.floor(srcW * scale);\n    const dstH = Math.floor(srcH * scale);\n    const canvas = document.createElement('canvas');\n    canvas.width = dstW;\n    canvas.height = dstH;\n    const context = canvas.getContext('2d');\n    context.drawImage(image, 0, 0, srcW, srcH, 0, 0, dstW, dstH);\n    return canvas;\n  }\n  return image;\n}\nclass WebglTexture {\n  constructor() {\n    this._glTexture = null;\n    this._glTarget = void 0;\n    this._glFormat = void 0;\n    this._glInternalFormat = void 0;\n    this._glPixelType = void 0;\n  }\n  destroy(device) {\n    if (this._glTexture) {\n      for (let i = 0; i < device.textureUnits.length; i++) {\n        const textureUnit = device.textureUnits[i];\n        for (let j = 0; j < textureUnit.length; j++) {\n          if (textureUnit[j] === this._glTexture) {\n            textureUnit[j] = null;\n          }\n        }\n      }\n      device.gl.deleteTexture(this._glTexture);\n      this._glTexture = null;\n    }\n  }\n  loseContext() {\n    this._glTexture = null;\n  }\n  initialize(device, texture) {\n    const gl = device.gl;\n    this._glTexture = gl.createTexture();\n    this._glTarget = texture._cubemap ? gl.TEXTURE_CUBE_MAP : texture._volume ? gl.TEXTURE_3D : gl.TEXTURE_2D;\n    switch (texture._format) {\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_A8:\n        this._glFormat = gl.ALPHA;\n        this._glInternalFormat = gl.ALPHA;\n        this._glPixelType = gl.UNSIGNED_BYTE;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_L8:\n        this._glFormat = gl.LUMINANCE;\n        this._glInternalFormat = gl.LUMINANCE;\n        this._glPixelType = gl.UNSIGNED_BYTE;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_LA8:\n        this._glFormat = gl.LUMINANCE_ALPHA;\n        this._glInternalFormat = gl.LUMINANCE_ALPHA;\n        this._glPixelType = gl.UNSIGNED_BYTE;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGB565:\n        this._glFormat = gl.RGB;\n        this._glInternalFormat = gl.RGB;\n        this._glPixelType = gl.UNSIGNED_SHORT_5_6_5;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA5551:\n        this._glFormat = gl.RGBA;\n        this._glInternalFormat = gl.RGBA;\n        this._glPixelType = gl.UNSIGNED_SHORT_5_5_5_1;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA4:\n        this._glFormat = gl.RGBA;\n        this._glInternalFormat = gl.RGBA;\n        this._glPixelType = gl.UNSIGNED_SHORT_4_4_4_4;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGB8:\n        this._glFormat = gl.RGB;\n        this._glInternalFormat = device.webgl2 ? gl.RGB8 : gl.RGB;\n        this._glPixelType = gl.UNSIGNED_BYTE;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA8:\n        this._glFormat = gl.RGBA;\n        this._glInternalFormat = device.webgl2 ? gl.RGBA8 : gl.RGBA;\n        this._glPixelType = gl.UNSIGNED_BYTE;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_DXT1:\n        this._glFormat = gl.RGB;\n        this._glInternalFormat = device.extCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_DXT3:\n        this._glFormat = gl.RGBA;\n        this._glInternalFormat = device.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_DXT5:\n        this._glFormat = gl.RGBA;\n        this._glInternalFormat = device.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_ETC1:\n        this._glFormat = gl.RGB;\n        this._glInternalFormat = device.extCompressedTextureETC1.COMPRESSED_RGB_ETC1_WEBGL;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_PVRTC_2BPP_RGB_1:\n        this._glFormat = gl.RGB;\n        this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_PVRTC_2BPP_RGBA_1:\n        this._glFormat = gl.RGBA;\n        this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_PVRTC_4BPP_RGB_1:\n        this._glFormat = gl.RGB;\n        this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_PVRTC_4BPP_RGBA_1:\n        this._glFormat = gl.RGBA;\n        this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_ETC2_RGB:\n        this._glFormat = gl.RGB;\n        this._glInternalFormat = device.extCompressedTextureETC.COMPRESSED_RGB8_ETC2;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_ETC2_RGBA:\n        this._glFormat = gl.RGBA;\n        this._glInternalFormat = device.extCompressedTextureETC.COMPRESSED_RGBA8_ETC2_EAC;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_ASTC_4x4:\n        this._glFormat = gl.RGBA;\n        this._glInternalFormat = device.extCompressedTextureASTC.COMPRESSED_RGBA_ASTC_4x4_KHR;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_ATC_RGB:\n        this._glFormat = gl.RGB;\n        this._glInternalFormat = device.extCompressedTextureATC.COMPRESSED_RGB_ATC_WEBGL;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_ATC_RGBA:\n        this._glFormat = gl.RGBA;\n        this._glInternalFormat = device.extCompressedTextureATC.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGB16F:\n        this._glFormat = gl.RGB;\n        if (device.webgl2) {\n          this._glInternalFormat = gl.RGB16F;\n          this._glPixelType = gl.HALF_FLOAT;\n        } else {\n          this._glInternalFormat = gl.RGB;\n          this._glPixelType = device.extTextureHalfFloat.HALF_FLOAT_OES;\n        }\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA16F:\n        this._glFormat = gl.RGBA;\n        if (device.webgl2) {\n          this._glInternalFormat = gl.RGBA16F;\n          this._glPixelType = gl.HALF_FLOAT;\n        } else {\n          this._glInternalFormat = gl.RGBA;\n          this._glPixelType = device.extTextureHalfFloat.HALF_FLOAT_OES;\n        }\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGB32F:\n        this._glFormat = gl.RGB;\n        if (device.webgl2) {\n          this._glInternalFormat = gl.RGB32F;\n        } else {\n          this._glInternalFormat = gl.RGB;\n        }\n        this._glPixelType = gl.FLOAT;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA32F:\n        this._glFormat = gl.RGBA;\n        if (device.webgl2) {\n          this._glInternalFormat = gl.RGBA32F;\n        } else {\n          this._glInternalFormat = gl.RGBA;\n        }\n        this._glPixelType = gl.FLOAT;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_R32F:\n        this._glFormat = gl.RED;\n        this._glInternalFormat = gl.R32F;\n        this._glPixelType = gl.FLOAT;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_DEPTH:\n        if (device.webgl2) {\n          this._glFormat = gl.DEPTH_COMPONENT;\n          this._glInternalFormat = gl.DEPTH_COMPONENT32F;\n          this._glPixelType = gl.FLOAT;\n        } else {\n          this._glFormat = gl.DEPTH_COMPONENT;\n          this._glInternalFormat = gl.DEPTH_COMPONENT;\n          this._glPixelType = gl.UNSIGNED_SHORT;\n        }\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_DEPTHSTENCIL:\n        this._glFormat = gl.DEPTH_STENCIL;\n        if (device.webgl2) {\n          this._glInternalFormat = gl.DEPTH24_STENCIL8;\n          this._glPixelType = gl.UNSIGNED_INT_24_8;\n        } else {\n          this._glInternalFormat = gl.DEPTH_STENCIL;\n          this._glPixelType = device.extDepthTexture.UNSIGNED_INT_24_8_WEBGL;\n        }\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_111110F:\n        this._glFormat = gl.RGB;\n        this._glInternalFormat = gl.R11F_G11F_B10F;\n        this._glPixelType = gl.UNSIGNED_INT_10F_11F_11F_REV;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_SRGB:\n        this._glFormat = gl.RGB;\n        this._glInternalFormat = gl.SRGB8;\n        this._glPixelType = gl.UNSIGNED_BYTE;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_SRGBA:\n        this._glFormat = gl.RGBA;\n        this._glInternalFormat = gl.SRGB8_ALPHA8;\n        this._glPixelType = gl.UNSIGNED_BYTE;\n        break;\n    }\n  }\n  upload(device, texture) {\n    const gl = device.gl;\n    if (!texture._needsUpload && (texture._needsMipmapsUpload && texture._mipmapsUploaded || !texture.pot)) return;\n    let mipLevel = 0;\n    let mipObject;\n    let resMult;\n    const requiredMipLevels = Math.log2(Math.max(texture._width, texture._height)) + 1;\n    while (texture._levels[mipLevel] || mipLevel === 0) {\n      if (!texture._needsUpload && mipLevel === 0) {\n        mipLevel++;\n        continue;\n      } else if (mipLevel && (!texture._needsMipmapsUpload || !texture._mipmaps)) {\n        break;\n      }\n      mipObject = texture._levels[mipLevel];\n      if (mipLevel === 1 && !texture._compressed && texture._levels.length < requiredMipLevels) {\n        gl.generateMipmap(this._glTarget);\n        texture._mipmapsUploaded = true;\n      }\n      if (texture._cubemap) {\n        let face;\n        if (device._isBrowserInterface(mipObject[0])) {\n          for (face = 0; face < 6; face++) {\n            if (!texture._levelsUpdated[0][face]) continue;\n            let src = mipObject[face];\n            if (device._isImageBrowserInterface(src)) {\n              if (src.width > device.maxCubeMapSize || src.height > device.maxCubeMapSize) {\n                src = downsampleImage(src, device.maxCubeMapSize);\n                if (mipLevel === 0) {\n                  texture._width = src.width;\n                  texture._height = src.height;\n                }\n              }\n            }\n            device.setUnpackFlipY(false);\n            device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);\n            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, this._glFormat, this._glPixelType, src);\n          }\n        } else {\n          resMult = 1 / Math.pow(2, mipLevel);\n          for (face = 0; face < 6; face++) {\n            if (!texture._levelsUpdated[0][face]) continue;\n            const texData = mipObject[face];\n            if (texture._compressed) {\n              gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, texData);\n            } else {\n              device.setUnpackFlipY(false);\n              device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);\n              gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, this._glFormat, this._glPixelType, texData);\n            }\n          }\n        }\n      } else if (texture._volume) {\n        resMult = 1 / Math.pow(2, mipLevel);\n        if (texture._compressed) {\n          gl.compressedTexImage3D(gl.TEXTURE_3D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, mipObject);\n        } else {\n          device.setUnpackFlipY(false);\n          device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);\n          gl.texImage3D(gl.TEXTURE_3D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, this._glFormat, this._glPixelType, mipObject);\n        }\n      } else {\n        if (device._isBrowserInterface(mipObject)) {\n          if (device._isImageBrowserInterface(mipObject)) {\n            if (mipObject.width > device.maxTextureSize || mipObject.height > device.maxTextureSize) {\n              mipObject = downsampleImage(mipObject, device.maxTextureSize);\n              if (mipLevel === 0) {\n                texture._width = mipObject.width;\n                texture._height = mipObject.height;\n              }\n            }\n          }\n          device.setUnpackFlipY(texture._flipY);\n          device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);\n          gl.texImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, this._glFormat, this._glPixelType, mipObject);\n        } else {\n          resMult = 1 / Math.pow(2, mipLevel);\n          if (texture._compressed) {\n            gl.compressedTexImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), 0, mipObject);\n          } else {\n            device.setUnpackFlipY(false);\n            device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);\n            gl.texImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, this._glFormat, this._glPixelType, mipObject);\n          }\n        }\n        if (mipLevel === 0) {\n          texture._mipmapsUploaded = false;\n        } else {\n          texture._mipmapsUploaded = true;\n        }\n      }\n      mipLevel++;\n    }\n    if (texture._needsUpload) {\n      if (texture._cubemap) {\n        for (let i = 0; i < 6; i++) texture._levelsUpdated[0][i] = false;\n      } else {\n        texture._levelsUpdated[0] = false;\n      }\n    }\n    if (!texture._compressed && texture._mipmaps && texture._needsMipmapsUpload && (texture.pot || device.webgl2) && texture._levels.length === 1) {\n      gl.generateMipmap(this._glTarget);\n      texture._mipmapsUploaded = true;\n    }\n    if (texture._gpuSize) {\n      texture.adjustVramSizeTracking(device._vram, -texture._gpuSize);\n    }\n    texture._gpuSize = texture.gpuSize;\n    texture.adjustVramSizeTracking(device._vram, texture._gpuSize);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-texture.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-vertex-buffer.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-vertex-buffer.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WebglVertexBuffer\": () => (/* binding */ WebglVertexBuffer)\n/* harmony export */ });\n/* harmony import */ var _webgl_buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgl-buffer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-buffer.js\");\n\n\nclass WebglVertexBuffer extends _webgl_buffer_js__WEBPACK_IMPORTED_MODULE_0__.WebglBuffer {\n  constructor(...args) {\n    super(...args);\n    this.vao = null;\n  }\n  destroy(device) {\n    super.destroy(device);\n    device.boundVao = null;\n    device.gl.bindVertexArray(null);\n  }\n  loseContext() {\n    super.loseContext();\n    this.vao = null;\n  }\n  unlock(vertexBuffer) {\n    const device = vertexBuffer.device;\n    super.unlock(device, vertexBuffer.usage, device.gl.ARRAY_BUFFER, vertexBuffer.storage);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/webgl/webgl-vertex-buffer.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/input/constants.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/input/constants.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ACTION_GAMEPAD\": () => (/* binding */ ACTION_GAMEPAD),\n/* harmony export */   \"ACTION_KEYBOARD\": () => (/* binding */ ACTION_KEYBOARD),\n/* harmony export */   \"ACTION_MOUSE\": () => (/* binding */ ACTION_MOUSE),\n/* harmony export */   \"AXIS_KEY\": () => (/* binding */ AXIS_KEY),\n/* harmony export */   \"AXIS_MOUSE_X\": () => (/* binding */ AXIS_MOUSE_X),\n/* harmony export */   \"AXIS_MOUSE_Y\": () => (/* binding */ AXIS_MOUSE_Y),\n/* harmony export */   \"AXIS_PAD_L_X\": () => (/* binding */ AXIS_PAD_L_X),\n/* harmony export */   \"AXIS_PAD_L_Y\": () => (/* binding */ AXIS_PAD_L_Y),\n/* harmony export */   \"AXIS_PAD_R_X\": () => (/* binding */ AXIS_PAD_R_X),\n/* harmony export */   \"AXIS_PAD_R_Y\": () => (/* binding */ AXIS_PAD_R_Y),\n/* harmony export */   \"EVENT_KEYDOWN\": () => (/* binding */ EVENT_KEYDOWN),\n/* harmony export */   \"EVENT_KEYUP\": () => (/* binding */ EVENT_KEYUP),\n/* harmony export */   \"EVENT_MOUSEDOWN\": () => (/* binding */ EVENT_MOUSEDOWN),\n/* harmony export */   \"EVENT_MOUSEMOVE\": () => (/* binding */ EVENT_MOUSEMOVE),\n/* harmony export */   \"EVENT_MOUSEUP\": () => (/* binding */ EVENT_MOUSEUP),\n/* harmony export */   \"EVENT_MOUSEWHEEL\": () => (/* binding */ EVENT_MOUSEWHEEL),\n/* harmony export */   \"EVENT_SELECT\": () => (/* binding */ EVENT_SELECT),\n/* harmony export */   \"EVENT_SELECTEND\": () => (/* binding */ EVENT_SELECTEND),\n/* harmony export */   \"EVENT_SELECTSTART\": () => (/* binding */ EVENT_SELECTSTART),\n/* harmony export */   \"EVENT_TOUCHCANCEL\": () => (/* binding */ EVENT_TOUCHCANCEL),\n/* harmony export */   \"EVENT_TOUCHEND\": () => (/* binding */ EVENT_TOUCHEND),\n/* harmony export */   \"EVENT_TOUCHMOVE\": () => (/* binding */ EVENT_TOUCHMOVE),\n/* harmony export */   \"EVENT_TOUCHSTART\": () => (/* binding */ EVENT_TOUCHSTART),\n/* harmony export */   \"KEY_0\": () => (/* binding */ KEY_0),\n/* harmony export */   \"KEY_1\": () => (/* binding */ KEY_1),\n/* harmony export */   \"KEY_2\": () => (/* binding */ KEY_2),\n/* harmony export */   \"KEY_3\": () => (/* binding */ KEY_3),\n/* harmony export */   \"KEY_4\": () => (/* binding */ KEY_4),\n/* harmony export */   \"KEY_5\": () => (/* binding */ KEY_5),\n/* harmony export */   \"KEY_6\": () => (/* binding */ KEY_6),\n/* harmony export */   \"KEY_7\": () => (/* binding */ KEY_7),\n/* harmony export */   \"KEY_8\": () => (/* binding */ KEY_8),\n/* harmony export */   \"KEY_9\": () => (/* binding */ KEY_9),\n/* harmony export */   \"KEY_A\": () => (/* binding */ KEY_A),\n/* harmony export */   \"KEY_ADD\": () => (/* binding */ KEY_ADD),\n/* harmony export */   \"KEY_ALT\": () => (/* binding */ KEY_ALT),\n/* harmony export */   \"KEY_B\": () => (/* binding */ KEY_B),\n/* harmony export */   \"KEY_BACKSPACE\": () => (/* binding */ KEY_BACKSPACE),\n/* harmony export */   \"KEY_BACK_SLASH\": () => (/* binding */ KEY_BACK_SLASH),\n/* harmony export */   \"KEY_C\": () => (/* binding */ KEY_C),\n/* harmony export */   \"KEY_CAPS_LOCK\": () => (/* binding */ KEY_CAPS_LOCK),\n/* harmony export */   \"KEY_CLOSE_BRACKET\": () => (/* binding */ KEY_CLOSE_BRACKET),\n/* harmony export */   \"KEY_COMMA\": () => (/* binding */ KEY_COMMA),\n/* harmony export */   \"KEY_CONTEXT_MENU\": () => (/* binding */ KEY_CONTEXT_MENU),\n/* harmony export */   \"KEY_CONTROL\": () => (/* binding */ KEY_CONTROL),\n/* harmony export */   \"KEY_D\": () => (/* binding */ KEY_D),\n/* harmony export */   \"KEY_DECIMAL\": () => (/* binding */ KEY_DECIMAL),\n/* harmony export */   \"KEY_DELETE\": () => (/* binding */ KEY_DELETE),\n/* harmony export */   \"KEY_DIVIDE\": () => (/* binding */ KEY_DIVIDE),\n/* harmony export */   \"KEY_DOWN\": () => (/* binding */ KEY_DOWN),\n/* harmony export */   \"KEY_E\": () => (/* binding */ KEY_E),\n/* harmony export */   \"KEY_END\": () => (/* binding */ KEY_END),\n/* harmony export */   \"KEY_ENTER\": () => (/* binding */ KEY_ENTER),\n/* harmony export */   \"KEY_EQUAL\": () => (/* binding */ KEY_EQUAL),\n/* harmony export */   \"KEY_ESCAPE\": () => (/* binding */ KEY_ESCAPE),\n/* harmony export */   \"KEY_F\": () => (/* binding */ KEY_F),\n/* harmony export */   \"KEY_F1\": () => (/* binding */ KEY_F1),\n/* harmony export */   \"KEY_F10\": () => (/* binding */ KEY_F10),\n/* harmony export */   \"KEY_F11\": () => (/* binding */ KEY_F11),\n/* harmony export */   \"KEY_F12\": () => (/* binding */ KEY_F12),\n/* harmony export */   \"KEY_F2\": () => (/* binding */ KEY_F2),\n/* harmony export */   \"KEY_F3\": () => (/* binding */ KEY_F3),\n/* harmony export */   \"KEY_F4\": () => (/* binding */ KEY_F4),\n/* harmony export */   \"KEY_F5\": () => (/* binding */ KEY_F5),\n/* harmony export */   \"KEY_F6\": () => (/* binding */ KEY_F6),\n/* harmony export */   \"KEY_F7\": () => (/* binding */ KEY_F7),\n/* harmony export */   \"KEY_F8\": () => (/* binding */ KEY_F8),\n/* harmony export */   \"KEY_F9\": () => (/* binding */ KEY_F9),\n/* harmony export */   \"KEY_G\": () => (/* binding */ KEY_G),\n/* harmony export */   \"KEY_H\": () => (/* binding */ KEY_H),\n/* harmony export */   \"KEY_HOME\": () => (/* binding */ KEY_HOME),\n/* harmony export */   \"KEY_I\": () => (/* binding */ KEY_I),\n/* harmony export */   \"KEY_INSERT\": () => (/* binding */ KEY_INSERT),\n/* harmony export */   \"KEY_J\": () => (/* binding */ KEY_J),\n/* harmony export */   \"KEY_K\": () => (/* binding */ KEY_K),\n/* harmony export */   \"KEY_L\": () => (/* binding */ KEY_L),\n/* harmony export */   \"KEY_LEFT\": () => (/* binding */ KEY_LEFT),\n/* harmony export */   \"KEY_M\": () => (/* binding */ KEY_M),\n/* harmony export */   \"KEY_META\": () => (/* binding */ KEY_META),\n/* harmony export */   \"KEY_MULTIPLY\": () => (/* binding */ KEY_MULTIPLY),\n/* harmony export */   \"KEY_N\": () => (/* binding */ KEY_N),\n/* harmony export */   \"KEY_NUMPAD_0\": () => (/* binding */ KEY_NUMPAD_0),\n/* harmony export */   \"KEY_NUMPAD_1\": () => (/* binding */ KEY_NUMPAD_1),\n/* harmony export */   \"KEY_NUMPAD_2\": () => (/* binding */ KEY_NUMPAD_2),\n/* harmony export */   \"KEY_NUMPAD_3\": () => (/* binding */ KEY_NUMPAD_3),\n/* harmony export */   \"KEY_NUMPAD_4\": () => (/* binding */ KEY_NUMPAD_4),\n/* harmony export */   \"KEY_NUMPAD_5\": () => (/* binding */ KEY_NUMPAD_5),\n/* harmony export */   \"KEY_NUMPAD_6\": () => (/* binding */ KEY_NUMPAD_6),\n/* harmony export */   \"KEY_NUMPAD_7\": () => (/* binding */ KEY_NUMPAD_7),\n/* harmony export */   \"KEY_NUMPAD_8\": () => (/* binding */ KEY_NUMPAD_8),\n/* harmony export */   \"KEY_NUMPAD_9\": () => (/* binding */ KEY_NUMPAD_9),\n/* harmony export */   \"KEY_O\": () => (/* binding */ KEY_O),\n/* harmony export */   \"KEY_OPEN_BRACKET\": () => (/* binding */ KEY_OPEN_BRACKET),\n/* harmony export */   \"KEY_P\": () => (/* binding */ KEY_P),\n/* harmony export */   \"KEY_PAGE_DOWN\": () => (/* binding */ KEY_PAGE_DOWN),\n/* harmony export */   \"KEY_PAGE_UP\": () => (/* binding */ KEY_PAGE_UP),\n/* harmony export */   \"KEY_PAUSE\": () => (/* binding */ KEY_PAUSE),\n/* harmony export */   \"KEY_PERIOD\": () => (/* binding */ KEY_PERIOD),\n/* harmony export */   \"KEY_PRINT_SCREEN\": () => (/* binding */ KEY_PRINT_SCREEN),\n/* harmony export */   \"KEY_Q\": () => (/* binding */ KEY_Q),\n/* harmony export */   \"KEY_R\": () => (/* binding */ KEY_R),\n/* harmony export */   \"KEY_RETURN\": () => (/* binding */ KEY_RETURN),\n/* harmony export */   \"KEY_RIGHT\": () => (/* binding */ KEY_RIGHT),\n/* harmony export */   \"KEY_S\": () => (/* binding */ KEY_S),\n/* harmony export */   \"KEY_SEMICOLON\": () => (/* binding */ KEY_SEMICOLON),\n/* harmony export */   \"KEY_SEPARATOR\": () => (/* binding */ KEY_SEPARATOR),\n/* harmony export */   \"KEY_SHIFT\": () => (/* binding */ KEY_SHIFT),\n/* harmony export */   \"KEY_SLASH\": () => (/* binding */ KEY_SLASH),\n/* harmony export */   \"KEY_SPACE\": () => (/* binding */ KEY_SPACE),\n/* harmony export */   \"KEY_SUBTRACT\": () => (/* binding */ KEY_SUBTRACT),\n/* harmony export */   \"KEY_T\": () => (/* binding */ KEY_T),\n/* harmony export */   \"KEY_TAB\": () => (/* binding */ KEY_TAB),\n/* harmony export */   \"KEY_U\": () => (/* binding */ KEY_U),\n/* harmony export */   \"KEY_UP\": () => (/* binding */ KEY_UP),\n/* harmony export */   \"KEY_V\": () => (/* binding */ KEY_V),\n/* harmony export */   \"KEY_W\": () => (/* binding */ KEY_W),\n/* harmony export */   \"KEY_WINDOWS\": () => (/* binding */ KEY_WINDOWS),\n/* harmony export */   \"KEY_X\": () => (/* binding */ KEY_X),\n/* harmony export */   \"KEY_Y\": () => (/* binding */ KEY_Y),\n/* harmony export */   \"KEY_Z\": () => (/* binding */ KEY_Z),\n/* harmony export */   \"MOUSEBUTTON_LEFT\": () => (/* binding */ MOUSEBUTTON_LEFT),\n/* harmony export */   \"MOUSEBUTTON_MIDDLE\": () => (/* binding */ MOUSEBUTTON_MIDDLE),\n/* harmony export */   \"MOUSEBUTTON_NONE\": () => (/* binding */ MOUSEBUTTON_NONE),\n/* harmony export */   \"MOUSEBUTTON_RIGHT\": () => (/* binding */ MOUSEBUTTON_RIGHT),\n/* harmony export */   \"PAD_1\": () => (/* binding */ PAD_1),\n/* harmony export */   \"PAD_2\": () => (/* binding */ PAD_2),\n/* harmony export */   \"PAD_3\": () => (/* binding */ PAD_3),\n/* harmony export */   \"PAD_4\": () => (/* binding */ PAD_4),\n/* harmony export */   \"PAD_DOWN\": () => (/* binding */ PAD_DOWN),\n/* harmony export */   \"PAD_FACE_1\": () => (/* binding */ PAD_FACE_1),\n/* harmony export */   \"PAD_FACE_2\": () => (/* binding */ PAD_FACE_2),\n/* harmony export */   \"PAD_FACE_3\": () => (/* binding */ PAD_FACE_3),\n/* harmony export */   \"PAD_FACE_4\": () => (/* binding */ PAD_FACE_4),\n/* harmony export */   \"PAD_LEFT\": () => (/* binding */ PAD_LEFT),\n/* harmony export */   \"PAD_L_SHOULDER_1\": () => (/* binding */ PAD_L_SHOULDER_1),\n/* harmony export */   \"PAD_L_SHOULDER_2\": () => (/* binding */ PAD_L_SHOULDER_2),\n/* harmony export */   \"PAD_L_STICK_BUTTON\": () => (/* binding */ PAD_L_STICK_BUTTON),\n/* harmony export */   \"PAD_L_STICK_X\": () => (/* binding */ PAD_L_STICK_X),\n/* harmony export */   \"PAD_L_STICK_Y\": () => (/* binding */ PAD_L_STICK_Y),\n/* harmony export */   \"PAD_RIGHT\": () => (/* binding */ PAD_RIGHT),\n/* harmony export */   \"PAD_R_SHOULDER_1\": () => (/* binding */ PAD_R_SHOULDER_1),\n/* harmony export */   \"PAD_R_SHOULDER_2\": () => (/* binding */ PAD_R_SHOULDER_2),\n/* harmony export */   \"PAD_R_STICK_BUTTON\": () => (/* binding */ PAD_R_STICK_BUTTON),\n/* harmony export */   \"PAD_R_STICK_X\": () => (/* binding */ PAD_R_STICK_X),\n/* harmony export */   \"PAD_R_STICK_Y\": () => (/* binding */ PAD_R_STICK_Y),\n/* harmony export */   \"PAD_SELECT\": () => (/* binding */ PAD_SELECT),\n/* harmony export */   \"PAD_START\": () => (/* binding */ PAD_START),\n/* harmony export */   \"PAD_UP\": () => (/* binding */ PAD_UP),\n/* harmony export */   \"PAD_VENDOR\": () => (/* binding */ PAD_VENDOR)\n/* harmony export */ });\nconst ACTION_MOUSE = 'mouse';\nconst ACTION_KEYBOARD = 'keyboard';\nconst ACTION_GAMEPAD = 'gamepad';\nconst AXIS_MOUSE_X = 'mousex';\nconst AXIS_MOUSE_Y = 'mousey';\nconst AXIS_PAD_L_X = 'padlx';\nconst AXIS_PAD_L_Y = 'padly';\nconst AXIS_PAD_R_X = 'padrx';\nconst AXIS_PAD_R_Y = 'padry';\nconst AXIS_KEY = 'key';\nconst EVENT_KEYDOWN = 'keydown';\nconst EVENT_KEYUP = 'keyup';\nconst EVENT_MOUSEDOWN = 'mousedown';\nconst EVENT_MOUSEMOVE = 'mousemove';\nconst EVENT_MOUSEUP = 'mouseup';\nconst EVENT_MOUSEWHEEL = 'mousewheel';\nconst EVENT_TOUCHSTART = 'touchstart';\nconst EVENT_TOUCHEND = 'touchend';\nconst EVENT_TOUCHMOVE = 'touchmove';\nconst EVENT_TOUCHCANCEL = 'touchcancel';\nconst EVENT_SELECT = 'select';\nconst EVENT_SELECTSTART = 'selectstart';\nconst EVENT_SELECTEND = 'selectend';\nconst KEY_BACKSPACE = 8;\nconst KEY_TAB = 9;\nconst KEY_RETURN = 13;\nconst KEY_ENTER = 13;\nconst KEY_SHIFT = 16;\nconst KEY_CONTROL = 17;\nconst KEY_ALT = 18;\nconst KEY_PAUSE = 19;\nconst KEY_CAPS_LOCK = 20;\nconst KEY_ESCAPE = 27;\nconst KEY_SPACE = 32;\nconst KEY_PAGE_UP = 33;\nconst KEY_PAGE_DOWN = 34;\nconst KEY_END = 35;\nconst KEY_HOME = 36;\nconst KEY_LEFT = 37;\nconst KEY_UP = 38;\nconst KEY_RIGHT = 39;\nconst KEY_DOWN = 40;\nconst KEY_PRINT_SCREEN = 44;\nconst KEY_INSERT = 45;\nconst KEY_DELETE = 46;\nconst KEY_0 = 48;\nconst KEY_1 = 49;\nconst KEY_2 = 50;\nconst KEY_3 = 51;\nconst KEY_4 = 52;\nconst KEY_5 = 53;\nconst KEY_6 = 54;\nconst KEY_7 = 55;\nconst KEY_8 = 56;\nconst KEY_9 = 57;\nconst KEY_SEMICOLON = 59;\nconst KEY_EQUAL = 61;\nconst KEY_A = 65;\nconst KEY_B = 66;\nconst KEY_C = 67;\nconst KEY_D = 68;\nconst KEY_E = 69;\nconst KEY_F = 70;\nconst KEY_G = 71;\nconst KEY_H = 72;\nconst KEY_I = 73;\nconst KEY_J = 74;\nconst KEY_K = 75;\nconst KEY_L = 76;\nconst KEY_M = 77;\nconst KEY_N = 78;\nconst KEY_O = 79;\nconst KEY_P = 80;\nconst KEY_Q = 81;\nconst KEY_R = 82;\nconst KEY_S = 83;\nconst KEY_T = 84;\nconst KEY_U = 85;\nconst KEY_V = 86;\nconst KEY_W = 87;\nconst KEY_X = 88;\nconst KEY_Y = 89;\nconst KEY_Z = 90;\nconst KEY_WINDOWS = 91;\nconst KEY_CONTEXT_MENU = 93;\nconst KEY_NUMPAD_0 = 96;\nconst KEY_NUMPAD_1 = 97;\nconst KEY_NUMPAD_2 = 98;\nconst KEY_NUMPAD_3 = 99;\nconst KEY_NUMPAD_4 = 100;\nconst KEY_NUMPAD_5 = 101;\nconst KEY_NUMPAD_6 = 102;\nconst KEY_NUMPAD_7 = 103;\nconst KEY_NUMPAD_8 = 104;\nconst KEY_NUMPAD_9 = 105;\nconst KEY_MULTIPLY = 106;\nconst KEY_ADD = 107;\nconst KEY_SEPARATOR = 108;\nconst KEY_SUBTRACT = 109;\nconst KEY_DECIMAL = 110;\nconst KEY_DIVIDE = 111;\nconst KEY_F1 = 112;\nconst KEY_F2 = 113;\nconst KEY_F3 = 114;\nconst KEY_F4 = 115;\nconst KEY_F5 = 116;\nconst KEY_F6 = 117;\nconst KEY_F7 = 118;\nconst KEY_F8 = 119;\nconst KEY_F9 = 120;\nconst KEY_F10 = 121;\nconst KEY_F11 = 122;\nconst KEY_F12 = 123;\nconst KEY_COMMA = 188;\nconst KEY_PERIOD = 190;\nconst KEY_SLASH = 191;\nconst KEY_OPEN_BRACKET = 219;\nconst KEY_BACK_SLASH = 220;\nconst KEY_CLOSE_BRACKET = 221;\nconst KEY_META = 224;\nconst MOUSEBUTTON_NONE = -1;\nconst MOUSEBUTTON_LEFT = 0;\nconst MOUSEBUTTON_MIDDLE = 1;\nconst MOUSEBUTTON_RIGHT = 2;\nconst PAD_1 = 0;\nconst PAD_2 = 1;\nconst PAD_3 = 2;\nconst PAD_4 = 3;\nconst PAD_FACE_1 = 0;\nconst PAD_FACE_2 = 1;\nconst PAD_FACE_3 = 2;\nconst PAD_FACE_4 = 3;\nconst PAD_L_SHOULDER_1 = 4;\nconst PAD_R_SHOULDER_1 = 5;\nconst PAD_L_SHOULDER_2 = 6;\nconst PAD_R_SHOULDER_2 = 7;\nconst PAD_SELECT = 8;\nconst PAD_START = 9;\nconst PAD_L_STICK_BUTTON = 10;\nconst PAD_R_STICK_BUTTON = 11;\nconst PAD_UP = 12;\nconst PAD_DOWN = 13;\nconst PAD_LEFT = 14;\nconst PAD_RIGHT = 15;\nconst PAD_VENDOR = 16;\nconst PAD_L_STICK_X = 0;\nconst PAD_L_STICK_Y = 1;\nconst PAD_R_STICK_X = 2;\nconst PAD_R_STICK_Y = 3;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/input/constants.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/input/mouse-event.js":
/*!************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/input/mouse-event.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MouseEvent\": () => (/* binding */ MouseEvent),\n/* harmony export */   \"isMousePointerLocked\": () => (/* binding */ isMousePointerLocked)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/input/constants.js\");\n\n\nfunction isMousePointerLocked() {\n  return !!(document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement);\n}\nclass MouseEvent {\n  constructor(mouse, event) {\n    let coords = {\n      x: 0,\n      y: 0\n    };\n    if (event) {\n      if (event instanceof MouseEvent) {\n        throw Error('Expected MouseEvent');\n      }\n      coords = mouse._getTargetCoords(event);\n    } else {\n      event = {};\n    }\n    if (coords) {\n      this.x = coords.x;\n      this.y = coords.y;\n    } else if (isMousePointerLocked()) {\n      this.x = 0;\n      this.y = 0;\n    } else {\n      return;\n    }\n    this.wheelDelta = 0;\n    if (event.type === 'wheel') {\n      if (event.deltaY > 0) {\n        this.wheelDelta = 1;\n      } else if (event.deltaY < 0) {\n        this.wheelDelta = -1;\n      }\n    }\n    if (isMousePointerLocked()) {\n      this.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;\n      this.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;\n    } else {\n      this.dx = this.x - mouse._lastX;\n      this.dy = this.y - mouse._lastY;\n    }\n    if (event.type === 'mousedown' || event.type === 'mouseup') {\n      this.button = event.button;\n    } else {\n      this.button = _constants_js__WEBPACK_IMPORTED_MODULE_0__.MOUSEBUTTON_NONE;\n    }\n    this.buttons = mouse._buttons.slice(0);\n    this.element = event.target;\n    this.ctrlKey = event.ctrlKey || false;\n    this.altKey = event.altKey || false;\n    this.shiftKey = event.shiftKey || false;\n    this.metaKey = event.metaKey || false;\n    this.event = event;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/input/mouse-event.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/input/mouse.js":
/*!******************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/input/mouse.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Mouse\": () => (/* binding */ Mouse)\n/* harmony export */ });\n/* harmony import */ var _core_platform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/platform.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/platform.js\");\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/input/constants.js\");\n/* harmony import */ var _mouse_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mouse-event.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/input/mouse-event.js\");\n\n\n\n\n\nclass Mouse extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor(element) {\n    super();\n    this._lastX = 0;\n    this._lastY = 0;\n    this._buttons = [false, false, false];\n    this._lastbuttons = [false, false, false];\n    this._upHandler = this._handleUp.bind(this);\n    this._downHandler = this._handleDown.bind(this);\n    this._moveHandler = this._handleMove.bind(this);\n    this._wheelHandler = this._handleWheel.bind(this);\n    this._contextMenuHandler = event => {\n      event.preventDefault();\n    };\n    this._target = null;\n    this._attached = false;\n    this.attach(element);\n  }\n  static isPointerLocked() {\n    return (0,_mouse_event_js__WEBPACK_IMPORTED_MODULE_1__.isMousePointerLocked)();\n  }\n  attach(element) {\n    this._target = element;\n    if (this._attached) return;\n    this._attached = true;\n    const opts = _core_platform_js__WEBPACK_IMPORTED_MODULE_2__.platform.passiveEvents ? {\n      passive: false\n    } : false;\n    window.addEventListener('mouseup', this._upHandler, opts);\n    window.addEventListener('mousedown', this._downHandler, opts);\n    window.addEventListener('mousemove', this._moveHandler, opts);\n    window.addEventListener('wheel', this._wheelHandler, opts);\n  }\n  detach() {\n    if (!this._attached) return;\n    this._attached = false;\n    this._target = null;\n    const opts = _core_platform_js__WEBPACK_IMPORTED_MODULE_2__.platform.passiveEvents ? {\n      passive: false\n    } : false;\n    window.removeEventListener('mouseup', this._upHandler, opts);\n    window.removeEventListener('mousedown', this._downHandler, opts);\n    window.removeEventListener('mousemove', this._moveHandler, opts);\n    window.removeEventListener('wheel', this._wheelHandler, opts);\n  }\n  disableContextMenu() {\n    if (!this._target) return;\n    this._target.addEventListener('contextmenu', this._contextMenuHandler);\n  }\n  enableContextMenu() {\n    if (!this._target) return;\n    this._target.removeEventListener('contextmenu', this._contextMenuHandler);\n  }\n  enablePointerLock(success, error) {\n    if (!document.body.requestPointerLock) {\n      if (error) error();\n      return;\n    }\n    const s = () => {\n      success();\n      document.removeEventListener('pointerlockchange', s);\n    };\n    const e = () => {\n      error();\n      document.removeEventListener('pointerlockerror', e);\n    };\n    if (success) {\n      document.addEventListener('pointerlockchange', s, false);\n    }\n    if (error) {\n      document.addEventListener('pointerlockerror', e, false);\n    }\n    document.body.requestPointerLock();\n  }\n  disablePointerLock(success) {\n    if (!document.exitPointerLock) {\n      return;\n    }\n    const s = () => {\n      success();\n      document.removeEventListener('pointerlockchange', s);\n    };\n    if (success) {\n      document.addEventListener('pointerlockchange', s, false);\n    }\n    document.exitPointerLock();\n  }\n  update() {\n    this._lastbuttons[0] = this._buttons[0];\n    this._lastbuttons[1] = this._buttons[1];\n    this._lastbuttons[2] = this._buttons[2];\n  }\n  isPressed(button) {\n    return this._buttons[button];\n  }\n  wasPressed(button) {\n    return this._buttons[button] && !this._lastbuttons[button];\n  }\n  wasReleased(button) {\n    return !this._buttons[button] && this._lastbuttons[button];\n  }\n  _handleUp(event) {\n    this._buttons[event.button] = false;\n    const e = new _mouse_event_js__WEBPACK_IMPORTED_MODULE_1__.MouseEvent(this, event);\n    if (!e.event) return;\n    this.fire(_constants_js__WEBPACK_IMPORTED_MODULE_3__.EVENT_MOUSEUP, e);\n  }\n  _handleDown(event) {\n    this._buttons[event.button] = true;\n    const e = new _mouse_event_js__WEBPACK_IMPORTED_MODULE_1__.MouseEvent(this, event);\n    if (!e.event) return;\n    this.fire(_constants_js__WEBPACK_IMPORTED_MODULE_3__.EVENT_MOUSEDOWN, e);\n  }\n  _handleMove(event) {\n    const e = new _mouse_event_js__WEBPACK_IMPORTED_MODULE_1__.MouseEvent(this, event);\n    if (!e.event) return;\n    this.fire(_constants_js__WEBPACK_IMPORTED_MODULE_3__.EVENT_MOUSEMOVE, e);\n    this._lastX = e.x;\n    this._lastY = e.y;\n  }\n  _handleWheel(event) {\n    const e = new _mouse_event_js__WEBPACK_IMPORTED_MODULE_1__.MouseEvent(this, event);\n    if (!e.event) return;\n    this.fire(_constants_js__WEBPACK_IMPORTED_MODULE_3__.EVENT_MOUSEWHEEL, e);\n  }\n  _getTargetCoords(event) {\n    const rect = this._target.getBoundingClientRect();\n    const left = Math.floor(rect.left);\n    const top = Math.floor(rect.top);\n    if (event.clientX < left || event.clientX >= left + this._target.clientWidth || event.clientY < top || event.clientY >= top + this._target.clientHeight) {\n      return null;\n    }\n    return {\n      x: event.clientX - left,\n      y: event.clientY - top\n    };\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/input/mouse.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/input/touch-device.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/input/touch-device.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TouchDevice\": () => (/* binding */ TouchDevice)\n/* harmony export */ });\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _touch_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./touch-event.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/input/touch-event.js\");\n\n\n\nclass TouchDevice extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor(element) {\n    super();\n    this._element = null;\n    this._startHandler = this._handleTouchStart.bind(this);\n    this._endHandler = this._handleTouchEnd.bind(this);\n    this._moveHandler = this._handleTouchMove.bind(this);\n    this._cancelHandler = this._handleTouchCancel.bind(this);\n    this.attach(element);\n  }\n  attach(element) {\n    if (this._element) {\n      this.detach();\n    }\n    this._element = element;\n    this._element.addEventListener('touchstart', this._startHandler, false);\n    this._element.addEventListener('touchend', this._endHandler, false);\n    this._element.addEventListener('touchmove', this._moveHandler, false);\n    this._element.addEventListener('touchcancel', this._cancelHandler, false);\n  }\n  detach() {\n    if (this._element) {\n      this._element.removeEventListener('touchstart', this._startHandler, false);\n      this._element.removeEventListener('touchend', this._endHandler, false);\n      this._element.removeEventListener('touchmove', this._moveHandler, false);\n      this._element.removeEventListener('touchcancel', this._cancelHandler, false);\n    }\n    this._element = null;\n  }\n  _handleTouchStart(e) {\n    this.fire('touchstart', new _touch_event_js__WEBPACK_IMPORTED_MODULE_1__.TouchEvent(this, e));\n  }\n  _handleTouchEnd(e) {\n    this.fire('touchend', new _touch_event_js__WEBPACK_IMPORTED_MODULE_1__.TouchEvent(this, e));\n  }\n  _handleTouchMove(e) {\n    e.preventDefault();\n    this.fire('touchmove', new _touch_event_js__WEBPACK_IMPORTED_MODULE_1__.TouchEvent(this, e));\n  }\n  _handleTouchCancel(e) {\n    this.fire('touchcancel', new _touch_event_js__WEBPACK_IMPORTED_MODULE_1__.TouchEvent(this, e));\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/input/touch-device.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/input/touch-event.js":
/*!************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/input/touch-event.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Touch\": () => (/* binding */ Touch),\n/* harmony export */   \"TouchEvent\": () => (/* binding */ TouchEvent),\n/* harmony export */   \"getTouchTargetCoords\": () => (/* binding */ getTouchTargetCoords)\n/* harmony export */ });\nfunction getTouchTargetCoords(touch) {\n  let totalOffsetX = 0;\n  let totalOffsetY = 0;\n  let target = touch.target;\n  while (!(target instanceof HTMLElement)) {\n    target = target.parentNode;\n  }\n  let currentElement = target;\n  do {\n    totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;\n    totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;\n    currentElement = currentElement.offsetParent;\n  } while (currentElement);\n  return {\n    x: touch.pageX - totalOffsetX,\n    y: touch.pageY - totalOffsetY\n  };\n}\nclass Touch {\n  constructor(touch) {\n    const coords = getTouchTargetCoords(touch);\n    this.id = touch.identifier;\n    this.x = coords.x;\n    this.y = coords.y;\n    this.target = touch.target;\n    this.touch = touch;\n  }\n}\nclass TouchEvent {\n  constructor(device, event) {\n    this.element = event.target;\n    this.event = event;\n    this.touches = [];\n    this.changedTouches = [];\n    if (event) {\n      for (let i = 0, l = event.touches.length; i < l; i++) {\n        this.touches.push(new Touch(event.touches[i]));\n      }\n      for (let i = 0, l = event.changedTouches.length; i < l; i++) {\n        this.changedTouches.push(new Touch(event.changedTouches[i]));\n      }\n    }\n  }\n  getTouchById(id, list) {\n    for (let i = 0, l = list.length; i < l; i++) {\n      if (list[i].id === id) {\n        return list[i];\n      }\n    }\n    return null;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/input/touch-event.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/net/http.js":
/*!***************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/net/http.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Http\": () => (/* binding */ Http),\n/* harmony export */   \"http\": () => (/* binding */ http)\n/* harmony export */ });\n/* harmony import */ var _core_core_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/core.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/core.js\");\n/* harmony import */ var _core_time_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/time.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/time.js\");\n/* harmony import */ var _core_path_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/path.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/path.js\");\n/* harmony import */ var _core_uri_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/uri.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/uri.js\");\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n\n\n\n\n\n\nclass Http {\n  get(url, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    return this.request('GET', url, options, callback);\n  }\n  post(url, data, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    options.postdata = data;\n    return this.request('POST', url, options, callback);\n  }\n  put(url, data, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    options.postdata = data;\n    return this.request('PUT', url, options, callback);\n  }\n  del(url, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    return this.request('DELETE', url, options, callback);\n  }\n  request(method, url, options, callback) {\n    let uri, query, postdata;\n    let errored = false;\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    if (options.retry) {\n      options = Object.assign({\n        retries: 0,\n        maxRetries: 5\n      }, options);\n    }\n    options.callback = callback;\n    if (options.async == null) {\n      options.async = true;\n    }\n    if (options.headers == null) {\n      options.headers = {};\n    }\n    if (options.postdata != null) {\n      if (options.postdata instanceof Document) {\n        postdata = options.postdata;\n      } else if (options.postdata instanceof FormData) {\n        postdata = options.postdata;\n      } else if (options.postdata instanceof Object) {\n        let contentType = options.headers['Content-Type'];\n        if (contentType === undefined) {\n          options.headers['Content-Type'] = Http.ContentType.FORM_URLENCODED;\n          contentType = options.headers['Content-Type'];\n        }\n        switch (contentType) {\n          case Http.ContentType.FORM_URLENCODED:\n            {\n              postdata = '';\n              let bFirstItem = true;\n              for (const key in options.postdata) {\n                if (options.postdata.hasOwnProperty(key)) {\n                  if (bFirstItem) {\n                    bFirstItem = false;\n                  } else {\n                    postdata += '&';\n                  }\n                  const encodedKey = encodeURIComponent(key);\n                  const encodedValue = encodeURIComponent(options.postdata[key]);\n                  postdata += `${encodedKey}=${encodedValue}`;\n                }\n              }\n              break;\n            }\n          default:\n          case Http.ContentType.JSON:\n            if (contentType == null) {\n              options.headers['Content-Type'] = Http.ContentType.JSON;\n            }\n            postdata = JSON.stringify(options.postdata);\n            break;\n        }\n      } else {\n        postdata = options.postdata;\n      }\n    }\n    if (options.cache === false) {\n      const timestamp = (0,_core_time_js__WEBPACK_IMPORTED_MODULE_0__.now)();\n      uri = new _core_uri_js__WEBPACK_IMPORTED_MODULE_1__.URI(url);\n      if (!uri.query) {\n        uri.query = 'ts=' + timestamp;\n      } else {\n        uri.query = uri.query + '&ts=' + timestamp;\n      }\n      url = uri.toString();\n    }\n    if (options.query) {\n      uri = new _core_uri_js__WEBPACK_IMPORTED_MODULE_1__.URI(url);\n      query = (0,_core_core_js__WEBPACK_IMPORTED_MODULE_2__.extend)(uri.getQuery(), options.query);\n      uri.setQuery(query);\n      url = uri.toString();\n    }\n    const xhr = new XMLHttpRequest();\n    xhr.open(method, url, options.async);\n    xhr.withCredentials = options.withCredentials !== undefined ? options.withCredentials : false;\n    xhr.responseType = options.responseType || this._guessResponseType(url);\n    for (const header in options.headers) {\n      if (options.headers.hasOwnProperty(header)) {\n        xhr.setRequestHeader(header, options.headers[header]);\n      }\n    }\n    xhr.onreadystatechange = () => {\n      this._onReadyStateChange(method, url, options, xhr);\n    };\n    xhr.onerror = () => {\n      this._onError(method, url, options, xhr);\n      errored = true;\n    };\n    try {\n      xhr.send(postdata);\n    } catch (e) {\n      if (!errored) {\n        options.error(xhr.status, xhr, e);\n      }\n    }\n    return xhr;\n  }\n  _guessResponseType(url) {\n    const uri = new _core_uri_js__WEBPACK_IMPORTED_MODULE_1__.URI(url);\n    const ext = _core_path_js__WEBPACK_IMPORTED_MODULE_3__.path.getExtension(uri.path);\n    if (Http.binaryExtensions.indexOf(ext) >= 0) {\n      return Http.ResponseType.ARRAY_BUFFER;\n    }\n    if (ext === '.xml') {\n      return Http.ResponseType.DOCUMENT;\n    }\n    return Http.ResponseType.TEXT;\n  }\n  _isBinaryContentType(contentType) {\n    const binTypes = [Http.ContentType.BASIS, Http.ContentType.BIN, Http.ContentType.DDS, Http.ContentType.GLB, Http.ContentType.MP3, Http.ContentType.MP4, Http.ContentType.OGG, Http.ContentType.OPUS, Http.ContentType.WAV];\n    if (binTypes.indexOf(contentType) >= 0) {\n      return true;\n    }\n    return false;\n  }\n  _isBinaryResponseType(responseType) {\n    return responseType === Http.ResponseType.ARRAY_BUFFER || responseType === Http.ResponseType.BLOB || responseType === Http.ResponseType.JSON;\n  }\n  _onReadyStateChange(method, url, options, xhr) {\n    if (xhr.readyState === 4) {\n      switch (xhr.status) {\n        case 0:\n          {\n            if (xhr.responseURL && xhr.responseURL.startsWith('file:///')) {\n              this._onSuccess(method, url, options, xhr);\n            } else {\n              this._onError(method, url, options, xhr);\n            }\n            break;\n          }\n        case 200:\n        case 201:\n        case 206:\n        case 304:\n          {\n            this._onSuccess(method, url, options, xhr);\n            break;\n          }\n        default:\n          {\n            this._onError(method, url, options, xhr);\n            break;\n          }\n      }\n    }\n  }\n  _onSuccess(method, url, options, xhr) {\n    let response;\n    let contentType;\n    const header = xhr.getResponseHeader('Content-Type');\n    if (header) {\n      const parts = header.split(';');\n      contentType = parts[0].trim();\n    }\n    try {\n      if (contentType === Http.ContentType.JSON || url.split('?')[0].endsWith('.json')) {\n        response = JSON.parse(xhr.responseText);\n      } else if (this._isBinaryContentType(contentType) || this._isBinaryResponseType(xhr.responseType)) {\n        response = xhr.response;\n      } else if (xhr.responseType === Http.ResponseType.DOCUMENT || contentType === Http.ContentType.XML) {\n        response = xhr.responseXML;\n      } else {\n        response = xhr.responseText;\n      }\n      options.callback(null, response);\n    } catch (err) {\n      options.callback(err);\n    }\n  }\n  _onError(method, url, options, xhr) {\n    if (options.retrying) {\n      return;\n    }\n    if (options.retry && options.retries < options.maxRetries) {\n      options.retries++;\n      options.retrying = true;\n      const retryDelay = _core_math_math_js__WEBPACK_IMPORTED_MODULE_4__.math.clamp(Math.pow(2, options.retries) * Http.retryDelay, 0, options.maxRetryDelay || 5000);\n      console.log(`${method}: ${url} - Error ${xhr.status}. Retrying in ${retryDelay} ms`);\n      setTimeout(() => {\n        options.retrying = false;\n        this.request(method, url, options, options.callback);\n      }, retryDelay);\n    } else {\n      options.callback(xhr.status === 0 ? 'Network error' : xhr.status, null);\n    }\n  }\n}\nHttp.ContentType = {\n  AAC: 'audio/aac',\n  BASIS: 'image/basis',\n  BIN: 'application/octet-stream',\n  DDS: 'image/dds',\n  FORM_URLENCODED: 'application/x-www-form-urlencoded',\n  GIF: 'image/gif',\n  GLB: 'model/gltf-binary',\n  JPEG: 'image/jpeg',\n  JSON: 'application/json',\n  MP3: 'audio/mpeg',\n  MP4: 'audio/mp4',\n  OGG: 'audio/ogg',\n  OPUS: 'audio/ogg; codecs=\"opus\"',\n  PNG: 'image/png',\n  TEXT: 'text/plain',\n  WAV: 'audio/x-wav',\n  XML: 'application/xml'\n};\nHttp.ResponseType = {\n  TEXT: 'text',\n  ARRAY_BUFFER: 'arraybuffer',\n  BLOB: 'blob',\n  DOCUMENT: 'document',\n  JSON: 'json'\n};\nHttp.binaryExtensions = ['.model', '.wav', '.ogg', '.mp3', '.mp4', '.m4a', '.aac', '.dds', '.basis', '.glb', '.opus'];\nHttp.retryDelay = 100;\nconst http = new Http();\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/net/http.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/sound/instance.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/sound/instance.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SoundInstance\": () => (/* binding */ SoundInstance)\n/* harmony export */ });\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _audio_capabilities_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../audio/capabilities.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/audio/capabilities.js\");\n\n\n\n\nconst STATE_PLAYING = 0;\nconst STATE_PAUSED = 1;\nconst STATE_STOPPED = 2;\nfunction capTime(time, duration) {\n  return time % duration || 0;\n}\nclass SoundInstance extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor(manager, sound, options) {\n    super();\n    this.source = null;\n    this._manager = manager;\n    this._volume = options.volume !== undefined ? _core_math_math_js__WEBPACK_IMPORTED_MODULE_1__.math.clamp(Number(options.volume) || 0, 0, 1) : 1;\n    this._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;\n    this._loop = !!(options.loop !== undefined ? options.loop : false);\n    this._sound = sound;\n    this._state = STATE_STOPPED;\n    this._suspended = false;\n    this._suspendEndEvent = 0;\n    this._suspendInstanceEvents = false;\n    this._playWhenLoaded = true;\n    this._startTime = Math.max(0, Number(options.startTime) || 0);\n    this._duration = Math.max(0, Number(options.duration) || 0);\n    this._startOffset = null;\n    this._onPlayCallback = options.onPlay;\n    this._onPauseCallback = options.onPause;\n    this._onResumeCallback = options.onResume;\n    this._onStopCallback = options.onStop;\n    this._onEndCallback = options.onEnd;\n    if ((0,_audio_capabilities_js__WEBPACK_IMPORTED_MODULE_2__.hasAudioContext)()) {\n      this._startedAt = 0;\n      this._currentTime = 0;\n      this._currentOffset = 0;\n      this._inputNode = null;\n      this._connectorNode = null;\n      this._firstNode = null;\n      this._lastNode = null;\n      this._waitingContextSuspension = false;\n      this._initializeNodes();\n      this._endedHandler = this._onEnded.bind(this);\n    } else {\n      this._isReady = false;\n      this._loadedMetadataHandler = this._onLoadedMetadata.bind(this);\n      this._timeUpdateHandler = this._onTimeUpdate.bind(this);\n      this._endedHandler = this._onEnded.bind(this);\n      this._createSource();\n    }\n  }\n  set currentTime(value) {\n    if (value < 0) return;\n    if (this._state === STATE_PLAYING) {\n      const suspend = this._suspendInstanceEvents;\n      this._suspendInstanceEvents = true;\n      this.stop();\n      this._startOffset = value;\n      this.play();\n      this._suspendInstanceEvents = suspend;\n    } else {\n      this._startOffset = value;\n      this._currentTime = value;\n    }\n  }\n  get currentTime() {\n    if (this._startOffset !== null) {\n      return this._startOffset;\n    }\n    if (this._state === STATE_PAUSED) {\n      return this._currentTime;\n    }\n    if (this._state === STATE_STOPPED || !this.source) {\n      return 0;\n    }\n    this._updateCurrentTime();\n    return this._currentTime;\n  }\n  set duration(value) {\n    this._duration = Math.max(0, Number(value) || 0);\n    const isPlaying = this._state === STATE_PLAYING;\n    this.stop();\n    if (isPlaying) {\n      this.play();\n    }\n  }\n  get duration() {\n    if (!this._sound) {\n      return 0;\n    }\n    if (this._duration) {\n      return capTime(this._duration, this._sound.duration);\n    }\n    return this._sound.duration;\n  }\n  get isPaused() {\n    return this._state === STATE_PAUSED;\n  }\n  get isPlaying() {\n    return this._state === STATE_PLAYING;\n  }\n  get isStopped() {\n    return this._state === STATE_STOPPED;\n  }\n  get isSuspended() {\n    return this._suspended;\n  }\n  set loop(value) {\n    this._loop = !!value;\n    if (this.source) {\n      this.source.loop = this._loop;\n    }\n  }\n  get loop() {\n    return this._loop;\n  }\n  set pitch(pitch) {\n    this._currentOffset = this.currentTime;\n    this._startedAt = this._manager.context.currentTime;\n    this._pitch = Math.max(Number(pitch) || 0, 0.01);\n    if (this.source) {\n      this.source.playbackRate.value = this._pitch;\n    }\n  }\n  get pitch() {\n    return this._pitch;\n  }\n  set sound(value) {\n    this._sound = value;\n    if (this._state !== STATE_STOPPED) {\n      this.stop();\n    } else {\n      this._createSource();\n    }\n  }\n  get sound() {\n    return this._sound;\n  }\n  set startTime(value) {\n    this._startTime = Math.max(0, Number(value) || 0);\n    const isPlaying = this._state === STATE_PLAYING;\n    this.stop();\n    if (isPlaying) {\n      this.play();\n    }\n  }\n  get startTime() {\n    return this._startTime;\n  }\n  set volume(volume) {\n    volume = _core_math_math_js__WEBPACK_IMPORTED_MODULE_1__.math.clamp(volume, 0, 1);\n    this._volume = volume;\n    if (this.gain) {\n      this.gain.gain.value = volume * this._manager.volume;\n    }\n  }\n  get volume() {\n    return this._volume;\n  }\n  _onPlay() {\n    this.fire('play');\n    if (this._onPlayCallback) this._onPlayCallback(this);\n  }\n  _onPause() {\n    this.fire('pause');\n    if (this._onPauseCallback) this._onPauseCallback(this);\n  }\n  _onResume() {\n    this.fire('resume');\n    if (this._onResumeCallback) this._onResumeCallback(this);\n  }\n  _onStop() {\n    this.fire('stop');\n    if (this._onStopCallback) this._onStopCallback(this);\n  }\n  _onEnded() {\n    if (this._suspendEndEvent > 0) {\n      this._suspendEndEvent--;\n      return;\n    }\n    this.fire('end');\n    if (this._onEndCallback) this._onEndCallback(this);\n    this.stop();\n  }\n  _onManagerVolumeChange() {\n    this.volume = this._volume;\n  }\n  _onManagerSuspend() {\n    if (this._state === STATE_PLAYING && !this._suspended) {\n      this._suspended = true;\n      this.pause();\n    }\n  }\n  _onManagerResume() {\n    if (this._suspended) {\n      this._suspended = false;\n      this.resume();\n    }\n  }\n  _initializeNodes() {\n    this.gain = this._manager.context.createGain();\n    this._inputNode = this.gain;\n    this._connectorNode = this.gain;\n    this._connectorNode.connect(this._manager.context.destination);\n  }\n  play() {\n    if (this._state !== STATE_STOPPED) {\n      this.stop();\n    }\n    this._state = STATE_PLAYING;\n    this._playWhenLoaded = false;\n    if (this._waitingContextSuspension) {\n      return false;\n    }\n    if (this._manager.suspended) {\n      this._manager.once('resume', this._playAudioImmediate, this);\n      this._waitingContextSuspension = true;\n      return false;\n    }\n    this._playAudioImmediate();\n    return true;\n  }\n  _playAudioImmediate() {\n    this._waitingContextSuspension = false;\n    if (this._state !== STATE_PLAYING) {\n      return;\n    }\n    if (!this.source) {\n      this._createSource();\n    }\n    let offset = capTime(this._startOffset, this.duration);\n    offset = capTime(this._startTime + offset, this._sound.duration);\n    this._startOffset = null;\n    if (this._duration) {\n      this.source.start(0, offset, this._duration);\n    } else {\n      this.source.start(0, offset);\n    }\n    this._startedAt = this._manager.context.currentTime;\n    this._currentTime = 0;\n    this._currentOffset = offset;\n    this.volume = this._volume;\n    this.loop = this._loop;\n    this.pitch = this._pitch;\n    this._manager.on('volumechange', this._onManagerVolumeChange, this);\n    this._manager.on('suspend', this._onManagerSuspend, this);\n    this._manager.on('resume', this._onManagerResume, this);\n    this._manager.on('destroy', this._onManagerDestroy, this);\n    if (!this._suspendInstanceEvents) {\n      this._onPlay();\n    }\n  }\n  pause() {\n    this._playWhenLoaded = false;\n    if (this._state !== STATE_PLAYING) return false;\n    this._state = STATE_PAUSED;\n    if (this._waitingContextSuspension) {\n      return true;\n    }\n    this._updateCurrentTime();\n    this._suspendEndEvent++;\n    this.source.stop(0);\n    this.source = null;\n    this._startOffset = null;\n    if (!this._suspendInstanceEvents) this._onPause();\n    return true;\n  }\n  resume() {\n    if (this._state !== STATE_PAUSED) {\n      return false;\n    }\n    this._state = STATE_PLAYING;\n    if (this._waitingContextSuspension) {\n      return true;\n    }\n    if (!this.source) {\n      this._createSource();\n    }\n    let offset = this.currentTime;\n    if (this._startOffset !== null) {\n      offset = capTime(this._startOffset, this.duration);\n      offset = capTime(this._startTime + offset, this._sound.duration);\n      this._startOffset = null;\n    }\n    if (this._duration) {\n      this.source.start(0, offset, this._duration);\n    } else {\n      this.source.start(0, offset);\n    }\n    this._startedAt = this._manager.context.currentTime;\n    this._currentOffset = offset;\n    this.volume = this._volume;\n    this.loop = this._loop;\n    this.pitch = this._pitch;\n    this._playWhenLoaded = false;\n    if (!this._suspendInstanceEvents) this._onResume();\n    return true;\n  }\n  stop() {\n    this._playWhenLoaded = false;\n    if (this._state === STATE_STOPPED) return false;\n    const wasPlaying = this._state === STATE_PLAYING;\n    this._state = STATE_STOPPED;\n    if (this._waitingContextSuspension) {\n      return true;\n    }\n    this._manager.off('volumechange', this._onManagerVolumeChange, this);\n    this._manager.off('suspend', this._onManagerSuspend, this);\n    this._manager.off('resume', this._onManagerResume, this);\n    this._manager.off('destroy', this._onManagerDestroy, this);\n    this._startedAt = 0;\n    this._currentTime = 0;\n    this._currentOffset = 0;\n    this._startOffset = null;\n    this._suspendEndEvent++;\n    if (wasPlaying && this.source) {\n      this.source.stop(0);\n    }\n    this.source = null;\n    if (!this._suspendInstanceEvents) this._onStop();\n    return true;\n  }\n  setExternalNodes(firstNode, lastNode) {\n    if (!firstNode) {\n      console.error('The firstNode must be a valid Audio Node');\n      return;\n    }\n    if (!lastNode) {\n      lastNode = firstNode;\n    }\n    const speakers = this._manager.context.destination;\n    if (this._firstNode !== firstNode) {\n      if (this._firstNode) {\n        this._connectorNode.disconnect(this._firstNode);\n      } else {\n        this._connectorNode.disconnect(speakers);\n      }\n      this._firstNode = firstNode;\n      this._connectorNode.connect(firstNode);\n    }\n    if (this._lastNode !== lastNode) {\n      if (this._lastNode) {\n        this._lastNode.disconnect(speakers);\n      }\n      this._lastNode = lastNode;\n      this._lastNode.connect(speakers);\n    }\n  }\n  clearExternalNodes() {\n    const speakers = this._manager.context.destination;\n    if (this._firstNode) {\n      this._connectorNode.disconnect(this._firstNode);\n      this._firstNode = null;\n    }\n    if (this._lastNode) {\n      this._lastNode.disconnect(speakers);\n      this._lastNode = null;\n    }\n    this._connectorNode.connect(speakers);\n  }\n  getExternalNodes() {\n    return [this._firstNode, this._lastNode];\n  }\n  _createSource() {\n    if (!this._sound) {\n      return null;\n    }\n    const context = this._manager.context;\n    if (this._sound.buffer) {\n      this.source = context.createBufferSource();\n      this.source.buffer = this._sound.buffer;\n      this.source.connect(this._inputNode);\n      this.source.onended = this._endedHandler;\n      this.source.loopStart = capTime(this._startTime, this.source.buffer.duration);\n      if (this._duration) {\n        this.source.loopEnd = Math.max(this.source.loopStart, capTime(this._startTime + this._duration, this.source.buffer.duration));\n      }\n    }\n    return this.source;\n  }\n  _updateCurrentTime() {\n    this._currentTime = capTime((this._manager.context.currentTime - this._startedAt) * this._pitch + this._currentOffset, this.duration);\n  }\n  _onManagerDestroy() {\n    if (this.source && this._state === STATE_PLAYING) {\n      this.source.stop(0);\n      this.source = null;\n    }\n  }\n}\nif (!(0,_audio_capabilities_js__WEBPACK_IMPORTED_MODULE_2__.hasAudioContext)()) {\n  Object.assign(SoundInstance.prototype, {\n    play: function () {\n      if (this._state !== STATE_STOPPED) {\n        this.stop();\n      }\n      if (!this.source) {\n        if (!this._createSource()) {\n          return false;\n        }\n      }\n      this.volume = this._volume;\n      this.pitch = this._pitch;\n      this.loop = this._loop;\n      this.source.play();\n      this._state = STATE_PLAYING;\n      this._playWhenLoaded = false;\n      this._manager.on('volumechange', this._onManagerVolumeChange, this);\n      this._manager.on('suspend', this._onManagerSuspend, this);\n      this._manager.on('resume', this._onManagerResume, this);\n      this._manager.on('destroy', this._onManagerDestroy, this);\n      if (this._manager.suspended) this._onManagerSuspend();\n      if (!this._suspendInstanceEvents) this._onPlay();\n      return true;\n    },\n    pause: function () {\n      if (!this.source || this._state !== STATE_PLAYING) return false;\n      this._suspendEndEvent++;\n      this.source.pause();\n      this._playWhenLoaded = false;\n      this._state = STATE_PAUSED;\n      this._startOffset = null;\n      if (!this._suspendInstanceEvents) this._onPause();\n      return true;\n    },\n    resume: function () {\n      if (!this.source || this._state !== STATE_PAUSED) return false;\n      this._state = STATE_PLAYING;\n      this._playWhenLoaded = false;\n      if (this.source.paused) {\n        this.source.play();\n        if (!this._suspendInstanceEvents) this._onResume();\n      }\n      return true;\n    },\n    stop: function () {\n      if (!this.source || this._state === STATE_STOPPED) return false;\n      this._manager.off('volumechange', this._onManagerVolumeChange, this);\n      this._manager.off('suspend', this._onManagerSuspend, this);\n      this._manager.off('resume', this._onManagerResume, this);\n      this._manager.off('destroy', this._onManagerDestroy, this);\n      this._suspendEndEvent++;\n      this.source.pause();\n      this._playWhenLoaded = false;\n      this._state = STATE_STOPPED;\n      this._startOffset = null;\n      if (!this._suspendInstanceEvents) this._onStop();\n      return true;\n    },\n    setExternalNodes: function () {},\n    clearExternalNodes: function () {},\n    getExternalNodes: function () {\n      return [null, null];\n    },\n    _onLoadedMetadata: function () {\n      this.source.removeEventListener('loadedmetadata', this._loadedMetadataHandler);\n      this._isReady = true;\n      let offset = capTime(this._startOffset, this.duration);\n      offset = capTime(this._startTime + offset, this._sound.duration);\n      this._startOffset = null;\n      this.source.currentTime = offset;\n    },\n    _createSource: function () {\n      if (this._sound && this._sound.audio) {\n        this._isReady = false;\n        this.source = this._sound.audio.cloneNode(true);\n        this.source.addEventListener('loadedmetadata', this._loadedMetadataHandler);\n        this.source.addEventListener('timeupdate', this._timeUpdateHandler);\n        this.source.onended = this._endedHandler;\n      }\n      return this.source;\n    },\n    _onTimeUpdate: function () {\n      if (!this._duration) return;\n      if (this.source.currentTime > capTime(this._startTime + this._duration, this.source.duration)) {\n        if (this.loop) {\n          this.source.currentTime = capTime(this._startTime, this.source.duration);\n        } else {\n          this.source.removeEventListener('timeupdate', this._timeUpdateHandler);\n          this.source.pause();\n          this._onEnded();\n        }\n      }\n    },\n    _onManagerDestroy: function () {\n      if (this.source) {\n        this.source.pause();\n      }\n    }\n  });\n  Object.defineProperty(SoundInstance.prototype, 'volume', {\n    get: function () {\n      return this._volume;\n    },\n    set: function (volume) {\n      volume = _core_math_math_js__WEBPACK_IMPORTED_MODULE_1__.math.clamp(volume, 0, 1);\n      this._volume = volume;\n      if (this.source) {\n        this.source.volume = volume * this._manager.volume;\n      }\n    }\n  });\n  Object.defineProperty(SoundInstance.prototype, 'pitch', {\n    get: function () {\n      return this._pitch;\n    },\n    set: function (pitch) {\n      this._pitch = Math.max(Number(pitch) || 0, 0.01);\n      if (this.source) {\n        this.source.playbackRate = this._pitch;\n      }\n    }\n  });\n  Object.defineProperty(SoundInstance.prototype, 'sound', {\n    get: function () {\n      return this._sound;\n    },\n    set: function (value) {\n      this.stop();\n      this._sound = value;\n    }\n  });\n  Object.defineProperty(SoundInstance.prototype, 'currentTime', {\n    get: function () {\n      if (this._startOffset !== null) {\n        return this._startOffset;\n      }\n      if (this._state === STATE_STOPPED || !this.source) {\n        return 0;\n      }\n      return this.source.currentTime - this._startTime;\n    },\n    set: function (value) {\n      if (value < 0) return;\n      this._startOffset = value;\n      if (this.source && this._isReady) {\n        this.source.currentTime = capTime(this._startTime + capTime(value, this.duration), this._sound.duration);\n        this._startOffset = null;\n      }\n    }\n  });\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/sound/instance.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/sound/instance3d.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/sound/instance3d.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SoundInstance3d\": () => (/* binding */ SoundInstance3d)\n/* harmony export */ });\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _audio_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../audio/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/audio/constants.js\");\n/* harmony import */ var _audio_capabilities_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../audio/capabilities.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/audio/capabilities.js\");\n/* harmony import */ var _instance_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instance.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/sound/instance.js\");\n\n\n\n\n\n\n\nconst MAX_DISTANCE = 10000;\nclass SoundInstance3d extends _instance_js__WEBPACK_IMPORTED_MODULE_0__.SoundInstance {\n  constructor(manager, sound, options = {}) {\n    super(manager, sound, options);\n    this._position = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n    this._velocity = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n    if (options.position) this.position = options.position;\n    this.maxDistance = options.maxDistance !== undefined ? Number(options.maxDistance) : MAX_DISTANCE;\n    this.refDistance = options.refDistance !== undefined ? Number(options.refDistance) : 1;\n    this.rollOffFactor = options.rollOffFactor !== undefined ? Number(options.rollOffFactor) : 1;\n    this.distanceModel = options.distanceModel !== undefined ? options.distanceModel : _audio_constants_js__WEBPACK_IMPORTED_MODULE_2__.DISTANCE_LINEAR;\n  }\n  _initializeNodes() {\n    this.gain = this._manager.context.createGain();\n    this.panner = this._manager.context.createPanner();\n    this.panner.connect(this.gain);\n    this._inputNode = this.panner;\n    this._connectorNode = this.gain;\n    this._connectorNode.connect(this._manager.context.destination);\n  }\n  set position(value) {\n    this._position.copy(value);\n    const panner = this.panner;\n    if ('positionX' in panner) {\n      panner.positionX.value = value.x;\n      panner.positionY.value = value.y;\n      panner.positionZ.value = value.z;\n    } else if (panner.setPosition) {\n      panner.setPosition(value.x, value.y, value.z);\n    }\n  }\n  get position() {\n    return this._position;\n  }\n  set velocity(velocity) {\n    this._velocity.copy(velocity);\n  }\n  get velocity() {\n    return this._velocity;\n  }\n  set maxDistance(value) {\n    this.panner.maxDistance = value;\n  }\n  get maxDistance() {\n    return this.panner.maxDistance;\n  }\n  set refDistance(value) {\n    this.panner.refDistance = value;\n  }\n  get refDistance() {\n    return this.panner.refDistance;\n  }\n  set rollOffFactor(value) {\n    this.panner.rolloffFactor = value;\n  }\n  get rollOffFactor() {\n    return this.panner.rolloffFactor;\n  }\n  set distanceModel(value) {\n    this.panner.distanceModel = value;\n  }\n  get distanceModel() {\n    return this.panner.distanceModel;\n  }\n}\nif (!(0,_audio_capabilities_js__WEBPACK_IMPORTED_MODULE_3__.hasAudioContext)()) {\n  let offset = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n  const fallOff = function fallOff(posOne, posTwo, refDistance, maxDistance, rollOffFactor, distanceModel) {\n    offset = offset.sub2(posOne, posTwo);\n    const distance = offset.length();\n    if (distance < refDistance) {\n      return 1;\n    } else if (distance > maxDistance) {\n      return 0;\n    }\n    let result = 0;\n    if (distanceModel === _audio_constants_js__WEBPACK_IMPORTED_MODULE_2__.DISTANCE_LINEAR) {\n      result = 1 - rollOffFactor * (distance - refDistance) / (maxDistance - refDistance);\n    } else if (distanceModel === _audio_constants_js__WEBPACK_IMPORTED_MODULE_2__.DISTANCE_INVERSE) {\n      result = refDistance / (refDistance + rollOffFactor * (distance - refDistance));\n    } else if (distanceModel === _audio_constants_js__WEBPACK_IMPORTED_MODULE_2__.DISTANCE_EXPONENTIAL) {\n      result = Math.pow(distance / refDistance, -rollOffFactor);\n    }\n    return _core_math_math_js__WEBPACK_IMPORTED_MODULE_4__.math.clamp(result, 0, 1);\n  };\n  Object.defineProperty(SoundInstance3d.prototype, 'position', {\n    get: function () {\n      return this._position;\n    },\n    set: function (position) {\n      this._position.copy(position);\n      if (this.source) {\n        const listener = this._manager.listener;\n        const lpos = listener.getPosition();\n        const factor = fallOff(lpos, this._position, this.refDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);\n        const v = this.volume;\n        this.source.volume = v * factor * this._manager.volume;\n      }\n    }\n  });\n  Object.defineProperty(SoundInstance3d.prototype, 'maxDistance', {\n    get: function () {\n      return this._maxDistance;\n    },\n    set: function (value) {\n      this._maxDistance = value;\n    }\n  });\n  Object.defineProperty(SoundInstance3d.prototype, 'refDistance', {\n    get: function () {\n      return this._refDistance;\n    },\n    set: function (value) {\n      this._refDistance = value;\n    }\n  });\n  Object.defineProperty(SoundInstance3d.prototype, 'rollOffFactor', {\n    get: function () {\n      return this._rollOffFactor;\n    },\n    set: function (value) {\n      this._rollOffFactor = value;\n    }\n  });\n  Object.defineProperty(SoundInstance3d.prototype, 'distanceModel', {\n    get: function () {\n      return this._distanceModel;\n    },\n    set: function (value) {\n      this._distanceModel = value;\n    }\n  });\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/sound/instance3d.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/sound/listener.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/sound/listener.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Listener\": () => (/* binding */ Listener)\n/* harmony export */ });\n/* harmony import */ var _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/math/mat4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n\n\n\n\nclass Listener {\n  constructor(manager) {\n    this._manager = manager;\n    this.position = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n    this.velocity = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n    this.orientation = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__.Mat4();\n  }\n  getPosition() {\n    return this.position;\n  }\n  setPosition(position) {\n    this.position.copy(position);\n    const listener = this.listener;\n    if (listener) {\n      if ('positionX' in listener) {\n        listener.positionX.value = position.x;\n        listener.positionY.value = position.y;\n        listener.positionZ.value = position.z;\n      } else if (listener.setPosition) {\n        listener.setPosition(position.x, position.y, position.z);\n      }\n    }\n  }\n  getVelocity() {\n    return this.velocity;\n  }\n  setVelocity(velocity) {}\n  setOrientation(orientation) {\n    this.orientation.copy(orientation);\n    const listener = this.listener;\n    if (listener) {\n      const m = orientation.data;\n      if ('forwardX' in listener) {\n        listener.forwardX.value = -m[8];\n        listener.forwardY.value = -m[9];\n        listener.forwardZ.value = -m[10];\n        listener.upX.value = m[4];\n        listener.upY.value = m[5];\n        listener.upZ.value = m[6];\n      } else if (listener.setOrientation) {\n        listener.setOrientation(-m[8], -m[9], -m[10], m[4], m[5], m[6]);\n      }\n    }\n  }\n  getOrientation() {\n    return this.orientation;\n  }\n  get listener() {\n    const context = this._manager.context;\n    return context ? context.listener : null;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/sound/listener.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/sound/manager.js":
/*!********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/sound/manager.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SoundManager\": () => (/* binding */ SoundManager)\n/* harmony export */ });\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _audio_channel_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../audio/channel.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/audio/channel.js\");\n/* harmony import */ var _audio_channel3d_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../audio/channel3d.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/audio/channel3d.js\");\n/* harmony import */ var _listener_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./listener.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/sound/listener.js\");\n\n\n\n\n\n\n\nconst CONTEXT_STATE_RUNNING = 'running';\nconst USER_INPUT_EVENTS = ['click', 'touchstart', 'mousedown'];\nclass SoundManager extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor() {\n    super();\n    this._context = null;\n    this.AudioContext = typeof AudioContext !== 'undefined' && AudioContext || typeof webkitAudioContext !== 'undefined' && webkitAudioContext;\n    if (!this.AudioContext) ;\n    this._unlockHandlerFunc = this._unlockHandler.bind(this);\n    this._userSuspended = false;\n    this.listener = new _listener_js__WEBPACK_IMPORTED_MODULE_1__.Listener(this);\n    this._volume = 1;\n  }\n  set volume(volume) {\n    volume = _core_math_math_js__WEBPACK_IMPORTED_MODULE_2__.math.clamp(volume, 0, 1);\n    this._volume = volume;\n    this.fire('volumechange', volume);\n  }\n  get volume() {\n    return this._volume;\n  }\n  get suspended() {\n    return this._userSuspended;\n  }\n  get context() {\n    if (!this._context && this.AudioContext) {\n      this._context = new this.AudioContext();\n      if (this._context.state !== CONTEXT_STATE_RUNNING) {\n        this._registerUnlockListeners();\n      }\n    }\n    return this._context;\n  }\n  suspend() {\n    if (!this._userSuspended) {\n      this._userSuspended = true;\n      if (this._context && this._context.state === CONTEXT_STATE_RUNNING) {\n        this._suspend();\n      }\n    }\n  }\n  resume() {\n    if (this._userSuspended) {\n      this._userSuspended = false;\n      if (this._context && this._context.state !== CONTEXT_STATE_RUNNING) {\n        this._resume();\n      }\n    }\n  }\n  destroy() {\n    this.fire('destroy');\n    if (this._context) {\n      var _this$_context;\n      this._removeUnlockListeners();\n      (_this$_context = this._context) == null ? void 0 : _this$_context.close();\n      this._context = null;\n    }\n  }\n  playSound(sound, options = {}) {\n    let channel = null;\n    if (_audio_channel_js__WEBPACK_IMPORTED_MODULE_3__.Channel) {\n      channel = new _audio_channel_js__WEBPACK_IMPORTED_MODULE_3__.Channel(this, sound, options);\n      channel.play();\n    }\n    return channel;\n  }\n  playSound3d(sound, position, options = {}) {\n    let channel = null;\n    if (_audio_channel3d_js__WEBPACK_IMPORTED_MODULE_4__.Channel3d) {\n      channel = new _audio_channel3d_js__WEBPACK_IMPORTED_MODULE_4__.Channel3d(this, sound, options);\n      channel.setPosition(position);\n      if (options.volume) {\n        channel.setVolume(options.volume);\n      }\n      if (options.loop) {\n        channel.setLoop(options.loop);\n      }\n      if (options.maxDistance) {\n        channel.setMaxDistance(options.maxDistance);\n      }\n      if (options.minDistance) {\n        channel.setMinDistance(options.minDistance);\n      }\n      if (options.rollOffFactor) {\n        channel.setRollOffFactor(options.rollOffFactor);\n      }\n      if (options.distanceModel) {\n        channel.setDistanceModel(options.distanceModel);\n      }\n      channel.play();\n    }\n    return channel;\n  }\n  _resume() {\n    this._context.resume().then(() => {\n      const source = this._context.createBufferSource();\n      source.buffer = this._context.createBuffer(1, 1, this._context.sampleRate);\n      source.connect(this._context.destination);\n      source.start(0);\n      source.onended = event => {\n        source.disconnect(0);\n        this.fire('resume');\n      };\n    }, e => {}).catch(e => {});\n  }\n  _suspend() {\n    this._context.suspend().then(() => {\n      this.fire('suspend');\n    }, e => {}).catch(e => {});\n  }\n  _unlockHandler() {\n    this._removeUnlockListeners();\n    if (!this._userSuspended && this._context.state !== CONTEXT_STATE_RUNNING) {\n      this._resume();\n    }\n  }\n  _registerUnlockListeners() {\n    USER_INPUT_EVENTS.forEach(eventName => {\n      window.addEventListener(eventName, this._unlockHandlerFunc, false);\n    });\n  }\n  _removeUnlockListeners() {\n    USER_INPUT_EVENTS.forEach(eventName => {\n      window.removeEventListener(eventName, this._unlockHandlerFunc, false);\n    });\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/sound/manager.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/platform/sound/sound.js":
/*!******************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/platform/sound/sound.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Sound\": () => (/* binding */ Sound)\n/* harmony export */ });\nclass Sound {\n  constructor(resource) {\n    this.audio = void 0;\n    this.buffer = void 0;\n    if (resource instanceof Audio) {\n      this.audio = resource;\n    } else {\n      this.buffer = resource;\n    }\n  }\n  get duration() {\n    let duration = 0;\n    if (this.buffer) {\n      duration = this.buffer.duration;\n    } else if (this.audio) {\n      duration = this.audio.duration;\n    }\n    return duration || 0;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/platform/sound/sound.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/polyfill/OESVertexArrayObject.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/polyfill/OESVertexArrayObject.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"setupVertexArrayObject\": () => (/* binding */ setupVertexArrayObject)\n/* harmony export */ });\nvar glErrorShadow = {};\nfunction error(msg) {\n  if (window.console && window.console.error) {\n    window.console.error(msg);\n  }\n}\nfunction log(msg) {\n  if (window.console && window.console.log) {\n    window.console.log(msg);\n  }\n}\nfunction synthesizeGLError(err, opt_msg) {\n  glErrorShadow[err] = true;\n  if (opt_msg !== undefined) {\n    error(opt_msg);\n  }\n}\nfunction wrapGLError(gl) {\n  var f = gl.getError;\n  gl.getError = function () {\n    var err;\n    do {\n      err = f.apply(gl);\n      if (err != gl.NO_ERROR) {\n        glErrorShadow[err] = true;\n      }\n    } while (err != gl.NO_ERROR);\n    for (var err in glErrorShadow) {\n      if (glErrorShadow[err]) {\n        delete glErrorShadow[err];\n        return parseInt(err);\n      }\n    }\n    return gl.NO_ERROR;\n  };\n}\nvar WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES(ext) {\n  var gl = ext.gl;\n  this.ext = ext;\n  this.isAlive = true;\n  this.hasBeenBound = false;\n  this.elementArrayBuffer = null;\n  this.attribs = new Array(ext.maxVertexAttribs);\n  for (var n = 0; n < this.attribs.length; n++) {\n    var attrib = new WebGLVertexArrayObjectOES.VertexAttrib(gl);\n    this.attribs[n] = attrib;\n  }\n  this.maxAttrib = 0;\n};\nWebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {\n  this.enabled = false;\n  this.buffer = null;\n  this.size = 4;\n  this.type = gl.FLOAT;\n  this.normalized = false;\n  this.stride = 16;\n  this.offset = 0;\n  this.cached = \"\";\n  this.recache();\n};\nWebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {\n  this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(\":\");\n};\nvar OESVertexArrayObject = function OESVertexArrayObject(gl) {\n  var self = this;\n  this.gl = gl;\n  wrapGLError(gl);\n  var original = this.original = {\n    getParameter: gl.getParameter,\n    enableVertexAttribArray: gl.enableVertexAttribArray,\n    disableVertexAttribArray: gl.disableVertexAttribArray,\n    bindBuffer: gl.bindBuffer,\n    getVertexAttrib: gl.getVertexAttrib,\n    vertexAttribPointer: gl.vertexAttribPointer\n  };\n  gl.getParameter = function getParameter(pname) {\n    if (pname == self.VERTEX_ARRAY_BINDING_OES) {\n      if (self.currentVertexArrayObject == self.defaultVertexArrayObject) {\n        return null;\n      } else {\n        return self.currentVertexArrayObject;\n      }\n    }\n    return original.getParameter.apply(this, arguments);\n  };\n  gl.enableVertexAttribArray = function enableVertexAttribArray(index) {\n    var vao = self.currentVertexArrayObject;\n    vao.maxAttrib = Math.max(vao.maxAttrib, index);\n    var attrib = vao.attribs[index];\n    attrib.enabled = true;\n    return original.enableVertexAttribArray.apply(this, arguments);\n  };\n  gl.disableVertexAttribArray = function disableVertexAttribArray(index) {\n    var vao = self.currentVertexArrayObject;\n    vao.maxAttrib = Math.max(vao.maxAttrib, index);\n    var attrib = vao.attribs[index];\n    attrib.enabled = false;\n    return original.disableVertexAttribArray.apply(this, arguments);\n  };\n  gl.bindBuffer = function bindBuffer(target, buffer) {\n    switch (target) {\n      case gl.ARRAY_BUFFER:\n        self.currentArrayBuffer = buffer;\n        break;\n      case gl.ELEMENT_ARRAY_BUFFER:\n        self.currentVertexArrayObject.elementArrayBuffer = buffer;\n        break;\n    }\n    return original.bindBuffer.apply(this, arguments);\n  };\n  gl.getVertexAttrib = function getVertexAttrib(index, pname) {\n    var vao = self.currentVertexArrayObject;\n    var attrib = vao.attribs[index];\n    switch (pname) {\n      case gl.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:\n        return attrib.buffer;\n      case gl.VERTEX_ATTRIB_ARRAY_ENABLED:\n        return attrib.enabled;\n      case gl.VERTEX_ATTRIB_ARRAY_SIZE:\n        return attrib.size;\n      case gl.VERTEX_ATTRIB_ARRAY_STRIDE:\n        return attrib.stride;\n      case gl.VERTEX_ATTRIB_ARRAY_TYPE:\n        return attrib.type;\n      case gl.VERTEX_ATTRIB_ARRAY_NORMALIZED:\n        return attrib.normalized;\n      default:\n        return original.getVertexAttrib.apply(this, arguments);\n    }\n  };\n  gl.vertexAttribPointer = function vertexAttribPointer(indx, size, type, normalized, stride, offset) {\n    var vao = self.currentVertexArrayObject;\n    vao.maxAttrib = Math.max(vao.maxAttrib, indx);\n    var attrib = vao.attribs[indx];\n    attrib.buffer = self.currentArrayBuffer;\n    attrib.size = size;\n    attrib.type = type;\n    attrib.normalized = normalized;\n    attrib.stride = stride;\n    attrib.offset = offset;\n    attrib.recache();\n    return original.vertexAttribPointer.apply(this, arguments);\n  };\n  if (gl.instrumentExtension) {\n    gl.instrumentExtension(this, \"OES_vertex_array_object\");\n  }\n  gl.canvas.addEventListener('webglcontextrestored', function () {\n    log(\"OESVertexArrayObject emulation library context restored\");\n    self.reset_();\n  }, true);\n  this.reset_();\n};\nOESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 0x85B5;\nOESVertexArrayObject.prototype.reset_ = function reset_() {\n  var contextWasLost = this.vertexArrayObjects !== undefined;\n  if (contextWasLost) {\n    for (var ii = 0; ii < this.vertexArrayObjects.length; ++ii) {\n      this.vertexArrayObjects.isAlive = false;\n    }\n  }\n  var gl = this.gl;\n  this.maxVertexAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n  this.defaultVertexArrayObject = new WebGLVertexArrayObjectOES(this);\n  this.currentVertexArrayObject = null;\n  this.currentArrayBuffer = null;\n  this.vertexArrayObjects = [this.defaultVertexArrayObject];\n  this.bindVertexArrayOES(null);\n};\nOESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {\n  var arrayObject = new WebGLVertexArrayObjectOES(this);\n  this.vertexArrayObjects.push(arrayObject);\n  return arrayObject;\n};\nOESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {\n  arrayObject.isAlive = false;\n  this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);\n  if (this.currentVertexArrayObject == arrayObject) {\n    this.bindVertexArrayOES(null);\n  }\n};\nOESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {\n  if (arrayObject && arrayObject instanceof WebGLVertexArrayObjectOES) {\n    if (arrayObject.hasBeenBound && arrayObject.ext == this) {\n      return true;\n    }\n  }\n  return false;\n};\nOESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {\n  var gl = this.gl;\n  if (arrayObject && !arrayObject.isAlive) {\n    synthesizeGLError(gl.INVALID_OPERATION, \"bindVertexArrayOES: attempt to bind deleted arrayObject\");\n    return;\n  }\n  var original = this.original;\n  var oldVAO = this.currentVertexArrayObject;\n  this.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;\n  this.currentVertexArrayObject.hasBeenBound = true;\n  var newVAO = this.currentVertexArrayObject;\n  if (oldVAO == newVAO) {\n    return;\n  }\n  if (!oldVAO || newVAO.elementArrayBuffer != oldVAO.elementArrayBuffer) {\n    original.bindBuffer.call(gl, gl.ELEMENT_ARRAY_BUFFER, newVAO.elementArrayBuffer);\n  }\n  var currentBinding = this.currentArrayBuffer;\n  var maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);\n  for (var n = 0; n <= maxAttrib; n++) {\n    var attrib = newVAO.attribs[n];\n    var oldAttrib = oldVAO ? oldVAO.attribs[n] : null;\n    if (!oldVAO || attrib.enabled != oldAttrib.enabled) {\n      if (attrib.enabled) {\n        original.enableVertexAttribArray.call(gl, n);\n      } else {\n        original.disableVertexAttribArray.call(gl, n);\n      }\n    }\n    if (attrib.enabled) {\n      var bufferChanged = false;\n      if (!oldVAO || attrib.buffer != oldAttrib.buffer) {\n        if (currentBinding != attrib.buffer) {\n          original.bindBuffer.call(gl, gl.ARRAY_BUFFER, attrib.buffer);\n          currentBinding = attrib.buffer;\n        }\n        bufferChanged = true;\n      }\n      if (bufferChanged || attrib.cached != oldAttrib.cached) {\n        original.vertexAttribPointer.call(gl, n, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);\n      }\n    }\n  }\n  if (this.currentArrayBuffer != currentBinding) {\n    original.bindBuffer.call(gl, gl.ARRAY_BUFFER, this.currentArrayBuffer);\n  }\n};\nconst setupVertexArrayObject = function setupVertexArrayObject(gl) {\n  if (gl.getSupportedExtensions) {\n    var exts = gl.getSupportedExtensions();\n    if (exts.indexOf(\"OES_vertex_array_object\") != -1) {\n      return;\n    }\n  } else if (gl.getExtension) {\n    var vao = gl.getExtension(\"OES_vertex_array_object\");\n    if (vao) {\n      return;\n    }\n  }\n  if (gl.getSupportedExtensions) {\n    var original_getSupportedExtensions = gl.getSupportedExtensions;\n    gl.getSupportedExtensions = function getSupportedExtensions() {\n      var list = original_getSupportedExtensions.call(this) || [];\n      list.push(\"OES_vertex_array_object\");\n      return list;\n    };\n  }\n  var original_getExtension = gl.getExtension;\n  gl.getExtension = function getExtension(name) {\n    if (name == \"OES_vertex_array_object\") {\n      if (!gl.__OESVertexArrayObject) {\n        gl.__OESVertexArrayObject = new OESVertexArrayObject(gl);\n      }\n      return gl.__OESVertexArrayObject;\n    }\n    if (original_getExtension) {\n      return original_getExtension.call(this, name);\n    } else {\n      return null;\n    }\n  };\n};\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/polyfill/OESVertexArrayObject.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/animation/animation.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/animation/animation.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Animation\": () => (/* binding */ Animation),\n/* harmony export */   \"Key\": () => (/* binding */ Key),\n/* harmony export */   \"Node\": () => (/* binding */ Node)\n/* harmony export */ });\nclass Key {\n  constructor(time, position, rotation, scale) {\n    this.time = time;\n    this.position = position;\n    this.rotation = rotation;\n    this.scale = scale;\n  }\n}\nclass Node {\n  constructor() {\n    this._name = '';\n    this._keys = [];\n  }\n}\nclass Animation {\n  constructor() {\n    this.name = '';\n    this.duration = 0;\n    this._nodes = [];\n    this._nodeDict = {};\n  }\n  getNode(name) {\n    return this._nodeDict[name];\n  }\n  addNode(node) {\n    this._nodes.push(node);\n    this._nodeDict[node._name] = node;\n  }\n  get nodes() {\n    return this._nodes;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/animation/animation.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/animation/skeleton.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/animation/skeleton.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Skeleton\": () => (/* binding */ Skeleton)\n/* harmony export */ });\n/* harmony import */ var _core_math_quat_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/math/quat.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/quat.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n\n\n\n\nclass InterpolatedKey {\n  constructor() {\n    this._written = false;\n    this._name = '';\n    this._keyFrames = [];\n    this._quat = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_0__.Quat();\n    this._pos = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n    this._scale = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n    this._targetNode = null;\n  }\n  getTarget() {\n    return this._targetNode;\n  }\n  setTarget(node) {\n    this._targetNode = node;\n  }\n}\nclass Skeleton {\n  constructor(graph) {\n    this.looping = true;\n    this._animation = null;\n    this._time = 0;\n    this._interpolatedKeys = [];\n    this._interpolatedKeyDict = {};\n    this._currKeyIndices = {};\n    this.graph = null;\n    const addInterpolatedKeys = node => {\n      const interpKey = new InterpolatedKey();\n      interpKey._name = node.name;\n      this._interpolatedKeys.push(interpKey);\n      this._interpolatedKeyDict[node.name] = interpKey;\n      this._currKeyIndices[node.name] = 0;\n      for (let i = 0; i < node._children.length; i++) addInterpolatedKeys(node._children[i]);\n    };\n    addInterpolatedKeys(graph);\n  }\n  set animation(value) {\n    this._animation = value;\n    this.currentTime = 0;\n  }\n  get animation() {\n    return this._animation;\n  }\n  set currentTime(value) {\n    this._time = value;\n    const numNodes = this._interpolatedKeys.length;\n    for (let i = 0; i < numNodes; i++) {\n      const node = this._interpolatedKeys[i];\n      const nodeName = node._name;\n      this._currKeyIndices[nodeName] = 0;\n    }\n    this.addTime(0);\n    this.updateGraph();\n  }\n  get currentTime() {\n    return this._time;\n  }\n  get numNodes() {\n    return this._interpolatedKeys.length;\n  }\n  addTime(delta) {\n    if (this._animation !== null) {\n      const nodes = this._animation._nodes;\n      const duration = this._animation.duration;\n      if (this._time === duration && !this.looping) {\n        return;\n      }\n      this._time += delta;\n      if (this._time > duration) {\n        this._time = this.looping ? 0.0 : duration;\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n          const nodeName = node._name;\n          this._currKeyIndices[nodeName] = 0;\n        }\n      } else if (this._time < 0) {\n        this._time = this.looping ? duration : 0.0;\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n          const nodeName = node._name;\n          this._currKeyIndices[nodeName] = node._keys.length - 2;\n        }\n      }\n      const offset = delta >= 0 ? 1 : -1;\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        const nodeName = node._name;\n        const keys = node._keys;\n        const interpKey = this._interpolatedKeyDict[nodeName];\n        if (interpKey === undefined) {\n          continue;\n        }\n        let foundKey = false;\n        if (keys.length !== 1) {\n          for (let currKeyIndex = this._currKeyIndices[nodeName]; currKeyIndex < keys.length - 1 && currKeyIndex >= 0; currKeyIndex += offset) {\n            const k1 = keys[currKeyIndex];\n            const k2 = keys[currKeyIndex + 1];\n            if (k1.time <= this._time && k2.time >= this._time) {\n              const alpha = (this._time - k1.time) / (k2.time - k1.time);\n              interpKey._pos.lerp(k1.position, k2.position, alpha);\n              interpKey._quat.slerp(k1.rotation, k2.rotation, alpha);\n              interpKey._scale.lerp(k1.scale, k2.scale, alpha);\n              interpKey._written = true;\n              this._currKeyIndices[nodeName] = currKeyIndex;\n              foundKey = true;\n              break;\n            }\n          }\n        }\n        if (keys.length === 1 || !foundKey && this._time === 0.0 && this.looping) {\n          interpKey._pos.copy(keys[0].position);\n          interpKey._quat.copy(keys[0].rotation);\n          interpKey._scale.copy(keys[0].scale);\n          interpKey._written = true;\n        }\n      }\n    }\n  }\n  blend(skel1, skel2, alpha) {\n    const numNodes = this._interpolatedKeys.length;\n    for (let i = 0; i < numNodes; i++) {\n      const key1 = skel1._interpolatedKeys[i];\n      const key2 = skel2._interpolatedKeys[i];\n      const dstKey = this._interpolatedKeys[i];\n      if (key1._written && key2._written) {\n        dstKey._quat.slerp(key1._quat, skel2._interpolatedKeys[i]._quat, alpha);\n        dstKey._pos.lerp(key1._pos, skel2._interpolatedKeys[i]._pos, alpha);\n        dstKey._scale.lerp(key1._scale, key2._scale, alpha);\n        dstKey._written = true;\n      } else if (key1._written) {\n        dstKey._quat.copy(key1._quat);\n        dstKey._pos.copy(key1._pos);\n        dstKey._scale.copy(key1._scale);\n        dstKey._written = true;\n      } else if (key2._written) {\n        dstKey._quat.copy(key2._quat);\n        dstKey._pos.copy(key2._pos);\n        dstKey._scale.copy(key2._scale);\n        dstKey._written = true;\n      }\n    }\n  }\n  setGraph(graph) {\n    this.graph = graph;\n    if (graph) {\n      for (let i = 0; i < this._interpolatedKeys.length; i++) {\n        const interpKey = this._interpolatedKeys[i];\n        const graphNode = graph.findByName(interpKey._name);\n        this._interpolatedKeys[i].setTarget(graphNode);\n      }\n    } else {\n      for (let i = 0; i < this._interpolatedKeys.length; i++) {\n        this._interpolatedKeys[i].setTarget(null);\n      }\n    }\n  }\n  updateGraph() {\n    if (this.graph) {\n      for (let i = 0; i < this._interpolatedKeys.length; i++) {\n        const interpKey = this._interpolatedKeys[i];\n        if (interpKey._written) {\n          const transform = interpKey.getTarget();\n          transform.localPosition.copy(interpKey._pos);\n          transform.localRotation.copy(interpKey._quat);\n          transform.localScale.copy(interpKey._scale);\n          if (!transform._dirtyLocal) transform._dirtifyLocal();\n          interpKey._written = false;\n        }\n      }\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/animation/skeleton.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/area-light-luts.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/area-light-luts.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AreaLightLuts\": () => (/* binding */ AreaLightLuts)\n/* harmony export */ });\n/* harmony import */ var _core_math_float_packing_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/math/float-packing.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/float-packing.js\");\n/* harmony import */ var _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/graphics/texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js\");\n/* harmony import */ var _platform_graphics_device_cache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/graphics/device-cache.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/device-cache.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n\n\n\n\n\nclass AreaLightCacheEntry {\n  constructor(texture0, texture1) {\n    this.texture0 = texture0;\n    this.texture1 = texture1;\n  }\n  destroy() {\n    var _this$texture, _this$texture2;\n    (_this$texture = this.texture0) == null ? void 0 : _this$texture.destroy();\n    (_this$texture2 = this.texture1) == null ? void 0 : _this$texture2.destroy();\n  }\n}\nconst deviceCache = new _platform_graphics_device_cache_js__WEBPACK_IMPORTED_MODULE_0__.DeviceCache();\nclass AreaLightLuts {\n  static createTexture(device, format, size, postfix = '') {\n    const tex = new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture(device, {\n      width: size,\n      height: size,\n      format: format,\n      addressU: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.ADDRESS_CLAMP_TO_EDGE,\n      addressV: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.ADDRESS_CLAMP_TO_EDGE,\n      type: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.TEXTURETYPE_DEFAULT,\n      magFilter: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.FILTER_LINEAR,\n      minFilter: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.FILTER_NEAREST,\n      anisotropy: 1,\n      name: `AreaLightLUT${postfix}`\n    });\n    return tex;\n  }\n  static applyTextures(device, texture1, texture2) {\n    deviceCache.remove(device);\n    deviceCache.get(device, () => {\n      return new AreaLightCacheEntry(texture1, texture1 === texture2 ? null : texture2);\n    });\n    device.scope.resolve('areaLightsLutTex1').setValue(texture1);\n    device.scope.resolve('areaLightsLutTex2').setValue(texture2);\n  }\n  static createPlaceholder(device) {\n    const texture = AreaLightLuts.createTexture(device, device.areaLightLutFormat, 2, 'placeholder');\n    const pixels = texture.lock();\n    pixels.fill(0);\n    texture.unlock();\n    AreaLightLuts.applyTextures(device, texture, texture);\n  }\n  static set(device, ltcMat1, ltcMat2) {\n    function buildTexture(device, data, format) {\n      const texture = AreaLightLuts.createTexture(device, format, 64);\n      texture.lock().set(data);\n      texture.unlock();\n      return texture;\n    }\n    function offsetScale(data, offset, scale) {\n      const count = data.length;\n      const ret = new Float32Array(count);\n      for (let i = 0; i < count; i++) {\n        const n = i % 4;\n        ret[i] = (data[i] + offset[n]) * scale[n];\n      }\n      return ret;\n    }\n    function convertToHalfFloat(data) {\n      const count = data.length;\n      const ret = new Uint16Array(count);\n      const float2Half = _core_math_float_packing_js__WEBPACK_IMPORTED_MODULE_3__.FloatPacking.float2Half;\n      for (let i = 0; i < count; i++) {\n        ret[i] = float2Half(data[i]);\n      }\n      return ret;\n    }\n    function convertToUint(data) {\n      const count = data.length;\n      const ret = new Uint8ClampedArray(count);\n      for (let i = 0; i < count; i++) {\n        ret[i] = data[i] * 255;\n      }\n      return ret;\n    }\n    const srcData1 = ltcMat1;\n    const srcData2 = ltcMat2;\n    let data1, data2;\n    const format = device.areaLightLutFormat;\n    if (format === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.PIXELFORMAT_RGBA32F) {\n      data1 = srcData1;\n      data2 = srcData2;\n    } else if (format === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.PIXELFORMAT_RGBA16F) {\n      data1 = convertToHalfFloat(srcData1);\n      data2 = convertToHalfFloat(srcData2);\n    } else {\n      const o1 = [0.0, 0.2976, 0.01381, 0.0];\n      const s1 = [0.999, 3.08737, 1.6546, 0.603249];\n      const o2 = [-0.306897, 0.0, 0.0, 0.0];\n      const s2 = [1.442787, 1.0, 1.0, 1.0];\n      data1 = convertToUint(offsetScale(srcData1, o1, s1));\n      data2 = convertToUint(offsetScale(srcData2, o2, s2));\n    }\n    const tex1 = buildTexture(device, data1, format);\n    const tex2 = buildTexture(device, data2, format);\n    AreaLightLuts.applyTextures(device, tex1, tex2);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/area-light-luts.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/batching/batch-group.js":
/*!************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/batching/batch-group.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BatchGroup\": () => (/* binding */ BatchGroup)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n\n\nclass BatchGroup {\n  constructor(id, name, dynamic, maxAabbSize, layers = [_constants_js__WEBPACK_IMPORTED_MODULE_0__.LAYERID_WORLD]) {\n    this.dynamic = dynamic;\n    this.maxAabbSize = maxAabbSize;\n    this.id = id;\n    this.name = name;\n    this.layers = layers;\n    this._ui = false;\n    this._sprite = false;\n    this._obj = {\n      model: [],\n      element: [],\n      sprite: [],\n      render: []\n    };\n  }\n}\nBatchGroup.MODEL = 'model';\nBatchGroup.ELEMENT = 'element';\nBatchGroup.SPRITE = 'sprite';\nBatchGroup.RENDER = 'render';\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/batching/batch-group.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/batching/batch-manager.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/batching/batch-manager.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BatchManager\": () => (/* binding */ BatchManager)\n/* harmony export */ });\n/* harmony import */ var _core_math_mat3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/math/mat3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat3.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/shape/bounding-box.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/shape/bounding-box.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _mesh_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../mesh.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh.js\");\n/* harmony import */ var _mesh_instance_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../mesh-instance.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh-instance.js\");\n/* harmony import */ var _shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../shader-lib/chunks/chunks.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/chunks.js\");\n/* harmony import */ var _batch_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./batch.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/batching/batch.js\");\n/* harmony import */ var _batch_group_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./batch-group.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/batching/batch-group.js\");\n/* harmony import */ var _skin_batch_instance_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./skin-batch-instance.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/batching/skin-batch-instance.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction paramsIdentical(a, b) {\n  if (a && !b) return false;\n  if (!a && b) return false;\n  a = a.data;\n  b = b.data;\n  if (a === b) return true;\n  if (a instanceof Float32Array && b instanceof Float32Array) {\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n  return false;\n}\nfunction equalParamSets(params1, params2) {\n  for (const param in params1) {\n    if (params1.hasOwnProperty(param) && !paramsIdentical(params1[param], params2[param])) return false;\n  }\n  for (const param in params2) {\n    if (params2.hasOwnProperty(param) && !paramsIdentical(params2[param], params1[param])) return false;\n  }\n  return true;\n}\nfunction equalLightLists(lightList1, lightList2) {\n  for (let k = 0; k < lightList1.length; k++) {\n    if (lightList2.indexOf(lightList1[k]) < 0) return false;\n  }\n  for (let k = 0; k < lightList2.length; k++) {\n    if (lightList1.indexOf(lightList2[k]) < 0) return false;\n  }\n  return true;\n}\nconst mat3 = new _core_math_mat3_js__WEBPACK_IMPORTED_MODULE_0__.Mat3();\nconst worldMatX = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst worldMatY = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst worldMatZ = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nfunction getScaleSign(mi) {\n  const wt = mi.node.worldTransform;\n  wt.getX(worldMatX);\n  wt.getY(worldMatY);\n  wt.getZ(worldMatZ);\n  worldMatX.cross(worldMatX, worldMatY);\n  return worldMatX.dot(worldMatZ) >= 0 ? 1 : -1;\n}\nclass BatchManager {\n  constructor(device, root, scene) {\n    this.device = device;\n    this.rootNode = root;\n    this.scene = scene;\n    this._init = false;\n    this._batchGroups = {};\n    this._batchGroupCounter = 0;\n    this._batchList = [];\n    this._dirtyGroups = [];\n  }\n  destroy() {\n    this.device = null;\n    this.rootNode = null;\n    this.scene = null;\n    this._batchGroups = {};\n    this._batchList = [];\n    this._dirtyGroups = [];\n  }\n  addGroup(name, dynamic, maxAabbSize, id, layers) {\n    if (id === undefined) {\n      id = this._batchGroupCounter;\n      this._batchGroupCounter++;\n    }\n    if (this._batchGroups[id]) {\n      return undefined;\n    }\n    const group = new _batch_group_js__WEBPACK_IMPORTED_MODULE_2__.BatchGroup(id, name, dynamic, maxAabbSize, layers);\n    this._batchGroups[id] = group;\n    return group;\n  }\n  removeGroup(id) {\n    if (!this._batchGroups[id]) {\n      return;\n    }\n    const newBatchList = [];\n    for (let i = 0; i < this._batchList.length; i++) {\n      if (this._batchList[i].batchGroupId === id) {\n        this.destroyBatch(this._batchList[i]);\n      } else {\n        newBatchList.push(this._batchList[i]);\n      }\n    }\n    this._batchList = newBatchList;\n    this._removeModelsFromBatchGroup(this.rootNode, id);\n    delete this._batchGroups[id];\n  }\n  markGroupDirty(id) {\n    if (this._dirtyGroups.indexOf(id) < 0) {\n      this._dirtyGroups.push(id);\n    }\n  }\n  getGroupByName(name) {\n    const groups = this._batchGroups;\n    for (const group in groups) {\n      if (!groups.hasOwnProperty(group)) continue;\n      if (groups[group].name === name) {\n        return groups[group];\n      }\n    }\n    return null;\n  }\n  getBatches(batchGroupId) {\n    const results = [];\n    const len = this._batchList.length;\n    for (let i = 0; i < len; i++) {\n      const batch = this._batchList[i];\n      if (batch.batchGroupId === batchGroupId) {\n        results.push(batch);\n      }\n    }\n    return results;\n  }\n  _removeModelsFromBatchGroup(node, id) {\n    if (!node.enabled) return;\n    if (node.model && node.model.batchGroupId === id) {\n      node.model.batchGroupId = -1;\n    }\n    if (node.render && node.render.batchGroupId === id) {\n      node.render.batchGroupId = -1;\n    }\n    if (node.element && node.element.batchGroupId === id) {\n      node.element.batchGroupId = -1;\n    }\n    if (node.sprite && node.sprite.batchGroupId === id) {\n      node.sprite.batchGroupId = -1;\n    }\n    for (let i = 0; i < node._children.length; i++) {\n      this._removeModelsFromBatchGroup(node._children[i], id);\n    }\n  }\n  insert(type, groupId, node) {\n    const group = this._batchGroups[groupId];\n    if (group) {\n      if (group._obj[type].indexOf(node) < 0) {\n        group._obj[type].push(node);\n        this.markGroupDirty(groupId);\n      }\n    }\n  }\n  remove(type, groupId, node) {\n    const group = this._batchGroups[groupId];\n    if (group) {\n      const idx = group._obj[type].indexOf(node);\n      if (idx >= 0) {\n        group._obj[type].splice(idx, 1);\n        this.markGroupDirty(groupId);\n      }\n    }\n  }\n  _extractRender(node, arr, group, groupMeshInstances) {\n    if (node.render) {\n      if (node.render.isStatic) {\n        const drawCalls = this.scene.drawCalls;\n        const nodeMeshInstances = node.render.meshInstances;\n        for (let i = 0; i < drawCalls.length; i++) {\n          if (!drawCalls[i]._staticSource) continue;\n          if (nodeMeshInstances.indexOf(drawCalls[i]._staticSource) < 0) continue;\n          arr.push(drawCalls[i]);\n        }\n        for (let i = 0; i < nodeMeshInstances.length; i++) {\n          if (drawCalls.indexOf(nodeMeshInstances[i]) >= 0) {\n            arr.push(nodeMeshInstances[i]);\n          }\n        }\n      } else {\n        arr = groupMeshInstances[node.render.batchGroupId] = arr.concat(node.render.meshInstances);\n      }\n      node.render.removeFromLayers();\n    }\n    return arr;\n  }\n  _extractModel(node, arr, group, groupMeshInstances) {\n    if (node.model && node.model.model) {\n      if (node.model.isStatic) {\n        const drawCalls = this.scene.drawCalls;\n        const nodeMeshInstances = node.model.meshInstances;\n        for (let i = 0; i < drawCalls.length; i++) {\n          if (!drawCalls[i]._staticSource) continue;\n          if (nodeMeshInstances.indexOf(drawCalls[i]._staticSource) < 0) continue;\n          arr.push(drawCalls[i]);\n        }\n        for (let i = 0; i < nodeMeshInstances.length; i++) {\n          if (drawCalls.indexOf(nodeMeshInstances[i]) >= 0) {\n            arr.push(nodeMeshInstances[i]);\n          }\n        }\n      } else {\n        arr = groupMeshInstances[node.model.batchGroupId] = arr.concat(node.model.meshInstances);\n      }\n      node.model.removeModelFromLayers();\n    }\n    return arr;\n  }\n  _extractElement(node, arr, group) {\n    if (!node.element) return;\n    let valid = false;\n    if (node.element._text && node.element._text._model.meshInstances.length > 0) {\n      arr.push(node.element._text._model.meshInstances[0]);\n      node.element.removeModelFromLayers(node.element._text._model);\n      valid = true;\n    } else if (node.element._image) {\n      arr.push(node.element._image._renderable.meshInstance);\n      node.element.removeModelFromLayers(node.element._image._renderable.model);\n      if (node.element._image._renderable.unmaskMeshInstance) {\n        arr.push(node.element._image._renderable.unmaskMeshInstance);\n        if (!node.element._image._renderable.unmaskMeshInstance.stencilFront || !node.element._image._renderable.unmaskMeshInstance.stencilBack) {\n          node.element._dirtifyMask();\n          node.element._onPrerender();\n        }\n      }\n      valid = true;\n    }\n    if (valid) {\n      group._ui = true;\n    }\n  }\n  _collectAndRemoveMeshInstances(groupMeshInstances, groupIds) {\n    for (let g = 0; g < groupIds.length; g++) {\n      const id = groupIds[g];\n      const group = this._batchGroups[id];\n      if (!group) continue;\n      let arr = groupMeshInstances[id];\n      if (!arr) arr = groupMeshInstances[id] = [];\n      for (let m = 0; m < group._obj.model.length; m++) {\n        arr = this._extractModel(group._obj.model[m], arr, group, groupMeshInstances);\n      }\n      for (let r = 0; r < group._obj.render.length; r++) {\n        arr = this._extractRender(group._obj.render[r], arr, group, groupMeshInstances);\n      }\n      for (let e = 0; e < group._obj.element.length; e++) {\n        this._extractElement(group._obj.element[e], arr, group);\n      }\n      for (let s = 0; s < group._obj.sprite.length; s++) {\n        const node = group._obj.sprite[s];\n        if (node.sprite && node.sprite._meshInstance && (group.dynamic || node.sprite.sprite._renderMode === _constants_js__WEBPACK_IMPORTED_MODULE_3__.SPRITE_RENDERMODE_SIMPLE)) {\n          arr.push(node.sprite._meshInstance);\n          node.sprite.removeModelFromLayers();\n          group._sprite = true;\n          node.sprite._batchGroup = group;\n        }\n      }\n    }\n  }\n  generate(groupIds) {\n    const groupMeshInstances = {};\n    if (!groupIds) {\n      groupIds = Object.keys(this._batchGroups);\n    }\n    const newBatchList = [];\n    for (let i = 0; i < this._batchList.length; i++) {\n      if (groupIds.indexOf(this._batchList[i].batchGroupId) < 0) {\n        newBatchList.push(this._batchList[i]);\n        continue;\n      }\n      this.destroyBatch(this._batchList[i]);\n    }\n    this._batchList = newBatchList;\n    this._collectAndRemoveMeshInstances(groupMeshInstances, groupIds);\n    if (groupIds === this._dirtyGroups) {\n      this._dirtyGroups.length = 0;\n    } else {\n      const newDirtyGroups = [];\n      for (let i = 0; i < this._dirtyGroups.length; i++) {\n        if (groupIds.indexOf(this._dirtyGroups[i]) < 0) newDirtyGroups.push(this._dirtyGroups[i]);\n      }\n      this._dirtyGroups = newDirtyGroups;\n    }\n    let group, lists, groupData, batch;\n    for (const groupId in groupMeshInstances) {\n      if (!groupMeshInstances.hasOwnProperty(groupId)) continue;\n      group = groupMeshInstances[groupId];\n      groupData = this._batchGroups[groupId];\n      if (!groupData) {\n        continue;\n      }\n      lists = this.prepare(group, groupData.dynamic, groupData.maxAabbSize, groupData._ui || groupData._sprite);\n      for (let i = 0; i < lists.length; i++) {\n        batch = this.create(lists[i], groupData.dynamic, parseInt(groupId, 10));\n        if (batch) {\n          batch.addToLayers(this.scene, groupData.layers);\n        }\n      }\n    }\n  }\n  prepare(meshInstances, dynamic, maxAabbSize = Number.POSITIVE_INFINITY, translucent) {\n    if (meshInstances.length === 0) return [];\n    const halfMaxAabbSize = maxAabbSize * 0.5;\n    const maxInstanceCount = this.device.supportsBoneTextures ? 1024 : this.device.boneLimit;\n    const maxNumVertices = this.device.extUintElement ? 0xffffffff : 0xffff;\n    const aabb = new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_4__.BoundingBox();\n    const testAabb = new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_4__.BoundingBox();\n    let skipTranslucentAabb = null;\n    let sf;\n    const lists = [];\n    let j = 0;\n    if (translucent) {\n      meshInstances.sort(function (a, b) {\n        return a.drawOrder - b.drawOrder;\n      });\n    }\n    let meshInstancesLeftA = meshInstances;\n    let meshInstancesLeftB;\n    const skipMesh = translucent ? function (mi) {\n      if (skipTranslucentAabb) {\n        skipTranslucentAabb.add(mi.aabb);\n      } else {\n        skipTranslucentAabb = mi.aabb.clone();\n      }\n      meshInstancesLeftB.push(mi);\n    } : function (mi) {\n      meshInstancesLeftB.push(mi);\n    };\n    while (meshInstancesLeftA.length > 0) {\n      lists[j] = [meshInstancesLeftA[0]];\n      meshInstancesLeftB = [];\n      const material = meshInstancesLeftA[0].material;\n      const layer = meshInstancesLeftA[0].layer;\n      const defs = meshInstancesLeftA[0]._shaderDefs;\n      const params = meshInstancesLeftA[0].parameters;\n      const stencil = meshInstancesLeftA[0].stencilFront;\n      const lightList = meshInstancesLeftA[0]._staticLightList;\n      let vertCount = meshInstancesLeftA[0].mesh.vertexBuffer.getNumVertices();\n      const drawOrder = meshInstancesLeftA[0].drawOrder;\n      aabb.copy(meshInstancesLeftA[0].aabb);\n      const scaleSign = getScaleSign(meshInstancesLeftA[0]);\n      const vertexFormatBatchingHash = meshInstancesLeftA[0].mesh.vertexBuffer.format.batchingHash;\n      const indexed = meshInstancesLeftA[0].mesh.primitive[0].indexed;\n      skipTranslucentAabb = null;\n      for (let i = 1; i < meshInstancesLeftA.length; i++) {\n        const mi = meshInstancesLeftA[i];\n        if (dynamic && lists[j].length >= maxInstanceCount) {\n          meshInstancesLeftB = meshInstancesLeftB.concat(meshInstancesLeftA.slice(i));\n          break;\n        }\n        if (material !== mi.material || layer !== mi.layer || vertexFormatBatchingHash !== mi.mesh.vertexBuffer.format.batchingHash || indexed !== mi.mesh.primitive[0].indexed || defs !== mi._shaderDefs || vertCount + mi.mesh.vertexBuffer.getNumVertices() > maxNumVertices) {\n          skipMesh(mi);\n          continue;\n        }\n        testAabb.copy(aabb);\n        testAabb.add(mi.aabb);\n        if (testAabb.halfExtents.x > halfMaxAabbSize || testAabb.halfExtents.y > halfMaxAabbSize || testAabb.halfExtents.z > halfMaxAabbSize) {\n          skipMesh(mi);\n          continue;\n        }\n        if (stencil) {\n          if (!(sf = mi.stencilFront) || stencil.func !== sf.func || stencil.zpass !== sf.zpass) {\n            skipMesh(mi);\n            continue;\n          }\n        }\n        if (scaleSign !== getScaleSign(mi)) {\n          skipMesh(mi);\n          continue;\n        }\n        if (!equalParamSets(params, mi.parameters)) {\n          skipMesh(mi);\n          continue;\n        }\n        const staticLights = mi._staticLightList;\n        if (lightList && staticLights) {\n          if (!equalLightLists(lightList, staticLights)) {\n            skipMesh(mi);\n            continue;\n          }\n        } else if (lightList || staticLights) {\n          skipMesh(mi);\n          continue;\n        }\n        if (translucent && skipTranslucentAabb && skipTranslucentAabb.intersects(mi.aabb) && mi.drawOrder !== drawOrder) {\n          skipMesh(mi);\n          continue;\n        }\n        aabb.add(mi.aabb);\n        vertCount += mi.mesh.vertexBuffer.getNumVertices();\n        lists[j].push(mi);\n      }\n      j++;\n      meshInstancesLeftA = meshInstancesLeftB;\n    }\n    return lists;\n  }\n  collectBatchedMeshData(meshInstances, dynamic) {\n    let streams = null;\n    let batchNumVerts = 0;\n    let batchNumIndices = 0;\n    let material = null;\n    for (let i = 0; i < meshInstances.length; i++) {\n      if (meshInstances[i].visible) {\n        const mesh = meshInstances[i].mesh;\n        const numVerts = mesh.vertexBuffer.numVertices;\n        batchNumVerts += numVerts;\n        batchNumIndices += mesh.primitive[0].indexed ? mesh.primitive[0].count : mesh.primitive[0].type === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.PRIMITIVE_TRIFAN && mesh.primitive[0].count === 4 ? 6 : 0;\n        if (!streams) {\n          material = meshInstances[i].material;\n          streams = {};\n          const elems = mesh.vertexBuffer.format.elements;\n          for (let j = 0; j < elems.length; j++) {\n            const semantic = elems[j].name;\n            streams[semantic] = {\n              numComponents: elems[j].numComponents,\n              dataType: elems[j].dataType,\n              normalize: elems[j].normalize,\n              count: 0\n            };\n          }\n          if (dynamic) {\n            streams[_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.SEMANTIC_BLENDINDICES] = {\n              numComponents: 1,\n              dataType: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.TYPE_FLOAT32,\n              normalize: false,\n              count: 0\n            };\n          }\n        }\n      }\n    }\n    return {\n      streams: streams,\n      batchNumVerts: batchNumVerts,\n      batchNumIndices: batchNumIndices,\n      material: material\n    };\n  }\n  create(meshInstances, dynamic, batchGroupId) {\n    if (!this._init) {\n      const boneLimit = '#define BONE_LIMIT ' + this.device.getBoneLimit() + '\\n';\n      this.transformVS = boneLimit + '#define DYNAMICBATCH\\n' + _shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_6__.shaderChunks.transformVS;\n      this.skinTexVS = _shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_6__.shaderChunks.skinBatchTexVS;\n      this.skinConstVS = _shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_6__.shaderChunks.skinBatchConstVS;\n      this.vertexFormats = {};\n      this._init = true;\n    }\n    let stream = null;\n    let semantic;\n    let mesh, numVerts;\n    let batch = null;\n    const batchData = this.collectBatchedMeshData(meshInstances, dynamic);\n    if (batchData.streams) {\n      const streams = batchData.streams;\n      let material = batchData.material;\n      const batchNumVerts = batchData.batchNumVerts;\n      const batchNumIndices = batchData.batchNumIndices;\n      batch = new _batch_js__WEBPACK_IMPORTED_MODULE_7__.Batch(meshInstances, dynamic, batchGroupId);\n      this._batchList.push(batch);\n      let indexBase, numIndices, indexData;\n      let verticesOffset = 0;\n      let indexOffset = 0;\n      let transform;\n      const vec = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n      const indexArrayType = batchNumVerts <= 0xffff ? Uint16Array : Uint32Array;\n      const indices = new indexArrayType(batchNumIndices);\n      for (semantic in streams) {\n        stream = streams[semantic];\n        stream.typeArrayType = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.typedArrayTypes[stream.dataType];\n        stream.elementByteSize = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.typedArrayTypesByteSize[stream.dataType];\n        stream.buffer = new stream.typeArrayType(batchNumVerts * stream.numComponents);\n      }\n      for (let i = 0; i < meshInstances.length; i++) {\n        if (!meshInstances[i].visible) continue;\n        mesh = meshInstances[i].mesh;\n        numVerts = mesh.vertexBuffer.numVertices;\n        if (!dynamic) {\n          transform = meshInstances[i].node.getWorldTransform();\n        }\n        for (semantic in streams) {\n          if (semantic !== _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.SEMANTIC_BLENDINDICES) {\n            stream = streams[semantic];\n            const subarray = new stream.typeArrayType(stream.buffer.buffer, stream.elementByteSize * stream.count);\n            const totalComponents = mesh.getVertexStream(semantic, subarray) * stream.numComponents;\n            stream.count += totalComponents;\n            if (!dynamic && stream.numComponents >= 3) {\n              if (semantic === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.SEMANTIC_POSITION) {\n                for (let j = 0; j < totalComponents; j += stream.numComponents) {\n                  vec.set(subarray[j], subarray[j + 1], subarray[j + 2]);\n                  transform.transformPoint(vec, vec);\n                  subarray[j] = vec.x;\n                  subarray[j + 1] = vec.y;\n                  subarray[j + 2] = vec.z;\n                }\n              } else if (semantic === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.SEMANTIC_NORMAL || semantic === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.SEMANTIC_TANGENT) {\n                transform.invertTo3x3(mat3);\n                mat3.transpose();\n                for (let j = 0; j < totalComponents; j += stream.numComponents) {\n                  vec.set(subarray[j], subarray[j + 1], subarray[j + 2]);\n                  mat3.transformVector(vec, vec);\n                  subarray[j] = vec.x;\n                  subarray[j + 1] = vec.y;\n                  subarray[j + 2] = vec.z;\n                }\n              }\n            }\n          }\n        }\n        if (dynamic) {\n          stream = streams[_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.SEMANTIC_BLENDINDICES];\n          for (let j = 0; j < numVerts; j++) stream.buffer[stream.count++] = i;\n        }\n        if (mesh.primitive[0].indexed) {\n          indexBase = mesh.primitive[0].base;\n          numIndices = mesh.primitive[0].count;\n          const srcFormat = mesh.indexBuffer[0].getFormat();\n          indexData = new _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.typedArrayIndexFormats[srcFormat](mesh.indexBuffer[0].storage);\n        } else if (mesh.primitive[0].type === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.PRIMITIVE_TRIFAN && mesh.primitive[0].count === 4) {\n          indexBase = 0;\n          numIndices = 6;\n          indexData = [0, 1, 3, 2, 3, 1];\n        } else {\n          numIndices = 0;\n          continue;\n        }\n        for (let j = 0; j < numIndices; j++) {\n          indices[j + indexOffset] = indexData[indexBase + j] + verticesOffset;\n        }\n        indexOffset += numIndices;\n        verticesOffset += numVerts;\n      }\n      mesh = new _mesh_js__WEBPACK_IMPORTED_MODULE_8__.Mesh(this.device);\n      for (semantic in streams) {\n        stream = streams[semantic];\n        mesh.setVertexStream(semantic, stream.buffer, stream.numComponents, undefined, stream.dataType, stream.normalize);\n      }\n      if (indices.length > 0) mesh.setIndices(indices);\n      mesh.update(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.PRIMITIVE_TRIANGLES, false);\n      if (dynamic) {\n        material = material.clone();\n        material.chunks.transformVS = this.transformVS;\n        material.chunks.skinTexVS = this.skinTexVS;\n        material.chunks.skinConstVS = this.skinConstVS;\n        material.update();\n      }\n      const meshInstance = new _mesh_instance_js__WEBPACK_IMPORTED_MODULE_9__.MeshInstance(mesh, material, this.rootNode);\n      meshInstance.castShadow = batch.origMeshInstances[0].castShadow;\n      meshInstance.parameters = batch.origMeshInstances[0].parameters;\n      meshInstance.isStatic = batch.origMeshInstances[0].isStatic;\n      meshInstance.layer = batch.origMeshInstances[0].layer;\n      meshInstance._staticLightList = batch.origMeshInstances[0]._staticLightList;\n      meshInstance._shaderDefs = batch.origMeshInstances[0]._shaderDefs;\n      meshInstance.cull = batch.origMeshInstances[0].cull;\n      const batchGroup = this._batchGroups[batchGroupId];\n      if (batchGroup && batchGroup._ui) meshInstance.cull = false;\n      if (dynamic) {\n        const nodes = [];\n        for (let i = 0; i < batch.origMeshInstances.length; i++) {\n          nodes.push(batch.origMeshInstances[i].node);\n        }\n        meshInstance.skinInstance = new _skin_batch_instance_js__WEBPACK_IMPORTED_MODULE_10__.SkinBatchInstance(this.device, nodes, this.rootNode);\n      }\n      meshInstance._updateAabb = false;\n      meshInstance.drawOrder = batch.origMeshInstances[0].drawOrder;\n      meshInstance.stencilFront = batch.origMeshInstances[0].stencilFront;\n      meshInstance.stencilBack = batch.origMeshInstances[0].stencilBack;\n      meshInstance.flipFaces = getScaleSign(batch.origMeshInstances[0]) < 0;\n      meshInstance.castShadow = batch.origMeshInstances[0].castShadow;\n      batch.meshInstance = meshInstance;\n      batch.updateBoundingBox();\n    }\n    return batch;\n  }\n  updateAll() {\n    if (this._dirtyGroups.length > 0) {\n      this.generate(this._dirtyGroups);\n    }\n    for (let i = 0; i < this._batchList.length; i++) {\n      if (!this._batchList[i].dynamic) continue;\n      this._batchList[i].updateBoundingBox();\n    }\n  }\n  clone(batch, clonedMeshInstances) {\n    const batch2 = new _batch_js__WEBPACK_IMPORTED_MODULE_7__.Batch(clonedMeshInstances, batch.dynamic, batch.batchGroupId);\n    this._batchList.push(batch2);\n    const nodes = [];\n    for (let i = 0; i < clonedMeshInstances.length; i++) {\n      nodes.push(clonedMeshInstances[i].node);\n    }\n    batch2.meshInstance = new _mesh_instance_js__WEBPACK_IMPORTED_MODULE_9__.MeshInstance(batch.meshInstance.mesh, batch.meshInstance.material, batch.meshInstance.node);\n    batch2.meshInstance._updateAabb = false;\n    batch2.meshInstance.parameters = clonedMeshInstances[0].parameters;\n    batch2.meshInstance.isStatic = clonedMeshInstances[0].isStatic;\n    batch2.meshInstance.cull = clonedMeshInstances[0].cull;\n    batch2.meshInstance.layer = clonedMeshInstances[0].layer;\n    batch2.meshInstance._staticLightList = clonedMeshInstances[0]._staticLightList;\n    if (batch.dynamic) {\n      batch2.meshInstance.skinInstance = new _skin_batch_instance_js__WEBPACK_IMPORTED_MODULE_10__.SkinBatchInstance(this.device, nodes, this.rootNode);\n    }\n    batch2.meshInstance.castShadow = batch.meshInstance.castShadow;\n    batch2.meshInstance._shader = batch.meshInstance._shader.slice();\n    batch2.meshInstance.castShadow = batch.meshInstance.castShadow;\n    return batch2;\n  }\n  destroyBatch(batch) {\n    batch.destroy(this.scene, this._batchGroups[batch.batchGroupId].layers);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/batching/batch-manager.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/batching/batch.js":
/*!******************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/batching/batch.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Batch\": () => (/* binding */ Batch)\n/* harmony export */ });\n/* harmony import */ var _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/shape/bounding-box.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/shape/bounding-box.js\");\n\n\nclass Batch {\n  constructor(meshInstances, dynamic, batchGroupId) {\n    this.origMeshInstances = meshInstances;\n    this._aabb = new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_0__.BoundingBox();\n    this.meshInstance = null;\n    this.dynamic = dynamic;\n    this.batchGroupId = batchGroupId;\n  }\n  destroy(scene, layers) {\n    if (this.meshInstance) {\n      this.removeFromLayers(scene, layers);\n      this.meshInstance.destroy();\n      this.meshInstance = null;\n    }\n  }\n  addToLayers(scene, layers) {\n    for (let i = 0; i < layers.length; i++) {\n      const layer = scene.layers.getLayerById(layers[i]);\n      if (layer) {\n        layer.addMeshInstances([this.meshInstance]);\n      }\n    }\n  }\n  removeFromLayers(scene, layers) {\n    for (let i = 0; i < layers.length; i++) {\n      const layer = scene.layers.getLayerById(layers[i]);\n      if (layer) {\n        layer.removeMeshInstances([this.meshInstance]);\n      }\n    }\n  }\n  updateBoundingBox() {\n    this._aabb.copy(this.origMeshInstances[0].aabb);\n    for (let i = 1; i < this.origMeshInstances.length; i++) {\n      this._aabb.add(this.origMeshInstances[i].aabb);\n    }\n    this.meshInstance.aabb = this._aabb;\n    this.meshInstance._aabbVer = 0;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/batching/batch.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/batching/skin-batch-instance.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/batching/skin-batch-instance.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SkinBatchInstance\": () => (/* binding */ SkinBatchInstance)\n/* harmony export */ });\n/* harmony import */ var _skin_instance_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../skin-instance.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/skin-instance.js\");\n\n\nclass SkinBatchInstance extends _skin_instance_js__WEBPACK_IMPORTED_MODULE_0__.SkinInstance {\n  constructor(device, nodes, rootNode) {\n    super();\n    const numBones = nodes.length;\n    this.init(device, numBones);\n    this.device = device;\n    this.rootNode = rootNode;\n    this.bones = nodes;\n  }\n  updateMatrices(rootNode, skinUpdateIndex) {}\n  updateMatrixPalette(rootNode, skinUpdateIndex) {\n    const mp = this.matrixPalette;\n    const count = this.bones.length;\n    for (let i = 0; i < count; i++) {\n      const pe = this.bones[i].getWorldTransform().data;\n      const base = i * 12;\n      mp[base] = pe[0];\n      mp[base + 1] = pe[4];\n      mp[base + 2] = pe[8];\n      mp[base + 3] = pe[12];\n      mp[base + 4] = pe[1];\n      mp[base + 5] = pe[5];\n      mp[base + 6] = pe[9];\n      mp[base + 7] = pe[13];\n      mp[base + 8] = pe[2];\n      mp[base + 9] = pe[6];\n      mp[base + 10] = pe[10];\n      mp[base + 11] = pe[14];\n    }\n    this.uploadBones(this.device);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/batching/skin-batch-instance.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/camera.js":
/*!**********************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/camera.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Camera\": () => (/* binding */ Camera)\n/* harmony export */ });\n/* harmony import */ var _core_math_color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/math/color.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n/* harmony import */ var _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/math/mat4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/math/vec4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec4.js\");\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _core_shape_frustum_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/shape/frustum.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/shape/frustum.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n\n\n\n\n\n\n\n\nconst _deviceCoord = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst _halfSize = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst _point = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst _invViewProjMat = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__.Mat4();\nconst _frustumPoints = [new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3()];\nclass Camera {\n  constructor() {\n    this._aspectRatio = 16 / 9;\n    this._aspectRatioMode = _constants_js__WEBPACK_IMPORTED_MODULE_2__.ASPECT_AUTO;\n    this._calculateProjection = null;\n    this._calculateTransform = null;\n    this._clearColor = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_3__.Color(0.75, 0.75, 0.75, 1);\n    this._clearColorBuffer = true;\n    this._clearDepth = 1;\n    this._clearDepthBuffer = true;\n    this._clearStencil = 0;\n    this._clearStencilBuffer = true;\n    this._cullingMask = 0xFFFFFFFF;\n    this._cullFaces = true;\n    this._farClip = 1000;\n    this._flipFaces = false;\n    this._fov = 45;\n    this._frustumCulling = true;\n    this._horizontalFov = false;\n    this._layers = [_constants_js__WEBPACK_IMPORTED_MODULE_2__.LAYERID_WORLD, _constants_js__WEBPACK_IMPORTED_MODULE_2__.LAYERID_DEPTH, _constants_js__WEBPACK_IMPORTED_MODULE_2__.LAYERID_SKYBOX, _constants_js__WEBPACK_IMPORTED_MODULE_2__.LAYERID_UI, _constants_js__WEBPACK_IMPORTED_MODULE_2__.LAYERID_IMMEDIATE];\n    this._layersSet = new Set(this._layers);\n    this._nearClip = 0.1;\n    this._node = null;\n    this._orthoHeight = 10;\n    this._projection = _constants_js__WEBPACK_IMPORTED_MODULE_2__.PROJECTION_PERSPECTIVE;\n    this._rect = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_4__.Vec4(0, 0, 1, 1);\n    this._renderTarget = null;\n    this._scissorRect = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_4__.Vec4(0, 0, 1, 1);\n    this._scissorRectClear = false;\n    this._aperture = 16.0;\n    this._shutter = 1.0 / 1000.0;\n    this._sensitivity = 1000;\n    this._projMat = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__.Mat4();\n    this._projMatDirty = true;\n    this._projMatSkybox = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__.Mat4();\n    this._viewMat = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__.Mat4();\n    this._viewMatDirty = true;\n    this._viewProjMat = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__.Mat4();\n    this._viewProjMatDirty = true;\n    this.frustum = new _core_shape_frustum_js__WEBPACK_IMPORTED_MODULE_5__.Frustum();\n  }\n  get fullSizeClearRect() {\n    const rect = this._scissorRectClear ? this.scissorRect : this._rect;\n    return rect.x === 0 && rect.y === 0 && rect.z === 1 && rect.w === 1;\n  }\n  set aspectRatio(newValue) {\n    if (this._aspectRatio !== newValue) {\n      this._aspectRatio = newValue;\n      this._projMatDirty = true;\n    }\n  }\n  get aspectRatio() {\n    return this._aspectRatio;\n  }\n  set aspectRatioMode(newValue) {\n    if (this._aspectRatioMode !== newValue) {\n      this._aspectRatioMode = newValue;\n      this._projMatDirty = true;\n    }\n  }\n  get aspectRatioMode() {\n    return this._aspectRatioMode;\n  }\n  set calculateProjection(newValue) {\n    this._calculateProjection = newValue;\n    this._projMatDirty = true;\n  }\n  get calculateProjection() {\n    return this._calculateProjection;\n  }\n  set calculateTransform(newValue) {\n    this._calculateTransform = newValue;\n  }\n  get calculateTransform() {\n    return this._calculateTransform;\n  }\n  set clearColor(newValue) {\n    this._clearColor.copy(newValue);\n  }\n  get clearColor() {\n    return this._clearColor;\n  }\n  set clearColorBuffer(newValue) {\n    this._clearColorBuffer = newValue;\n  }\n  get clearColorBuffer() {\n    return this._clearColorBuffer;\n  }\n  set clearDepth(newValue) {\n    this._clearDepth = newValue;\n  }\n  get clearDepth() {\n    return this._clearDepth;\n  }\n  set clearDepthBuffer(newValue) {\n    this._clearDepthBuffer = newValue;\n  }\n  get clearDepthBuffer() {\n    return this._clearDepthBuffer;\n  }\n  set clearStencil(newValue) {\n    this._clearStencil = newValue;\n  }\n  get clearStencil() {\n    return this._clearStencil;\n  }\n  set clearStencilBuffer(newValue) {\n    this._clearStencilBuffer = newValue;\n  }\n  get clearStencilBuffer() {\n    return this._clearStencilBuffer;\n  }\n  set cullingMask(newValue) {\n    this._cullingMask = newValue;\n  }\n  get cullingMask() {\n    return this._cullingMask;\n  }\n  set cullFaces(newValue) {\n    this._cullFaces = newValue;\n  }\n  get cullFaces() {\n    return this._cullFaces;\n  }\n  set farClip(newValue) {\n    if (this._farClip !== newValue) {\n      this._farClip = newValue;\n      this._projMatDirty = true;\n    }\n  }\n  get farClip() {\n    return this._farClip;\n  }\n  set flipFaces(newValue) {\n    this._flipFaces = newValue;\n  }\n  get flipFaces() {\n    return this._flipFaces;\n  }\n  set fov(newValue) {\n    if (this._fov !== newValue) {\n      this._fov = newValue;\n      this._projMatDirty = true;\n    }\n  }\n  get fov() {\n    return this._fov;\n  }\n  set frustumCulling(newValue) {\n    this._frustumCulling = newValue;\n  }\n  get frustumCulling() {\n    return this._frustumCulling;\n  }\n  set horizontalFov(newValue) {\n    if (this._horizontalFov !== newValue) {\n      this._horizontalFov = newValue;\n      this._projMatDirty = true;\n    }\n  }\n  get horizontalFov() {\n    return this._horizontalFov;\n  }\n  set layers(newValue) {\n    this._layers = newValue.slice(0);\n    this._layersSet = new Set(this._layers);\n  }\n  get layers() {\n    return this._layers;\n  }\n  get layersSet() {\n    return this._layersSet;\n  }\n  set nearClip(newValue) {\n    if (this._nearClip !== newValue) {\n      this._nearClip = newValue;\n      this._projMatDirty = true;\n    }\n  }\n  get nearClip() {\n    return this._nearClip;\n  }\n  set node(newValue) {\n    this._node = newValue;\n  }\n  get node() {\n    return this._node;\n  }\n  set orthoHeight(newValue) {\n    if (this._orthoHeight !== newValue) {\n      this._orthoHeight = newValue;\n      this._projMatDirty = true;\n    }\n  }\n  get orthoHeight() {\n    return this._orthoHeight;\n  }\n  set projection(newValue) {\n    if (this._projection !== newValue) {\n      this._projection = newValue;\n      this._projMatDirty = true;\n    }\n  }\n  get projection() {\n    return this._projection;\n  }\n  get projectionMatrix() {\n    this._evaluateProjectionMatrix();\n    return this._projMat;\n  }\n  set rect(newValue) {\n    this._rect.copy(newValue);\n  }\n  get rect() {\n    return this._rect;\n  }\n  set renderTarget(newValue) {\n    this._renderTarget = newValue;\n  }\n  get renderTarget() {\n    return this._renderTarget;\n  }\n  set scissorRect(newValue) {\n    this._scissorRect.copy(newValue);\n  }\n  get scissorRect() {\n    return this._scissorRect;\n  }\n  get viewMatrix() {\n    if (this._viewMatDirty) {\n      const wtm = this._node.getWorldTransform();\n      this._viewMat.copy(wtm).invert();\n      this._viewMatDirty = false;\n    }\n    return this._viewMat;\n  }\n  set aperture(newValue) {\n    this._aperture = newValue;\n  }\n  get aperture() {\n    return this._aperture;\n  }\n  set sensitivity(newValue) {\n    this._sensitivity = newValue;\n  }\n  get sensitivity() {\n    return this._sensitivity;\n  }\n  set shutter(newValue) {\n    this._shutter = newValue;\n  }\n  get shutter() {\n    return this._shutter;\n  }\n  clone() {\n    return new Camera().copy(this);\n  }\n  copy(other) {\n    this.aspectRatio = other.aspectRatio;\n    this.aspectRatioMode = other.aspectRatioMode;\n    this.calculateProjection = other.calculateProjection;\n    this.calculateTransform = other.calculateTransform;\n    this.clearColor = other.clearColor;\n    this.clearColorBuffer = other.clearColorBuffer;\n    this.clearDepth = other.clearDepth;\n    this.clearDepthBuffer = other.clearDepthBuffer;\n    this.clearStencil = other.clearStencil;\n    this.clearStencilBuffer = other.clearStencilBuffer;\n    this.cullFaces = other.cullFaces;\n    this.cullingMask = other.cullingMask;\n    this.farClip = other.farClip;\n    this.flipFaces = other.flipFaces;\n    this.fov = other.fov;\n    this.frustumCulling = other.frustumCulling;\n    this.horizontalFov = other.horizontalFov;\n    this.layers = other.layers;\n    this.nearClip = other.nearClip;\n    this.orthoHeight = other.orthoHeight;\n    this.projection = other.projection;\n    this.rect = other.rect;\n    this.renderTarget = other.renderTarget;\n    this.scissorRect = other.scissorRect;\n    this.aperture = other.aperture;\n    this.shutter = other.shutter;\n    this.sensitivity = other.sensitivity;\n    return this;\n  }\n  _updateViewProjMat() {\n    if (this._projMatDirty || this._viewMatDirty || this._viewProjMatDirty) {\n      this._viewProjMat.mul2(this.projectionMatrix, this.viewMatrix);\n      this._viewProjMatDirty = false;\n    }\n  }\n  worldToScreen(worldCoord, cw, ch, screenCoord = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3()) {\n    this._updateViewProjMat();\n    this._viewProjMat.transformPoint(worldCoord, screenCoord);\n    const vpm = this._viewProjMat.data;\n    const w = worldCoord.x * vpm[3] + worldCoord.y * vpm[7] + worldCoord.z * vpm[11] + 1 * vpm[15];\n    screenCoord.x = (screenCoord.x / w + 1) * 0.5 * cw;\n    screenCoord.y = (1 - screenCoord.y / w) * 0.5 * ch;\n    return screenCoord;\n  }\n  screenToWorld(x, y, z, cw, ch, worldCoord = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3()) {\n    const range = this._farClip - this._nearClip;\n    _deviceCoord.set(x / cw, (ch - y) / ch, z / range);\n    _deviceCoord.mulScalar(2);\n    _deviceCoord.sub(_core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3.ONE);\n    if (this._projection === _constants_js__WEBPACK_IMPORTED_MODULE_2__.PROJECTION_PERSPECTIVE) {\n      _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__.Mat4._getPerspectiveHalfSize(_halfSize, this._fov, this._aspectRatio, this._nearClip, this._horizontalFov);\n      _halfSize.x *= _deviceCoord.x;\n      _halfSize.y *= _deviceCoord.y;\n      const invView = this._node.getWorldTransform();\n      _halfSize.z = -this._nearClip;\n      invView.transformPoint(_halfSize, _point);\n      const cameraPos = this._node.getPosition();\n      worldCoord.sub2(_point, cameraPos);\n      worldCoord.normalize();\n      worldCoord.mulScalar(z);\n      worldCoord.add(cameraPos);\n    } else {\n      this._updateViewProjMat();\n      _invViewProjMat.copy(this._viewProjMat).invert();\n      _invViewProjMat.transformPoint(_deviceCoord, worldCoord);\n    }\n    return worldCoord;\n  }\n  _evaluateProjectionMatrix() {\n    if (this._projMatDirty) {\n      if (this._projection === _constants_js__WEBPACK_IMPORTED_MODULE_2__.PROJECTION_PERSPECTIVE) {\n        this._projMat.setPerspective(this._fov, this._aspectRatio, this._nearClip, this._farClip, this._horizontalFov);\n        this._projMatSkybox.copy(this._projMat);\n      } else {\n        const y = this._orthoHeight;\n        const x = y * this._aspectRatio;\n        this._projMat.setOrtho(-x, x, -y, y, this._nearClip, this._farClip);\n        this._projMatSkybox.setPerspective(this._fov, this._aspectRatio, this._nearClip, this._farClip);\n      }\n      this._projMatDirty = false;\n    }\n  }\n  getProjectionMatrixSkybox() {\n    this._evaluateProjectionMatrix();\n    return this._projMatSkybox;\n  }\n  getExposure() {\n    const ev100 = Math.log2(this._aperture * this._aperture / this._shutter * 100.0 / this._sensitivity);\n    return 1.0 / (Math.pow(2.0, ev100) * 1.2);\n  }\n  getScreenSize(sphere) {\n    if (this._projection === _constants_js__WEBPACK_IMPORTED_MODULE_2__.PROJECTION_PERSPECTIVE) {\n      const distance = this._node.getPosition().distance(sphere.center);\n      if (distance < sphere.radius) {\n        return 1;\n      }\n      const viewAngle = Math.asin(sphere.radius / distance);\n      const sphereViewHeight = Math.tan(viewAngle);\n      const screenViewHeight = Math.tan(this._fov / 2 * _core_math_math_js__WEBPACK_IMPORTED_MODULE_6__.math.DEG_TO_RAD);\n      return Math.min(sphereViewHeight / screenViewHeight, 1);\n    }\n    return _core_math_math_js__WEBPACK_IMPORTED_MODULE_6__.math.clamp(sphere.radius / this._orthoHeight, 0, 1);\n  }\n  getFrustumCorners(near = this._nearClip, far = this._farClip) {\n    const fov = this._fov * Math.PI / 180.0;\n    let y = this._projection === _constants_js__WEBPACK_IMPORTED_MODULE_2__.PROJECTION_PERSPECTIVE ? Math.tan(fov / 2.0) * near : this._orthoHeight;\n    let x = y * this._aspectRatio;\n    const points = _frustumPoints;\n    points[0].x = x;\n    points[0].y = -y;\n    points[0].z = -near;\n    points[1].x = x;\n    points[1].y = y;\n    points[1].z = -near;\n    points[2].x = -x;\n    points[2].y = y;\n    points[2].z = -near;\n    points[3].x = -x;\n    points[3].y = -y;\n    points[3].z = -near;\n    if (this._projection === _constants_js__WEBPACK_IMPORTED_MODULE_2__.PROJECTION_PERSPECTIVE) {\n      y = Math.tan(fov / 2.0) * far;\n      x = y * this._aspectRatio;\n    }\n    points[4].x = x;\n    points[4].y = -y;\n    points[4].z = -far;\n    points[5].x = x;\n    points[5].y = y;\n    points[5].z = -far;\n    points[6].x = -x;\n    points[6].y = y;\n    points[6].z = -far;\n    points[7].x = -x;\n    points[7].y = -y;\n    points[7].z = -far;\n    return points;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/camera.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/composition/layer-composition.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/composition/layer-composition.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LayerComposition\": () => (/* binding */ LayerComposition)\n/* harmony export */ });\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _core_set_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/set-utils.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/set-utils.js\");\n/* harmony import */ var _core_sort_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/sort.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/sort.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _render_action_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./render-action.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/composition/render-action.js\");\n/* harmony import */ var _lighting_world_clusters_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lighting/world-clusters.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/lighting/world-clusters.js\");\n/* harmony import */ var _light_composition_data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./light-composition-data.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/composition/light-composition-data.js\");\n\n\n\n\n\n\n\n\n\nconst tempSet = new Set();\nconst tempClusterArray = [];\nclass LayerComposition extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor(name = 'Untitled') {\n    super();\n    this.name = name;\n    this.layerList = [];\n    this.subLayerList = [];\n    this.subLayerEnabled = [];\n    this._opaqueOrder = {};\n    this._transparentOrder = {};\n    this._dirty = false;\n    this._dirtyBlend = false;\n    this._dirtyLights = false;\n    this._dirtyCameras = false;\n    this._meshInstances = [];\n    this._meshInstancesSet = new Set();\n    this._lights = [];\n    this._lightsMap = new Map();\n    this._lightCompositionData = [];\n    this._splitLights = [[], [], []];\n    this.cameras = [];\n    this._renderActions = [];\n    this._worldClusters = [];\n    this._emptyWorldClusters = null;\n  }\n  destroy() {\n    if (this._emptyWorldClusters) {\n      this._emptyWorldClusters.destroy();\n      this._emptyWorldClusters = null;\n    }\n    this._worldClusters.forEach(cluster => {\n      cluster.destroy();\n    });\n    this._worldClusters = null;\n    this._renderActions.forEach(ra => ra.destroy());\n    this._renderActions = null;\n  }\n  getEmptyWorldClusters(device) {\n    if (!this._emptyWorldClusters) {\n      this._emptyWorldClusters = new _lighting_world_clusters_js__WEBPACK_IMPORTED_MODULE_1__.WorldClusters(device);\n      this._emptyWorldClusters.name = 'ClusterEmpty';\n      this._emptyWorldClusters.update([], false, null);\n    }\n    return this._emptyWorldClusters;\n  }\n  _splitLightsArray(target) {\n    const lights = target._lights;\n    target._splitLights[_constants_js__WEBPACK_IMPORTED_MODULE_2__.LIGHTTYPE_DIRECTIONAL].length = 0;\n    target._splitLights[_constants_js__WEBPACK_IMPORTED_MODULE_2__.LIGHTTYPE_OMNI].length = 0;\n    target._splitLights[_constants_js__WEBPACK_IMPORTED_MODULE_2__.LIGHTTYPE_SPOT].length = 0;\n    for (let i = 0; i < lights.length; i++) {\n      const light = lights[i];\n      if (light.enabled) {\n        target._splitLights[light._type].push(light);\n      }\n    }\n  }\n  _update(device, clusteredLightingEnabled = false) {\n    const len = this.layerList.length;\n    let result = 0;\n    if (!this._dirty || !this._dirtyLights || !this._dirtyCameras) {\n      for (let i = 0; i < len; i++) {\n        const layer = this.layerList[i];\n        if (layer._dirty) {\n          this._dirty = true;\n        }\n        if (layer._dirtyLights) {\n          this._dirtyLights = true;\n        }\n        if (layer._dirtyCameras) {\n          this._dirtyCameras = true;\n        }\n      }\n    }\n    function addUniqueMeshInstance(destArray, destSet, srcArray) {\n      let dirtyBlend = false;\n      const srcLen = srcArray.length;\n      for (let s = 0; s < srcLen; s++) {\n        const meshInst = srcArray[s];\n        if (!destSet.has(meshInst)) {\n          destSet.add(meshInst);\n          destArray.push(meshInst);\n          const material = meshInst.material;\n          if (material && material._dirtyBlend) {\n            dirtyBlend = true;\n            material._dirtyBlend = false;\n          }\n        }\n      }\n      return dirtyBlend;\n    }\n    if (this._dirty) {\n      result |= _constants_js__WEBPACK_IMPORTED_MODULE_2__.COMPUPDATED_INSTANCES;\n      this._meshInstances.length = 0;\n      this._meshInstancesSet.clear();\n      for (let i = 0; i < len; i++) {\n        const layer = this.layerList[i];\n        if (!layer.passThrough) {\n          this._dirtyBlend = addUniqueMeshInstance(this._meshInstances, this._meshInstancesSet, layer.opaqueMeshInstances) || this._dirtyBlend;\n          this._dirtyBlend = addUniqueMeshInstance(this._meshInstances, this._meshInstancesSet, layer.transparentMeshInstances) || this._dirtyBlend;\n        }\n        layer._dirty = false;\n      }\n      this._dirty = false;\n    }\n    function moveByBlendType(dest, src, moveTransparent) {\n      for (let s = 0; s < src.length;) {\n        var _src$s$material;\n        if (((_src$s$material = src[s].material) == null ? void 0 : _src$s$material.transparent) === moveTransparent) {\n          dest.push(src[s]);\n          src[s] = src[src.length - 1];\n          src.length--;\n        } else {\n          s++;\n        }\n      }\n    }\n    if (this._dirtyBlend) {\n      result |= _constants_js__WEBPACK_IMPORTED_MODULE_2__.COMPUPDATED_BLEND;\n      for (let i = 0; i < len; i++) {\n        const layer = this.layerList[i];\n        if (!layer.passThrough) {\n          moveByBlendType(layer.opaqueMeshInstances, layer.transparentMeshInstances, false);\n          moveByBlendType(layer.transparentMeshInstances, layer.opaqueMeshInstances, true);\n        }\n      }\n      this._dirtyBlend = false;\n    }\n    if (this._dirtyLights) {\n      result |= _constants_js__WEBPACK_IMPORTED_MODULE_2__.COMPUPDATED_LIGHTS;\n      this._dirtyLights = false;\n      this.updateLights();\n    }\n    if (result) {\n      this.updateShadowCasters();\n    }\n    if (this._dirtyCameras || result & _constants_js__WEBPACK_IMPORTED_MODULE_2__.COMPUPDATED_LIGHTS) {\n      this._dirtyCameras = false;\n      result |= _constants_js__WEBPACK_IMPORTED_MODULE_2__.COMPUPDATED_CAMERAS;\n      this.cameras.length = 0;\n      for (let i = 0; i < len; i++) {\n        const layer = this.layerList[i];\n        layer._dirtyCameras = false;\n        for (let j = 0; j < layer.cameras.length; j++) {\n          const camera = layer.cameras[j];\n          const index = this.cameras.indexOf(camera);\n          if (index < 0) {\n            this.cameras.push(camera);\n          }\n        }\n      }\n      if (this.cameras.length > 1) {\n        (0,_core_sort_js__WEBPACK_IMPORTED_MODULE_3__.sortPriority)(this.cameras);\n      }\n      const cameraLayers = [];\n      let renderActionCount = 0;\n      for (let i = 0; i < this.cameras.length; i++) {\n        const camera = this.cameras[i];\n        cameraLayers.length = 0;\n        let cameraFirstRenderAction = true;\n        const cameraFirstRenderActionIndex = renderActionCount;\n        let lastRenderAction = null;\n        let postProcessMarked = false;\n        for (let j = 0; j < len; j++) {\n          const layer = this.layerList[j];\n          const isLayerEnabled = this.subLayerEnabled[j];\n          if (layer && isLayerEnabled) {\n            if (layer.cameras.length > 0) {\n              if (camera.layers.indexOf(layer.id) >= 0) {\n                cameraLayers.push(layer);\n                if (!postProcessMarked && layer.id === camera.disablePostEffectsLayer) {\n                  postProcessMarked = true;\n                  if (lastRenderAction) {\n                    lastRenderAction.triggerPostprocess = true;\n                  }\n                }\n                const cameraIndex = layer.cameras.indexOf(camera);\n                if (cameraIndex >= 0) {\n                  lastRenderAction = this.addRenderAction(this._renderActions, renderActionCount, layer, j, cameraIndex, cameraFirstRenderAction, postProcessMarked);\n                  renderActionCount++;\n                  cameraFirstRenderAction = false;\n                }\n              }\n            }\n          }\n        }\n        if (cameraFirstRenderActionIndex < renderActionCount) {\n          this._renderActions[cameraFirstRenderActionIndex].collectDirectionalLights(cameraLayers, this._splitLights[_constants_js__WEBPACK_IMPORTED_MODULE_2__.LIGHTTYPE_DIRECTIONAL], this._lights);\n          lastRenderAction.lastCameraUse = true;\n        }\n        if (!postProcessMarked && lastRenderAction) {\n          lastRenderAction.triggerPostprocess = true;\n        }\n        if (camera.renderTarget && camera.postEffectsEnabled) {\n          this.propagateRenderTarget(cameraFirstRenderActionIndex - 1, camera);\n        }\n      }\n      for (let i = renderActionCount; i < this._renderActions.length; i++) {\n        this._renderActions[i].destroy();\n      }\n      this._renderActions.length = renderActionCount;\n    }\n    if (result & (_constants_js__WEBPACK_IMPORTED_MODULE_2__.COMPUPDATED_CAMERAS | _constants_js__WEBPACK_IMPORTED_MODULE_2__.COMPUPDATED_LIGHTS | _constants_js__WEBPACK_IMPORTED_MODULE_2__.COMPUPDATED_INSTANCES)) {\n      if (clusteredLightingEnabled) {\n        this.allocateLightClusters(device);\n      }\n    }\n    if (result & (_constants_js__WEBPACK_IMPORTED_MODULE_2__.COMPUPDATED_LIGHTS | _constants_js__WEBPACK_IMPORTED_MODULE_2__.COMPUPDATED_LIGHTS)) {\n      this._logRenderActions();\n    }\n    return result;\n  }\n  updateShadowCasters() {\n    const lightCount = this._lights.length;\n    for (let i = 0; i < lightCount; i++) {\n      this._lightCompositionData[i].clearShadowCasters();\n    }\n    const len = this.layerList.length;\n    for (let i = 0; i < len; i++) {\n      const layer = this.layerList[i];\n      if (!tempSet.has(layer)) {\n        tempSet.add(layer);\n        const lights = layer._lights;\n        for (let j = 0; j < lights.length; j++) {\n          if (lights[j].castShadows) {\n            const lightIndex = this._lightsMap.get(lights[j]);\n            const lightCompData = this._lightCompositionData[lightIndex];\n            lightCompData.addShadowCasters(layer.shadowCasters);\n          }\n        }\n      }\n    }\n    tempSet.clear();\n  }\n  updateLights() {\n    this._lights.length = 0;\n    this._lightsMap.clear();\n    const count = this.layerList.length;\n    for (let i = 0; i < count; i++) {\n      const layer = this.layerList[i];\n      if (!tempSet.has(layer)) {\n        tempSet.add(layer);\n        const lights = layer._lights;\n        for (let j = 0; j < lights.length; j++) {\n          const light = lights[j];\n          let lightIndex = this._lightsMap.get(light);\n          if (lightIndex === undefined) {\n            lightIndex = this._lights.length;\n            this._lightsMap.set(light, lightIndex);\n            this._lights.push(light);\n            let lightCompData = this._lightCompositionData[lightIndex];\n            if (!lightCompData) {\n              lightCompData = new _light_composition_data_js__WEBPACK_IMPORTED_MODULE_4__.LightCompositionData();\n              this._lightCompositionData[lightIndex] = lightCompData;\n            }\n          }\n        }\n      }\n      this._splitLightsArray(layer);\n      layer._dirtyLights = false;\n    }\n    tempSet.clear();\n    this._splitLightsArray(this);\n    const lightCount = this._lights.length;\n    this._lightCompositionData.length = lightCount;\n  }\n  findCompatibleCluster(layer, renderActionCount, emptyWorldClusters) {\n    for (let i = 0; i < renderActionCount; i++) {\n      const ra = this._renderActions[i];\n      const raLayer = this.layerList[ra.layerIndex];\n      if (ra.lightClusters !== emptyWorldClusters) {\n        if (layer === raLayer) {\n          return ra.lightClusters;\n        }\n        if (ra.lightClusters) {\n          if (_core_set_utils_js__WEBPACK_IMPORTED_MODULE_5__.set.equals(layer._clusteredLightsSet, raLayer._clusteredLightsSet)) {\n            return ra.lightClusters;\n          }\n        }\n      }\n    }\n    return null;\n  }\n  allocateLightClusters(device) {\n    tempClusterArray.push(...this._worldClusters);\n    const emptyWorldClusters = this.getEmptyWorldClusters(device);\n    this._worldClusters.length = 0;\n    const count = this._renderActions.length;\n    for (let i = 0; i < count; i++) {\n      const ra = this._renderActions[i];\n      const layer = this.layerList[ra.layerIndex];\n      ra.lightClusters = null;\n      if (layer.hasClusteredLights) {\n        const transparent = this.subLayerList[ra.layerIndex];\n        const meshInstances = transparent ? layer.transparentMeshInstances : layer.opaqueMeshInstances;\n        if (meshInstances.length) {\n          let clusters = this.findCompatibleCluster(layer, i, emptyWorldClusters);\n          if (!clusters) {\n            if (tempClusterArray.length) {\n              clusters = tempClusterArray.pop();\n            }\n            if (!clusters) {\n              clusters = new _lighting_world_clusters_js__WEBPACK_IMPORTED_MODULE_1__.WorldClusters(device);\n            }\n            clusters.name = 'Cluster-' + this._worldClusters.length;\n            this._worldClusters.push(clusters);\n          }\n          ra.lightClusters = clusters;\n        }\n      }\n      if (!ra.lightClusters) {\n        ra.lightClusters = emptyWorldClusters;\n      }\n    }\n    tempClusterArray.forEach(item => {\n      item.destroy();\n    });\n    tempClusterArray.length = 0;\n  }\n  addRenderAction(renderActions, renderActionIndex, layer, layerIndex, cameraIndex, cameraFirstRenderAction, postProcessMarked) {\n    let renderAction = renderActions[renderActionIndex];\n    if (!renderAction) {\n      renderAction = renderActions[renderActionIndex] = new _render_action_js__WEBPACK_IMPORTED_MODULE_6__.RenderAction();\n    }\n    let rt = layer.renderTarget;\n    const camera = layer.cameras[cameraIndex];\n    if (camera && camera.renderTarget) {\n      if (layer.id !== _constants_js__WEBPACK_IMPORTED_MODULE_2__.LAYERID_DEPTH) {\n        rt = camera.renderTarget;\n      }\n    }\n    let used = false;\n    for (let i = renderActionIndex - 1; i >= 0; i--) {\n      if (renderActions[i].camera === camera && renderActions[i].renderTarget === rt) {\n        used = true;\n        break;\n      }\n    }\n    const needsClear = cameraFirstRenderAction || !used;\n    let clearColor = needsClear ? camera.clearColorBuffer : false;\n    let clearDepth = needsClear ? camera.clearDepthBuffer : false;\n    let clearStencil = needsClear ? camera.clearStencilBuffer : false;\n    clearColor || (clearColor = layer.clearColorBuffer);\n    clearDepth || (clearDepth = layer.clearDepthBuffer);\n    clearStencil || (clearStencil = layer.clearStencilBuffer);\n    if (postProcessMarked && camera.postEffectsEnabled) {\n      rt = null;\n    }\n    renderAction.reset();\n    renderAction.triggerPostprocess = false;\n    renderAction.layerIndex = layerIndex;\n    renderAction.cameraIndex = cameraIndex;\n    renderAction.camera = camera;\n    renderAction.renderTarget = rt;\n    renderAction.clearColor = clearColor;\n    renderAction.clearDepth = clearDepth;\n    renderAction.clearStencil = clearStencil;\n    renderAction.firstCameraUse = cameraFirstRenderAction;\n    renderAction.lastCameraUse = false;\n    return renderAction;\n  }\n  propagateRenderTarget(startIndex, fromCamera) {\n    for (let a = startIndex; a >= 0; a--) {\n      const ra = this._renderActions[a];\n      const layer = this.layerList[ra.layerIndex];\n      if (ra.renderTarget && layer.id !== _constants_js__WEBPACK_IMPORTED_MODULE_2__.LAYERID_DEPTH) {\n        break;\n      }\n      if (layer.id === _constants_js__WEBPACK_IMPORTED_MODULE_2__.LAYERID_DEPTH) {\n        continue;\n      }\n      const thisCamera = ra == null ? void 0 : ra.camera.camera;\n      if (thisCamera) {\n        if (!fromCamera.camera.rect.equals(thisCamera.rect) || !fromCamera.camera.scissorRect.equals(thisCamera.scissorRect)) {\n          break;\n        }\n      }\n      ra.renderTarget = fromCamera.renderTarget;\n    }\n  }\n  _logRenderActions() {}\n  _isLayerAdded(layer) {\n    if (this.layerList.indexOf(layer) >= 0) {\n      return true;\n    }\n    return false;\n  }\n  _isSublayerAdded(layer, transparent) {\n    for (let i = 0; i < this.layerList.length; i++) {\n      if (this.layerList[i] === layer && this.subLayerList[i] === transparent) {\n        return true;\n      }\n    }\n    return false;\n  }\n  push(layer) {\n    if (this._isLayerAdded(layer)) return;\n    this.layerList.push(layer);\n    this.layerList.push(layer);\n    this._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;\n    this._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;\n    this.subLayerEnabled.push(true);\n    this.subLayerEnabled.push(true);\n    this._dirty = true;\n    this._dirtyLights = true;\n    this._dirtyCameras = true;\n    this.fire('add', layer);\n  }\n  insert(layer, index) {\n    if (this._isLayerAdded(layer)) return;\n    this.layerList.splice(index, 0, layer, layer);\n    this.subLayerList.splice(index, 0, false, true);\n    const count = this.layerList.length;\n    this._updateOpaqueOrder(index, count - 1);\n    this._updateTransparentOrder(index, count - 1);\n    this.subLayerEnabled.splice(index, 0, true, true);\n    this._dirty = true;\n    this._dirtyLights = true;\n    this._dirtyCameras = true;\n    this.fire('add', layer);\n  }\n  remove(layer) {\n    let id = this.layerList.indexOf(layer);\n    delete this._opaqueOrder[id];\n    delete this._transparentOrder[id];\n    while (id >= 0) {\n      this.layerList.splice(id, 1);\n      this.subLayerList.splice(id, 1);\n      this.subLayerEnabled.splice(id, 1);\n      id = this.layerList.indexOf(layer);\n      this._dirty = true;\n      this._dirtyLights = true;\n      this._dirtyCameras = true;\n      this.fire('remove', layer);\n    }\n    const count = this.layerList.length;\n    this._updateOpaqueOrder(0, count - 1);\n    this._updateTransparentOrder(0, count - 1);\n  }\n  pushOpaque(layer) {\n    if (this._isSublayerAdded(layer, false)) return;\n    this.layerList.push(layer);\n    this._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;\n    this.subLayerEnabled.push(true);\n    this._dirty = true;\n    this._dirtyLights = true;\n    this._dirtyCameras = true;\n    this.fire('add', layer);\n  }\n  insertOpaque(layer, index) {\n    if (this._isSublayerAdded(layer, false)) return;\n    this.layerList.splice(index, 0, layer);\n    this.subLayerList.splice(index, 0, false);\n    const count = this.subLayerList.length;\n    this._updateOpaqueOrder(index, count - 1);\n    this.subLayerEnabled.splice(index, 0, true);\n    this._dirty = true;\n    this._dirtyLights = true;\n    this._dirtyCameras = true;\n    this.fire('add', layer);\n  }\n  removeOpaque(layer) {\n    for (let i = 0, len = this.layerList.length; i < len; i++) {\n      if (this.layerList[i] === layer && !this.subLayerList[i]) {\n        this.layerList.splice(i, 1);\n        this.subLayerList.splice(i, 1);\n        len--;\n        this._updateOpaqueOrder(i, len - 1);\n        this.subLayerEnabled.splice(i, 1);\n        this._dirty = true;\n        this._dirtyLights = true;\n        this._dirtyCameras = true;\n        if (this.layerList.indexOf(layer) < 0) {\n          this.fire('remove', layer);\n        }\n        return;\n      }\n    }\n  }\n  pushTransparent(layer) {\n    if (this._isSublayerAdded(layer, true)) return;\n    this.layerList.push(layer);\n    this._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;\n    this.subLayerEnabled.push(true);\n    this._dirty = true;\n    this._dirtyLights = true;\n    this._dirtyCameras = true;\n    this.fire('add', layer);\n  }\n  insertTransparent(layer, index) {\n    if (this._isSublayerAdded(layer, true)) return;\n    this.layerList.splice(index, 0, layer);\n    this.subLayerList.splice(index, 0, true);\n    const count = this.subLayerList.length;\n    this._updateTransparentOrder(index, count - 1);\n    this.subLayerEnabled.splice(index, 0, true);\n    this._dirty = true;\n    this._dirtyLights = true;\n    this._dirtyCameras = true;\n    this.fire('add', layer);\n  }\n  removeTransparent(layer) {\n    for (let i = 0, len = this.layerList.length; i < len; i++) {\n      if (this.layerList[i] === layer && this.subLayerList[i]) {\n        this.layerList.splice(i, 1);\n        this.subLayerList.splice(i, 1);\n        len--;\n        this._updateTransparentOrder(i, len - 1);\n        this.subLayerEnabled.splice(i, 1);\n        this._dirty = true;\n        this._dirtyLights = true;\n        this._dirtyCameras = true;\n        if (this.layerList.indexOf(layer) < 0) {\n          this.fire('remove', layer);\n        }\n        return;\n      }\n    }\n  }\n  _getSublayerIndex(layer, transparent) {\n    let id = this.layerList.indexOf(layer);\n    if (id < 0) return -1;\n    if (this.subLayerList[id] !== transparent) {\n      id = this.layerList.indexOf(layer, id + 1);\n      if (id < 0) return -1;\n      if (this.subLayerList[id] !== transparent) {\n        return -1;\n      }\n    }\n    return id;\n  }\n  getOpaqueIndex(layer) {\n    return this._getSublayerIndex(layer, false);\n  }\n  getTransparentIndex(layer) {\n    return this._getSublayerIndex(layer, true);\n  }\n  getLayerById(id) {\n    for (let i = 0; i < this.layerList.length; i++) {\n      if (this.layerList[i].id === id) return this.layerList[i];\n    }\n    return null;\n  }\n  getLayerByName(name) {\n    for (let i = 0; i < this.layerList.length; i++) {\n      if (this.layerList[i].name === name) return this.layerList[i];\n    }\n    return null;\n  }\n  _updateOpaqueOrder(startIndex, endIndex) {\n    for (let i = startIndex; i <= endIndex; i++) {\n      if (this.subLayerList[i] === false) {\n        this._opaqueOrder[this.layerList[i].id] = i;\n      }\n    }\n  }\n  _updateTransparentOrder(startIndex, endIndex) {\n    for (let i = startIndex; i <= endIndex; i++) {\n      if (this.subLayerList[i] === true) {\n        this._transparentOrder[this.layerList[i].id] = i;\n      }\n    }\n  }\n  _sortLayersDescending(layersA, layersB, order) {\n    let topLayerA = -1;\n    let topLayerB = -1;\n    for (let i = 0, len = layersA.length; i < len; i++) {\n      const id = layersA[i];\n      if (order.hasOwnProperty(id)) {\n        topLayerA = Math.max(topLayerA, order[id]);\n      }\n    }\n    for (let i = 0, len = layersB.length; i < len; i++) {\n      const id = layersB[i];\n      if (order.hasOwnProperty(id)) {\n        topLayerB = Math.max(topLayerB, order[id]);\n      }\n    }\n    if (topLayerA === -1 && topLayerB !== -1) {\n      return 1;\n    } else if (topLayerB === -1 && topLayerA !== -1) {\n      return -1;\n    }\n    return topLayerB - topLayerA;\n  }\n  sortTransparentLayers(layersA, layersB) {\n    return this._sortLayersDescending(layersA, layersB, this._transparentOrder);\n  }\n  sortOpaqueLayers(layersA, layersB) {\n    return this._sortLayersDescending(layersA, layersB, this._opaqueOrder);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/composition/layer-composition.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/composition/light-composition-data.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/composition/light-composition-data.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LightCompositionData\": () => (/* binding */ LightCompositionData)\n/* harmony export */ });\nclass LightCompositionData {\n  constructor() {\n    this.shadowCastersSet = new Set();\n    this.shadowCastersList = [];\n  }\n  clearShadowCasters() {\n    this.shadowCastersSet.clear();\n    this.shadowCastersList.length = 0;\n  }\n  addShadowCasters(casters) {\n    for (let i = 0; i < casters.length; i++) {\n      const item = casters[i];\n      if (!this.shadowCastersSet.has(item)) {\n        this.shadowCastersSet.add(item);\n        this.shadowCastersList.push(item);\n      }\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/composition/light-composition-data.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/composition/render-action.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/composition/render-action.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RenderAction\": () => (/* binding */ RenderAction)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n\n\nclass RenderAction {\n  constructor() {\n    this.layerIndex = 0;\n    this.cameraIndex = 0;\n    this.camera = null;\n    this.renderTarget = null;\n    this.lightClusters = null;\n    this.clearColor = false;\n    this.clearDepth = false;\n    this.clearStencil = false;\n    this.triggerPostprocess = false;\n    this.firstCameraUse = false;\n    this.lastCameraUse = false;\n    this.directionalLightsSet = new Set();\n    this.directionalLights = [];\n    this.directionalLightsIndices = [];\n    this.viewBindGroups = [];\n  }\n  destroy() {\n    this.viewBindGroups.forEach(bg => {\n      bg.defaultUniformBuffer.destroy();\n      bg.destroy();\n    });\n    this.viewBindGroups.length = 0;\n  }\n  get hasDirectionalShadowLights() {\n    return this.directionalLights.length > 0;\n  }\n  reset() {\n    this.lightClusters = null;\n    this.directionalLightsSet.clear();\n    this.directionalLights.length = 0;\n    this.directionalLightsIndices.length = 0;\n  }\n  isLayerEnabled(layerComposition) {\n    const layer = layerComposition.layerList[this.layerIndex];\n    return layer.enabled && layerComposition.subLayerEnabled[this.layerIndex];\n  }\n  collectDirectionalLights(cameraLayers, dirLights, allLights) {\n    this.directionalLightsSet.clear();\n    this.directionalLights.length = 0;\n    this.directionalLightsIndices.length = 0;\n    for (let i = 0; i < dirLights.length; i++) {\n      const light = dirLights[i];\n      if (light.castShadows) {\n        for (let l = 0; l < cameraLayers.length; l++) {\n          if (cameraLayers[l]._splitLights[_constants_js__WEBPACK_IMPORTED_MODULE_0__.LIGHTTYPE_DIRECTIONAL].indexOf(light) >= 0) {\n            if (!this.directionalLightsSet.has(light)) {\n              this.directionalLightsSet.add(light);\n              this.directionalLights.push(light);\n              const lightIndex = allLights.indexOf(light);\n              this.directionalLightsIndices.push(lightIndex);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/composition/render-action.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/compress/compress-utils.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/compress/compress-utils.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CompressUtils\": () => (/* binding */ CompressUtils)\n/* harmony export */ });\nconst CompressUtils = {\n  setCompressedPRS: function (entity, data, compressed) {\n    const a = compressed.singleVecs;\n    let b, i;\n    const v = data.___1;\n    if (!v) {\n      b = compressed.tripleVecs;\n      i = data.___2;\n    }\n    let n = v ? v[0] : b[i];\n    entity.setLocalPosition(a[n], a[n + 1], a[n + 2]);\n    n = v ? v[1] : b[i + 1];\n    entity.setLocalEulerAngles(a[n], a[n + 1], a[n + 2]);\n    n = v ? v[2] : b[i + 2];\n    entity.setLocalScale(a[n], a[n + 1], a[n + 2]);\n  },\n  oneCharToKey: function (s, data) {\n    const i = s.charCodeAt(0) - data.fieldFirstCode;\n    return data.fieldArray[i];\n  },\n  multCharToKey: function (s, data) {\n    let ind = 0;\n    for (let i = 0; i < s.length; i++) {\n      ind = ind * data.fieldCodeBase + s.charCodeAt(i) - data.fieldFirstCode;\n    }\n    return data.fieldArray[ind];\n  }\n};\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/compress/compress-utils.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/compress/decompress.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/compress/decompress.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Decompress\": () => (/* binding */ Decompress)\n/* harmony export */ });\n/* harmony import */ var _compress_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compress-utils.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/compress/compress-utils.js\");\n\n\nclass Decompress {\n  constructor(node, data) {\n    this._node = node;\n    this._data = data;\n  }\n  run() {\n    const type = Object.prototype.toString.call(this._node);\n    if (type === '[object Object]') {\n      this._handleMap();\n    } else if (type === '[object Array]') {\n      this._handleArray();\n    } else {\n      this._result = this._node;\n    }\n    return this._result;\n  }\n  _handleMap() {\n    this._result = {};\n    const a = Object.keys(this._node);\n    a.forEach(this._handleKey, this);\n  }\n  _handleKey(origKey) {\n    let newKey = origKey;\n    const len = origKey.length;\n    if (len === 1) {\n      newKey = _compress_utils_js__WEBPACK_IMPORTED_MODULE_0__.CompressUtils.oneCharToKey(origKey, this._data);\n    } else if (len === 2) {\n      newKey = _compress_utils_js__WEBPACK_IMPORTED_MODULE_0__.CompressUtils.multCharToKey(origKey, this._data);\n    }\n    this._result[newKey] = new Decompress(this._node[origKey], this._data).run();\n  }\n  _handleArray() {\n    this._result = [];\n    this._node.forEach(this._handleArElt, this);\n  }\n  _handleArElt(elt) {\n    const v = new Decompress(elt, this._data).run();\n    this._result.push(v);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/compress/decompress.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js":
/*!*************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ASPECT_AUTO\": () => (/* binding */ ASPECT_AUTO),\n/* harmony export */   \"ASPECT_MANUAL\": () => (/* binding */ ASPECT_MANUAL),\n/* harmony export */   \"BAKE_COLOR\": () => (/* binding */ BAKE_COLOR),\n/* harmony export */   \"BAKE_COLORDIR\": () => (/* binding */ BAKE_COLORDIR),\n/* harmony export */   \"BLEND_ADDITIVE\": () => (/* binding */ BLEND_ADDITIVE),\n/* harmony export */   \"BLEND_ADDITIVEALPHA\": () => (/* binding */ BLEND_ADDITIVEALPHA),\n/* harmony export */   \"BLEND_MAX\": () => (/* binding */ BLEND_MAX),\n/* harmony export */   \"BLEND_MIN\": () => (/* binding */ BLEND_MIN),\n/* harmony export */   \"BLEND_MULTIPLICATIVE\": () => (/* binding */ BLEND_MULTIPLICATIVE),\n/* harmony export */   \"BLEND_MULTIPLICATIVE2X\": () => (/* binding */ BLEND_MULTIPLICATIVE2X),\n/* harmony export */   \"BLEND_NONE\": () => (/* binding */ BLEND_NONE),\n/* harmony export */   \"BLEND_NORMAL\": () => (/* binding */ BLEND_NORMAL),\n/* harmony export */   \"BLEND_PREMULTIPLIED\": () => (/* binding */ BLEND_PREMULTIPLIED),\n/* harmony export */   \"BLEND_SCREEN\": () => (/* binding */ BLEND_SCREEN),\n/* harmony export */   \"BLEND_SUBTRACTIVE\": () => (/* binding */ BLEND_SUBTRACTIVE),\n/* harmony export */   \"BLUR_BOX\": () => (/* binding */ BLUR_BOX),\n/* harmony export */   \"BLUR_GAUSSIAN\": () => (/* binding */ BLUR_GAUSSIAN),\n/* harmony export */   \"COMPUPDATED_BLEND\": () => (/* binding */ COMPUPDATED_BLEND),\n/* harmony export */   \"COMPUPDATED_CAMERAS\": () => (/* binding */ COMPUPDATED_CAMERAS),\n/* harmony export */   \"COMPUPDATED_INSTANCES\": () => (/* binding */ COMPUPDATED_INSTANCES),\n/* harmony export */   \"COMPUPDATED_LIGHTS\": () => (/* binding */ COMPUPDATED_LIGHTS),\n/* harmony export */   \"CUBEPROJ_BOX\": () => (/* binding */ CUBEPROJ_BOX),\n/* harmony export */   \"CUBEPROJ_NONE\": () => (/* binding */ CUBEPROJ_NONE),\n/* harmony export */   \"DETAILMODE_ADD\": () => (/* binding */ DETAILMODE_ADD),\n/* harmony export */   \"DETAILMODE_MAX\": () => (/* binding */ DETAILMODE_MAX),\n/* harmony export */   \"DETAILMODE_MIN\": () => (/* binding */ DETAILMODE_MIN),\n/* harmony export */   \"DETAILMODE_MUL\": () => (/* binding */ DETAILMODE_MUL),\n/* harmony export */   \"DETAILMODE_OVERLAY\": () => (/* binding */ DETAILMODE_OVERLAY),\n/* harmony export */   \"DETAILMODE_SCREEN\": () => (/* binding */ DETAILMODE_SCREEN),\n/* harmony export */   \"EMITTERSHAPE_BOX\": () => (/* binding */ EMITTERSHAPE_BOX),\n/* harmony export */   \"EMITTERSHAPE_SPHERE\": () => (/* binding */ EMITTERSHAPE_SPHERE),\n/* harmony export */   \"FOG_EXP\": () => (/* binding */ FOG_EXP),\n/* harmony export */   \"FOG_EXP2\": () => (/* binding */ FOG_EXP2),\n/* harmony export */   \"FOG_LINEAR\": () => (/* binding */ FOG_LINEAR),\n/* harmony export */   \"FOG_NONE\": () => (/* binding */ FOG_NONE),\n/* harmony export */   \"FRESNEL_NONE\": () => (/* binding */ FRESNEL_NONE),\n/* harmony export */   \"FRESNEL_SCHLICK\": () => (/* binding */ FRESNEL_SCHLICK),\n/* harmony export */   \"GAMMA_NONE\": () => (/* binding */ GAMMA_NONE),\n/* harmony export */   \"GAMMA_SRGB\": () => (/* binding */ GAMMA_SRGB),\n/* harmony export */   \"GAMMA_SRGBFAST\": () => (/* binding */ GAMMA_SRGBFAST),\n/* harmony export */   \"GAMMA_SRGBHDR\": () => (/* binding */ GAMMA_SRGBHDR),\n/* harmony export */   \"LAYERID_DEPTH\": () => (/* binding */ LAYERID_DEPTH),\n/* harmony export */   \"LAYERID_IMMEDIATE\": () => (/* binding */ LAYERID_IMMEDIATE),\n/* harmony export */   \"LAYERID_SKYBOX\": () => (/* binding */ LAYERID_SKYBOX),\n/* harmony export */   \"LAYERID_UI\": () => (/* binding */ LAYERID_UI),\n/* harmony export */   \"LAYERID_WORLD\": () => (/* binding */ LAYERID_WORLD),\n/* harmony export */   \"LAYER_FX\": () => (/* binding */ LAYER_FX),\n/* harmony export */   \"LAYER_GIZMO\": () => (/* binding */ LAYER_GIZMO),\n/* harmony export */   \"LAYER_HUD\": () => (/* binding */ LAYER_HUD),\n/* harmony export */   \"LAYER_WORLD\": () => (/* binding */ LAYER_WORLD),\n/* harmony export */   \"LIGHTFALLOFF_INVERSESQUARED\": () => (/* binding */ LIGHTFALLOFF_INVERSESQUARED),\n/* harmony export */   \"LIGHTFALLOFF_LINEAR\": () => (/* binding */ LIGHTFALLOFF_LINEAR),\n/* harmony export */   \"LIGHTSHAPE_DISK\": () => (/* binding */ LIGHTSHAPE_DISK),\n/* harmony export */   \"LIGHTSHAPE_PUNCTUAL\": () => (/* binding */ LIGHTSHAPE_PUNCTUAL),\n/* harmony export */   \"LIGHTSHAPE_RECT\": () => (/* binding */ LIGHTSHAPE_RECT),\n/* harmony export */   \"LIGHTSHAPE_SPHERE\": () => (/* binding */ LIGHTSHAPE_SPHERE),\n/* harmony export */   \"LIGHTTYPE_COUNT\": () => (/* binding */ LIGHTTYPE_COUNT),\n/* harmony export */   \"LIGHTTYPE_DIRECTIONAL\": () => (/* binding */ LIGHTTYPE_DIRECTIONAL),\n/* harmony export */   \"LIGHTTYPE_OMNI\": () => (/* binding */ LIGHTTYPE_OMNI),\n/* harmony export */   \"LIGHTTYPE_POINT\": () => (/* binding */ LIGHTTYPE_POINT),\n/* harmony export */   \"LIGHTTYPE_SPOT\": () => (/* binding */ LIGHTTYPE_SPOT),\n/* harmony export */   \"LINEBATCH_GIZMO\": () => (/* binding */ LINEBATCH_GIZMO),\n/* harmony export */   \"LINEBATCH_OVERLAY\": () => (/* binding */ LINEBATCH_OVERLAY),\n/* harmony export */   \"LINEBATCH_WORLD\": () => (/* binding */ LINEBATCH_WORLD),\n/* harmony export */   \"MASK_AFFECT_DYNAMIC\": () => (/* binding */ MASK_AFFECT_DYNAMIC),\n/* harmony export */   \"MASK_AFFECT_LIGHTMAPPED\": () => (/* binding */ MASK_AFFECT_LIGHTMAPPED),\n/* harmony export */   \"MASK_BAKE\": () => (/* binding */ MASK_BAKE),\n/* harmony export */   \"ORIENTATION_HORIZONTAL\": () => (/* binding */ ORIENTATION_HORIZONTAL),\n/* harmony export */   \"ORIENTATION_VERTICAL\": () => (/* binding */ ORIENTATION_VERTICAL),\n/* harmony export */   \"PARTICLEMODE_CPU\": () => (/* binding */ PARTICLEMODE_CPU),\n/* harmony export */   \"PARTICLEMODE_GPU\": () => (/* binding */ PARTICLEMODE_GPU),\n/* harmony export */   \"PARTICLEORIENTATION_EMITTER\": () => (/* binding */ PARTICLEORIENTATION_EMITTER),\n/* harmony export */   \"PARTICLEORIENTATION_SCREEN\": () => (/* binding */ PARTICLEORIENTATION_SCREEN),\n/* harmony export */   \"PARTICLEORIENTATION_WORLD\": () => (/* binding */ PARTICLEORIENTATION_WORLD),\n/* harmony export */   \"PARTICLESORT_DISTANCE\": () => (/* binding */ PARTICLESORT_DISTANCE),\n/* harmony export */   \"PARTICLESORT_NEWER_FIRST\": () => (/* binding */ PARTICLESORT_NEWER_FIRST),\n/* harmony export */   \"PARTICLESORT_NONE\": () => (/* binding */ PARTICLESORT_NONE),\n/* harmony export */   \"PARTICLESORT_OLDER_FIRST\": () => (/* binding */ PARTICLESORT_OLDER_FIRST),\n/* harmony export */   \"PROJECTION_ORTHOGRAPHIC\": () => (/* binding */ PROJECTION_ORTHOGRAPHIC),\n/* harmony export */   \"PROJECTION_PERSPECTIVE\": () => (/* binding */ PROJECTION_PERSPECTIVE),\n/* harmony export */   \"RENDERSTYLE_POINTS\": () => (/* binding */ RENDERSTYLE_POINTS),\n/* harmony export */   \"RENDERSTYLE_SOLID\": () => (/* binding */ RENDERSTYLE_SOLID),\n/* harmony export */   \"RENDERSTYLE_WIREFRAME\": () => (/* binding */ RENDERSTYLE_WIREFRAME),\n/* harmony export */   \"SHADERDEF_DIRLM\": () => (/* binding */ SHADERDEF_DIRLM),\n/* harmony export */   \"SHADERDEF_INSTANCING\": () => (/* binding */ SHADERDEF_INSTANCING),\n/* harmony export */   \"SHADERDEF_LM\": () => (/* binding */ SHADERDEF_LM),\n/* harmony export */   \"SHADERDEF_LMAMBIENT\": () => (/* binding */ SHADERDEF_LMAMBIENT),\n/* harmony export */   \"SHADERDEF_MORPH_NORMAL\": () => (/* binding */ SHADERDEF_MORPH_NORMAL),\n/* harmony export */   \"SHADERDEF_MORPH_POSITION\": () => (/* binding */ SHADERDEF_MORPH_POSITION),\n/* harmony export */   \"SHADERDEF_MORPH_TEXTURE_BASED\": () => (/* binding */ SHADERDEF_MORPH_TEXTURE_BASED),\n/* harmony export */   \"SHADERDEF_NOSHADOW\": () => (/* binding */ SHADERDEF_NOSHADOW),\n/* harmony export */   \"SHADERDEF_SCREENSPACE\": () => (/* binding */ SHADERDEF_SCREENSPACE),\n/* harmony export */   \"SHADERDEF_SKIN\": () => (/* binding */ SHADERDEF_SKIN),\n/* harmony export */   \"SHADERDEF_TANGENTS\": () => (/* binding */ SHADERDEF_TANGENTS),\n/* harmony export */   \"SHADERDEF_UV0\": () => (/* binding */ SHADERDEF_UV0),\n/* harmony export */   \"SHADERDEF_UV1\": () => (/* binding */ SHADERDEF_UV1),\n/* harmony export */   \"SHADERDEF_VCOLOR\": () => (/* binding */ SHADERDEF_VCOLOR),\n/* harmony export */   \"SHADERTYPE_DEPTH\": () => (/* binding */ SHADERTYPE_DEPTH),\n/* harmony export */   \"SHADERTYPE_FORWARD\": () => (/* binding */ SHADERTYPE_FORWARD),\n/* harmony export */   \"SHADERTYPE_PICK\": () => (/* binding */ SHADERTYPE_PICK),\n/* harmony export */   \"SHADERTYPE_SHADOW\": () => (/* binding */ SHADERTYPE_SHADOW),\n/* harmony export */   \"SHADER_DEPTH\": () => (/* binding */ SHADER_DEPTH),\n/* harmony export */   \"SHADER_FORWARD\": () => (/* binding */ SHADER_FORWARD),\n/* harmony export */   \"SHADER_FORWARDHDR\": () => (/* binding */ SHADER_FORWARDHDR),\n/* harmony export */   \"SHADER_PICK\": () => (/* binding */ SHADER_PICK),\n/* harmony export */   \"SHADER_SHADOW\": () => (/* binding */ SHADER_SHADOW),\n/* harmony export */   \"SHADOWUPDATE_NONE\": () => (/* binding */ SHADOWUPDATE_NONE),\n/* harmony export */   \"SHADOWUPDATE_REALTIME\": () => (/* binding */ SHADOWUPDATE_REALTIME),\n/* harmony export */   \"SHADOWUPDATE_THISFRAME\": () => (/* binding */ SHADOWUPDATE_THISFRAME),\n/* harmony export */   \"SHADOW_COUNT\": () => (/* binding */ SHADOW_COUNT),\n/* harmony export */   \"SHADOW_DEPTH\": () => (/* binding */ SHADOW_DEPTH),\n/* harmony export */   \"SHADOW_PCF1\": () => (/* binding */ SHADOW_PCF1),\n/* harmony export */   \"SHADOW_PCF3\": () => (/* binding */ SHADOW_PCF3),\n/* harmony export */   \"SHADOW_PCF5\": () => (/* binding */ SHADOW_PCF5),\n/* harmony export */   \"SHADOW_VSM16\": () => (/* binding */ SHADOW_VSM16),\n/* harmony export */   \"SHADOW_VSM32\": () => (/* binding */ SHADOW_VSM32),\n/* harmony export */   \"SHADOW_VSM8\": () => (/* binding */ SHADOW_VSM8),\n/* harmony export */   \"SORTKEY_DEPTH\": () => (/* binding */ SORTKEY_DEPTH),\n/* harmony export */   \"SORTKEY_FORWARD\": () => (/* binding */ SORTKEY_FORWARD),\n/* harmony export */   \"SORTMODE_BACK2FRONT\": () => (/* binding */ SORTMODE_BACK2FRONT),\n/* harmony export */   \"SORTMODE_CUSTOM\": () => (/* binding */ SORTMODE_CUSTOM),\n/* harmony export */   \"SORTMODE_FRONT2BACK\": () => (/* binding */ SORTMODE_FRONT2BACK),\n/* harmony export */   \"SORTMODE_MANUAL\": () => (/* binding */ SORTMODE_MANUAL),\n/* harmony export */   \"SORTMODE_MATERIALMESH\": () => (/* binding */ SORTMODE_MATERIALMESH),\n/* harmony export */   \"SORTMODE_NONE\": () => (/* binding */ SORTMODE_NONE),\n/* harmony export */   \"SPECOCC_AO\": () => (/* binding */ SPECOCC_AO),\n/* harmony export */   \"SPECOCC_GLOSSDEPENDENT\": () => (/* binding */ SPECOCC_GLOSSDEPENDENT),\n/* harmony export */   \"SPECOCC_NONE\": () => (/* binding */ SPECOCC_NONE),\n/* harmony export */   \"SPECULAR_BLINN\": () => (/* binding */ SPECULAR_BLINN),\n/* harmony export */   \"SPECULAR_PHONG\": () => (/* binding */ SPECULAR_PHONG),\n/* harmony export */   \"SPRITE_RENDERMODE_SIMPLE\": () => (/* binding */ SPRITE_RENDERMODE_SIMPLE),\n/* harmony export */   \"SPRITE_RENDERMODE_SLICED\": () => (/* binding */ SPRITE_RENDERMODE_SLICED),\n/* harmony export */   \"SPRITE_RENDERMODE_TILED\": () => (/* binding */ SPRITE_RENDERMODE_TILED),\n/* harmony export */   \"TONEMAP_ACES\": () => (/* binding */ TONEMAP_ACES),\n/* harmony export */   \"TONEMAP_ACES2\": () => (/* binding */ TONEMAP_ACES2),\n/* harmony export */   \"TONEMAP_FILMIC\": () => (/* binding */ TONEMAP_FILMIC),\n/* harmony export */   \"TONEMAP_HEJL\": () => (/* binding */ TONEMAP_HEJL),\n/* harmony export */   \"TONEMAP_LINEAR\": () => (/* binding */ TONEMAP_LINEAR),\n/* harmony export */   \"VIEW_CENTER\": () => (/* binding */ VIEW_CENTER),\n/* harmony export */   \"VIEW_LEFT\": () => (/* binding */ VIEW_LEFT),\n/* harmony export */   \"VIEW_RIGHT\": () => (/* binding */ VIEW_RIGHT),\n/* harmony export */   \"shadowTypeToString\": () => (/* binding */ shadowTypeToString)\n/* harmony export */ });\nconst BLEND_SUBTRACTIVE = 0;\nconst BLEND_ADDITIVE = 1;\nconst BLEND_NORMAL = 2;\nconst BLEND_NONE = 3;\nconst BLEND_PREMULTIPLIED = 4;\nconst BLEND_MULTIPLICATIVE = 5;\nconst BLEND_ADDITIVEALPHA = 6;\nconst BLEND_MULTIPLICATIVE2X = 7;\nconst BLEND_SCREEN = 8;\nconst BLEND_MIN = 9;\nconst BLEND_MAX = 10;\nconst FOG_NONE = 'none';\nconst FOG_LINEAR = 'linear';\nconst FOG_EXP = 'exp';\nconst FOG_EXP2 = 'exp2';\nconst FRESNEL_NONE = 0;\nconst FRESNEL_SCHLICK = 2;\nconst LAYER_HUD = 0;\nconst LAYER_GIZMO = 1;\nconst LAYER_FX = 2;\nconst LAYER_WORLD = 15;\nconst LAYERID_WORLD = 0;\nconst LAYERID_DEPTH = 1;\nconst LAYERID_SKYBOX = 2;\nconst LAYERID_IMMEDIATE = 3;\nconst LAYERID_UI = 4;\nconst LIGHTTYPE_DIRECTIONAL = 0;\nconst LIGHTTYPE_OMNI = 1;\nconst LIGHTTYPE_POINT = LIGHTTYPE_OMNI;\nconst LIGHTTYPE_SPOT = 2;\nconst LIGHTTYPE_COUNT = 3;\nconst LIGHTSHAPE_PUNCTUAL = 0;\nconst LIGHTSHAPE_RECT = 1;\nconst LIGHTSHAPE_DISK = 2;\nconst LIGHTSHAPE_SPHERE = 3;\nconst LIGHTFALLOFF_LINEAR = 0;\nconst LIGHTFALLOFF_INVERSESQUARED = 1;\nconst SHADOW_PCF3 = 0;\nconst SHADOW_DEPTH = 0;\nconst SHADOW_VSM8 = 1;\nconst SHADOW_VSM16 = 2;\nconst SHADOW_VSM32 = 3;\nconst SHADOW_PCF5 = 4;\nconst SHADOW_PCF1 = 5;\nconst SHADOW_COUNT = 6;\nconst shadowTypeToString = {};\nshadowTypeToString[SHADOW_PCF3] = 'PCF3';\nshadowTypeToString[SHADOW_VSM8] = 'VSM8';\nshadowTypeToString[SHADOW_VSM16] = 'VSM16';\nshadowTypeToString[SHADOW_VSM32] = 'VSM32';\nshadowTypeToString[SHADOW_PCF5] = 'PCF5';\nshadowTypeToString[SHADOW_PCF1] = 'PCF1';\nconst BLUR_BOX = 0;\nconst BLUR_GAUSSIAN = 1;\nconst PARTICLESORT_NONE = 0;\nconst PARTICLESORT_DISTANCE = 1;\nconst PARTICLESORT_NEWER_FIRST = 2;\nconst PARTICLESORT_OLDER_FIRST = 3;\nconst PARTICLEMODE_GPU = 0;\nconst PARTICLEMODE_CPU = 1;\nconst EMITTERSHAPE_BOX = 0;\nconst EMITTERSHAPE_SPHERE = 1;\nconst PARTICLEORIENTATION_SCREEN = 0;\nconst PARTICLEORIENTATION_WORLD = 1;\nconst PARTICLEORIENTATION_EMITTER = 2;\nconst PROJECTION_PERSPECTIVE = 0;\nconst PROJECTION_ORTHOGRAPHIC = 1;\nconst RENDERSTYLE_SOLID = 0;\nconst RENDERSTYLE_WIREFRAME = 1;\nconst RENDERSTYLE_POINTS = 2;\nconst CUBEPROJ_NONE = 0;\nconst CUBEPROJ_BOX = 1;\nconst SPECULAR_PHONG = 0;\nconst SPECULAR_BLINN = 1;\nconst DETAILMODE_MUL = 'mul';\nconst DETAILMODE_ADD = 'add';\nconst DETAILMODE_SCREEN = 'screen';\nconst DETAILMODE_OVERLAY = 'overlay';\nconst DETAILMODE_MIN = 'min';\nconst DETAILMODE_MAX = 'max';\nconst GAMMA_NONE = 0;\nconst GAMMA_SRGB = 1;\nconst GAMMA_SRGBFAST = 2;\nconst GAMMA_SRGBHDR = 3;\nconst TONEMAP_LINEAR = 0;\nconst TONEMAP_FILMIC = 1;\nconst TONEMAP_HEJL = 2;\nconst TONEMAP_ACES = 3;\nconst TONEMAP_ACES2 = 4;\nconst SPECOCC_NONE = 0;\nconst SPECOCC_AO = 1;\nconst SPECOCC_GLOSSDEPENDENT = 2;\nconst SHADERDEF_NOSHADOW = 1;\nconst SHADERDEF_SKIN = 2;\nconst SHADERDEF_UV0 = 4;\nconst SHADERDEF_UV1 = 8;\nconst SHADERDEF_VCOLOR = 16;\nconst SHADERDEF_INSTANCING = 32;\nconst SHADERDEF_LM = 64;\nconst SHADERDEF_DIRLM = 128;\nconst SHADERDEF_SCREENSPACE = 256;\nconst SHADERDEF_TANGENTS = 512;\nconst SHADERDEF_MORPH_POSITION = 1024;\nconst SHADERDEF_MORPH_NORMAL = 2048;\nconst SHADERDEF_MORPH_TEXTURE_BASED = 4096;\nconst SHADERDEF_LMAMBIENT = 8192;\nconst LINEBATCH_WORLD = 0;\nconst LINEBATCH_OVERLAY = 1;\nconst LINEBATCH_GIZMO = 2;\nconst SHADOWUPDATE_NONE = 0;\nconst SHADOWUPDATE_THISFRAME = 1;\nconst SHADOWUPDATE_REALTIME = 2;\nconst SORTKEY_FORWARD = 0;\nconst SORTKEY_DEPTH = 1;\nconst MASK_AFFECT_DYNAMIC = 1;\nconst MASK_AFFECT_LIGHTMAPPED = 2;\nconst MASK_BAKE = 4;\nconst SHADER_FORWARD = 0;\nconst SHADER_FORWARDHDR = 1;\nconst SHADER_DEPTH = 2;\nconst SHADER_PICK = 3;\nconst SHADER_SHADOW = 4;\nconst SHADERTYPE_FORWARD = 'forward';\nconst SHADERTYPE_DEPTH = 'depth';\nconst SHADERTYPE_PICK = 'pick';\nconst SHADERTYPE_SHADOW = 'shadow';\nconst SPRITE_RENDERMODE_SIMPLE = 0;\nconst SPRITE_RENDERMODE_SLICED = 1;\nconst SPRITE_RENDERMODE_TILED = 2;\nconst BAKE_COLOR = 0;\nconst BAKE_COLORDIR = 1;\nconst VIEW_CENTER = 0;\nconst VIEW_LEFT = 1;\nconst VIEW_RIGHT = 2;\nconst SORTMODE_NONE = 0;\nconst SORTMODE_MANUAL = 1;\nconst SORTMODE_MATERIALMESH = 2;\nconst SORTMODE_BACK2FRONT = 3;\nconst SORTMODE_FRONT2BACK = 4;\nconst SORTMODE_CUSTOM = 5;\nconst COMPUPDATED_INSTANCES = 1;\nconst COMPUPDATED_LIGHTS = 2;\nconst COMPUPDATED_CAMERAS = 4;\nconst COMPUPDATED_BLEND = 8;\nconst ASPECT_AUTO = 0;\nconst ASPECT_MANUAL = 1;\nconst ORIENTATION_HORIZONTAL = 0;\nconst ORIENTATION_VERTICAL = 1;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/frame-graph.js":
/*!***************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/frame-graph.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FrameGraph\": () => (/* binding */ FrameGraph)\n/* harmony export */ });\n\n\n\nclass FrameGraph {\n  constructor() {\n    this.renderPasses = [];\n    this.renderTargetMap = new Map();\n  }\n  addRenderPass(renderPass) {\n    this.renderPasses.push(renderPass);\n  }\n  reset() {\n    this.renderPasses.length = 0;\n  }\n  compile() {\n    const renderTargetMap = this.renderTargetMap;\n    const renderPasses = this.renderPasses;\n    for (let i = 0; i < renderPasses.length; i++) {\n      const renderPass = renderPasses[i];\n      const renderTarget = renderPass.renderTarget;\n      if (renderTarget !== undefined) {\n        const prevPass = renderTargetMap.get(renderTarget);\n        if (prevPass) {\n          if (!renderPass.colorOps.clear) {\n            prevPass.colorOps.store = true;\n          }\n          if (!renderPass.depthStencilOps.clearDepth) {\n            prevPass.depthStencilOps.storeDepth = true;\n          }\n          if (!renderPass.depthStencilOps.clearStencil) {\n            prevPass.depthStencilOps.storeStencil = true;\n          }\n        }\n        renderTargetMap.set(renderTarget, renderPass);\n      }\n    }\n    let lastCubeTexture = null;\n    let lastCubeRenderPass = null;\n    for (let i = 0; i < renderPasses.length; i++) {\n      const renderPass = renderPasses[i];\n      const renderTarget = renderPass.renderTarget;\n      const thisTexture = renderTarget == null ? void 0 : renderTarget.colorBuffer;\n      if (thisTexture != null && thisTexture.cubemap) {\n        if (lastCubeTexture === thisTexture) {\n          lastCubeRenderPass.colorOps.mipmaps = false;\n        }\n        lastCubeTexture = renderTarget.colorBuffer;\n        lastCubeRenderPass = renderPass;\n      } else if (renderPass.requiresCubemaps) {\n        lastCubeTexture = null;\n        lastCubeRenderPass = null;\n      }\n    }\n    renderTargetMap.forEach((renderPass, renderTarget) => {\n      if (renderTarget === null) {\n        renderPass.colorOps.store = true;\n        renderPass.colorOps.resolve = false;\n        renderPass.colorOps.mipmaps = false;\n      }\n    });\n    renderTargetMap.clear();\n  }\n  render(device) {\n    this.compile();\n    const renderPasses = this.renderPasses;\n    for (let i = 0; i < renderPasses.length; i++) {\n      renderPasses[i].render();\n    }\n    this.log(device);\n  }\n  log(device) {}\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/frame-graph.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/graph-node.js":
/*!**************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/graph-node.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GraphNode\": () => (/* binding */ GraphNode)\n/* harmony export */ });\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _core_tags_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/tags.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/tags.js\");\n/* harmony import */ var _core_math_mat3_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/math/mat3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat3.js\");\n/* harmony import */ var _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/math/mat4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js\");\n/* harmony import */ var _core_math_quat_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/math/quat.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/quat.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n\n\n\n\n\n\n\n\nconst scaleCompensatePosTransform = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\nconst scaleCompensatePos = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst scaleCompensateRot = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_2__.Quat();\nconst scaleCompensateRot2 = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_2__.Quat();\nconst scaleCompensateScale = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst scaleCompensateScaleForParent = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst tmpMat4 = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\nconst tmpQuat = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_2__.Quat();\nconst position = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst invParentWtm = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\nconst rotation = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_2__.Quat();\nconst invParentRot = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_2__.Quat();\nconst matrix = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\nconst target = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst up = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nclass GraphNode extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_3__.EventHandler {\n  constructor(name = 'Untitled') {\n    super();\n    this.name = name;\n    this.tags = new _core_tags_js__WEBPACK_IMPORTED_MODULE_4__.Tags(this);\n    this._labels = {};\n    this.localPosition = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n    this.localRotation = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_2__.Quat();\n    this.localScale = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3(1, 1, 1);\n    this.localEulerAngles = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n    this.position = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n    this.rotation = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_2__.Quat();\n    this.eulerAngles = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n    this._scale = null;\n    this.localTransform = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\n    this._dirtyLocal = false;\n    this._aabbVer = 0;\n    this._frozen = false;\n    this.worldTransform = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\n    this._dirtyWorld = false;\n    this._normalMatrix = new _core_math_mat3_js__WEBPACK_IMPORTED_MODULE_5__.Mat3();\n    this._dirtyNormal = true;\n    this._right = null;\n    this._up = null;\n    this._forward = null;\n    this._parent = null;\n    this._children = [];\n    this._graphDepth = 0;\n    this._enabled = true;\n    this._enabledInHierarchy = false;\n    this.scaleCompensation = false;\n  }\n  get right() {\n    if (!this._right) {\n      this._right = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n    }\n    return this.getWorldTransform().getX(this._right).normalize();\n  }\n  get up() {\n    if (!this._up) {\n      this._up = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n    }\n    return this.getWorldTransform().getY(this._up).normalize();\n  }\n  get forward() {\n    if (!this._forward) {\n      this._forward = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n    }\n    return this.getWorldTransform().getZ(this._forward).normalize().mulScalar(-1);\n  }\n  get normalMatrix() {\n    const normalMat = this._normalMatrix;\n    if (this._dirtyNormal) {\n      this.getWorldTransform().invertTo3x3(normalMat);\n      normalMat.transpose();\n      this._dirtyNormal = false;\n    }\n    return normalMat;\n  }\n  set enabled(enabled) {\n    if (this._enabled !== enabled) {\n      var _this$_parent;\n      this._enabled = enabled;\n      if (enabled && (_this$_parent = this._parent) != null && _this$_parent.enabled || !enabled) {\n        this._notifyHierarchyStateChanged(this, enabled);\n      }\n    }\n  }\n  get enabled() {\n    return this._enabled && this._enabledInHierarchy;\n  }\n  get parent() {\n    return this._parent;\n  }\n  get path() {\n    let node = this._parent;\n    if (!node) {\n      return '';\n    }\n    let result = this.name;\n    while (node && node._parent) {\n      result = `${node.name}/${result}`;\n      node = node._parent;\n    }\n    return result;\n  }\n  get root() {\n    let result = this;\n    while (result._parent) {\n      result = result._parent;\n    }\n    return result;\n  }\n  get children() {\n    return this._children;\n  }\n  get graphDepth() {\n    return this._graphDepth;\n  }\n  _notifyHierarchyStateChanged(node, enabled) {\n    node._onHierarchyStateChanged(enabled);\n    const c = node._children;\n    for (let i = 0, len = c.length; i < len; i++) {\n      if (c[i]._enabled) this._notifyHierarchyStateChanged(c[i], enabled);\n    }\n  }\n  _onHierarchyStateChanged(enabled) {\n    this._enabledInHierarchy = enabled;\n    if (enabled && !this._frozen) this._unfreezeParentToRoot();\n  }\n  _cloneInternal(clone) {\n    clone.name = this.name;\n    const tags = this.tags._list;\n    clone.tags.clear();\n    for (let i = 0; i < tags.length; i++) clone.tags.add(tags[i]);\n    clone._labels = Object.assign({}, this._labels);\n    clone.localPosition.copy(this.localPosition);\n    clone.localRotation.copy(this.localRotation);\n    clone.localScale.copy(this.localScale);\n    clone.localEulerAngles.copy(this.localEulerAngles);\n    clone.position.copy(this.position);\n    clone.rotation.copy(this.rotation);\n    clone.eulerAngles.copy(this.eulerAngles);\n    clone.localTransform.copy(this.localTransform);\n    clone._dirtyLocal = this._dirtyLocal;\n    clone.worldTransform.copy(this.worldTransform);\n    clone._dirtyWorld = this._dirtyWorld;\n    clone._dirtyNormal = this._dirtyNormal;\n    clone._aabbVer = this._aabbVer + 1;\n    clone._enabled = this._enabled;\n    clone.scaleCompensation = this.scaleCompensation;\n    clone._enabledInHierarchy = false;\n  }\n  clone() {\n    const clone = new this.constructor();\n    this._cloneInternal(clone);\n    return clone;\n  }\n  copy(source) {\n    source._cloneInternal(this);\n    return this;\n  }\n  find(attr, value) {\n    let result,\n      results = [];\n    const len = this._children.length;\n    if (attr instanceof Function) {\n      const fn = attr;\n      result = fn(this);\n      if (result) results.push(this);\n      for (let i = 0; i < len; i++) {\n        const descendants = this._children[i].find(fn);\n        if (descendants.length) results = results.concat(descendants);\n      }\n    } else {\n      let testValue;\n      if (this[attr]) {\n        if (this[attr] instanceof Function) {\n          testValue = this[attr]();\n        } else {\n          testValue = this[attr];\n        }\n        if (testValue === value) results.push(this);\n      }\n      for (let i = 0; i < len; ++i) {\n        const descendants = this._children[i].find(attr, value);\n        if (descendants.length) results = results.concat(descendants);\n      }\n    }\n    return results;\n  }\n  findOne(attr, value) {\n    const len = this._children.length;\n    let result = null;\n    if (attr instanceof Function) {\n      const fn = attr;\n      result = fn(this);\n      if (result) return this;\n      for (let i = 0; i < len; i++) {\n        result = this._children[i].findOne(fn);\n        if (result) return result;\n      }\n    } else {\n      let testValue;\n      if (this[attr]) {\n        if (this[attr] instanceof Function) {\n          testValue = this[attr]();\n        } else {\n          testValue = this[attr];\n        }\n        if (testValue === value) {\n          return this;\n        }\n      }\n      for (let i = 0; i < len; i++) {\n        result = this._children[i].findOne(attr, value);\n        if (result !== null) return result;\n      }\n    }\n    return null;\n  }\n  findByTag() {\n    const query = arguments;\n    const results = [];\n    const queryNode = (node, checkNode) => {\n      if (checkNode && node.tags.has(...query)) {\n        results.push(node);\n      }\n      for (let i = 0; i < node._children.length; i++) {\n        queryNode(node._children[i], true);\n      }\n    };\n    queryNode(this, false);\n    return results;\n  }\n  findByName(name) {\n    if (this.name === name) return this;\n    for (let i = 0; i < this._children.length; i++) {\n      const found = this._children[i].findByName(name);\n      if (found !== null) return found;\n    }\n    return null;\n  }\n  findByPath(path) {\n    const parts = Array.isArray(path) ? path : path.split('/');\n    let result = this;\n    for (let i = 0, imax = parts.length; i < imax; ++i) {\n      result = result.children.find(c => c.name === parts[i]);\n      if (!result) {\n        return null;\n      }\n    }\n    return result;\n  }\n  forEach(callback, thisArg) {\n    callback.call(thisArg, this);\n    const children = this._children;\n    for (let i = 0; i < children.length; i++) {\n      children[i].forEach(callback, thisArg);\n    }\n  }\n  isDescendantOf(node) {\n    let parent = this._parent;\n    while (parent) {\n      if (parent === node) return true;\n      parent = parent._parent;\n    }\n    return false;\n  }\n  isAncestorOf(node) {\n    return node.isDescendantOf(this);\n  }\n  getEulerAngles() {\n    this.getWorldTransform().getEulerAngles(this.eulerAngles);\n    return this.eulerAngles;\n  }\n  getLocalEulerAngles() {\n    this.localRotation.getEulerAngles(this.localEulerAngles);\n    return this.localEulerAngles;\n  }\n  getLocalPosition() {\n    return this.localPosition;\n  }\n  getLocalRotation() {\n    return this.localRotation;\n  }\n  getLocalScale() {\n    return this.localScale;\n  }\n  getLocalTransform() {\n    if (this._dirtyLocal) {\n      this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);\n      this._dirtyLocal = false;\n    }\n    return this.localTransform;\n  }\n  getPosition() {\n    this.getWorldTransform().getTranslation(this.position);\n    return this.position;\n  }\n  getRotation() {\n    this.rotation.setFromMat4(this.getWorldTransform());\n    return this.rotation;\n  }\n  getScale() {\n    if (!this._scale) {\n      this._scale = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n    }\n    return this.getWorldTransform().getScale(this._scale);\n  }\n  getWorldTransform() {\n    if (!this._dirtyLocal && !this._dirtyWorld) return this.worldTransform;\n    if (this._parent) this._parent.getWorldTransform();\n    this._sync();\n    return this.worldTransform;\n  }\n  reparent(parent, index) {\n    const current = this._parent;\n    if (current) current.removeChild(this);\n    if (parent) {\n      if (index >= 0) {\n        parent.insertChild(this, index);\n      } else {\n        parent.addChild(this);\n      }\n    }\n  }\n  setLocalEulerAngles(x, y, z) {\n    this.localRotation.setFromEulerAngles(x, y, z);\n    if (!this._dirtyLocal) this._dirtifyLocal();\n  }\n  setLocalPosition(x, y, z) {\n    if (x instanceof _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3) {\n      this.localPosition.copy(x);\n    } else {\n      this.localPosition.set(x, y, z);\n    }\n    if (!this._dirtyLocal) this._dirtifyLocal();\n  }\n  setLocalRotation(x, y, z, w) {\n    if (x instanceof _core_math_quat_js__WEBPACK_IMPORTED_MODULE_2__.Quat) {\n      this.localRotation.copy(x);\n    } else {\n      this.localRotation.set(x, y, z, w);\n    }\n    if (!this._dirtyLocal) this._dirtifyLocal();\n  }\n  setLocalScale(x, y, z) {\n    if (x instanceof _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3) {\n      this.localScale.copy(x);\n    } else {\n      this.localScale.set(x, y, z);\n    }\n    if (!this._dirtyLocal) this._dirtifyLocal();\n  }\n  _dirtifyLocal() {\n    if (!this._dirtyLocal) {\n      this._dirtyLocal = true;\n      if (!this._dirtyWorld) this._dirtifyWorld();\n    }\n  }\n  _unfreezeParentToRoot() {\n    let p = this._parent;\n    while (p) {\n      p._frozen = false;\n      p = p._parent;\n    }\n  }\n  _dirtifyWorld() {\n    if (!this._dirtyWorld) this._unfreezeParentToRoot();\n    this._dirtifyWorldInternal();\n  }\n  _dirtifyWorldInternal() {\n    if (!this._dirtyWorld) {\n      this._frozen = false;\n      this._dirtyWorld = true;\n      for (let i = 0; i < this._children.length; i++) {\n        if (!this._children[i]._dirtyWorld) this._children[i]._dirtifyWorldInternal();\n      }\n    }\n    this._dirtyNormal = true;\n    this._aabbVer++;\n  }\n  setPosition(x, y, z) {\n    if (x instanceof _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3) {\n      position.copy(x);\n    } else {\n      position.set(x, y, z);\n    }\n    if (this._parent === null) {\n      this.localPosition.copy(position);\n    } else {\n      invParentWtm.copy(this._parent.getWorldTransform()).invert();\n      invParentWtm.transformPoint(position, this.localPosition);\n    }\n    if (!this._dirtyLocal) this._dirtifyLocal();\n  }\n  setRotation(x, y, z, w) {\n    if (x instanceof _core_math_quat_js__WEBPACK_IMPORTED_MODULE_2__.Quat) {\n      rotation.copy(x);\n    } else {\n      rotation.set(x, y, z, w);\n    }\n    if (this._parent === null) {\n      this.localRotation.copy(rotation);\n    } else {\n      const parentRot = this._parent.getRotation();\n      invParentRot.copy(parentRot).invert();\n      this.localRotation.copy(invParentRot).mul(rotation);\n    }\n    if (!this._dirtyLocal) this._dirtifyLocal();\n  }\n  setEulerAngles(x, y, z) {\n    this.localRotation.setFromEulerAngles(x, y, z);\n    if (this._parent !== null) {\n      const parentRot = this._parent.getRotation();\n      invParentRot.copy(parentRot).invert();\n      this.localRotation.mul2(invParentRot, this.localRotation);\n    }\n    if (!this._dirtyLocal) this._dirtifyLocal();\n  }\n  addChild(node) {\n    this._prepareInsertChild(node);\n    this._children.push(node);\n    this._onInsertChild(node);\n  }\n  addChildAndSaveTransform(node) {\n    const wPos = node.getPosition();\n    const wRot = node.getRotation();\n    this._prepareInsertChild(node);\n    node.setPosition(tmpMat4.copy(this.worldTransform).invert().transformPoint(wPos));\n    node.setRotation(tmpQuat.copy(this.getRotation()).invert().mul(wRot));\n    this._children.push(node);\n    this._onInsertChild(node);\n  }\n  insertChild(node, index) {\n    this._prepareInsertChild(node);\n    this._children.splice(index, 0, node);\n    this._onInsertChild(node);\n  }\n  _prepareInsertChild(node) {\n    if (node._parent) {\n      node._parent.removeChild(node);\n    }\n  }\n  _fireOnHierarchy(name, nameHierarchy, parent) {\n    this.fire(name, parent);\n    for (let i = 0; i < this._children.length; i++) {\n      this._children[i]._fireOnHierarchy(nameHierarchy, nameHierarchy, parent);\n    }\n  }\n  _onInsertChild(node) {\n    node._parent = this;\n    const enabledInHierarchy = node._enabled && this.enabled;\n    if (node._enabledInHierarchy !== enabledInHierarchy) {\n      node._enabledInHierarchy = enabledInHierarchy;\n      node._notifyHierarchyStateChanged(node, enabledInHierarchy);\n    }\n    node._updateGraphDepth();\n    node._dirtifyWorld();\n    if (this._frozen) node._unfreezeParentToRoot();\n    node._fireOnHierarchy('insert', 'inserthierarchy', this);\n    if (this.fire) this.fire('childinsert', node);\n  }\n  _updateGraphDepth() {\n    this._graphDepth = this._parent ? this._parent._graphDepth + 1 : 0;\n    for (let i = 0, len = this._children.length; i < len; i++) {\n      this._children[i]._updateGraphDepth();\n    }\n  }\n  removeChild(child) {\n    const index = this._children.indexOf(child);\n    if (index === -1) {\n      return;\n    }\n    this._children.splice(index, 1);\n    child._parent = null;\n    child._fireOnHierarchy('remove', 'removehierarchy', this);\n    this.fire('childremove', child);\n  }\n  _sync() {\n    if (this._dirtyLocal) {\n      this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);\n      this._dirtyLocal = false;\n    }\n    if (this._dirtyWorld) {\n      if (this._parent === null) {\n        this.worldTransform.copy(this.localTransform);\n      } else {\n        if (this.scaleCompensation) {\n          let parentWorldScale;\n          const parent = this._parent;\n          let scale = this.localScale;\n          let parentToUseScaleFrom = parent;\n          if (parentToUseScaleFrom) {\n            while (parentToUseScaleFrom && parentToUseScaleFrom.scaleCompensation) {\n              parentToUseScaleFrom = parentToUseScaleFrom._parent;\n            }\n            if (parentToUseScaleFrom) {\n              parentToUseScaleFrom = parentToUseScaleFrom._parent;\n              if (parentToUseScaleFrom) {\n                parentWorldScale = parentToUseScaleFrom.worldTransform.getScale();\n                scaleCompensateScale.mul2(parentWorldScale, this.localScale);\n                scale = scaleCompensateScale;\n              }\n            }\n          }\n          scaleCompensateRot2.setFromMat4(parent.worldTransform);\n          scaleCompensateRot.mul2(scaleCompensateRot2, this.localRotation);\n          let tmatrix = parent.worldTransform;\n          if (parent.scaleCompensation) {\n            scaleCompensateScaleForParent.mul2(parentWorldScale, parent.getLocalScale());\n            scaleCompensatePosTransform.setTRS(parent.worldTransform.getTranslation(scaleCompensatePos), scaleCompensateRot2, scaleCompensateScaleForParent);\n            tmatrix = scaleCompensatePosTransform;\n          }\n          tmatrix.transformPoint(this.localPosition, scaleCompensatePos);\n          this.worldTransform.setTRS(scaleCompensatePos, scaleCompensateRot, scale);\n        } else {\n          this.worldTransform.mulAffine2(this._parent.worldTransform, this.localTransform);\n        }\n      }\n      this._dirtyWorld = false;\n    }\n  }\n  syncHierarchy() {\n    if (!this._enabled) return;\n    if (this._frozen) return;\n    this._frozen = true;\n    if (this._dirtyLocal || this._dirtyWorld) {\n      this._sync();\n    }\n    const children = this._children;\n    for (let i = 0, len = children.length; i < len; i++) {\n      children[i].syncHierarchy();\n    }\n  }\n  lookAt(x, y, z, ux = 0, uy = 1, uz = 0) {\n    if (x instanceof _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3) {\n      target.copy(x);\n      if (y instanceof _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3) {\n        up.copy(y);\n      } else {\n        up.copy(_core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3.UP);\n      }\n    } else if (z === undefined) {\n      return;\n    } else {\n      target.set(x, y, z);\n      up.set(ux, uy, uz);\n    }\n    matrix.setLookAt(this.getPosition(), target, up);\n    rotation.setFromMat4(matrix);\n    this.setRotation(rotation);\n  }\n  translate(x, y, z) {\n    if (x instanceof _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3) {\n      position.copy(x);\n    } else {\n      position.set(x, y, z);\n    }\n    position.add(this.getPosition());\n    this.setPosition(position);\n  }\n  translateLocal(x, y, z) {\n    if (x instanceof _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3) {\n      position.copy(x);\n    } else {\n      position.set(x, y, z);\n    }\n    this.localRotation.transformVector(position, position);\n    this.localPosition.add(position);\n    if (!this._dirtyLocal) this._dirtifyLocal();\n  }\n  rotate(x, y, z) {\n    rotation.setFromEulerAngles(x, y, z);\n    if (this._parent === null) {\n      this.localRotation.mul2(rotation, this.localRotation);\n    } else {\n      const rot = this.getRotation();\n      const parentRot = this._parent.getRotation();\n      invParentRot.copy(parentRot).invert();\n      rotation.mul2(invParentRot, rotation);\n      this.localRotation.mul2(rotation, rot);\n    }\n    if (!this._dirtyLocal) this._dirtifyLocal();\n  }\n  rotateLocal(x, y, z) {\n    rotation.setFromEulerAngles(x, y, z);\n    this.localRotation.mul(rotation);\n    if (!this._dirtyLocal) this._dirtifyLocal();\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/graph-node.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/graphics/env-lighting.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/graphics/env-lighting.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EnvLighting\": () => (/* binding */ EnvLighting)\n/* harmony export */ });\n/* harmony import */ var _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/math/vec4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec4.js\");\n/* harmony import */ var _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../platform/graphics/texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js\");\n/* harmony import */ var _reproject_texture_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./reproject-texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/graphics/reproject-texture.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n\n\n\n\n\nconst fixCubemapSeams = true;\nconst RGBA8_TYPE = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTURETYPE_RGBM;\nconst calcLevels = (width, height = 0) => {\n  return 1 + Math.floor(Math.log2(Math.max(width, height)));\n};\nconst supportsFloat16 = device => {\n  return device.extTextureHalfFloat && device.textureHalfFloatRenderable;\n};\nconst supportsFloat32 = device => {\n  return device.extTextureFloat && device.textureFloatRenderable;\n};\nconst lightingSourcePixelFormat = device => {\n  return supportsFloat16(device) ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA16F : supportsFloat32(device) ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA32F : _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA8;\n};\nconst lightingPixelFormat = device => {\n  return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA8;\n};\nconst createCubemap = (device, size, format, mipmaps) => {\n  return new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture(device, {\n    name: `lighting-${size}`,\n    cubemap: true,\n    width: size,\n    height: size,\n    format: format,\n    type: format === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA8 ? RGBA8_TYPE : _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTURETYPE_DEFAULT,\n    addressU: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_CLAMP_TO_EDGE,\n    addressV: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_CLAMP_TO_EDGE,\n    fixCubemapSeams: fixCubemapSeams,\n    mipmaps: !!mipmaps\n  });\n};\nclass EnvLighting {\n  static generateSkyboxCubemap(source, size) {\n    const device = source.device;\n    const result = createCubemap(device, size || (source.cubemap ? source.width : source.width / 4), _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA8, false);\n    (0,_reproject_texture_js__WEBPACK_IMPORTED_MODULE_2__.reprojectTexture)(source, result, {\n      numSamples: 1024\n    });\n    return result;\n  }\n  static generateLightingSource(source, options) {\n    const device = source.device;\n    const format = lightingSourcePixelFormat(device);\n    const result = (options == null ? void 0 : options.target) || new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture(device, {\n      name: `lighting-source`,\n      cubemap: true,\n      width: (options == null ? void 0 : options.size) || 128,\n      height: (options == null ? void 0 : options.size) || 128,\n      format: format,\n      type: format === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA8 ? RGBA8_TYPE : _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTURETYPE_DEFAULT,\n      addressU: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_CLAMP_TO_EDGE,\n      addressV: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_CLAMP_TO_EDGE,\n      fixCubemapSeams: false,\n      mipmaps: true\n    });\n    (0,_reproject_texture_js__WEBPACK_IMPORTED_MODULE_2__.reprojectTexture)(source, result, {\n      numSamples: source.mipmaps ? 1 : 1024\n    });\n    return result;\n  }\n  static generateAtlas(source, options) {\n    const device = source.device;\n    const format = lightingPixelFormat();\n    const result = (options == null ? void 0 : options.target) || new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture(device, {\n      name: 'envAtlas',\n      width: (options == null ? void 0 : options.size) || 512,\n      height: (options == null ? void 0 : options.size) || 512,\n      format: format,\n      type: RGBA8_TYPE ,\n      projection: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTUREPROJECTION_EQUIRECT,\n      addressU: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_CLAMP_TO_EDGE,\n      addressV: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_CLAMP_TO_EDGE,\n      mipmaps: false\n    });\n    const s = result.width / 512;\n    const rect = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_3__.Vec4(0, 0, 512 * s, 256 * s);\n    const levels = calcLevels(256) - calcLevels(4);\n    for (let i = 0; i < levels; ++i) {\n      (0,_reproject_texture_js__WEBPACK_IMPORTED_MODULE_2__.reprojectTexture)(source, result, {\n        numSamples: 1,\n        rect: rect,\n        seamPixels: s\n      });\n      rect.x += rect.w;\n      rect.y += rect.w;\n      rect.z = Math.max(1, Math.floor(rect.z * 0.5));\n      rect.w = Math.max(1, Math.floor(rect.w * 0.5));\n    }\n    rect.set(0, 256 * s, 256 * s, 128 * s);\n    for (let i = 1; i < 7; ++i) {\n      (0,_reproject_texture_js__WEBPACK_IMPORTED_MODULE_2__.reprojectTexture)(source, result, {\n        numSamples: (options == null ? void 0 : options.numReflectionSamples) || 1024,\n        distribution: (options == null ? void 0 : options.distribution) || 'ggx',\n        specularPower: Math.max(1, 2048 >> i * 2),\n        rect: rect,\n        seamPixels: s\n      });\n      rect.y += rect.w;\n      rect.z = Math.max(1, Math.floor(rect.z * 0.5));\n      rect.w = Math.max(1, Math.floor(rect.w * 0.5));\n    }\n    rect.set(128 * s, (256 + 128) * s, 64 * s, 32 * s);\n    (0,_reproject_texture_js__WEBPACK_IMPORTED_MODULE_2__.reprojectTexture)(source, result, {\n      numSamples: (options == null ? void 0 : options.numAmbientSamples) || 2048,\n      distribution: 'lambert',\n      rect: rect,\n      seamPixels: s\n    });\n    return result;\n  }\n  static generatePrefilteredAtlas(sources, options) {\n    const device = sources[0].device;\n    const format = sources[0].format;\n    const type = sources[0].type;\n    const result = (options == null ? void 0 : options.target) || new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture(device, {\n      name: 'envPrefilteredAtlas',\n      width: (options == null ? void 0 : options.size) || 512,\n      height: (options == null ? void 0 : options.size) || 512,\n      format: format,\n      type: type,\n      projection: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTUREPROJECTION_EQUIRECT,\n      addressU: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_CLAMP_TO_EDGE,\n      addressV: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_CLAMP_TO_EDGE,\n      mipmaps: false\n    });\n    const s = result.width / 512;\n    const rect = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_3__.Vec4(0, 0, 512 * s, 256 * s);\n    const levels = calcLevels(512);\n    for (let i = 0; i < levels; ++i) {\n      (0,_reproject_texture_js__WEBPACK_IMPORTED_MODULE_2__.reprojectTexture)(sources[0], result, {\n        numSamples: 1,\n        rect: rect,\n        seamPixels: s\n      });\n      rect.x += rect.w;\n      rect.y += rect.w;\n      rect.z = Math.max(1, Math.floor(rect.z * 0.5));\n      rect.w = Math.max(1, Math.floor(rect.w * 0.5));\n    }\n    rect.set(0, 256 * s, 256 * s, 128 * s);\n    for (let i = 1; i < sources.length; ++i) {\n      (0,_reproject_texture_js__WEBPACK_IMPORTED_MODULE_2__.reprojectTexture)(sources[i], result, {\n        numSamples: 1,\n        rect: rect,\n        seamPixels: s\n      });\n      rect.y += rect.w;\n      rect.z = Math.max(1, Math.floor(rect.z * 0.5));\n      rect.w = Math.max(1, Math.floor(rect.w * 0.5));\n    }\n    rect.set(128 * s, (256 + 128) * s, 64 * s, 32 * s);\n    if (options != null && options.legacyAmbient) {\n      (0,_reproject_texture_js__WEBPACK_IMPORTED_MODULE_2__.reprojectTexture)(sources[5], result, {\n        numSamples: 1,\n        rect: rect,\n        seamPixels: s\n      });\n    } else {\n      (0,_reproject_texture_js__WEBPACK_IMPORTED_MODULE_2__.reprojectTexture)(sources[0], result, {\n        numSamples: (options == null ? void 0 : options.numSamples) || 2048,\n        distribution: 'lambert',\n        rect: rect,\n        seamPixels: s\n      });\n    }\n    return result;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/graphics/env-lighting.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/graphics/lightmap-cache.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/graphics/lightmap-cache.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LightmapCache\": () => (/* binding */ LightmapCache)\n/* harmony export */ });\n/* harmony import */ var _core_ref_counted_cache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/ref-counted-cache.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/ref-counted-cache.js\");\n\n\nclass LightmapCache {\n  static incRef(texture) {\n    this.cache.incRef(texture);\n  }\n  static decRef(texture) {\n    this.cache.decRef(texture);\n  }\n  static destroy() {\n    this.cache.destroy();\n  }\n}\nLightmapCache.cache = new _core_ref_counted_cache_js__WEBPACK_IMPORTED_MODULE_0__.RefCountedCache();\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/graphics/lightmap-cache.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/graphics/reproject-texture.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/graphics/reproject-texture.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"reprojectTexture\": () => (/* binding */ reprojectTexture)\n/* harmony export */ });\n/* harmony import */ var _core_math_random_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/math/random.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/random.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_device_cache_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../platform/graphics/device-cache.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/device-cache.js\");\n/* harmony import */ var _platform_graphics_graphics_device_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../platform/graphics/graphics-device.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/graphics-device.js\");\n/* harmony import */ var _platform_graphics_render_target_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../platform/graphics/render-target.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/render-target.js\");\n/* harmony import */ var _platform_graphics_simple_post_effect_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../platform/graphics/simple-post-effect.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/simple-post-effect.js\");\n/* harmony import */ var _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../platform/graphics/texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js\");\n/* harmony import */ var _shader_lib_chunk_utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../shader-lib/chunk-utils.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunk-utils.js\");\n/* harmony import */ var _shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../shader-lib/chunks/chunks.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/chunks.js\");\n/* harmony import */ var _shader_lib_get_program_library_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../shader-lib/get-program-library.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/get-program-library.js\");\n/* harmony import */ var _shader_lib_utils_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../shader-lib/utils.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/utils.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst getProjectionName = projection => {\n  switch (projection) {\n    case _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTUREPROJECTION_CUBE:\n      return \"Cubemap\";\n    case _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TEXTUREPROJECTION_OCTAHEDRAL:\n      return \"Octahedral\";\n    default:\n      return \"Equirect\";\n  }\n};\nconst packFloat32ToRGBA8 = (value, array, offset) => {\n  if (value <= 0) {\n    array[offset + 0] = 0;\n    array[offset + 1] = 0;\n    array[offset + 2] = 0;\n    array[offset + 3] = 0;\n  } else if (value >= 1.0) {\n    array[offset + 0] = 255;\n    array[offset + 1] = 0;\n    array[offset + 2] = 0;\n    array[offset + 3] = 0;\n  } else {\n    let encX = 1 * value % 1;\n    let encY = 255 * value % 1;\n    let encZ = 65025 * value % 1;\n    const encW = 16581375.0 * value % 1;\n    encX -= encY / 255;\n    encY -= encZ / 255;\n    encZ -= encW / 255;\n    array[offset + 0] = Math.min(255, Math.floor(encX * 256));\n    array[offset + 1] = Math.min(255, Math.floor(encY * 256));\n    array[offset + 2] = Math.min(255, Math.floor(encZ * 256));\n    array[offset + 3] = Math.min(255, Math.floor(encW * 256));\n  }\n};\nconst packSamples = samples => {\n  const numSamples = samples.length;\n  const w = Math.min(numSamples, 512);\n  const h = Math.ceil(numSamples / w);\n  const data = new Uint8Array(w * h * 4);\n  let off = 0;\n  for (let i = 0; i < numSamples; i += 4) {\n    packFloat32ToRGBA8(samples[i + 0] * 0.5 + 0.5, data, off + 0);\n    packFloat32ToRGBA8(samples[i + 1] * 0.5 + 0.5, data, off + 4);\n    packFloat32ToRGBA8(samples[i + 2] * 0.5 + 0.5, data, off + 8);\n    packFloat32ToRGBA8(samples[i + 3] / 8, data, off + 12);\n    off += 16;\n  }\n  return {\n    width: w,\n    height: h,\n    data: data\n  };\n};\nconst hemisphereSamplePhong = (dstVec, x, y, specularPower) => {\n  const phi = y * 2 * Math.PI;\n  const cosTheta = Math.pow(1 - x, 1 / (specularPower + 1));\n  const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n  dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();\n};\nconst hemisphereSampleLambert = (dstVec, x, y) => {\n  const phi = y * 2 * Math.PI;\n  const cosTheta = Math.sqrt(1 - x);\n  const sinTheta = Math.sqrt(x);\n  dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();\n};\nconst hemisphereSampleGGX = (dstVec, x, y, a) => {\n  const phi = y * 2 * Math.PI;\n  const cosTheta = Math.sqrt((1 - x) / (1 + (a * a - 1) * x));\n  const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n  dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();\n};\nconst D_GGX = (NoH, linearRoughness) => {\n  const a = NoH * linearRoughness;\n  const k = linearRoughness / (1.0 - NoH * NoH + a * a);\n  return k * k * (1 / Math.PI);\n};\nconst generatePhongSamples = (numSamples, specularPower) => {\n  const H = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n  const result = [];\n  for (let i = 0; i < numSamples; ++i) {\n    hemisphereSamplePhong(H, i / numSamples, _core_math_random_js__WEBPACK_IMPORTED_MODULE_2__.random.radicalInverse(i), specularPower);\n    result.push(H.x, H.y, H.z, 0);\n  }\n  return result;\n};\nconst generateLambertSamples = (numSamples, sourceTotalPixels) => {\n  const pixelsPerSample = sourceTotalPixels / numSamples;\n  const H = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n  const result = [];\n  for (let i = 0; i < numSamples; ++i) {\n    hemisphereSampleLambert(H, i / numSamples, _core_math_random_js__WEBPACK_IMPORTED_MODULE_2__.random.radicalInverse(i));\n    const pdf = H.z / Math.PI;\n    const mipLevel = 0.5 * Math.log2(pixelsPerSample / pdf);\n    result.push(H.x, H.y, H.z, mipLevel);\n  }\n  return result;\n};\nconst requiredSamplesGGX = {\n  \"16\": {\n    \"2\": 26,\n    \"8\": 20,\n    \"32\": 17,\n    \"128\": 16,\n    \"512\": 16\n  },\n  \"32\": {\n    \"2\": 53,\n    \"8\": 40,\n    \"32\": 34,\n    \"128\": 32,\n    \"512\": 32\n  },\n  \"128\": {\n    \"2\": 214,\n    \"8\": 163,\n    \"32\": 139,\n    \"128\": 130,\n    \"512\": 128\n  },\n  \"1024\": {\n    \"2\": 1722,\n    \"8\": 1310,\n    \"32\": 1114,\n    \"128\": 1041,\n    \"512\": 1025\n  }\n};\nconst getRequiredSamplesGGX = (numSamples, specularPower) => {\n  const table = requiredSamplesGGX[numSamples];\n  return table && table[specularPower] || numSamples;\n};\nconst generateGGXSamples = (numSamples, specularPower, sourceTotalPixels) => {\n  const pixelsPerSample = sourceTotalPixels / numSamples;\n  const roughness = 1 - Math.log2(specularPower) / 11.0;\n  const a = roughness * roughness;\n  const H = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n  const L = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n  const N = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3(0, 0, 1);\n  const result = [];\n  const requiredSamples = getRequiredSamplesGGX(numSamples, specularPower);\n  for (let i = 0; i < requiredSamples; ++i) {\n    hemisphereSampleGGX(H, i / requiredSamples, _core_math_random_js__WEBPACK_IMPORTED_MODULE_2__.random.radicalInverse(i), a);\n    const NoH = H.z;\n    L.set(H.x, H.y, H.z).mulScalar(2 * NoH).sub(N);\n    if (L.z > 0) {\n      const pdf = D_GGX(Math.min(1, NoH), a) / 4 + 0.001;\n      const mipLevel = 0.5 * Math.log2(pixelsPerSample / pdf);\n      result.push(L.x, L.y, L.z, mipLevel);\n    }\n  }\n  while (result.length < numSamples * 4) {\n    result.push(0, 0, 0, 0);\n  }\n  return result;\n};\nconst createSamplesTex = (device, name, samples) => {\n  const packedSamples = packSamples(samples);\n  return new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_3__.Texture(device, {\n    name: name,\n    width: packedSamples.width,\n    height: packedSamples.height,\n    mipmaps: false,\n    minFilter: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_NEAREST,\n    magFilter: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_NEAREST,\n    levels: [packedSamples.data]\n  });\n};\nclass SimpleCache {\n  constructor(destroyContent = true) {\n    this.map = new Map();\n    this.destroyContent = destroyContent;\n  }\n  destroy() {\n    if (this.destroyContent) {\n      this.map.forEach((value, key) => {\n        value.destroy();\n      });\n    }\n  }\n  get(key, missFunc) {\n    if (!this.map.has(key)) {\n      const result = missFunc();\n      this.map.set(key, result);\n      return result;\n    }\n    return this.map.get(key);\n  }\n}\nconst samplesCache = new SimpleCache(false);\nconst deviceCache = new _platform_graphics_device_cache_js__WEBPACK_IMPORTED_MODULE_4__.DeviceCache();\nconst getCachedTexture = (device, key, getSamplesFnc) => {\n  const cache = deviceCache.get(device, () => {\n    return new SimpleCache();\n  });\n  return cache.get(key, () => {\n    return createSamplesTex(device, key, samplesCache.get(key, getSamplesFnc));\n  });\n};\nconst generateLambertSamplesTex = (device, numSamples, sourceTotalPixels) => {\n  const key = `lambert-samples-${numSamples}-${sourceTotalPixels}`;\n  return getCachedTexture(device, key, () => {\n    return generateLambertSamples(numSamples, sourceTotalPixels);\n  });\n};\nconst generatePhongSamplesTex = (device, numSamples, specularPower) => {\n  const key = `phong-samples-${numSamples}-${specularPower}`;\n  return getCachedTexture(device, key, () => {\n    return generatePhongSamples(numSamples, specularPower);\n  });\n};\nconst generateGGXSamplesTex = (device, numSamples, specularPower, sourceTotalPixels) => {\n  const key = `ggx-samples-${numSamples}-${specularPower}-${sourceTotalPixels}`;\n  return getCachedTexture(device, key, () => {\n    return generateGGXSamples(numSamples, specularPower, sourceTotalPixels);\n  });\n};\nconst vsCode = `\nattribute vec2 vertex_position;\n\nuniform vec4 uvMod;\n\nvarying vec2 vUv0;\n\nvoid main(void) {\n    gl_Position = vec4(vertex_position, 0.5, 1.0);\n    vUv0 = (vertex_position.xy * 0.5 + 0.5) * uvMod.xy + uvMod.zw;\n}\n`;\nfunction reprojectTexture(source, target, options = {}) {\n  var _options;\n  if (source instanceof _platform_graphics_graphics_device_js__WEBPACK_IMPORTED_MODULE_5__.GraphicsDevice) {\n    source = arguments[1];\n    target = arguments[2];\n    options = {};\n    if (arguments[3] !== undefined) {\n      options.specularPower = arguments[3];\n    }\n    if (arguments[4] !== undefined) {\n      options.numSamples = arguments[4];\n    }\n  }\n  const funcNames = {\n    'none': 'reproject',\n    'lambert': 'prefilterSamplesUnweighted',\n    'phong': 'prefilterSamplesUnweighted',\n    'ggx': 'prefilterSamples'\n  };\n  const specularPower = options.hasOwnProperty('specularPower') ? options.specularPower : 1;\n  const face = options.hasOwnProperty('face') ? options.face : null;\n  const distribution = options.hasOwnProperty('distribution') ? options.distribution : specularPower === 1 ? 'none' : 'phong';\n  const processFunc = funcNames[distribution] || 'reproject';\n  const decodeFunc = _shader_lib_chunk_utils_js__WEBPACK_IMPORTED_MODULE_6__.ChunkUtils.decodeFunc(source.encoding);\n  const encodeFunc = _shader_lib_chunk_utils_js__WEBPACK_IMPORTED_MODULE_6__.ChunkUtils.encodeFunc(target.encoding);\n  const sourceFunc = `sample${getProjectionName(source.projection)}`;\n  const targetFunc = `getDirection${getProjectionName(target.projection)}`;\n  const numSamples = options.hasOwnProperty('numSamples') ? options.numSamples : 1024;\n  const shaderKey = `${processFunc}_${decodeFunc}_${encodeFunc}_${sourceFunc}_${targetFunc}_${numSamples}`;\n  const device = source.device;\n  let shader = (0,_shader_lib_get_program_library_js__WEBPACK_IMPORTED_MODULE_7__.getProgramLibrary)(device).getCachedShader(shaderKey);\n  if (!shader) {\n    const defines = `#define PROCESS_FUNC ${processFunc}\\n` + `#define DECODE_FUNC ${decodeFunc}\\n` + `#define ENCODE_FUNC ${encodeFunc}\\n` + `#define SOURCE_FUNC ${sourceFunc}\\n` + `#define TARGET_FUNC ${targetFunc}\\n` + `#define NUM_SAMPLES ${numSamples}\\n` + `#define NUM_SAMPLES_SQRT ${Math.round(Math.sqrt(numSamples)).toFixed(1)}\\n` + (device.extTextureLod ? `#define SUPPORTS_TEXLOD\\n` : '');\n    let extensions = '';\n    if (!device.webgl2) {\n      extensions = '#extension GL_OES_standard_derivatives: enable\\n';\n      if (device.extTextureLod) {\n        extensions += '#extension GL_EXT_shader_texture_lod: enable\\n\\n';\n      }\n    }\n    shader = (0,_shader_lib_utils_js__WEBPACK_IMPORTED_MODULE_8__.createShaderFromCode)(device, vsCode, `${defines}\\n${_shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_9__.shaderChunks.reprojectPS}`, shaderKey, false, extensions);\n  }\n  const constantSource = device.scope.resolve(source.cubemap ? \"sourceCube\" : \"sourceTex\");\n  constantSource.setValue(source);\n  const constantParams = device.scope.resolve(\"params\");\n  const constantParams2 = device.scope.resolve(\"params2\");\n  const uvModParam = device.scope.resolve(\"uvMod\");\n  if ((_options = options) != null && _options.seamPixels) {\n    const p = options.seamPixels;\n    const w = options.rect ? options.rect.z : target.width;\n    const h = options.rect ? options.rect.w : target.height;\n    const innerWidth = w - p * 2;\n    const innerHeight = h - p * 2;\n    uvModParam.setValue([(innerWidth + p * 2) / innerWidth, (innerHeight + p * 2) / innerHeight, -p / innerWidth, -p / innerHeight]);\n  } else {\n    uvModParam.setValue([1, 1, 0, 0]);\n  }\n  const params = [0, specularPower, source.fixCubemapSeams ? 1.0 / source.width : 0.0, target.fixCubemapSeams ? 1.0 / target.width : 0.0];\n  const params2 = [target.width * target.height * (target.cubemap ? 6 : 1), source.width * source.height * (source.cubemap ? 6 : 1)];\n  if (processFunc.startsWith('prefilterSamples')) {\n    const sourceTotalPixels = source.width * source.height * (source.cubemap ? 6 : 1);\n    const samplesTex = distribution === 'ggx' ? generateGGXSamplesTex(device, numSamples, specularPower, sourceTotalPixels) : distribution === 'lambert' ? generateLambertSamplesTex(device, numSamples, sourceTotalPixels) : generatePhongSamplesTex(device, numSamples, specularPower);\n    device.scope.resolve(\"samplesTex\").setValue(samplesTex);\n    device.scope.resolve(\"samplesTexInverseSize\").setValue([1.0 / samplesTex.width, 1.0 / samplesTex.height]);\n  }\n  for (let f = 0; f < (target.cubemap ? 6 : 1); f++) {\n    if (face === null || f === face) {\n      var _options2;\n      const renderTarget = new _platform_graphics_render_target_js__WEBPACK_IMPORTED_MODULE_10__.RenderTarget({\n        colorBuffer: target,\n        face: f,\n        depth: false\n      });\n      params[0] = f;\n      constantParams.setValue(params);\n      constantParams2.setValue(params2);\n      (0,_platform_graphics_simple_post_effect_js__WEBPACK_IMPORTED_MODULE_11__.drawQuadWithShader)(device, renderTarget, shader, (_options2 = options) == null ? void 0 : _options2.rect);\n      renderTarget.destroy();\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/graphics/reproject-texture.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/graphics/scene-grab.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/graphics/scene-grab.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SceneGrab\": () => (/* binding */ SceneGrab)\n/* harmony export */ });\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_render_target_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../platform/graphics/render-target.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/render-target.js\");\n/* harmony import */ var _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../platform/graphics/texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _layer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../layer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/layer.js\");\n\n\n\n\n\n\n\nconst _depthUniformNames = ['uSceneDepthMap', 'uDepthMap'];\nconst _colorUniformNames = ['uSceneColorMap', 'texture_grabPass'];\nclass SceneGrab {\n  constructor(device, scene) {\n    this.scene = scene;\n    this.device = device;\n    this.layer = null;\n    if (this.device.webgl2 || this.device.deviceType === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.DEVICETYPE_WEBGPU) {\n      this.initMainPath();\n    } else {\n      this.initFallbackPath();\n    }\n  }\n  static requiresRenderPass(device, camera) {\n    if (device.webgl2 || device.deviceType === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.DEVICETYPE_WEBGPU) {\n      return false;\n    }\n    return camera.renderSceneDepthMap;\n  }\n  setupUniform(device, depth, buffer) {\n    const names = depth ? _depthUniformNames : _colorUniformNames;\n    names.forEach(name => device.scope.resolve(name).setValue(buffer));\n  }\n  allocateTexture(device, source, name, format, isDepth, mipmaps) {\n    return new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture(device, {\n      name,\n      format,\n      width: source ? source.colorBuffer.width : device.width,\n      height: source ? source.colorBuffer.height : device.height,\n      mipmaps,\n      minFilter: isDepth ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_NEAREST : mipmaps ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_LINEAR_MIPMAP_LINEAR : _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_LINEAR,\n      magFilter: isDepth ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_NEAREST : _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_LINEAR,\n      addressU: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_CLAMP_TO_EDGE,\n      addressV: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_CLAMP_TO_EDGE\n    });\n  }\n  getSourceColorFormat(texture) {\n    var _texture$format;\n    return (_texture$format = texture == null ? void 0 : texture.format) != null ? _texture$format : this.device.framebufferFormat;\n  }\n  shouldReallocate(targetRT, sourceTexture, testFormat) {\n    if (testFormat) {\n      const targetFormat = targetRT == null ? void 0 : targetRT.colorBuffer.format;\n      const sourceFormat = this.getSourceColorFormat(sourceTexture);\n      if (targetFormat !== sourceFormat) return true;\n    }\n    const width = (sourceTexture == null ? void 0 : sourceTexture.width) || this.device.width;\n    const height = (sourceTexture == null ? void 0 : sourceTexture.height) || this.device.height;\n    return !targetRT || width !== targetRT.width || height !== targetRT.height;\n  }\n  allocateRenderTarget(renderTarget, sourceRenderTarget, device, format, isDepth, mipmaps, isDepthUniforms) {\n    const names = isDepthUniforms ? _depthUniformNames : _colorUniformNames;\n    const buffer = this.allocateTexture(device, sourceRenderTarget, names[0], format, isDepth, mipmaps);\n    if (renderTarget) {\n      renderTarget.destroyFrameBuffers();\n      if (isDepth) {\n        renderTarget._depthBuffer = buffer;\n      } else {\n        renderTarget._colorBuffer = buffer;\n      }\n    } else {\n      renderTarget = new _platform_graphics_render_target_js__WEBPACK_IMPORTED_MODULE_2__.RenderTarget({\n        name: 'renderTargetSceneGrab',\n        colorBuffer: isDepth ? null : buffer,\n        depthBuffer: isDepth ? buffer : null,\n        depth: !isDepth,\n        stencil: device.supportsStencil,\n        autoResolve: false\n      });\n    }\n    return renderTarget;\n  }\n  releaseRenderTarget(rt) {\n    if (rt) {\n      rt.destroyTextureBuffers();\n      rt.destroy();\n    }\n  }\n  initMainPath() {\n    const device = this.device;\n    const self = this;\n    this.layer = new _layer_js__WEBPACK_IMPORTED_MODULE_3__.Layer({\n      enabled: false,\n      name: \"Depth\",\n      id: _constants_js__WEBPACK_IMPORTED_MODULE_4__.LAYERID_DEPTH,\n      onDisable: function () {\n        self.releaseRenderTarget(this.depthRenderTarget);\n        this.depthRenderTarget = null;\n        self.releaseRenderTarget(this.colorRenderTarget);\n        this.colorRenderTarget = null;\n      },\n      onPreRenderOpaque: function (cameraPass) {\n        const camera = this.cameras[cameraPass];\n        if (camera.renderSceneColorMap) {\n          var _camera$renderTarget;\n          if (self.shouldReallocate(this.colorRenderTarget, (_camera$renderTarget = camera.renderTarget) == null ? void 0 : _camera$renderTarget.colorBuffer, true)) {\n            var _camera$renderTarget2;\n            self.releaseRenderTarget(this.colorRenderTarget);\n            const format = self.getSourceColorFormat((_camera$renderTarget2 = camera.renderTarget) == null ? void 0 : _camera$renderTarget2.colorBuffer);\n            this.colorRenderTarget = self.allocateRenderTarget(this.colorRenderTarget, camera.renderTarget, device, format, false, true, false);\n          }\n          const colorBuffer = this.colorRenderTarget.colorBuffer;\n          if (device.deviceType === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.DEVICETYPE_WEBGPU) {\n            device.copyRenderTarget(camera.renderTarget, this.colorRenderTarget, true, false);\n          } else {\n            device.copyRenderTarget(device.renderTarget, this.colorRenderTarget, true, false);\n            device.activeTexture(device.maxCombinedTextures - 1);\n            device.bindTexture(colorBuffer);\n            device.gl.generateMipmap(colorBuffer.impl._glTarget);\n          }\n          self.setupUniform(device, false, colorBuffer);\n        }\n        if (camera.renderSceneDepthMap) {\n          var _camera$renderTarget3;\n          if (self.shouldReallocate(this.depthRenderTarget, (_camera$renderTarget3 = camera.renderTarget) == null ? void 0 : _camera$renderTarget3.depthBuffer)) {\n            self.releaseRenderTarget(this.depthRenderTarget);\n            this.depthRenderTarget = self.allocateRenderTarget(this.depthRenderTarget, camera.renderTarget, device, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_DEPTHSTENCIL, true, false, true);\n          }\n          device.copyRenderTarget(device.renderTarget, this.depthRenderTarget, false, true);\n          self.setupUniform(device, true, this.depthRenderTarget.depthBuffer);\n        }\n      },\n      onPostRenderOpaque: function (cameraPass) {}\n    });\n  }\n  initFallbackPath() {\n    const self = this;\n    const device = this.device;\n    const scene = this.scene;\n    this.layer = new _layer_js__WEBPACK_IMPORTED_MODULE_3__.Layer({\n      enabled: false,\n      name: \"Depth\",\n      id: _constants_js__WEBPACK_IMPORTED_MODULE_4__.LAYERID_DEPTH,\n      shaderPass: _constants_js__WEBPACK_IMPORTED_MODULE_4__.SHADER_DEPTH,\n      onEnable: function () {\n        this.depthRenderTarget = new _platform_graphics_render_target_js__WEBPACK_IMPORTED_MODULE_2__.RenderTarget({\n          name: 'depthRenderTarget-webgl1',\n          depth: true,\n          stencil: device.supportsStencil,\n          autoResolve: false,\n          graphicsDevice: device\n        });\n        this.renderTarget = this.depthRenderTarget;\n      },\n      onDisable: function () {\n        this.depthRenderTarget.destroyTextureBuffers();\n        this.renderTarget = null;\n        self.releaseRenderTarget(this.colorRenderTarget);\n        this.colorRenderTarget = null;\n      },\n      onPostCull: function (cameraPass) {\n        const camera = this.cameras[cameraPass];\n        if (camera.renderSceneDepthMap) {\n          var _camera$renderTarget4;\n          if (!this.depthRenderTarget.depthBuffer || self.shouldReallocate(this.depthRenderTarget, (_camera$renderTarget4 = camera.renderTarget) == null ? void 0 : _camera$renderTarget4.depthBuffer)) {\n            this.depthRenderTarget.destroyTextureBuffers();\n            this.depthRenderTarget = self.allocateRenderTarget(this.depthRenderTarget, camera.renderTarget, device, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA8, false, false, true);\n          }\n          const visibleObjects = this.instances.visibleOpaque[cameraPass];\n          const visibleList = visibleObjects.list;\n          const layerComposition = scene.layers;\n          const subLayerEnabled = layerComposition.subLayerEnabled;\n          const isTransparent = layerComposition.subLayerList;\n          const rt = layerComposition.getLayerById(_constants_js__WEBPACK_IMPORTED_MODULE_4__.LAYERID_WORLD).renderTarget;\n          let visibleLength = 0;\n          const layers = layerComposition.layerList;\n          for (let i = 0; i < layers.length; i++) {\n            const layer = layers[i];\n            if (layer === this) break;\n            if (layer.renderTarget !== rt || !layer.enabled || !subLayerEnabled[i]) continue;\n            const layerCamId = layer.cameras.indexOf(camera);\n            if (layerCamId < 0) continue;\n            const transparent = isTransparent[i];\n            let layerVisibleList = transparent ? layer.instances.visibleTransparent[layerCamId] : layer.instances.visibleOpaque[layerCamId];\n            const layerVisibleListLength = layerVisibleList.length;\n            layerVisibleList = layerVisibleList.list;\n            for (let j = 0; j < layerVisibleListLength; j++) {\n              const drawCall = layerVisibleList[j];\n              if (drawCall.material && drawCall.material.depthWrite && !drawCall._noDepthDrawGl1) {\n                visibleList[visibleLength] = drawCall;\n                visibleLength++;\n              }\n            }\n          }\n          visibleObjects.length = visibleLength;\n        }\n      },\n      onPreRenderOpaque: function (cameraPass) {\n        const camera = this.cameras[cameraPass];\n        if (camera.renderSceneColorMap) {\n          var _camera$renderTarget5;\n          if (self.shouldReallocate(this.colorRenderTarget, (_camera$renderTarget5 = camera.renderTarget) == null ? void 0 : _camera$renderTarget5.colorBuffer)) {\n            var _camera$renderTarget6;\n            self.releaseRenderTarget(this.colorRenderTarget);\n            const format = self.getSourceColorFormat((_camera$renderTarget6 = camera.renderTarget) == null ? void 0 : _camera$renderTarget6.colorBuffer);\n            this.colorRenderTarget = self.allocateRenderTarget(this.colorRenderTarget, camera.renderTarget, device, format, false, false, false);\n          }\n          const colorBuffer = this.colorRenderTarget._colorBuffer;\n          if (!colorBuffer.impl._glTexture) {\n            colorBuffer.impl.initialize(device, colorBuffer);\n          }\n          device.bindTexture(colorBuffer);\n          const gl = device.gl;\n          gl.copyTexImage2D(gl.TEXTURE_2D, 0, colorBuffer.impl._glFormat, 0, 0, colorBuffer.width, colorBuffer.height, 0);\n          colorBuffer._needsUpload = false;\n          colorBuffer._needsMipmapsUpload = false;\n          self.setupUniform(device, false, colorBuffer);\n        }\n        if (camera.renderSceneDepthMap) {\n          self.setupUniform(device, true, this.depthRenderTarget.colorBuffer);\n        }\n      },\n      onDrawCall: function () {\n        device.setColorWrite(true, true, true, true);\n      },\n      onPostRenderOpaque: function (cameraPass) {\n        const camera = this.cameras[cameraPass];\n        if (camera.renderSceneDepthMap) {\n          const visibleObjects = this.instances.visibleOpaque[cameraPass];\n          visibleObjects.length = 0;\n        }\n      }\n    });\n  }\n  patch(layer) {\n    layer.onEnable = this.layer.onEnable;\n    layer.onDisable = this.layer.onDisable;\n    layer.onPreRenderOpaque = this.layer.onPreRenderOpaque;\n    layer.onPostRenderOpaque = this.layer.onPostRenderOpaque;\n    layer.shaderPass = this.layer.shaderPass;\n    layer.onPostCull = this.layer.onPostCull;\n    layer.onDrawCall = this.layer.onDrawCall;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/graphics/scene-grab.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/immediate/immediate-batch.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/immediate/immediate-batch.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ImmediateBatch\": () => (/* binding */ ImmediateBatch)\n/* harmony export */ });\n/* harmony import */ var _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/math/mat4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _mesh_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mesh.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh.js\");\n/* harmony import */ var _mesh_instance_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../mesh-instance.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh-instance.js\");\n/* harmony import */ var _graph_node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../graph-node.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/graph-node.js\");\n\n\n\n\n\n\nconst identityGraphNode = new _graph_node_js__WEBPACK_IMPORTED_MODULE_0__.GraphNode();\nidentityGraphNode.worldTransform = _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_1__.Mat4.IDENTITY;\nidentityGraphNode._dirtyWorld = identityGraphNode._dirtyNormal = false;\nclass ImmediateBatch {\n  constructor(device, material, layer) {\n    this.material = material;\n    this.layer = layer;\n    this.positions = [];\n    this.colors = [];\n    this.mesh = new _mesh_js__WEBPACK_IMPORTED_MODULE_2__.Mesh(device);\n    this.meshInstance = null;\n  }\n  addLines(positions, color) {\n    const destPos = this.positions;\n    const count = positions.length;\n    for (let i = 0; i < count; i++) {\n      const pos = positions[i];\n      destPos.push(pos.x, pos.y, pos.z);\n    }\n    const destCol = this.colors;\n    if (color.length) {\n      for (let i = 0; i < count; i++) {\n        const col = color[i];\n        destCol.push(col.r, col.g, col.b, col.a);\n      }\n    } else {\n      for (let i = 0; i < count; i++) {\n        destCol.push(color.r, color.g, color.b, color.a);\n      }\n    }\n  }\n  addLinesArrays(positions, color) {\n    const destPos = this.positions;\n    for (let i = 0; i < positions.length; i += 3) {\n      destPos.push(positions[i], positions[i + 1], positions[i + 2]);\n    }\n    const destCol = this.colors;\n    if (color.length) {\n      for (let i = 0; i < color.length; i += 4) {\n        destCol.push(color[i], color[i + 1], color[i + 2], color[i + 3]);\n      }\n    } else {\n      const count = positions.length / 3;\n      for (let i = 0; i < count; i++) {\n        destCol.push(color.r, color.g, color.b, color.a);\n      }\n    }\n  }\n  onPreRender(visibleList, transparent) {\n    if (this.positions.length > 0 && this.material.transparent === transparent) {\n      this.mesh.setPositions(this.positions);\n      this.mesh.setColors(this.colors);\n      this.mesh.update(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.PRIMITIVE_LINES, false);\n      if (!this.meshInstance) {\n        this.meshInstance = new _mesh_instance_js__WEBPACK_IMPORTED_MODULE_4__.MeshInstance(this.mesh, this.material, identityGraphNode);\n      }\n      this.positions.length = 0;\n      this.colors.length = 0;\n      visibleList.list.push(this.meshInstance);\n      visibleList.length++;\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/immediate/immediate-batch.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/immediate/immediate-batches.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/immediate/immediate-batches.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ImmediateBatches\": () => (/* binding */ ImmediateBatches)\n/* harmony export */ });\n/* harmony import */ var _immediate_batch_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./immediate-batch.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/immediate/immediate-batch.js\");\n\n\nclass ImmediateBatches {\n  constructor(device) {\n    this.device = device;\n    this.map = new Map();\n  }\n  getBatch(material, layer) {\n    let batch = this.map.get(material);\n    if (!batch) {\n      batch = new _immediate_batch_js__WEBPACK_IMPORTED_MODULE_0__.ImmediateBatch(this.device, material, layer);\n      this.map.set(material, batch);\n    }\n    return batch;\n  }\n  onPreRender(visibleList, transparent) {\n    this.map.forEach(batch => {\n      batch.onPreRender(visibleList, transparent);\n    });\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/immediate/immediate-batches.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/immediate/immediate.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/immediate/immediate.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Immediate\": () => (/* binding */ Immediate)\n/* harmony export */ });\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _graph_node_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../graph-node.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/graph-node.js\");\n/* harmony import */ var _mesh_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../mesh.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh.js\");\n/* harmony import */ var _mesh_instance_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../mesh-instance.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh-instance.js\");\n/* harmony import */ var _materials_basic_material_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../materials/basic-material.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/basic-material.js\");\n/* harmony import */ var _shader_lib_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shader-lib/utils.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/utils.js\");\n/* harmony import */ var _shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shader-lib/chunks/chunks.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/chunks.js\");\n/* harmony import */ var _immediate_batches_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./immediate-batches.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/immediate/immediate-batches.js\");\n\n\n\n\n\n\n\n\n\n\nconst tempPoints = [];\nclass Immediate {\n  constructor(device) {\n    this.device = device;\n    this.quadMesh = null;\n    this.textureShader = null;\n    this.depthTextureShader = null;\n    this.cubeLocalPos = null;\n    this.cubeWorldPos = null;\n    this.batchesMap = new Map();\n    this.allBatches = new Set();\n    this.updatedLayers = new Set();\n    this._materialDepth = null;\n    this._materialNoDepth = null;\n    this.layerMeshInstances = new Map();\n  }\n  createMaterial(depthTest) {\n    const material = new _materials_basic_material_js__WEBPACK_IMPORTED_MODULE_0__.BasicMaterial();\n    material.vertexColors = true;\n    material.blend = true;\n    material.blendType = _constants_js__WEBPACK_IMPORTED_MODULE_1__.BLEND_NORMAL;\n    material.depthTest = depthTest;\n    material.update();\n    return material;\n  }\n  get materialDepth() {\n    if (!this._materialDepth) {\n      this._materialDepth = this.createMaterial(true);\n    }\n    return this._materialDepth;\n  }\n  get materialNoDepth() {\n    if (!this._materialNoDepth) {\n      this._materialNoDepth = this.createMaterial(false);\n    }\n    return this._materialNoDepth;\n  }\n  getBatch(layer, depthTest) {\n    let batches = this.batchesMap.get(layer);\n    if (!batches) {\n      batches = new _immediate_batches_js__WEBPACK_IMPORTED_MODULE_2__.ImmediateBatches(this.device);\n      this.batchesMap.set(layer, batches);\n    }\n    this.allBatches.add(batches);\n    const material = depthTest ? this.materialDepth : this.materialNoDepth;\n    return batches.getBatch(material, layer);\n  }\n  static getTextureVS() {\n    return `\n            attribute vec2 vertex_position;\n            uniform mat4 matrix_model;\n            varying vec2 uv0;\n            void main(void) {\n                gl_Position = matrix_model * vec4(vertex_position, 0, 1);\n                uv0 = vertex_position.xy + 0.5;\n            }\n        `;\n  }\n  getTextureShader() {\n    if (!this.textureShader) {\n      const fshader = `\n                varying vec2 uv0;\n                uniform sampler2D colorMap;\n                void main (void) {\n                    gl_FragColor = vec4(texture2D(colorMap, uv0).xyz, 1);\n                }\n            `;\n      this.textureShader = (0,_shader_lib_utils_js__WEBPACK_IMPORTED_MODULE_3__.createShaderFromCode)(this.device, Immediate.getTextureVS(), fshader, 'DebugTextureShader');\n    }\n    return this.textureShader;\n  }\n  getDepthTextureShader() {\n    if (!this.depthTextureShader) {\n      const fshader = `\n                ${_shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_4__.shaderChunks.screenDepthPS}\n                varying vec2 uv0;\n                void main() {\n                    float depth = getLinearScreenDepth(uv0) * camera_params.x;\n                    gl_FragColor = vec4(vec3(depth), 1.0);\n                }\n            `;\n      this.depthTextureShader = (0,_shader_lib_utils_js__WEBPACK_IMPORTED_MODULE_3__.createShaderFromCode)(this.device, Immediate.getTextureVS(), fshader, 'DebugDepthTextureShader');\n    }\n    return this.depthTextureShader;\n  }\n  getQuadMesh() {\n    if (!this.quadMesh) {\n      this.quadMesh = new _mesh_js__WEBPACK_IMPORTED_MODULE_5__.Mesh(this.device);\n      this.quadMesh.setPositions([-0.5, -0.5, 0, 0.5, -0.5, 0, -0.5, 0.5, 0, 0.5, 0.5, 0]);\n      this.quadMesh.update(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_6__.PRIMITIVE_TRISTRIP);\n    }\n    return this.quadMesh;\n  }\n  drawMesh(material, matrix, mesh, meshInstance, layer) {\n    if (!meshInstance) {\n      const graphNode = this.getGraphNode(matrix);\n      meshInstance = new _mesh_instance_js__WEBPACK_IMPORTED_MODULE_7__.MeshInstance(mesh, material, graphNode);\n    }\n    let layerMeshInstances = this.layerMeshInstances.get(layer);\n    if (!layerMeshInstances) {\n      layerMeshInstances = [];\n      this.layerMeshInstances.set(layer, layerMeshInstances);\n    }\n    layerMeshInstances.push(meshInstance);\n  }\n  drawWireAlignedBox(min, max, color, depthTest, layer) {\n    tempPoints.push(min.x, min.y, min.z, min.x, max.y, min.z, min.x, max.y, min.z, max.x, max.y, min.z, max.x, max.y, min.z, max.x, min.y, min.z, max.x, min.y, min.z, min.x, min.y, min.z, min.x, min.y, max.z, min.x, max.y, max.z, min.x, max.y, max.z, max.x, max.y, max.z, max.x, max.y, max.z, max.x, min.y, max.z, max.x, min.y, max.z, min.x, min.y, max.z, min.x, min.y, min.z, min.x, min.y, max.z, min.x, max.y, min.z, min.x, max.y, max.z, max.x, max.y, min.z, max.x, max.y, max.z, max.x, min.y, min.z, max.x, min.y, max.z);\n    const batch = this.getBatch(layer, depthTest);\n    batch.addLinesArrays(tempPoints, color);\n    tempPoints.length = 0;\n  }\n  drawWireSphere(center, radius, color, numSegments, depthTest, layer) {\n    const step = 2 * Math.PI / numSegments;\n    let angle = 0;\n    for (let i = 0; i < numSegments; i++) {\n      const sin0 = Math.sin(angle);\n      const cos0 = Math.cos(angle);\n      angle += step;\n      const sin1 = Math.sin(angle);\n      const cos1 = Math.cos(angle);\n      tempPoints.push(center.x + radius * sin0, center.y, center.z + radius * cos0);\n      tempPoints.push(center.x + radius * sin1, center.y, center.z + radius * cos1);\n      tempPoints.push(center.x + radius * sin0, center.y + radius * cos0, center.z);\n      tempPoints.push(center.x + radius * sin1, center.y + radius * cos1, center.z);\n      tempPoints.push(center.x, center.y + radius * sin0, center.z + radius * cos0);\n      tempPoints.push(center.x, center.y + radius * sin1, center.z + radius * cos1);\n    }\n    const batch = this.getBatch(layer, depthTest);\n    batch.addLinesArrays(tempPoints, color);\n    tempPoints.length = 0;\n  }\n  getGraphNode(matrix) {\n    const graphNode = new _graph_node_js__WEBPACK_IMPORTED_MODULE_8__.GraphNode('ImmediateDebug');\n    graphNode.worldTransform = matrix;\n    graphNode._dirtyWorld = graphNode._dirtyNormal = false;\n    return graphNode;\n  }\n  onPreRenderLayer(layer, visibleList, transparent) {\n    this.batchesMap.forEach((batches, batchLayer) => {\n      if (batchLayer === layer) {\n        batches.onPreRender(visibleList, transparent);\n      }\n    });\n    if (!this.updatedLayers.has(layer)) {\n      this.updatedLayers.add(layer);\n      const meshInstances = this.layerMeshInstances.get(layer);\n      if (meshInstances) {\n        for (let i = 0; i < meshInstances.length; i++) {\n          visibleList.list[visibleList.length + i] = meshInstances[i];\n        }\n        visibleList.length += meshInstances.length;\n        meshInstances.length = 0;\n      }\n    }\n  }\n  onPostRender() {\n    this.allBatches.clear();\n    this.updatedLayers.clear();\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/immediate/immediate.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/layer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/layer.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Layer\": () => (/* binding */ Layer)\n/* harmony export */ });\n/* harmony import */ var _core_hash_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/hash.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/hash.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _materials_material_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./materials/material.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/material.js\");\n\n\n\n\n\nlet keyA, keyB, sortPos, sortDir;\nfunction sortManual(drawCallA, drawCallB) {\n  return drawCallA.drawOrder - drawCallB.drawOrder;\n}\nfunction sortMaterialMesh(drawCallA, drawCallB) {\n  keyA = drawCallA._key[_constants_js__WEBPACK_IMPORTED_MODULE_0__.SORTKEY_FORWARD];\n  keyB = drawCallB._key[_constants_js__WEBPACK_IMPORTED_MODULE_0__.SORTKEY_FORWARD];\n  if (keyA === keyB && drawCallA.mesh && drawCallB.mesh) {\n    return drawCallB.mesh.id - drawCallA.mesh.id;\n  }\n  return keyB - keyA;\n}\nfunction sortBackToFront(drawCallA, drawCallB) {\n  return drawCallB.zdist - drawCallA.zdist;\n}\nfunction sortFrontToBack(drawCallA, drawCallB) {\n  return drawCallA.zdist - drawCallB.zdist;\n}\nconst sortCallbacks = [null, sortManual, sortMaterialMesh, sortBackToFront, sortFrontToBack];\nfunction sortLights(lightA, lightB) {\n  return lightB.key - lightA.key;\n}\nlet layerCounter = 0;\nclass VisibleInstanceList {\n  constructor() {\n    this.list = [];\n    this.length = 0;\n    this.done = false;\n  }\n}\nclass InstanceList {\n  constructor() {\n    this.opaqueMeshInstances = [];\n    this.transparentMeshInstances = [];\n    this.shadowCasters = [];\n    this.visibleOpaque = [];\n    this.visibleTransparent = [];\n  }\n  prepare(index) {\n    if (!this.visibleOpaque[index]) {\n      this.visibleOpaque[index] = new VisibleInstanceList();\n    }\n    if (!this.visibleTransparent[index]) {\n      this.visibleTransparent[index] = new VisibleInstanceList();\n    }\n    this.visibleOpaque[index].done = false;\n    this.visibleTransparent[index].done = false;\n  }\n  delete(index) {\n    if (index < this.visibleOpaque.length) {\n      this.visibleOpaque.splice(index, 1);\n    }\n    if (index < this.visibleTransparent.length) {\n      this.visibleTransparent.splice(index, 1);\n    }\n  }\n}\nclass Layer {\n  constructor(options = {}) {\n    if (options.id !== undefined) {\n      this.id = options.id;\n      layerCounter = Math.max(this.id + 1, layerCounter);\n    } else {\n      this.id = layerCounter++;\n    }\n    this.name = options.name;\n    this._enabled = options.enabled === undefined ? true : options.enabled;\n    this._refCounter = this._enabled ? 1 : 0;\n    this.opaqueSortMode = options.opaqueSortMode === undefined ? _constants_js__WEBPACK_IMPORTED_MODULE_0__.SORTMODE_MATERIALMESH : options.opaqueSortMode;\n    this.transparentSortMode = options.transparentSortMode === undefined ? _constants_js__WEBPACK_IMPORTED_MODULE_0__.SORTMODE_BACK2FRONT : options.transparentSortMode;\n    if (options.renderTarget) {\n      this.renderTarget = options.renderTarget;\n    }\n    this.shaderPass = options.shaderPass === undefined ? _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADER_FORWARD : options.shaderPass;\n    this.passThrough = options.passThrough === undefined ? false : options.passThrough;\n    this._clearColorBuffer = !!options.clearColorBuffer;\n    this._clearDepthBuffer = !!options.clearDepthBuffer;\n    this._clearStencilBuffer = !!options.clearStencilBuffer;\n    this.onPreCull = options.onPreCull;\n    this.onPreRender = options.onPreRender;\n    this.onPreRenderOpaque = options.onPreRenderOpaque;\n    this.onPreRenderTransparent = options.onPreRenderTransparent;\n    this.onPostCull = options.onPostCull;\n    this.onPostRender = options.onPostRender;\n    this.onPostRenderOpaque = options.onPostRenderOpaque;\n    this.onPostRenderTransparent = options.onPostRenderTransparent;\n    this.onDrawCall = options.onDrawCall;\n    this.onEnable = options.onEnable;\n    this.onDisable = options.onDisable;\n    if (this._enabled && this.onEnable) {\n      this.onEnable();\n    }\n    this.layerReference = options.layerReference;\n    this.instances = options.layerReference ? options.layerReference.instances : new InstanceList();\n    this.cullingMask = options.cullingMask ? options.cullingMask : 0xFFFFFFFF;\n    this.opaqueMeshInstances = this.instances.opaqueMeshInstances;\n    this.transparentMeshInstances = this.instances.transparentMeshInstances;\n    this.shadowCasters = this.instances.shadowCasters;\n    this.customSortCallback = null;\n    this.customCalculateSortValues = null;\n    this._lights = [];\n    this._lightsSet = new Set();\n    this._clusteredLightsSet = new Set();\n    this._splitLights = [[], [], []];\n    this.cameras = [];\n    this._dirty = false;\n    this._dirtyLights = false;\n    this._dirtyCameras = false;\n    this._lightHash = 0;\n    this._staticLightHash = 0;\n    this._needsStaticPrepare = true;\n    this._staticPrepareDone = false;\n    this._shaderVersion = -1;\n    this._lightCube = null;\n  }\n  get hasClusteredLights() {\n    return this._clusteredLightsSet.size > 0;\n  }\n  set renderTarget(rt) {\n    this._renderTarget = rt;\n    this._dirtyCameras = true;\n  }\n  get renderTarget() {\n    return this._renderTarget;\n  }\n  set enabled(val) {\n    if (val !== this._enabled) {\n      this._enabled = val;\n      if (val) {\n        this.incrementCounter();\n        if (this.onEnable) this.onEnable();\n      } else {\n        this.decrementCounter();\n        if (this.onDisable) this.onDisable();\n      }\n    }\n  }\n  get enabled() {\n    return this._enabled;\n  }\n  set clearColorBuffer(val) {\n    this._clearColorBuffer = val;\n    this._dirtyCameras = true;\n  }\n  get clearColorBuffer() {\n    return this._clearColorBuffer;\n  }\n  set clearDepthBuffer(val) {\n    this._clearDepthBuffer = val;\n    this._dirtyCameras = true;\n  }\n  get clearDepthBuffer() {\n    return this._clearDepthBuffer;\n  }\n  set clearStencilBuffer(val) {\n    this._clearStencilBuffer = val;\n    this._dirtyCameras = true;\n  }\n  get clearStencilBuffer() {\n    return this._clearStencilBuffer;\n  }\n  get clusteredLightsSet() {\n    return this._clusteredLightsSet;\n  }\n  incrementCounter() {\n    if (this._refCounter === 0) {\n      this._enabled = true;\n      if (this.onEnable) this.onEnable();\n    }\n    this._refCounter++;\n  }\n  decrementCounter() {\n    if (this._refCounter === 1) {\n      this._enabled = false;\n      if (this.onDisable) this.onDisable();\n    } else if (this._refCounter === 0) {\n      return;\n    }\n    this._refCounter--;\n  }\n  addMeshInstances(meshInstances, skipShadowCasters) {\n    const sceneShaderVer = this._shaderVersion;\n    const casters = this.shadowCasters;\n    for (let i = 0; i < meshInstances.length; i++) {\n      const m = meshInstances[i];\n      const mat = m.material;\n      const arr = mat.blendType === _constants_js__WEBPACK_IMPORTED_MODULE_0__.BLEND_NONE ? this.opaqueMeshInstances : this.transparentMeshInstances;\n      if (this.opaqueMeshInstances.indexOf(m) < 0 && this.transparentMeshInstances.indexOf(m) < 0) {\n        arr.push(m);\n      }\n      if (!skipShadowCasters && m.castShadow && casters.indexOf(m) < 0) casters.push(m);\n      if (!this.passThrough && sceneShaderVer >= 0 && mat._shaderVersion !== sceneShaderVer) {\n        if (mat.getShaderVariant !== _materials_material_js__WEBPACK_IMPORTED_MODULE_1__.Material.prototype.getShaderVariant) {\n          mat.clearVariants();\n        }\n        mat._shaderVersion = sceneShaderVer;\n      }\n    }\n    if (!this.passThrough) this._dirty = true;\n  }\n  removeMeshInstanceFromArray(m, arr) {\n    let spliceOffset = -1;\n    let spliceCount = 0;\n    const len = arr.length;\n    for (let j = 0; j < len; j++) {\n      const drawCall = arr[j];\n      if (drawCall === m) {\n        spliceOffset = j;\n        spliceCount = 1;\n        break;\n      }\n      if (drawCall._staticSource === m) {\n        if (spliceOffset < 0) spliceOffset = j;\n        spliceCount++;\n      } else if (spliceOffset >= 0) {\n        break;\n      }\n    }\n    if (spliceOffset >= 0) {\n      arr.splice(spliceOffset, spliceCount);\n    }\n  }\n  removeMeshInstances(meshInstances, skipShadowCasters) {\n    const opaque = this.opaqueMeshInstances;\n    const transparent = this.transparentMeshInstances;\n    const casters = this.shadowCasters;\n    for (let i = 0; i < meshInstances.length; i++) {\n      const m = meshInstances[i];\n      this.removeMeshInstanceFromArray(m, opaque);\n      this.removeMeshInstanceFromArray(m, transparent);\n      if (!skipShadowCasters) {\n        const j = casters.indexOf(m);\n        if (j >= 0) casters.splice(j, 1);\n      }\n    }\n    this._dirty = true;\n  }\n  clearMeshInstances(skipShadowCasters) {\n    if (this.opaqueMeshInstances.length === 0 && this.transparentMeshInstances.length === 0) {\n      if (skipShadowCasters || this.shadowCasters.length === 0) return;\n    }\n    this.opaqueMeshInstances.length = 0;\n    this.transparentMeshInstances.length = 0;\n    if (!skipShadowCasters) this.shadowCasters.length = 0;\n    if (!this.passThrough) this._dirty = true;\n  }\n  addLight(light) {\n    const l = light.light;\n    if (!this._lightsSet.has(l)) {\n      this._lightsSet.add(l);\n      this._lights.push(l);\n      this._dirtyLights = true;\n      this._generateLightHash();\n    }\n    if (l.type !== _constants_js__WEBPACK_IMPORTED_MODULE_0__.LIGHTTYPE_DIRECTIONAL) {\n      this._clusteredLightsSet.add(l);\n    }\n  }\n  removeLight(light) {\n    const l = light.light;\n    if (this._lightsSet.has(l)) {\n      this._lightsSet.delete(l);\n      this._lights.splice(this._lights.indexOf(l), 1);\n      this._dirtyLights = true;\n      this._generateLightHash();\n    }\n    if (l.type !== _constants_js__WEBPACK_IMPORTED_MODULE_0__.LIGHTTYPE_DIRECTIONAL) {\n      this._clusteredLightsSet.delete(l);\n    }\n  }\n  clearLights() {\n    this._lightsSet.clear();\n    this._clusteredLightsSet.clear();\n    this._lights.length = 0;\n    this._dirtyLights = true;\n  }\n  addShadowCasters(meshInstances) {\n    const arr = this.shadowCasters;\n    for (let i = 0; i < meshInstances.length; i++) {\n      const m = meshInstances[i];\n      if (!m.castShadow) continue;\n      if (arr.indexOf(m) < 0) arr.push(m);\n    }\n    this._dirtyLights = true;\n  }\n  removeShadowCasters(meshInstances) {\n    const arr = this.shadowCasters;\n    for (let i = 0; i < meshInstances.length; i++) {\n      const id = arr.indexOf(meshInstances[i]);\n      if (id >= 0) arr.splice(id, 1);\n    }\n    this._dirtyLights = true;\n  }\n  _generateLightHash() {\n    if (this._lights.length > 0) {\n      this._lights.sort(sortLights);\n      let str = '';\n      let strStatic = '';\n      for (let i = 0; i < this._lights.length; i++) {\n        if (this._lights[i].isStatic) {\n          strStatic += this._lights[i].key;\n        } else {\n          str += this._lights[i].key;\n        }\n      }\n      if (str.length === 0) {\n        this._lightHash = 0;\n      } else {\n        this._lightHash = (0,_core_hash_js__WEBPACK_IMPORTED_MODULE_2__.hashCode)(str);\n      }\n      if (strStatic.length === 0) {\n        this._staticLightHash = 0;\n      } else {\n        this._staticLightHash = (0,_core_hash_js__WEBPACK_IMPORTED_MODULE_2__.hashCode)(strStatic);\n      }\n    } else {\n      this._lightHash = 0;\n      this._staticLightHash = 0;\n    }\n  }\n  addCamera(camera) {\n    if (this.cameras.indexOf(camera) >= 0) return;\n    this.cameras.push(camera);\n    this._dirtyCameras = true;\n  }\n  removeCamera(camera) {\n    const index = this.cameras.indexOf(camera);\n    if (index >= 0) {\n      this.cameras.splice(index, 1);\n      this._dirtyCameras = true;\n      this.instances.delete(index);\n    }\n  }\n  clearCameras() {\n    this.cameras.length = 0;\n    this._dirtyCameras = true;\n  }\n  _calculateSortDistances(drawCalls, drawCallsCount, camPos, camFwd) {\n    for (let i = 0; i < drawCallsCount; i++) {\n      const drawCall = drawCalls[i];\n      if (drawCall.command) continue;\n      if (drawCall.layer <= _constants_js__WEBPACK_IMPORTED_MODULE_0__.LAYER_FX) continue;\n      if (drawCall.calculateSortDistance) {\n        drawCall.zdist = drawCall.calculateSortDistance(drawCall, camPos, camFwd);\n        continue;\n      }\n      const meshPos = drawCall.aabb.center;\n      const tempx = meshPos.x - camPos.x;\n      const tempy = meshPos.y - camPos.y;\n      const tempz = meshPos.z - camPos.z;\n      drawCall.zdist = tempx * camFwd.x + tempy * camFwd.y + tempz * camFwd.z;\n    }\n  }\n  _sortVisible(transparent, cameraNode, cameraPass) {\n    const objects = this.instances;\n    const sortMode = transparent ? this.transparentSortMode : this.opaqueSortMode;\n    if (sortMode === _constants_js__WEBPACK_IMPORTED_MODULE_0__.SORTMODE_NONE) return;\n    const visible = transparent ? objects.visibleTransparent[cameraPass] : objects.visibleOpaque[cameraPass];\n    if (sortMode === _constants_js__WEBPACK_IMPORTED_MODULE_0__.SORTMODE_CUSTOM) {\n      sortPos = cameraNode.getPosition();\n      sortDir = cameraNode.forward;\n      if (this.customCalculateSortValues) {\n        this.customCalculateSortValues(visible.list, visible.length, sortPos, sortDir);\n      }\n      if (visible.list.length !== visible.length) {\n        visible.list.length = visible.length;\n      }\n      if (this.customSortCallback) {\n        visible.list.sort(this.customSortCallback);\n      }\n    } else {\n      if (sortMode === _constants_js__WEBPACK_IMPORTED_MODULE_0__.SORTMODE_BACK2FRONT || sortMode === _constants_js__WEBPACK_IMPORTED_MODULE_0__.SORTMODE_FRONT2BACK) {\n        sortPos = cameraNode.getPosition();\n        sortDir = cameraNode.forward;\n        this._calculateSortDistances(visible.list, visible.length, sortPos, sortDir);\n      }\n      if (visible.list.length !== visible.length) {\n        visible.list.length = visible.length;\n      }\n      visible.list.sort(sortCallbacks[sortMode]);\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/layer.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/light.js":
/*!*********************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/light.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Light\": () => (/* binding */ Light),\n/* harmony export */   \"lightTypes\": () => (/* binding */ lightTypes)\n/* harmony export */ });\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _core_math_color_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/math/color.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n/* harmony import */ var _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/math/mat4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js\");\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/math/vec4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec4.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _renderer_shadow_renderer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./renderer/shadow-renderer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/shadow-renderer.js\");\n\n\n\n\n\n\n\n\n\nconst tmpVec = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst tmpBiases = {\n  bias: 0,\n  normalBias: 0\n};\nconst chanId = {\n  r: 0,\n  g: 1,\n  b: 2,\n  a: 3\n};\nconst lightTypes = {\n  'directional': _constants_js__WEBPACK_IMPORTED_MODULE_1__.LIGHTTYPE_DIRECTIONAL,\n  'omni': _constants_js__WEBPACK_IMPORTED_MODULE_1__.LIGHTTYPE_OMNI,\n  'point': _constants_js__WEBPACK_IMPORTED_MODULE_1__.LIGHTTYPE_OMNI,\n  'spot': _constants_js__WEBPACK_IMPORTED_MODULE_1__.LIGHTTYPE_SPOT\n};\nconst directionalCascades = [[new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_2__.Vec4(0, 0, 1, 1)], [new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_2__.Vec4(0, 0, 0.5, 0.5), new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_2__.Vec4(0, 0.5, 0.5, 0.5)], [new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_2__.Vec4(0, 0, 0.5, 0.5), new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_2__.Vec4(0, 0.5, 0.5, 0.5), new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_2__.Vec4(0.5, 0, 0.5, 0.5)], [new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_2__.Vec4(0, 0, 0.5, 0.5), new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_2__.Vec4(0, 0.5, 0.5, 0.5), new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_2__.Vec4(0.5, 0, 0.5, 0.5), new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_2__.Vec4(0.5, 0.5, 0.5, 0.5)]];\nlet id = 0;\nclass LightRenderData {\n  constructor(device, camera, face, light) {\n    this.light = light;\n    this.camera = camera;\n    this.shadowCamera = _renderer_shadow_renderer_js__WEBPACK_IMPORTED_MODULE_3__.ShadowRenderer.createShadowCamera(device, light._shadowType, light._type, face);\n    this.shadowMatrix = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_4__.Mat4();\n    this.shadowViewport = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_2__.Vec4(0, 0, 1, 1);\n    this.shadowScissor = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_2__.Vec4(0, 0, 1, 1);\n    this.face = face;\n    this.visibleCasters = [];\n    this.viewBindGroups = [];\n  }\n  destroy() {\n    this.viewBindGroups.forEach(bg => {\n      bg.defaultUniformBuffer.destroy();\n      bg.destroy();\n    });\n    this.viewBindGroups.length = 0;\n  }\n  get shadowBuffer() {\n    const rt = this.shadowCamera.renderTarget;\n    if (rt) {\n      const light = this.light;\n      if (light._type === _constants_js__WEBPACK_IMPORTED_MODULE_1__.LIGHTTYPE_OMNI) {\n        return rt.colorBuffer;\n      }\n      return light._isPcf && light.device.supportsDepthShadow ? rt.depthBuffer : rt.colorBuffer;\n    }\n    return null;\n  }\n}\nclass Light {\n  constructor(graphicsDevice) {\n    this.device = graphicsDevice;\n    this.id = id++;\n    this._type = _constants_js__WEBPACK_IMPORTED_MODULE_1__.LIGHTTYPE_DIRECTIONAL;\n    this._color = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_5__.Color(0.8, 0.8, 0.8);\n    this._intensity = 1;\n    this._luminance = 0;\n    this._castShadows = false;\n    this._enabled = false;\n    this.mask = _constants_js__WEBPACK_IMPORTED_MODULE_1__.MASK_AFFECT_DYNAMIC;\n    this.isStatic = false;\n    this.key = 0;\n    this.bakeDir = true;\n    this.bakeNumSamples = 1;\n    this.bakeArea = 0;\n    this.attenuationStart = 10;\n    this.attenuationEnd = 10;\n    this._falloffMode = _constants_js__WEBPACK_IMPORTED_MODULE_1__.LIGHTFALLOFF_LINEAR;\n    this._shadowType = _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHADOW_PCF3;\n    this._vsmBlurSize = 11;\n    this.vsmBlurMode = _constants_js__WEBPACK_IMPORTED_MODULE_1__.BLUR_GAUSSIAN;\n    this.vsmBias = 0.01 * 0.25;\n    this._cookie = null;\n    this.cookieIntensity = 1;\n    this._cookieFalloff = true;\n    this._cookieChannel = 'rgb';\n    this._cookieTransform = null;\n    this._cookieTransformUniform = new Float32Array(4);\n    this._cookieOffset = null;\n    this._cookieOffsetUniform = new Float32Array(2);\n    this._cookieTransformSet = false;\n    this._cookieOffsetSet = false;\n    this._innerConeAngle = 40;\n    this._outerConeAngle = 45;\n    this.cascades = null;\n    this._shadowMatrixPalette = null;\n    this._shadowCascadeDistances = null;\n    this.numCascades = 1;\n    this.cascadeDistribution = 0.5;\n    this._shape = _constants_js__WEBPACK_IMPORTED_MODULE_1__.LIGHTSHAPE_PUNCTUAL;\n    this._finalColor = new Float32Array([0.8, 0.8, 0.8]);\n    const c = Math.pow(this._finalColor[0], 2.2);\n    this._linearFinalColor = new Float32Array([c, c, c]);\n    this._position = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(0, 0, 0);\n    this._direction = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(0, 0, 0);\n    this._innerConeAngleCos = Math.cos(this._innerConeAngle * Math.PI / 180);\n    this._updateOuterAngle(this._outerConeAngle);\n    this._usePhysicalUnits = undefined;\n    this._shadowMap = null;\n    this._shadowRenderParams = [];\n    this.shadowDistance = 40;\n    this._shadowResolution = 1024;\n    this.shadowBias = -0.0005;\n    this.shadowIntensity = 1.0;\n    this._normalOffsetBias = 0.0;\n    this.shadowUpdateMode = _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHADOWUPDATE_REALTIME;\n    this.shadowUpdateOverrides = null;\n    this._isVsm = false;\n    this._isPcf = true;\n    this._cookieMatrix = null;\n    this._atlasViewport = null;\n    this.atlasViewportAllocated = false;\n    this.atlasVersion = 0;\n    this.atlasSlotIndex = 0;\n    this.atlasSlotUpdated = false;\n    this._scene = null;\n    this._node = null;\n    this._renderData = [];\n    this.visibleThisFrame = false;\n    this.maxScreenSize = 0;\n  }\n  destroy() {\n    this._destroyShadowMap();\n    this.releaseRenderData();\n    this._renderData = null;\n  }\n  releaseRenderData() {\n    if (this._renderData) {\n      for (let i = 0; i < this._renderData.length; i++) {\n        this._renderData[i].destroy();\n      }\n      this._renderData.length = 0;\n    }\n  }\n  set numCascades(value) {\n    if (!this.cascades || this.numCascades !== value) {\n      this.cascades = directionalCascades[value - 1];\n      this._shadowMatrixPalette = new Float32Array(4 * 16);\n      this._shadowCascadeDistances = new Float32Array(4);\n      this._destroyShadowMap();\n      this.updateKey();\n    }\n  }\n  get numCascades() {\n    return this.cascades.length;\n  }\n  set shadowMap(shadowMap) {\n    if (this._shadowMap !== shadowMap) {\n      this._destroyShadowMap();\n      this._shadowMap = shadowMap;\n    }\n  }\n  get shadowMap() {\n    return this._shadowMap;\n  }\n  get numShadowFaces() {\n    const type = this._type;\n    if (type === _constants_js__WEBPACK_IMPORTED_MODULE_1__.LIGHTTYPE_DIRECTIONAL) {\n      return this.numCascades;\n    } else if (type === _constants_js__WEBPACK_IMPORTED_MODULE_1__.LIGHTTYPE_OMNI) {\n      return 6;\n    }\n    return 1;\n  }\n  set type(value) {\n    if (this._type === value) return;\n    this._type = value;\n    this._destroyShadowMap();\n    this.updateKey();\n    const stype = this._shadowType;\n    this._shadowType = null;\n    this.shadowUpdateOverrides = null;\n    this.shadowType = stype;\n  }\n  get type() {\n    return this._type;\n  }\n  set shape(value) {\n    if (this._shape === value) return;\n    this._shape = value;\n    this._destroyShadowMap();\n    this.updateKey();\n    const stype = this._shadowType;\n    this._shadowType = null;\n    this.shadowType = stype;\n  }\n  get shape() {\n    return this._shape;\n  }\n  set usePhysicalUnits(value) {\n    if (this._usePhysicalUnits !== value) {\n      this._usePhysicalUnits = value;\n      this._updateFinalColor();\n    }\n  }\n  get usePhysicalUnits() {\n    return this._usePhysicalUnits;\n  }\n  set shadowType(value) {\n    if (this._shadowType === value) return;\n    const device = this.device;\n    if (this._type === _constants_js__WEBPACK_IMPORTED_MODULE_1__.LIGHTTYPE_OMNI) value = _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHADOW_PCF3;\n    const supportsPCF5 = device.supportsDepthShadow;\n    if (value === _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHADOW_PCF5 && !supportsPCF5) {\n      value = _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHADOW_PCF3;\n    }\n    if (value === _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHADOW_VSM32 && !device.textureFloatRenderable) value = _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHADOW_VSM16;\n    if (value === _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHADOW_VSM16 && !device.textureHalfFloatRenderable) value = _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHADOW_VSM8;\n    this._isVsm = value >= _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHADOW_VSM8 && value <= _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHADOW_VSM32;\n    this._isPcf = value === _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHADOW_PCF5 || value === _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHADOW_PCF3;\n    this._shadowType = value;\n    this._destroyShadowMap();\n    this.updateKey();\n  }\n  get shadowType() {\n    return this._shadowType;\n  }\n  set enabled(value) {\n    if (this._enabled !== value) {\n      this._enabled = value;\n      this.layersDirty();\n    }\n  }\n  get enabled() {\n    return this._enabled;\n  }\n  set castShadows(value) {\n    if (this._castShadows !== value) {\n      this._castShadows = value;\n      this._destroyShadowMap();\n      this.layersDirty();\n      this.updateKey();\n    }\n  }\n  get castShadows() {\n    return this._castShadows && this.mask !== _constants_js__WEBPACK_IMPORTED_MODULE_1__.MASK_BAKE && this.mask !== 0;\n  }\n  set shadowResolution(value) {\n    if (this._shadowResolution !== value) {\n      if (this._type === _constants_js__WEBPACK_IMPORTED_MODULE_1__.LIGHTTYPE_OMNI) {\n        value = Math.min(value, this.device.maxCubeMapSize);\n      } else {\n        value = Math.min(value, this.device.maxTextureSize);\n      }\n      this._shadowResolution = value;\n      this._destroyShadowMap();\n    }\n  }\n  get shadowResolution() {\n    return this._shadowResolution;\n  }\n  set vsmBlurSize(value) {\n    if (this._vsmBlurSize === value) return;\n    if (value % 2 === 0) value++;\n    this._vsmBlurSize = value;\n  }\n  get vsmBlurSize() {\n    return this._vsmBlurSize;\n  }\n  set normalOffsetBias(value) {\n    if (this._normalOffsetBias === value) return;\n    if (!this._normalOffsetBias && value || this._normalOffsetBias && !value) {\n      this.updateKey();\n    }\n    this._normalOffsetBias = value;\n  }\n  get normalOffsetBias() {\n    return this._normalOffsetBias;\n  }\n  set falloffMode(value) {\n    if (this._falloffMode === value) return;\n    this._falloffMode = value;\n    this.updateKey();\n  }\n  get falloffMode() {\n    return this._falloffMode;\n  }\n  set innerConeAngle(value) {\n    if (this._innerConeAngle === value) return;\n    this._innerConeAngle = value;\n    this._innerConeAngleCos = Math.cos(value * Math.PI / 180);\n    if (this._usePhysicalUnits) {\n      this._updateFinalColor();\n    }\n  }\n  get innerConeAngle() {\n    return this._innerConeAngle;\n  }\n  set outerConeAngle(value) {\n    if (this._outerConeAngle === value) return;\n    this._outerConeAngle = value;\n    this._updateOuterAngle(value);\n    if (this._usePhysicalUnits) {\n      this._updateFinalColor();\n    }\n  }\n  get outerConeAngle() {\n    return this._outerConeAngle;\n  }\n  _updateOuterAngle(angle) {\n    const radAngle = angle * Math.PI / 180;\n    this._outerConeAngleCos = Math.cos(radAngle);\n    this._outerConeAngleSin = Math.sin(radAngle);\n  }\n  set intensity(value) {\n    if (this._intensity !== value) {\n      this._intensity = value;\n      this._updateFinalColor();\n    }\n  }\n  get intensity() {\n    return this._intensity;\n  }\n  set luminance(value) {\n    if (this._luminance !== value) {\n      this._luminance = value;\n      this._updateFinalColor();\n    }\n  }\n  get luminance() {\n    return this._luminance;\n  }\n  get cookieMatrix() {\n    if (!this._cookieMatrix) {\n      this._cookieMatrix = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_4__.Mat4();\n    }\n    return this._cookieMatrix;\n  }\n  get atlasViewport() {\n    if (!this._atlasViewport) {\n      this._atlasViewport = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_2__.Vec4(0, 0, 1, 1);\n    }\n    return this._atlasViewport;\n  }\n  set cookie(value) {\n    if (this._cookie === value) return;\n    this._cookie = value;\n    this.updateKey();\n  }\n  get cookie() {\n    return this._cookie;\n  }\n  set cookieFalloff(value) {\n    if (this._cookieFalloff === value) return;\n    this._cookieFalloff = value;\n    this.updateKey();\n  }\n  get cookieFalloff() {\n    return this._cookieFalloff;\n  }\n  set cookieChannel(value) {\n    if (this._cookieChannel === value) return;\n    if (value.length < 3) {\n      const chr = value.charAt(value.length - 1);\n      const addLen = 3 - value.length;\n      for (let i = 0; i < addLen; i++) value += chr;\n    }\n    this._cookieChannel = value;\n    this.updateKey();\n  }\n  get cookieChannel() {\n    return this._cookieChannel;\n  }\n  set cookieTransform(value) {\n    if (this._cookieTransform === value) return;\n    this._cookieTransform = value;\n    this._cookieTransformSet = !!value;\n    if (value && !this._cookieOffset) {\n      this.cookieOffset = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_6__.Vec2();\n      this._cookieOffsetSet = false;\n    }\n    this.updateKey();\n  }\n  get cookieTransform() {\n    return this._cookieTransform;\n  }\n  set cookieOffset(value) {\n    if (this._cookieOffset === value) return;\n    const xformNew = !!(this._cookieTransformSet || value);\n    if (xformNew && !value && this._cookieOffset) {\n      this._cookieOffset.set(0, 0);\n    } else {\n      this._cookieOffset = value;\n    }\n    this._cookieOffsetSet = !!value;\n    if (value && !this._cookieTransform) {\n      this.cookieTransform = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_2__.Vec4(1, 1, 0, 0);\n      this._cookieTransformSet = false;\n    }\n    this.updateKey();\n  }\n  get cookieOffset() {\n    return this._cookieOffset;\n  }\n  beginFrame() {\n    this.visibleThisFrame = this._type === _constants_js__WEBPACK_IMPORTED_MODULE_1__.LIGHTTYPE_DIRECTIONAL && this._enabled;\n    this.maxScreenSize = 0;\n    this.atlasViewportAllocated = false;\n    this.atlasSlotUpdated = false;\n  }\n  _destroyShadowMap() {\n    this.releaseRenderData();\n    if (this._shadowMap) {\n      if (!this._shadowMap.cached) {\n        this._shadowMap.destroy();\n      }\n      this._shadowMap = null;\n    }\n    if (this.shadowUpdateMode === _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHADOWUPDATE_NONE) {\n      this.shadowUpdateMode = _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHADOWUPDATE_THISFRAME;\n    }\n    if (this.shadowUpdateOverrides) {\n      for (let i = 0; i < this.shadowUpdateOverrides.length; i++) {\n        if (this.shadowUpdateOverrides[i] === _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHADOWUPDATE_NONE) {\n          this.shadowUpdateOverrides[i] = _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHADOWUPDATE_THISFRAME;\n        }\n      }\n    }\n  }\n  getRenderData(camera, face) {\n    for (let i = 0; i < this._renderData.length; i++) {\n      const current = this._renderData[i];\n      if (current.camera === camera && current.face === face) {\n        return current;\n      }\n    }\n    const rd = new LightRenderData(this.device, camera, face, this);\n    this._renderData.push(rd);\n    return rd;\n  }\n  clone() {\n    const clone = new Light(this.device);\n    clone.type = this._type;\n    clone.setColor(this._color);\n    clone.intensity = this._intensity;\n    clone.luminance = this._luminance;\n    clone.castShadows = this.castShadows;\n    clone._enabled = this._enabled;\n    clone.attenuationStart = this.attenuationStart;\n    clone.attenuationEnd = this.attenuationEnd;\n    clone.falloffMode = this._falloffMode;\n    clone.shadowType = this._shadowType;\n    clone.vsmBlurSize = this._vsmBlurSize;\n    clone.vsmBlurMode = this.vsmBlurMode;\n    clone.vsmBias = this.vsmBias;\n    clone.shadowUpdateMode = this.shadowUpdateMode;\n    clone.mask = this.mask;\n    if (this.shadowUpdateOverrides) {\n      clone.shadowUpdateOverrides = this.shadowUpdateOverrides.slice();\n    }\n    clone.innerConeAngle = this._innerConeAngle;\n    clone.outerConeAngle = this._outerConeAngle;\n    clone.numCascades = this.numCascades;\n    clone.cascadeDistribution = this.cascadeDistribution;\n    clone.shape = this._shape;\n    clone.shadowBias = this.shadowBias;\n    clone.normalOffsetBias = this._normalOffsetBias;\n    clone.shadowResolution = this._shadowResolution;\n    clone.shadowDistance = this.shadowDistance;\n    clone.shadowIntensity = this.shadowIntensity;\n    return clone;\n  }\n  static getLightUnitConversion(type, outerAngle = Math.PI / 4, innerAngle = 0) {\n    switch (type) {\n      case _constants_js__WEBPACK_IMPORTED_MODULE_1__.LIGHTTYPE_SPOT:\n        {\n          const falloffEnd = Math.cos(outerAngle);\n          const falloffStart = Math.cos(innerAngle);\n          return 2 * Math.PI * (1 - falloffStart + (falloffStart - falloffEnd) / 2.0);\n        }\n      case _constants_js__WEBPACK_IMPORTED_MODULE_1__.LIGHTTYPE_OMNI:\n        return 4 * Math.PI;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_1__.LIGHTTYPE_DIRECTIONAL:\n        return 1;\n    }\n  }\n  _getUniformBiasValues(lightRenderData) {\n    const farClip = lightRenderData.shadowCamera._farClip;\n    switch (this._type) {\n      case _constants_js__WEBPACK_IMPORTED_MODULE_1__.LIGHTTYPE_OMNI:\n        tmpBiases.bias = this.shadowBias;\n        tmpBiases.normalBias = this._normalOffsetBias;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_1__.LIGHTTYPE_SPOT:\n        if (this._isVsm) {\n          tmpBiases.bias = -0.00001 * 20;\n        } else {\n          tmpBiases.bias = this.shadowBias * 20;\n          if (!this.device.webgl2 && this.device.extStandardDerivatives) tmpBiases.bias *= -100;\n        }\n        tmpBiases.normalBias = this._isVsm ? this.vsmBias / (this.attenuationEnd / 7.0) : this._normalOffsetBias;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_1__.LIGHTTYPE_DIRECTIONAL:\n        if (this._isVsm) {\n          tmpBiases.bias = -0.00001 * 20;\n        } else {\n          tmpBiases.bias = this.shadowBias / farClip * 100;\n          if (!this.device.webgl2 && this.device.extStandardDerivatives) tmpBiases.bias *= -100;\n        }\n        tmpBiases.normalBias = this._isVsm ? this.vsmBias / (farClip / 7.0) : this._normalOffsetBias;\n        break;\n    }\n    return tmpBiases;\n  }\n  getColor() {\n    return this._color;\n  }\n  getBoundingSphere(sphere) {\n    if (this._type === _constants_js__WEBPACK_IMPORTED_MODULE_1__.LIGHTTYPE_SPOT) {\n      const size = this.attenuationEnd;\n      const angle = this._outerConeAngle;\n      const cosAngle = this._outerConeAngleCos;\n      const node = this._node;\n      tmpVec.copy(node.up);\n      if (angle > 45) {\n        sphere.radius = size * this._outerConeAngleSin;\n        tmpVec.mulScalar(-size * cosAngle);\n      } else {\n        sphere.radius = size / (2 * cosAngle);\n        tmpVec.mulScalar(-sphere.radius);\n      }\n      sphere.center.add2(node.getPosition(), tmpVec);\n    } else if (this._type === _constants_js__WEBPACK_IMPORTED_MODULE_1__.LIGHTTYPE_OMNI) {\n      sphere.center = this._node.getPosition();\n      sphere.radius = this.attenuationEnd;\n    }\n  }\n  getBoundingBox(box) {\n    if (this._type === _constants_js__WEBPACK_IMPORTED_MODULE_1__.LIGHTTYPE_SPOT) {\n      const range = this.attenuationEnd;\n      const angle = this._outerConeAngle;\n      const node = this._node;\n      const scl = Math.abs(Math.sin(angle * _core_math_math_js__WEBPACK_IMPORTED_MODULE_7__.math.DEG_TO_RAD) * range);\n      box.center.set(0, -range * 0.5, 0);\n      box.halfExtents.set(scl, range * 0.5, scl);\n      box.setFromTransformedAabb(box, node.getWorldTransform(), true);\n    } else if (this._type === _constants_js__WEBPACK_IMPORTED_MODULE_1__.LIGHTTYPE_OMNI) {\n      box.center.copy(this._node.getPosition());\n      box.halfExtents.set(this.attenuationEnd, this.attenuationEnd, this.attenuationEnd);\n    }\n  }\n  _updateFinalColor() {\n    const color = this._color;\n    const r = color.r;\n    const g = color.g;\n    const b = color.b;\n    let i = this._intensity;\n    if (this._usePhysicalUnits) {\n      i = this._luminance / Light.getLightUnitConversion(this._type, this._outerConeAngle * _core_math_math_js__WEBPACK_IMPORTED_MODULE_7__.math.DEG_TO_RAD, this._innerConeAngle * _core_math_math_js__WEBPACK_IMPORTED_MODULE_7__.math.DEG_TO_RAD);\n    }\n    const finalColor = this._finalColor;\n    const linearFinalColor = this._linearFinalColor;\n    finalColor[0] = r * i;\n    finalColor[1] = g * i;\n    finalColor[2] = b * i;\n    if (i >= 1) {\n      linearFinalColor[0] = Math.pow(r, 2.2) * i;\n      linearFinalColor[1] = Math.pow(g, 2.2) * i;\n      linearFinalColor[2] = Math.pow(b, 2.2) * i;\n    } else {\n      linearFinalColor[0] = Math.pow(finalColor[0], 2.2);\n      linearFinalColor[1] = Math.pow(finalColor[1], 2.2);\n      linearFinalColor[2] = Math.pow(finalColor[2], 2.2);\n    }\n  }\n  setColor() {\n    if (arguments.length === 1) {\n      this._color.set(arguments[0].r, arguments[0].g, arguments[0].b);\n    } else if (arguments.length === 3) {\n      this._color.set(arguments[0], arguments[1], arguments[2]);\n    }\n    this._updateFinalColor();\n  }\n  layersDirty() {\n    var _this$_scene;\n    if ((_this$_scene = this._scene) != null && _this$_scene.layers) {\n      this._scene.layers._dirtyLights = true;\n    }\n  }\n  updateKey() {\n    let key = this._type << 29 | (this._castShadows ? 1 : 0) << 28 | this._shadowType << 25 | this._falloffMode << 23 | (this._normalOffsetBias !== 0.0 ? 1 : 0) << 22 | (this._cookie ? 1 : 0) << 21 | (this._cookieFalloff ? 1 : 0) << 20 | chanId[this._cookieChannel.charAt(0)] << 18 | (this._cookieTransform ? 1 : 0) << 12 | this._shape << 10 | this.numCascades - 1 << 8;\n    if (this._cookieChannel.length === 3) {\n      key |= chanId[this._cookieChannel.charAt(1)] << 16;\n      key |= chanId[this._cookieChannel.charAt(2)] << 14;\n    }\n    if (key !== this.key && this._scene !== null) {\n      this.layersDirty();\n    }\n    this.key = key;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/light.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/lighting/light-texture-atlas.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/lighting/light-texture-atlas.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LightTextureAtlas\": () => (/* binding */ LightTextureAtlas)\n/* harmony export */ });\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/math/vec4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec4.js\");\n/* harmony import */ var _platform_graphics_render_target_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../platform/graphics/render-target.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/render-target.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _renderer_cookie_renderer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../renderer/cookie-renderer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/cookie-renderer.js\");\n/* harmony import */ var _renderer_shadow_map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderer/shadow-map.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/shadow-map.js\");\n\n\n\n\n\n\n\nconst _tempArray = [];\nconst _tempArray2 = [];\nconst _viewport = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_0__.Vec4();\nconst _scissor = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_0__.Vec4();\nclass Slot {\n  constructor(rect) {\n    this.size = Math.floor(rect.w * 1024);\n    this.used = false;\n    this.lightId = -1;\n    this.rect = rect;\n  }\n}\nclass LightTextureAtlas {\n  constructor(device) {\n    this.device = device;\n    this.version = 1;\n    this.shadowAtlasResolution = 2048;\n    this.shadowAtlas = null;\n    this.shadowEdgePixels = 3;\n    this.cookieAtlasResolution = 2048;\n    this.cookieAtlas = null;\n    this.cookieRenderTarget = null;\n    this.slots = [];\n    this.atlasSplit = [];\n    this.cubeSlotsOffsets = [new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_1__.Vec2(0, 0), new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_1__.Vec2(0, 1), new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_1__.Vec2(1, 0), new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_1__.Vec2(1, 1), new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_1__.Vec2(2, 0), new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_1__.Vec2(2, 1)];\n    this.scissorVec = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_0__.Vec4();\n    this.allocateShadowAtlas(1);\n    this.allocateCookieAtlas(1);\n    this.allocateUniforms();\n  }\n  destroy() {\n    this.destroyShadowAtlas();\n    this.destroyCookieAtlas();\n  }\n  destroyShadowAtlas() {\n    if (this.shadowAtlas) {\n      this.shadowAtlas.destroy();\n      this.shadowAtlas = null;\n    }\n  }\n  destroyCookieAtlas() {\n    if (this.cookieAtlas) {\n      this.cookieAtlas.destroy();\n      this.cookieAtlas = null;\n    }\n    if (this.cookieRenderTarget) {\n      this.cookieRenderTarget.destroy();\n      this.cookieRenderTarget = null;\n    }\n  }\n  allocateShadowAtlas(resolution) {\n    if (!this.shadowAtlas || this.shadowAtlas.texture.width !== resolution) {\n      this.version++;\n      this.destroyShadowAtlas();\n      this.shadowAtlas = _renderer_shadow_map_js__WEBPACK_IMPORTED_MODULE_2__.ShadowMap.createAtlas(this.device, resolution, _constants_js__WEBPACK_IMPORTED_MODULE_3__.SHADOW_PCF3);\n      this.shadowAtlas.cached = true;\n      const scissorOffset = 4 / this.shadowAtlasResolution;\n      this.scissorVec.set(scissorOffset, scissorOffset, -2 * scissorOffset, -2 * scissorOffset);\n    }\n  }\n  allocateCookieAtlas(resolution) {\n    if (!this.cookieAtlas || this.cookieAtlas.width !== resolution) {\n      this.version++;\n      this.destroyCookieAtlas();\n      this.cookieAtlas = _renderer_cookie_renderer_js__WEBPACK_IMPORTED_MODULE_4__.CookieRenderer.createTexture(this.device, resolution);\n      this.cookieRenderTarget = new _platform_graphics_render_target_js__WEBPACK_IMPORTED_MODULE_5__.RenderTarget({\n        colorBuffer: this.cookieAtlas,\n        depth: false,\n        flipY: true\n      });\n    }\n  }\n  allocateUniforms() {\n    this._shadowAtlasTextureId = this.device.scope.resolve('shadowAtlasTexture');\n    this._shadowAtlasParamsId = this.device.scope.resolve('shadowAtlasParams');\n    this._shadowAtlasParams = new Float32Array(2);\n    this._cookieAtlasTextureId = this.device.scope.resolve('cookieAtlasTexture');\n  }\n  updateUniforms() {\n    const isShadowFilterPcf = true;\n    const rt = this.shadowAtlas.renderTargets[0];\n    const shadowBuffer = this.device.webgl2 && isShadowFilterPcf ? rt.depthBuffer : rt.colorBuffer;\n    this._shadowAtlasTextureId.setValue(shadowBuffer);\n    this._shadowAtlasParams[0] = this.shadowAtlasResolution;\n    this._shadowAtlasParams[1] = this.shadowEdgePixels;\n    this._shadowAtlasParamsId.setValue(this._shadowAtlasParams);\n    this._cookieAtlasTextureId.setValue(this.cookieAtlas);\n  }\n  subdivide(numLights, lightingParams) {\n    let atlasSplit = lightingParams.atlasSplit;\n    if (!atlasSplit) {\n      const gridSize = Math.ceil(Math.sqrt(numLights));\n      atlasSplit = _tempArray2;\n      atlasSplit[0] = gridSize;\n      atlasSplit.length = 1;\n    }\n    const arraysEqual = (a, b) => a.length === b.length && a.every((v, i) => v === b[i]);\n    if (!arraysEqual(atlasSplit, this.atlasSplit)) {\n      this.version++;\n      this.slots.length = 0;\n      this.atlasSplit.length = 0;\n      this.atlasSplit.push(...atlasSplit);\n      const splitCount = this.atlasSplit[0];\n      if (splitCount > 1) {\n        const invSize = 1 / splitCount;\n        for (let i = 0; i < splitCount; i++) {\n          for (let j = 0; j < splitCount; j++) {\n            const rect = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_0__.Vec4(i * invSize, j * invSize, invSize, invSize);\n            const nextLevelSplit = this.atlasSplit[1 + i * splitCount + j];\n            if (nextLevelSplit > 1) {\n              for (let x = 0; x < nextLevelSplit; x++) {\n                for (let y = 0; y < nextLevelSplit; y++) {\n                  const invSizeNext = invSize / nextLevelSplit;\n                  const rectNext = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_0__.Vec4(rect.x + x * invSizeNext, rect.y + y * invSizeNext, invSizeNext, invSizeNext);\n                  this.slots.push(new Slot(rectNext));\n                }\n              }\n            } else {\n              this.slots.push(new Slot(rect));\n            }\n          }\n        }\n      } else {\n        this.slots.push(new Slot(new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_0__.Vec4(0, 0, 1, 1)));\n      }\n      this.slots.sort((a, b) => {\n        return b.size - a.size;\n      });\n    }\n  }\n  collectLights(spotLights, omniLights, lightingParams) {\n    const cookiesEnabled = lightingParams.cookiesEnabled;\n    const shadowsEnabled = lightingParams.shadowsEnabled;\n    let needsShadowAtlas = false;\n    let needsCookieAtlas = false;\n    const lights = _tempArray;\n    lights.length = 0;\n    const processLights = list => {\n      for (let i = 0; i < list.length; i++) {\n        const light = list[i];\n        if (light.visibleThisFrame) {\n          const lightShadow = shadowsEnabled && light.castShadows;\n          const lightCookie = cookiesEnabled && !!light.cookie;\n          needsShadowAtlas || (needsShadowAtlas = lightShadow);\n          needsCookieAtlas || (needsCookieAtlas = lightCookie);\n          if (lightShadow || lightCookie) {\n            lights.push(light);\n          }\n        }\n      }\n    };\n    if (cookiesEnabled || shadowsEnabled) {\n      processLights(spotLights);\n      processLights(omniLights);\n    }\n    lights.sort((a, b) => {\n      return b.maxScreenSize - a.maxScreenSize;\n    });\n    if (needsShadowAtlas) {\n      this.allocateShadowAtlas(this.shadowAtlasResolution);\n    }\n    if (needsCookieAtlas) {\n      this.allocateCookieAtlas(this.cookieAtlasResolution);\n    }\n    if (needsShadowAtlas || needsCookieAtlas) {\n      this.subdivide(lights.length, lightingParams);\n    }\n    return lights;\n  }\n  setupSlot(light, rect) {\n    light.atlasViewport.copy(rect);\n    const faceCount = light.numShadowFaces;\n    for (let face = 0; face < faceCount; face++) {\n      if (light.castShadows || light._cookie) {\n        _viewport.copy(rect);\n        _scissor.copy(rect);\n        if (light._type === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_SPOT) {\n          _viewport.add(this.scissorVec);\n        }\n        if (light._type === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_OMNI) {\n          const smallSize = _viewport.z / 3;\n          const offset = this.cubeSlotsOffsets[face];\n          _viewport.x += smallSize * offset.x;\n          _viewport.y += smallSize * offset.y;\n          _viewport.z = smallSize;\n          _viewport.w = smallSize;\n          _scissor.copy(_viewport);\n        }\n        if (light.castShadows) {\n          const lightRenderData = light.getRenderData(null, face);\n          lightRenderData.shadowViewport.copy(_viewport);\n          lightRenderData.shadowScissor.copy(_scissor);\n        }\n      }\n    }\n  }\n  assignSlot(light, slotIndex, slotReassigned) {\n    light.atlasViewportAllocated = true;\n    const slot = this.slots[slotIndex];\n    slot.lightId = light.id;\n    slot.used = true;\n    if (slotReassigned) {\n      light.atlasSlotUpdated = true;\n      light.atlasVersion = this.version;\n      light.atlasSlotIndex = slotIndex;\n    }\n  }\n  update(spotLights, omniLights, lightingParams) {\n    this.shadowAtlasResolution = lightingParams.shadowAtlasResolution;\n    this.cookieAtlasResolution = lightingParams.cookieAtlasResolution;\n    const lights = this.collectLights(spotLights, omniLights, lightingParams);\n    if (lights.length > 0) {\n      const slots = this.slots;\n      for (let i = 0; i < slots.length; i++) {\n        slots[i].used = false;\n      }\n      const assignCount = Math.min(lights.length, slots.length);\n      for (let i = 0; i < assignCount; i++) {\n        const light = lights[i];\n        if (light.castShadows) light._shadowMap = this.shadowAtlas;\n        const previousSlot = slots[light.atlasSlotIndex];\n        if (light.atlasVersion === this.version && light.id === (previousSlot == null ? void 0 : previousSlot.lightId)) {\n          const _previousSlot = slots[light.atlasSlotIndex];\n          if (_previousSlot.size === slots[i].size && !_previousSlot.used) {\n            this.assignSlot(light, light.atlasSlotIndex, false);\n          }\n        }\n      }\n      let usedCount = 0;\n      for (let i = 0; i < assignCount; i++) {\n        while (usedCount < slots.length && slots[usedCount].used) usedCount++;\n        const light = lights[i];\n        if (!light.atlasViewportAllocated) {\n          this.assignSlot(light, usedCount, true);\n        }\n        const slot = slots[light.atlasSlotIndex];\n        this.setupSlot(light, slot.rect);\n      }\n    }\n    this.updateUniforms();\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/lighting/light-texture-atlas.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/lighting/lighting-params.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/lighting/lighting-params.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LightingParams\": () => (/* binding */ LightingParams)\n/* harmony export */ });\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n\n\n\n\nclass LightingParams {\n  constructor(supportsAreaLights, maxTextureSize, dirtyLightsFnc) {\n    this._maxTextureSize = maxTextureSize;\n    this._supportsAreaLights = supportsAreaLights;\n    this._dirtyLightsFnc = dirtyLightsFnc;\n    this._areaLightsEnabled = false;\n    this._cells = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(10, 3, 10);\n    this._maxLightsPerCell = 255;\n    this._shadowsEnabled = true;\n    this._shadowType = _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHADOW_PCF3;\n    this._shadowAtlasResolution = 2048;\n    this._cookiesEnabled = false;\n    this._cookieAtlasResolution = 2048;\n    this.atlasSplit = null;\n    this.debugLayer = undefined;\n  }\n  applySettings(render) {\n    this.shadowsEnabled = render.lightingShadowsEnabled;\n    this.cookiesEnabled = render.lightingCookiesEnabled;\n    this.areaLightsEnabled = render.lightingAreaLightsEnabled;\n    this.shadowAtlasResolution = render.lightingShadowAtlasResolution;\n    this.cookieAtlasResolution = render.lightingCookieAtlasResolution;\n    this.maxLightsPerCell = render.lightingMaxLightsPerCell;\n    this.shadowType = render.lightingShadowType;\n    this.cell = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(render.lightingCells);\n  }\n  set cells(value) {\n    this._cells.copy(value);\n  }\n  get cells() {\n    return this._cells;\n  }\n  set maxLightsPerCell(value) {\n    this._maxLightsPerCell = _core_math_math_js__WEBPACK_IMPORTED_MODULE_2__.math.clamp(value, 1, 255);\n  }\n  get maxLightsPerCell() {\n    return this._maxLightsPerCell;\n  }\n  set cookieAtlasResolution(value) {\n    this._cookieAtlasResolution = _core_math_math_js__WEBPACK_IMPORTED_MODULE_2__.math.clamp(value, 32, this._maxTextureSize);\n  }\n  get cookieAtlasResolution() {\n    return this._cookieAtlasResolution;\n  }\n  set shadowAtlasResolution(value) {\n    this._shadowAtlasResolution = _core_math_math_js__WEBPACK_IMPORTED_MODULE_2__.math.clamp(value, 32, this._maxTextureSize);\n  }\n  get shadowAtlasResolution() {\n    return this._shadowAtlasResolution;\n  }\n  set shadowType(value) {\n    if (this._shadowType !== value) {\n      this._shadowType = value;\n      this._dirtyLightsFnc();\n    }\n  }\n  get shadowType() {\n    return this._shadowType;\n  }\n  set cookiesEnabled(value) {\n    if (this._cookiesEnabled !== value) {\n      this._cookiesEnabled = value;\n      this._dirtyLightsFnc();\n    }\n  }\n  get cookiesEnabled() {\n    return this._cookiesEnabled;\n  }\n  set areaLightsEnabled(value) {\n    if (this._supportsAreaLights) {\n      if (this._areaLightsEnabled !== value) {\n        this._areaLightsEnabled = value;\n        this._dirtyLightsFnc();\n      }\n    }\n  }\n  get areaLightsEnabled() {\n    return this._areaLightsEnabled;\n  }\n  set shadowsEnabled(value) {\n    if (this._shadowsEnabled !== value) {\n      this._shadowsEnabled = value;\n      this._dirtyLightsFnc();\n    }\n  }\n  get shadowsEnabled() {\n    return this._shadowsEnabled;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/lighting/lighting-params.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/lighting/lights-buffer.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/lighting/lights-buffer.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LightsBuffer\": () => (/* binding */ LightsBuffer)\n/* harmony export */ });\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _core_math_float_packing_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/math/float-packing.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/float-packing.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../platform/graphics/texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js\");\n/* harmony import */ var _renderer_light_camera_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../renderer/light-camera.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/light-camera.js\");\n\n\n\n\n\n\n\nconst epsilon = 0.000001;\nconst tempVec3 = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst tempAreaLightSizes = new Float32Array(6);\nconst areaHalfAxisWidth = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(-0.5, 0, 0);\nconst areaHalfAxisHeight = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(0, 0, 0.5);\nconst TextureIndex8 = {\n  FLAGS: 0,\n  COLOR_A: 1,\n  COLOR_B: 2,\n  SPOT_ANGLES: 3,\n  SHADOW_BIAS: 4,\n  COOKIE_A: 5,\n  COOKIE_B: 6,\n  COUNT_ALWAYS: 7,\n  POSITION_X: 7,\n  POSITION_Y: 8,\n  POSITION_Z: 9,\n  RANGE: 10,\n  SPOT_DIRECTION_X: 11,\n  SPOT_DIRECTION_Y: 12,\n  SPOT_DIRECTION_Z: 13,\n  PROJ_MAT_00: 14,\n  ATLAS_VIEWPORT_A: 14,\n  PROJ_MAT_01: 15,\n  ATLAS_VIEWPORT_B: 15,\n  PROJ_MAT_02: 16,\n  PROJ_MAT_03: 17,\n  PROJ_MAT_10: 18,\n  PROJ_MAT_11: 19,\n  PROJ_MAT_12: 20,\n  PROJ_MAT_13: 21,\n  PROJ_MAT_20: 22,\n  PROJ_MAT_21: 23,\n  PROJ_MAT_22: 24,\n  PROJ_MAT_23: 25,\n  PROJ_MAT_30: 26,\n  PROJ_MAT_31: 27,\n  PROJ_MAT_32: 28,\n  PROJ_MAT_33: 29,\n  AREA_DATA_WIDTH_X: 30,\n  AREA_DATA_WIDTH_Y: 31,\n  AREA_DATA_WIDTH_Z: 32,\n  AREA_DATA_HEIGHT_X: 33,\n  AREA_DATA_HEIGHT_Y: 34,\n  AREA_DATA_HEIGHT_Z: 35,\n  COUNT: 36\n};\nconst TextureIndexFloat = {\n  POSITION_RANGE: 0,\n  SPOT_DIRECTION: 1,\n  PROJ_MAT_0: 2,\n  ATLAS_VIEWPORT: 2,\n  PROJ_MAT_1: 3,\n  PROJ_MAT_2: 4,\n  PROJ_MAT_3: 5,\n  AREA_DATA_WIDTH: 6,\n  AREA_DATA_HEIGHT: 7,\n  COUNT: 8\n};\nclass LightsBuffer {\n  static initShaderDefines() {\n    const clusterTextureFormat = LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT ? 'FLOAT' : '8BIT';\n    LightsBuffer.shaderDefines = `\n            \\n#define CLUSTER_TEXTURE_${clusterTextureFormat}\n            ${LightsBuffer.buildShaderDefines(TextureIndex8, 'CLUSTER_TEXTURE_8_')}\n            ${LightsBuffer.buildShaderDefines(TextureIndexFloat, 'CLUSTER_TEXTURE_F_')}\n        `;\n  }\n  static buildShaderDefines(object, prefix) {\n    let str = '';\n    const floatOffset = LightsBuffer.useTexelFetch ? '' : '.5';\n    Object.keys(object).forEach(key => {\n      str += `\\n#define ${prefix}${key} ${object[key]}${floatOffset}`;\n    });\n    return str;\n  }\n  static init(device) {\n    LightsBuffer.lightTextureFormat = device.extTextureFloat && device.maxTextures > 8 ? LightsBuffer.FORMAT_FLOAT : LightsBuffer.FORMAT_8BIT;\n    LightsBuffer.useTexelFetch = device.supportsTextureFetch;\n    LightsBuffer.initShaderDefines();\n  }\n  static createTexture(device, width, height, format, name) {\n    const tex = new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture(device, {\n      name: name,\n      width: width,\n      height: height,\n      mipmaps: false,\n      format: format,\n      addressU: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.ADDRESS_CLAMP_TO_EDGE,\n      addressV: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.ADDRESS_CLAMP_TO_EDGE,\n      type: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.TEXTURETYPE_DEFAULT,\n      magFilter: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.FILTER_NEAREST,\n      minFilter: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.FILTER_NEAREST,\n      anisotropy: 1\n    });\n    return tex;\n  }\n  constructor(device) {\n    this.device = device;\n    this.cookiesEnabled = false;\n    this.shadowsEnabled = false;\n    this.areaLightsEnabled = false;\n    this.maxLights = 255;\n    let pixelsPerLight8 = TextureIndex8.COUNT_ALWAYS;\n    let pixelsPerLightFloat = 0;\n    if (LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT) {\n      pixelsPerLightFloat = TextureIndexFloat.COUNT;\n    } else {\n      pixelsPerLight8 = TextureIndex8.COUNT;\n    }\n    this.lights8 = new Uint8ClampedArray(4 * pixelsPerLight8 * this.maxLights);\n    this.lightsTexture8 = LightsBuffer.createTexture(this.device, pixelsPerLight8, this.maxLights, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.PIXELFORMAT_RGBA8, 'LightsTexture8');\n    this._lightsTexture8Id = this.device.scope.resolve('lightsTexture8');\n    if (pixelsPerLightFloat) {\n      this.lightsFloat = new Float32Array(4 * pixelsPerLightFloat * this.maxLights);\n      this.lightsTextureFloat = LightsBuffer.createTexture(this.device, pixelsPerLightFloat, this.maxLights, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.PIXELFORMAT_RGBA32F, 'LightsTextureFloat');\n      this._lightsTextureFloatId = this.device.scope.resolve('lightsTextureFloat');\n    } else {\n      this.lightsFloat = null;\n      this.lightsTextureFloat = null;\n      this._lightsTextureFloatId = undefined;\n    }\n    this._lightsTextureInvSizeId = this.device.scope.resolve('lightsTextureInvSize');\n    this._lightsTextureInvSizeData = new Float32Array(4);\n    this._lightsTextureInvSizeData[0] = pixelsPerLightFloat ? 1.0 / this.lightsTextureFloat.width : 0;\n    this._lightsTextureInvSizeData[1] = pixelsPerLightFloat ? 1.0 / this.lightsTextureFloat.height : 0;\n    this._lightsTextureInvSizeData[2] = 1.0 / this.lightsTexture8.width;\n    this._lightsTextureInvSizeData[3] = 1.0 / this.lightsTexture8.height;\n    this.invMaxColorValue = 0;\n    this.invMaxAttenuation = 0;\n    this.boundsMin = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n    this.boundsDelta = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n  }\n  destroy() {\n    if (this.lightsTexture8) {\n      this.lightsTexture8.destroy();\n      this.lightsTexture8 = null;\n    }\n    if (this.lightsTextureFloat) {\n      this.lightsTextureFloat.destroy();\n      this.lightsTextureFloat = null;\n    }\n  }\n  setCompressionRanges(maxAttenuation, maxColorValue) {\n    this.invMaxColorValue = 1 / maxColorValue;\n    this.invMaxAttenuation = 1 / maxAttenuation;\n  }\n  setBounds(min, delta) {\n    this.boundsMin.copy(min);\n    this.boundsDelta.copy(delta);\n  }\n  uploadTextures() {\n    if (this.lightsTextureFloat) {\n      this.lightsTextureFloat.lock().set(this.lightsFloat);\n      this.lightsTextureFloat.unlock();\n    }\n    this.lightsTexture8.lock().set(this.lights8);\n    this.lightsTexture8.unlock();\n  }\n  updateUniforms() {\n    this._lightsTexture8Id.setValue(this.lightsTexture8);\n    if (LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT) {\n      this._lightsTextureFloatId.setValue(this.lightsTextureFloat);\n    }\n    this._lightsTextureInvSizeId.setValue(this._lightsTextureInvSizeData);\n  }\n  getSpotDirection(direction, spot) {\n    const mat = spot._node.getWorldTransform();\n    mat.getY(direction).mulScalar(-1);\n    direction.normalize();\n  }\n  getLightAreaSizes(light) {\n    const mat = light._node.getWorldTransform();\n    mat.transformVector(areaHalfAxisWidth, tempVec3);\n    tempAreaLightSizes[0] = tempVec3.x;\n    tempAreaLightSizes[1] = tempVec3.y;\n    tempAreaLightSizes[2] = tempVec3.z;\n    mat.transformVector(areaHalfAxisHeight, tempVec3);\n    tempAreaLightSizes[3] = tempVec3.x;\n    tempAreaLightSizes[4] = tempVec3.y;\n    tempAreaLightSizes[5] = tempVec3.z;\n    return tempAreaLightSizes;\n  }\n  addLightDataFlags(data8, index, light, isSpot, castShadows, shadowIntensity) {\n    data8[index + 0] = isSpot ? 255 : 0;\n    data8[index + 1] = light._shape * 64;\n    data8[index + 2] = light._falloffMode * 255;\n    data8[index + 3] = castShadows ? shadowIntensity * 255 : 0;\n  }\n  addLightDataColor(data8, index, light, gammaCorrection, isCookie) {\n    const invMaxColorValue = this.invMaxColorValue;\n    const color = gammaCorrection ? light._linearFinalColor : light._finalColor;\n    _core_math_float_packing_js__WEBPACK_IMPORTED_MODULE_3__.FloatPacking.float2Bytes(color[0] * invMaxColorValue, data8, index + 0, 2);\n    _core_math_float_packing_js__WEBPACK_IMPORTED_MODULE_3__.FloatPacking.float2Bytes(color[1] * invMaxColorValue, data8, index + 2, 2);\n    _core_math_float_packing_js__WEBPACK_IMPORTED_MODULE_3__.FloatPacking.float2Bytes(color[2] * invMaxColorValue, data8, index + 4, 2);\n    data8[index + 6] = isCookie ? 255 : 0;\n    const isDynamic = !!(light.mask & _constants_js__WEBPACK_IMPORTED_MODULE_4__.MASK_AFFECT_DYNAMIC);\n    const isLightmapped = !!(light.mask & _constants_js__WEBPACK_IMPORTED_MODULE_4__.MASK_AFFECT_LIGHTMAPPED);\n    data8[index + 7] = isDynamic && isLightmapped ? 127 : isLightmapped ? 255 : 0;\n  }\n  addLightDataSpotAngles(data8, index, light) {\n    _core_math_float_packing_js__WEBPACK_IMPORTED_MODULE_3__.FloatPacking.float2Bytes(light._innerConeAngleCos * (0.5 - epsilon) + 0.5, data8, index + 0, 2);\n    _core_math_float_packing_js__WEBPACK_IMPORTED_MODULE_3__.FloatPacking.float2Bytes(light._outerConeAngleCos * (0.5 - epsilon) + 0.5, data8, index + 2, 2);\n  }\n  addLightDataShadowBias(data8, index, light) {\n    const lightRenderData = light.getRenderData(null, 0);\n    const biases = light._getUniformBiasValues(lightRenderData);\n    _core_math_float_packing_js__WEBPACK_IMPORTED_MODULE_3__.FloatPacking.float2BytesRange(biases.bias, data8, index, -1, 20, 2);\n    _core_math_float_packing_js__WEBPACK_IMPORTED_MODULE_3__.FloatPacking.float2Bytes(biases.normalBias, data8, index + 2, 2);\n  }\n  addLightDataPositionRange(data8, index, light, pos) {\n    const normPos = tempVec3.sub2(pos, this.boundsMin).div(this.boundsDelta);\n    _core_math_float_packing_js__WEBPACK_IMPORTED_MODULE_3__.FloatPacking.float2Bytes(normPos.x, data8, index + 0, 4);\n    _core_math_float_packing_js__WEBPACK_IMPORTED_MODULE_3__.FloatPacking.float2Bytes(normPos.y, data8, index + 4, 4);\n    _core_math_float_packing_js__WEBPACK_IMPORTED_MODULE_3__.FloatPacking.float2Bytes(normPos.z, data8, index + 8, 4);\n    _core_math_float_packing_js__WEBPACK_IMPORTED_MODULE_3__.FloatPacking.float2Bytes(light.attenuationEnd * this.invMaxAttenuation, data8, index + 12, 4);\n  }\n  addLightDataSpotDirection(data8, index, light) {\n    this.getSpotDirection(tempVec3, light);\n    _core_math_float_packing_js__WEBPACK_IMPORTED_MODULE_3__.FloatPacking.float2Bytes(tempVec3.x * (0.5 - epsilon) + 0.5, data8, index + 0, 4);\n    _core_math_float_packing_js__WEBPACK_IMPORTED_MODULE_3__.FloatPacking.float2Bytes(tempVec3.y * (0.5 - epsilon) + 0.5, data8, index + 4, 4);\n    _core_math_float_packing_js__WEBPACK_IMPORTED_MODULE_3__.FloatPacking.float2Bytes(tempVec3.z * (0.5 - epsilon) + 0.5, data8, index + 8, 4);\n  }\n  addLightDataLightProjMatrix(data8, index, lightProjectionMatrix) {\n    const matData = lightProjectionMatrix.data;\n    for (let m = 0; m < 12; m++) _core_math_float_packing_js__WEBPACK_IMPORTED_MODULE_3__.FloatPacking.float2BytesRange(matData[m], data8, index + 4 * m, -2, 2, 4);\n    for (let m = 12; m < 16; m++) {\n      _core_math_float_packing_js__WEBPACK_IMPORTED_MODULE_3__.FloatPacking.float2MantissaExponent(matData[m], data8, index + 4 * m, 4);\n    }\n  }\n  addLightDataCookies(data8, index, light) {\n    const isRgb = light._cookieChannel === 'rgb';\n    data8[index + 0] = Math.floor(light.cookieIntensity * 255);\n    data8[index + 1] = isRgb ? 255 : 0;\n    if (!isRgb) {\n      const channel = light._cookieChannel;\n      data8[index + 4] = channel === 'rrr' ? 255 : 0;\n      data8[index + 5] = channel === 'ggg' ? 255 : 0;\n      data8[index + 6] = channel === 'bbb' ? 255 : 0;\n      data8[index + 7] = channel === 'aaa' ? 255 : 0;\n    }\n  }\n  addLightAtlasViewport(data8, index, atlasViewport) {\n    _core_math_float_packing_js__WEBPACK_IMPORTED_MODULE_3__.FloatPacking.float2Bytes(atlasViewport.x, data8, index + 0, 2);\n    _core_math_float_packing_js__WEBPACK_IMPORTED_MODULE_3__.FloatPacking.float2Bytes(atlasViewport.y, data8, index + 2, 2);\n    _core_math_float_packing_js__WEBPACK_IMPORTED_MODULE_3__.FloatPacking.float2Bytes(atlasViewport.z / 3, data8, index + 4, 2);\n  }\n  addLightAreaSizes(data8, index, light) {\n    const areaSizes = this.getLightAreaSizes(light);\n    for (let i = 0; i < 6; i++) {\n      _core_math_float_packing_js__WEBPACK_IMPORTED_MODULE_3__.FloatPacking.float2MantissaExponent(areaSizes[i], data8, index + 4 * i, 4);\n    }\n  }\n  addLightData(light, lightIndex, gammaCorrection) {\n    const isSpot = light._type === _constants_js__WEBPACK_IMPORTED_MODULE_4__.LIGHTTYPE_SPOT;\n    const hasAtlasViewport = light.atlasViewportAllocated;\n    const isCookie = this.cookiesEnabled && !!light._cookie && hasAtlasViewport;\n    const isArea = this.areaLightsEnabled && light.shape !== _constants_js__WEBPACK_IMPORTED_MODULE_4__.LIGHTSHAPE_PUNCTUAL;\n    const castShadows = this.shadowsEnabled && light.castShadows && hasAtlasViewport;\n    const pos = light._node.getPosition();\n    let lightProjectionMatrix = null;\n    let atlasViewport = null;\n    if (isSpot) {\n      if (castShadows) {\n        const lightRenderData = light.getRenderData(null, 0);\n        lightProjectionMatrix = lightRenderData.shadowMatrix;\n      } else if (isCookie) {\n        lightProjectionMatrix = _renderer_light_camera_js__WEBPACK_IMPORTED_MODULE_5__.LightCamera.evalSpotCookieMatrix(light);\n      }\n    } else {\n      if (castShadows || isCookie) {\n        atlasViewport = light.atlasViewport;\n      }\n    }\n    const data8 = this.lights8;\n    const data8Start = lightIndex * this.lightsTexture8.width * 4;\n    this.addLightDataFlags(data8, data8Start + 4 * TextureIndex8.FLAGS, light, isSpot, castShadows, light.shadowIntensity);\n    this.addLightDataColor(data8, data8Start + 4 * TextureIndex8.COLOR_A, light, gammaCorrection, isCookie);\n    if (isSpot) {\n      this.addLightDataSpotAngles(data8, data8Start + 4 * TextureIndex8.SPOT_ANGLES, light);\n    }\n    if (light.castShadows) {\n      this.addLightDataShadowBias(data8, data8Start + 4 * TextureIndex8.SHADOW_BIAS, light);\n    }\n    if (isCookie) {\n      this.addLightDataCookies(data8, data8Start + 4 * TextureIndex8.COOKIE_A, light);\n    }\n    if (LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT) {\n      const dataFloat = this.lightsFloat;\n      const dataFloatStart = lightIndex * this.lightsTextureFloat.width * 4;\n      dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 0] = pos.x;\n      dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 1] = pos.y;\n      dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 2] = pos.z;\n      dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 3] = light.attenuationEnd;\n      if (isSpot) {\n        this.getSpotDirection(tempVec3, light);\n        dataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 0] = tempVec3.x;\n        dataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 1] = tempVec3.y;\n        dataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 2] = tempVec3.z;\n      }\n      if (lightProjectionMatrix) {\n        const matData = lightProjectionMatrix.data;\n        for (let m = 0; m < 16; m++) dataFloat[dataFloatStart + 4 * TextureIndexFloat.PROJ_MAT_0 + m] = matData[m];\n      }\n      if (atlasViewport) {\n        dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 0] = atlasViewport.x;\n        dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 1] = atlasViewport.y;\n        dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 2] = atlasViewport.z / 3;\n      }\n      if (isArea) {\n        const areaSizes = this.getLightAreaSizes(light);\n        dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 0] = areaSizes[0];\n        dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 1] = areaSizes[1];\n        dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 2] = areaSizes[2];\n        dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 0] = areaSizes[3];\n        dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 1] = areaSizes[4];\n        dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 2] = areaSizes[5];\n      }\n    } else {\n      this.addLightDataPositionRange(data8, data8Start + 4 * TextureIndex8.POSITION_X, light, pos);\n      if (isSpot) {\n        this.addLightDataSpotDirection(data8, data8Start + 4 * TextureIndex8.SPOT_DIRECTION_X, light);\n      }\n      if (lightProjectionMatrix) {\n        this.addLightDataLightProjMatrix(data8, data8Start + 4 * TextureIndex8.PROJ_MAT_00, lightProjectionMatrix);\n      }\n      if (atlasViewport) {\n        this.addLightAtlasViewport(data8, data8Start + 4 * TextureIndex8.ATLAS_VIEWPORT_A, atlasViewport);\n      }\n      if (isArea) {\n        this.addLightAreaSizes(data8, data8Start + 4 * TextureIndex8.AREA_DATA_WIDTH_X, light);\n      }\n    }\n  }\n}\nLightsBuffer.FORMAT_FLOAT = 0;\nLightsBuffer.FORMAT_8BIT = 1;\nLightsBuffer.lightTextureFormat = LightsBuffer.FORMAT_8BIT;\nLightsBuffer.useTexelFetch = false;\nLightsBuffer.shaderDefines = '';\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/lighting/lights-buffer.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/lighting/world-clusters.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/lighting/world-clusters.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WorldClusters\": () => (/* binding */ WorldClusters)\n/* harmony export */ });\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/shape/bounding-box.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/shape/bounding-box.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _lights_buffer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lights-buffer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/lighting/lights-buffer.js\");\n\n\n\n\n\n\n\n\nconst tempVec3 = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst tempMin3 = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst tempMax3 = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\nconst tempBox = new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_1__.BoundingBox();\nconst epsilon = 0.000001;\nclass ClusterLight {\n  constructor() {\n    this.light = null;\n    this.min = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n    this.max = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n  }\n}\nclass WorldClusters {\n  constructor(device) {\n    this.device = device;\n    this.name = 'Untitled';\n    this.reportCount = 0;\n    this.boundsMin = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n    this.boundsMax = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n    this.boundsDelta = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n    this._cells = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(1, 1, 1);\n    this._cellsLimit = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n    this.cells = this._cells;\n    this._maxCellLightCount = 0;\n    this._pixelsPerCellCount = 0;\n    this.maxCellLightCount = 4;\n    this._maxAttenuation = 0;\n    this._maxColorValue = 0;\n    this._usedLights = [];\n    this._usedLights.push(new ClusterLight());\n    this.lightsBuffer = new _lights_buffer_js__WEBPACK_IMPORTED_MODULE_2__.LightsBuffer(device);\n    this.registerUniforms(device);\n  }\n  set maxCellLightCount(count) {\n    const maxCellLightCount = _core_math_math_js__WEBPACK_IMPORTED_MODULE_3__.math.roundUp(count, 4);\n    if (maxCellLightCount !== this._maxCellLightCount) {\n      this._maxCellLightCount = maxCellLightCount;\n      this._pixelsPerCellCount = this._maxCellLightCount / 4;\n      this._cellsDirty = true;\n    }\n  }\n  get maxCellLightCount() {\n    return this._maxCellLightCount;\n  }\n  set cells(value) {\n    tempVec3.copy(value).floor();\n    if (!this._cells.equals(tempVec3)) {\n      this._cells.copy(tempVec3);\n      this._cellsLimit.copy(tempVec3).sub(_core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3.ONE);\n      this._cellsDirty = true;\n    }\n  }\n  get cells() {\n    return this._cells;\n  }\n  destroy() {\n    this.lightsBuffer.destroy();\n    this.releaseClusterTexture();\n  }\n  releaseClusterTexture() {\n    if (this.clusterTexture) {\n      this.clusterTexture.destroy();\n      this.clusterTexture = null;\n    }\n  }\n  registerUniforms(device) {\n    this._clusterMaxCellsId = device.scope.resolve('clusterMaxCells');\n    this._clusterWorldTextureId = device.scope.resolve('clusterWorldTexture');\n    this._clusterPixelsPerCellId = device.scope.resolve('clusterPixelsPerCell');\n    this._clusterTextureSizeId = device.scope.resolve('clusterTextureSize');\n    this._clusterTextureSizeData = new Float32Array(3);\n    this._clusterBoundsMinId = device.scope.resolve('clusterBoundsMin');\n    this._clusterBoundsMinData = new Float32Array(3);\n    this._clusterBoundsDeltaId = device.scope.resolve('clusterBoundsDelta');\n    this._clusterBoundsDeltaData = new Float32Array(3);\n    this._clusterCellsCountByBoundsSizeId = device.scope.resolve('clusterCellsCountByBoundsSize');\n    this._clusterCellsCountByBoundsSizeData = new Float32Array(3);\n    this._clusterCellsDotId = device.scope.resolve('clusterCellsDot');\n    this._clusterCellsDotData = new Float32Array(3);\n    this._clusterCellsMaxId = device.scope.resolve('clusterCellsMax');\n    this._clusterCellsMaxData = new Float32Array(3);\n    this._clusterCompressionLimit0Id = device.scope.resolve('clusterCompressionLimit0');\n    this._clusterCompressionLimit0Data = new Float32Array(2);\n  }\n  updateParams(lightingParams) {\n    if (lightingParams) {\n      this.cells = lightingParams.cells;\n      this.maxCellLightCount = lightingParams.maxLightsPerCell;\n      this.lightsBuffer.cookiesEnabled = lightingParams.cookiesEnabled;\n      this.lightsBuffer.shadowsEnabled = lightingParams.shadowsEnabled;\n      this.lightsBuffer.areaLightsEnabled = lightingParams.areaLightsEnabled;\n    }\n  }\n  updateCells() {\n    if (this._cellsDirty) {\n      this._cellsDirty = false;\n      const cx = this._cells.x;\n      const cy = this._cells.y;\n      const cz = this._cells.z;\n      const numCells = cx * cy * cz;\n      const totalPixels = this._pixelsPerCellCount * numCells;\n      let width = Math.ceil(Math.sqrt(totalPixels));\n      width = _core_math_math_js__WEBPACK_IMPORTED_MODULE_3__.math.roundUp(width, this._pixelsPerCellCount);\n      const height = Math.ceil(totalPixels / width);\n      this._clusterCellsMaxData[0] = cx;\n      this._clusterCellsMaxData[1] = cy;\n      this._clusterCellsMaxData[2] = cz;\n      this._clusterCellsDotData[0] = this._pixelsPerCellCount;\n      this._clusterCellsDotData[1] = cx * cz * this._pixelsPerCellCount;\n      this._clusterCellsDotData[2] = cx * this._pixelsPerCellCount;\n      this.clusters = new Uint8ClampedArray(4 * totalPixels);\n      this.counts = new Int32Array(numCells);\n      this._clusterTextureSizeData[0] = width;\n      this._clusterTextureSizeData[1] = 1.0 / width;\n      this._clusterTextureSizeData[2] = 1.0 / height;\n      this.releaseClusterTexture();\n      this.clusterTexture = _lights_buffer_js__WEBPACK_IMPORTED_MODULE_2__.LightsBuffer.createTexture(this.device, width, height, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_4__.PIXELFORMAT_RGBA8, 'ClusterTexture');\n    }\n  }\n  uploadTextures() {\n    this.clusterTexture.lock().set(this.clusters);\n    this.clusterTexture.unlock();\n    this.lightsBuffer.uploadTextures();\n  }\n  updateUniforms() {\n    this.lightsBuffer.updateUniforms();\n    this._clusterWorldTextureId.setValue(this.clusterTexture);\n    this._clusterMaxCellsId.setValue(this._pixelsPerCellCount);\n    const boundsDelta = this.boundsDelta;\n    this._clusterCellsCountByBoundsSizeData[0] = this._cells.x / boundsDelta.x;\n    this._clusterCellsCountByBoundsSizeData[1] = this._cells.y / boundsDelta.y;\n    this._clusterCellsCountByBoundsSizeData[2] = this._cells.z / boundsDelta.z;\n    this._clusterCellsCountByBoundsSizeId.setValue(this._clusterCellsCountByBoundsSizeData);\n    this._clusterBoundsMinData[0] = this.boundsMin.x;\n    this._clusterBoundsMinData[1] = this.boundsMin.y;\n    this._clusterBoundsMinData[2] = this.boundsMin.z;\n    this._clusterBoundsDeltaData[0] = boundsDelta.x;\n    this._clusterBoundsDeltaData[1] = boundsDelta.y;\n    this._clusterBoundsDeltaData[2] = boundsDelta.z;\n    this._clusterCompressionLimit0Data[0] = this._maxAttenuation;\n    this._clusterCompressionLimit0Data[1] = this._maxColorValue;\n    this._clusterPixelsPerCellId.setValue(this._pixelsPerCellCount);\n    this._clusterTextureSizeId.setValue(this._clusterTextureSizeData);\n    this._clusterBoundsMinId.setValue(this._clusterBoundsMinData);\n    this._clusterBoundsDeltaId.setValue(this._clusterBoundsDeltaData);\n    this._clusterCellsDotId.setValue(this._clusterCellsDotData);\n    this._clusterCellsMaxId.setValue(this._clusterCellsMaxData);\n    this._clusterCompressionLimit0Id.setValue(this._clusterCompressionLimit0Data);\n  }\n  evalLightCellMinMax(clusteredLight, min, max) {\n    min.copy(clusteredLight.min);\n    min.sub(this.boundsMin);\n    min.div(this.boundsDelta);\n    min.mul2(min, this.cells);\n    min.floor();\n    max.copy(clusteredLight.max);\n    max.sub(this.boundsMin);\n    max.div(this.boundsDelta);\n    max.mul2(max, this.cells);\n    max.ceil();\n    min.max(_core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3.ZERO);\n    max.min(this._cellsLimit);\n  }\n  collectLights(lights) {\n    const maxLights = this.lightsBuffer.maxLights;\n    const usedLights = this._usedLights;\n    let lightIndex = 1;\n    lights.forEach(light => {\n      const runtimeLight = !!(light.mask & (_constants_js__WEBPACK_IMPORTED_MODULE_5__.MASK_AFFECT_DYNAMIC | _constants_js__WEBPACK_IMPORTED_MODULE_5__.MASK_AFFECT_LIGHTMAPPED));\n      const zeroAngleSpotlight = light.type === _constants_js__WEBPACK_IMPORTED_MODULE_5__.LIGHTTYPE_SPOT && light._outerConeAngle === 0;\n      if (light.enabled && light.type !== _constants_js__WEBPACK_IMPORTED_MODULE_5__.LIGHTTYPE_DIRECTIONAL && light.visibleThisFrame && light.intensity > 0 && runtimeLight && !zeroAngleSpotlight) {\n        if (lightIndex < maxLights) {\n          let clusteredLight;\n          if (lightIndex < usedLights.length) {\n            clusteredLight = usedLights[lightIndex];\n          } else {\n            clusteredLight = new ClusterLight();\n            usedLights.push(clusteredLight);\n          }\n          clusteredLight.light = light;\n          light.getBoundingBox(tempBox);\n          clusteredLight.min.copy(tempBox.getMin());\n          clusteredLight.max.copy(tempBox.getMax());\n          lightIndex++;\n        }\n      }\n    });\n    usedLights.length = lightIndex;\n  }\n  evaluateBounds() {\n    const usedLights = this._usedLights;\n    const min = this.boundsMin;\n    const max = this.boundsMax;\n    if (usedLights.length > 1) {\n      min.copy(usedLights[1].min);\n      max.copy(usedLights[1].max);\n      for (let i = 2; i < usedLights.length; i++) {\n        min.min(usedLights[i].min);\n        max.max(usedLights[i].max);\n      }\n    } else {\n      min.set(0, 0, 0);\n      max.set(1, 1, 1);\n    }\n    this.boundsDelta.sub2(max, min);\n    this.lightsBuffer.setBounds(min, this.boundsDelta);\n  }\n  evaluateCompressionLimits(gammaCorrection) {\n    let maxAttenuation = 0;\n    let maxColorValue = 0;\n    const usedLights = this._usedLights;\n    for (let i = 1; i < usedLights.length; i++) {\n      const light = usedLights[i].light;\n      maxAttenuation = Math.max(light.attenuationEnd, maxAttenuation);\n      const color = gammaCorrection ? light._linearFinalColor : light._finalColor;\n      maxColorValue = Math.max(color[0], maxColorValue);\n      maxColorValue = Math.max(color[1], maxColorValue);\n      maxColorValue = Math.max(color[2], maxColorValue);\n    }\n    this._maxAttenuation = maxAttenuation + epsilon;\n    this._maxColorValue = maxColorValue + epsilon;\n    this.lightsBuffer.setCompressionRanges(this._maxAttenuation, this._maxColorValue);\n  }\n  updateClusters(gammaCorrection) {\n    this.counts.fill(0);\n    this.clusters.fill(0);\n    const divX = this._cells.x;\n    const divZ = this._cells.z;\n    const counts = this.counts;\n    const limit = this._maxCellLightCount;\n    const clusters = this.clusters;\n    const pixelsPerCellCount = this._pixelsPerCellCount;\n    const usedLights = this._usedLights;\n    for (let i = 1; i < usedLights.length; i++) {\n      const clusteredLight = usedLights[i];\n      const light = clusteredLight.light;\n      this.lightsBuffer.addLightData(light, i, gammaCorrection);\n      this.evalLightCellMinMax(clusteredLight, tempMin3, tempMax3);\n      const xStart = tempMin3.x;\n      const xEnd = tempMax3.x;\n      const yStart = tempMin3.y;\n      const yEnd = tempMax3.y;\n      const zStart = tempMin3.z;\n      const zEnd = tempMax3.z;\n      for (let x = xStart; x <= xEnd; x++) {\n        for (let z = zStart; z <= zEnd; z++) {\n          for (let y = yStart; y <= yEnd; y++) {\n            const clusterIndex = x + divX * (z + y * divZ);\n            const count = counts[clusterIndex];\n            if (count < limit) {\n              clusters[pixelsPerCellCount * clusterIndex * 4 + count] = i;\n              counts[clusterIndex] = count + 1;\n            }\n          }\n        }\n      }\n    }\n  }\n  update(lights, gammaCorrection, lightingParams) {\n    this.updateParams(lightingParams);\n    this.updateCells();\n    this.collectLights(lights);\n    this.evaluateBounds();\n    this.evaluateCompressionLimits(gammaCorrection);\n    this.updateClusters(gammaCorrection);\n    this.uploadTextures();\n  }\n  activate() {\n    this.updateUniforms();\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/lighting/world-clusters.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/basic-material.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/basic-material.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BasicMaterial\": () => (/* binding */ BasicMaterial)\n/* harmony export */ });\n/* harmony import */ var _core_math_color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/math/color.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n/* harmony import */ var _platform_graphics_shader_processor_options_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../platform/graphics/shader-processor-options.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-processor-options.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _shader_lib_get_program_library_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shader-lib/get-program-library.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/get-program-library.js\");\n/* harmony import */ var _shader_lib_programs_basic_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shader-lib/programs/basic.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/programs/basic.js\");\n/* harmony import */ var _material_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./material.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/material.js\");\n\n\n\n\n\n\n\n\nclass BasicMaterial extends _material_js__WEBPACK_IMPORTED_MODULE_0__.Material {\n  constructor() {\n    super();\n    this.color = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_1__.Color(1, 1, 1, 1);\n    this.colorUniform = new Float32Array(4);\n    this.colorMap = null;\n    this.vertexColors = false;\n  }\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.colorMap = source.colorMap;\n    this.vertexColors = source.vertexColors;\n    return this;\n  }\n  updateUniforms(device, scene) {\n    this.clearParameters();\n    this.colorUniform[0] = this.color.r;\n    this.colorUniform[1] = this.color.g;\n    this.colorUniform[2] = this.color.b;\n    this.colorUniform[3] = this.color.a;\n    this.setParameter('uColor', this.colorUniform);\n    if (this.colorMap) {\n      this.setParameter('texture_diffuseMap', this.colorMap);\n    }\n  }\n  getShaderVariant(device, scene, objDefs, staticLightList, pass, sortedLights, viewUniformFormat, viewBindGroupFormat) {\n    if (this.updateShader) {\n      this.updateShader(device, scene, objDefs, staticLightList, pass, sortedLights);\n      return this.shader;\n    }\n    const options = {\n      skin: objDefs && (objDefs & _constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADERDEF_SKIN) !== 0,\n      screenSpace: objDefs && (objDefs & _constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADERDEF_SCREENSPACE) !== 0,\n      useInstancing: objDefs && (objDefs & _constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADERDEF_INSTANCING) !== 0,\n      useMorphPosition: objDefs && (objDefs & _constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADERDEF_MORPH_POSITION) !== 0,\n      useMorphNormal: objDefs && (objDefs & _constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADERDEF_MORPH_NORMAL) !== 0,\n      useMorphTextureBased: objDefs && (objDefs & _constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADERDEF_MORPH_TEXTURE_BASED) !== 0,\n      alphaTest: this.alphaTest > 0,\n      vertexColors: this.vertexColors,\n      diffuseMap: !!this.colorMap,\n      pass: pass\n    };\n    const processingOptions = new _platform_graphics_shader_processor_options_js__WEBPACK_IMPORTED_MODULE_3__.ShaderProcessorOptions(viewUniformFormat, viewBindGroupFormat);\n    const library = (0,_shader_lib_get_program_library_js__WEBPACK_IMPORTED_MODULE_4__.getProgramLibrary)(device);\n    library.register('basic', _shader_lib_programs_basic_js__WEBPACK_IMPORTED_MODULE_5__.basic);\n    return library.getProgram('basic', options, processingOptions);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/basic-material.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/default-material.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/default-material.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getDefaultMaterial\": () => (/* binding */ getDefaultMaterial),\n/* harmony export */   \"setDefaultMaterial\": () => (/* binding */ setDefaultMaterial)\n/* harmony export */ });\n/* harmony import */ var _platform_graphics_device_cache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/graphics/device-cache.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/device-cache.js\");\n\n\n\nconst defaultMaterialDeviceCache = new _platform_graphics_device_cache_js__WEBPACK_IMPORTED_MODULE_0__.DeviceCache();\nfunction getDefaultMaterial(device) {\n  const material = defaultMaterialDeviceCache.get(device);\n  return material;\n}\nfunction setDefaultMaterial(device, material) {\n  defaultMaterialDeviceCache.get(device, () => {\n    return material;\n  });\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/default-material.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/lit-options.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/lit-options.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LitOptions\": () => (/* binding */ LitOptions)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n\n\n\nclass LitOptions {\n  constructor() {\n    this.hasTangents = false;\n    this.chunks = [];\n    this._pass = 0;\n    this.alphaTest = false;\n    this.forceFragmentPrecision = false;\n    this.blendType = _constants_js__WEBPACK_IMPORTED_MODULE_0__.BLEND_NONE;\n    this.separateAmbient = false;\n    this.screenSpace = false;\n    this.skin = false;\n    this.useInstancing = false;\n    this.useMorphPosition = false;\n    this.useMorphNormal = false;\n    this.useMorphTextureBased = false;\n    this.nineSlicedMode = false;\n    this.clusteredLightingEnabled = true;\n    this.clusteredLightingCookiesEnabled = false;\n    this.clusteredLightingShadowsEnabled = false;\n    this.clusteredLightingShadowType = 0;\n    this.clusteredLightingAreaLightsEnabled = false;\n    this.vertexColors = false;\n    this.lightMapEnabled = false;\n    this.useLightMapVertexColors = false;\n    this.dirLightMapEnabled = false;\n    this.heightMapEnabled = false;\n    this.normalMapEnabled = false;\n    this.clearCoatNormalMapEnabled = false;\n    this.aoMapEnabled = false;\n    this.useAoVertexColors = false;\n    this.diffuseMapEnabled = false;\n    this.useAmbientTint = false;\n    this.customFragmentShader = null;\n    this.pixelSnap = false;\n    this.useClearCoatNormalMap = false;\n    this.useDiffuseMap = false;\n    this.useAoMap = false;\n    this.detailModes = 0;\n    this.shadingModel = 0;\n    this.ambientSH = false;\n    this.fastTbn = false;\n    this.twoSidedLighting = false;\n    this.occludeSpecular = false;\n    this.occludeSpecularFloat = false;\n    this.useMsdf = false;\n    this.msdfTextAttribute = 0;\n    this.alphaToCoverage = false;\n    this.opacityFadesSpecular = false;\n    this.cubeMapProjection = false;\n    this.occludeDirect = false;\n    this.conserveEnergy = false;\n    this.useSpecular = false;\n    this.useSpecularityFactor = false;\n    this.useSpecularColor = false;\n    this.enableGGXSpecular = false;\n    this.fresnelModel = 0;\n    this.useRefraction = false;\n    this.useClearCoat = false;\n    this.useSheen = false;\n    this.useIridescence = false;\n    this.useMetalness = false;\n    this.useDynamicRefraction = false;\n    this.fog = _constants_js__WEBPACK_IMPORTED_MODULE_0__.FOG_NONE;\n    this.gamma = _constants_js__WEBPACK_IMPORTED_MODULE_0__.GAMMA_NONE;\n    this.toneMap = -1;\n    this.fixSeams = false;\n    this.reflectionSource = null;\n    this.reflectionEncoding = null;\n    this.ambientSource = 'constant';\n    this.ambientEncoding = null;\n    this.skyboxIntensity = 1.0;\n    this.useCubeMapRotation = false;\n    this.lightMapWithoutAmbient = false;\n    this.lights = [];\n    this.noShadow = false;\n    this.lightMaskDynamic = 0x0;\n  }\n  set pass(p) {}\n  get pass() {\n    return this._pass;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/lit-options.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/material.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/material.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Material\": () => (/* binding */ Material)\n/* harmony export */ });\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_shader_processor_options_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../platform/graphics/shader-processor-options.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-processor-options.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _shader_lib_get_program_library_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shader-lib/get-program-library.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/get-program-library.js\");\n/* harmony import */ var _default_material_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./default-material.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/default-material.js\");\n\n\n\n\n\n\n\nlet id = 0;\nclass Material {\n  constructor() {\n    this._shader = null;\n    this.meshInstances = [];\n    this.name = 'Untitled';\n    this.id = id++;\n    this.variants = {};\n    this.parameters = {};\n    this.alphaTest = 0;\n    this.alphaToCoverage = false;\n    this.blend = false;\n    this.blendSrc = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ONE;\n    this.blendDst = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ZERO;\n    this.blendEquation = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDEQUATION_ADD;\n    this.separateAlphaBlend = false;\n    this.blendSrcAlpha = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ONE;\n    this.blendDstAlpha = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ZERO;\n    this.blendAlphaEquation = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDEQUATION_ADD;\n    this.cull = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.CULLFACE_BACK;\n    this.depthTest = true;\n    this.depthFunc = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FUNC_LESSEQUAL;\n    this.depthWrite = true;\n    this.stencilFront = null;\n    this.stencilBack = null;\n    this.depthBias = 0;\n    this.slopeDepthBias = 0;\n    this.redWrite = true;\n    this.greenWrite = true;\n    this.blueWrite = true;\n    this.alphaWrite = true;\n    this._shaderVersion = 0;\n    this._scene = null;\n    this._dirtyBlend = false;\n    this.dirty = true;\n  }\n  set shader(shader) {\n    this._shader = shader;\n  }\n  get shader() {\n    return this._shader;\n  }\n  get transparent() {\n    return this.blend;\n  }\n  set blendType(type) {\n    let blend = true;\n    switch (type) {\n      case _constants_js__WEBPACK_IMPORTED_MODULE_1__.BLEND_NONE:\n        blend = false;\n        this.blendSrc = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ONE;\n        this.blendDst = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ZERO;\n        this.blendEquation = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDEQUATION_ADD;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_1__.BLEND_NORMAL:\n        this.blendSrc = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_SRC_ALPHA;\n        this.blendDst = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ONE_MINUS_SRC_ALPHA;\n        this.blendEquation = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDEQUATION_ADD;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_1__.BLEND_PREMULTIPLIED:\n        this.blendSrc = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ONE;\n        this.blendDst = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ONE_MINUS_SRC_ALPHA;\n        this.blendEquation = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDEQUATION_ADD;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_1__.BLEND_ADDITIVE:\n        this.blendSrc = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ONE;\n        this.blendDst = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ONE;\n        this.blendEquation = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDEQUATION_ADD;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_1__.BLEND_ADDITIVEALPHA:\n        this.blendSrc = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_SRC_ALPHA;\n        this.blendDst = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ONE;\n        this.blendEquation = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDEQUATION_ADD;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_1__.BLEND_MULTIPLICATIVE2X:\n        this.blendSrc = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_DST_COLOR;\n        this.blendDst = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_SRC_COLOR;\n        this.blendEquation = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDEQUATION_ADD;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_1__.BLEND_SCREEN:\n        this.blendSrc = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ONE_MINUS_DST_COLOR;\n        this.blendDst = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ONE;\n        this.blendEquation = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDEQUATION_ADD;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_1__.BLEND_MULTIPLICATIVE:\n        this.blendSrc = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_DST_COLOR;\n        this.blendDst = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ZERO;\n        this.blendEquation = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDEQUATION_ADD;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_1__.BLEND_MIN:\n        this.blendSrc = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ONE;\n        this.blendDst = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ONE;\n        this.blendEquation = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDEQUATION_MIN;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_1__.BLEND_MAX:\n        this.blendSrc = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ONE;\n        this.blendDst = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ONE;\n        this.blendEquation = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDEQUATION_MAX;\n        break;\n    }\n    if (this.blend !== blend) {\n      this.blend = blend;\n      if (this._scene) {\n        this._scene.layers._dirtyBlend = true;\n      } else {\n        this._dirtyBlend = true;\n      }\n    }\n    this._updateMeshInstanceKeys();\n  }\n  get blendType() {\n    if (!this.blend) {\n      return _constants_js__WEBPACK_IMPORTED_MODULE_1__.BLEND_NONE;\n    }\n    if (this.blendSrc === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_SRC_ALPHA && this.blendDst === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ONE_MINUS_SRC_ALPHA && this.blendEquation === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDEQUATION_ADD) {\n      return _constants_js__WEBPACK_IMPORTED_MODULE_1__.BLEND_NORMAL;\n    }\n    if (this.blendSrc === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ONE && this.blendDst === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ONE && this.blendEquation === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDEQUATION_ADD) {\n      return _constants_js__WEBPACK_IMPORTED_MODULE_1__.BLEND_ADDITIVE;\n    }\n    if (this.blendSrc === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_SRC_ALPHA && this.blendDst === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ONE && this.blendEquation === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDEQUATION_ADD) {\n      return _constants_js__WEBPACK_IMPORTED_MODULE_1__.BLEND_ADDITIVEALPHA;\n    }\n    if (this.blendSrc === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_DST_COLOR && this.blendDst === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_SRC_COLOR && this.blendEquation === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDEQUATION_ADD) {\n      return _constants_js__WEBPACK_IMPORTED_MODULE_1__.BLEND_MULTIPLICATIVE2X;\n    }\n    if (this.blendSrc === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ONE_MINUS_DST_COLOR && this.blendDst === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ONE && this.blendEquation === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDEQUATION_ADD) {\n      return _constants_js__WEBPACK_IMPORTED_MODULE_1__.BLEND_SCREEN;\n    }\n    if (this.blendSrc === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ONE && this.blendDst === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ONE && this.blendEquation === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDEQUATION_MIN) {\n      return _constants_js__WEBPACK_IMPORTED_MODULE_1__.BLEND_MIN;\n    }\n    if (this.blendSrc === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ONE && this.blendDst === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ONE && this.blendEquation === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDEQUATION_MAX) {\n      return _constants_js__WEBPACK_IMPORTED_MODULE_1__.BLEND_MAX;\n    }\n    if (this.blendSrc === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_DST_COLOR && this.blendDst === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ZERO && this.blendEquation === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDEQUATION_ADD) {\n      return _constants_js__WEBPACK_IMPORTED_MODULE_1__.BLEND_MULTIPLICATIVE;\n    }\n    if (this.blendSrc === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ONE && this.blendDst === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDMODE_ONE_MINUS_SRC_ALPHA && this.blendEquation === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLENDEQUATION_ADD) {\n      return _constants_js__WEBPACK_IMPORTED_MODULE_1__.BLEND_PREMULTIPLIED;\n    }\n    return _constants_js__WEBPACK_IMPORTED_MODULE_1__.BLEND_NORMAL;\n  }\n  copy(source) {\n    this.name = source.name;\n    this._shader = source._shader;\n    this.alphaTest = source.alphaTest;\n    this.alphaToCoverage = source.alphaToCoverage;\n    this.blend = source.blend;\n    this.blendSrc = source.blendSrc;\n    this.blendDst = source.blendDst;\n    this.blendEquation = source.blendEquation;\n    this.separateAlphaBlend = source.separateAlphaBlend;\n    this.blendSrcAlpha = source.blendSrcAlpha;\n    this.blendDstAlpha = source.blendDstAlpha;\n    this.blendAlphaEquation = source.blendAlphaEquation;\n    this.cull = source.cull;\n    this.depthTest = source.depthTest;\n    this.depthFunc = source.depthFunc;\n    this.depthWrite = source.depthWrite;\n    this.depthBias = source.depthBias;\n    this.slopeDepthBias = source.slopeDepthBias;\n    if (source.stencilFront) this.stencilFront = source.stencilFront.clone();\n    if (source.stencilBack) {\n      if (source.stencilFront === source.stencilBack) {\n        this.stencilBack = this.stencilFront;\n      } else {\n        this.stencilBack = source.stencilBack.clone();\n      }\n    }\n    this.redWrite = source.redWrite;\n    this.greenWrite = source.greenWrite;\n    this.blueWrite = source.blueWrite;\n    this.alphaWrite = source.alphaWrite;\n    return this;\n  }\n  clone() {\n    const clone = new this.constructor();\n    return clone.copy(this);\n  }\n  _updateMeshInstanceKeys() {\n    const meshInstances = this.meshInstances;\n    for (let i = 0; i < meshInstances.length; i++) {\n      meshInstances[i].updateKey();\n    }\n  }\n  updateUniforms(device, scene) {}\n  getShaderVariant(device, scene, objDefs, staticLightList, pass, sortedLights, viewUniformFormat, viewBindGroupFormat) {\n    const key = `shader-id-${this._shader.id}`;\n    const shaderDefinition = this._shader.definition;\n    const materialGenerator = {\n      generateKey: function (options) {\n        return key;\n      },\n      createShaderDefinition: function (device, options) {\n        return shaderDefinition;\n      }\n    };\n    const libraryModuleName = 'shader';\n    const library = (0,_shader_lib_get_program_library_js__WEBPACK_IMPORTED_MODULE_2__.getProgramLibrary)(device);\n    library.register(libraryModuleName, materialGenerator);\n    const processingOptions = new _platform_graphics_shader_processor_options_js__WEBPACK_IMPORTED_MODULE_3__.ShaderProcessorOptions(viewUniformFormat, viewBindGroupFormat);\n    const variant = library.getProgram(libraryModuleName, {}, processingOptions);\n    library.unregister(libraryModuleName);\n    return variant;\n  }\n  update() {\n    this.dirty = true;\n    if (this._shader) this._shader.failed = false;\n  }\n  clearParameters() {\n    this.parameters = {};\n  }\n  getParameters() {\n    return this.parameters;\n  }\n  clearVariants() {\n    this.variants = {};\n    const meshInstances = this.meshInstances;\n    const count = meshInstances.length;\n    for (let i = 0; i < count; i++) {\n      meshInstances[i].clearShaders();\n    }\n  }\n  getParameter(name) {\n    return this.parameters[name];\n  }\n  setParameter(name, data) {\n    if (data === undefined && typeof name === 'object') {\n      const uniformObject = name;\n      if (uniformObject.length) {\n        for (let i = 0; i < uniformObject.length; i++) {\n          this.setParameter(uniformObject[i]);\n        }\n        return;\n      }\n      name = uniformObject.name;\n      data = uniformObject.value;\n    }\n    const param = this.parameters[name];\n    if (param) {\n      param.data = data;\n    } else {\n      this.parameters[name] = {\n        scopeId: null,\n        data: data\n      };\n    }\n  }\n  deleteParameter(name) {\n    if (this.parameters[name]) {\n      delete this.parameters[name];\n    }\n  }\n  setParameters(device, names) {\n    const parameters = this.parameters;\n    if (names === undefined) names = parameters;\n    for (const paramName in names) {\n      const parameter = parameters[paramName];\n      if (parameter) {\n        if (!parameter.scopeId) {\n          parameter.scopeId = device.scope.resolve(paramName);\n        }\n        parameter.scopeId.setValue(parameter.data);\n      }\n    }\n  }\n  destroy() {\n    this.variants = {};\n    this._shader = null;\n    for (let i = 0; i < this.meshInstances.length; i++) {\n      const meshInstance = this.meshInstances[i];\n      meshInstance.clearShaders();\n      meshInstance._material = null;\n      if (meshInstance.mesh) {\n        const defaultMaterial = (0,_default_material_js__WEBPACK_IMPORTED_MODULE_4__.getDefaultMaterial)(meshInstance.mesh.device);\n        if (this !== defaultMaterial) {\n          meshInstance.material = defaultMaterial;\n        }\n      }\n    }\n    this.meshInstances.length = 0;\n  }\n  addMeshInstanceRef(meshInstance) {\n    this.meshInstances.push(meshInstance);\n  }\n  removeMeshInstanceRef(meshInstance) {\n    const meshInstances = this.meshInstances;\n    const i = meshInstances.indexOf(meshInstance);\n    if (i !== -1) {\n      meshInstances.splice(i, 1);\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/material.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material-options-builder.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material-options-builder.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"StandardMaterialOptionsBuilder\": () => (/* binding */ StandardMaterialOptionsBuilder)\n/* harmony export */ });\n/* harmony import */ var _core_math_quat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/math/quat.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/quat.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _shader_lib_programs_standard_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shader-lib/programs/standard.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/programs/standard.js\");\n\n\n\n\n\nconst arraysEqual = (a, b) => {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; ++i) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n};\nconst notWhite = color => {\n  return color.r !== 1 || color.g !== 1 || color.b !== 1;\n};\nconst notBlack = color => {\n  return color.r !== 0 || color.g !== 0 || color.b !== 0;\n};\nclass StandardMaterialOptionsBuilder {\n  constructor() {\n    this._mapXForms = null;\n  }\n  updateMinRef(options, scene, stdMat, objDefs, staticLightList, pass, sortedLights) {\n    this._updateSharedOptions(options, scene, stdMat, objDefs, pass);\n    this._updateMinOptions(options, stdMat);\n    this._updateUVOptions(options, stdMat, objDefs, true);\n    options.litOptions.chunks = options.chunks;\n  }\n  updateRef(options, scene, stdMat, objDefs, staticLightList, pass, sortedLights) {\n    this._updateSharedOptions(options, scene, stdMat, objDefs, pass);\n    this._updateEnvOptions(options, stdMat, scene);\n    this._updateMaterialOptions(options, stdMat);\n    if (pass === _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADER_FORWARDHDR) {\n      if (options.litOptions.gamma) options.litOptions.gamma = _constants_js__WEBPACK_IMPORTED_MODULE_0__.GAMMA_SRGBHDR;\n      options.litOptions.toneMap = _constants_js__WEBPACK_IMPORTED_MODULE_0__.TONEMAP_LINEAR;\n    }\n    options.litOptions.hasTangents = objDefs && (objDefs & _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADERDEF_TANGENTS) !== 0;\n    this._updateLightOptions(options, scene, stdMat, objDefs, sortedLights, staticLightList);\n    this._updateUVOptions(options, stdMat, objDefs, false);\n    options.litOptions.chunks = options.chunks;\n  }\n  _updateSharedOptions(options, scene, stdMat, objDefs, pass) {\n    options.forceUv1 = stdMat.forceUv1;\n    options.chunks = stdMat.chunks || '';\n    options.pass = pass;\n    options.litOptions.alphaTest = stdMat.alphaTest > 0;\n    options.litOptions.forceFragmentPrecision = stdMat.forceFragmentPrecision || '';\n    options.litOptions.blendType = stdMat.blendType;\n    options.litOptions.separateAmbient = false;\n    options.litOptions.screenSpace = objDefs && (objDefs & _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADERDEF_SCREENSPACE) !== 0;\n    options.litOptions.skin = objDefs && (objDefs & _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADERDEF_SKIN) !== 0;\n    options.litOptions.useInstancing = objDefs && (objDefs & _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADERDEF_INSTANCING) !== 0;\n    options.litOptions.useMorphPosition = objDefs && (objDefs & _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADERDEF_MORPH_POSITION) !== 0;\n    options.litOptions.useMorphNormal = objDefs && (objDefs & _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADERDEF_MORPH_NORMAL) !== 0;\n    options.litOptions.useMorphTextureBased = objDefs && (objDefs & _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADERDEF_MORPH_TEXTURE_BASED) !== 0;\n    options.litOptions.nineSlicedMode = stdMat.nineSlicedMode || 0;\n    if (scene.clusteredLightingEnabled && stdMat.useLighting) {\n      options.litOptions.clusteredLightingEnabled = true;\n      options.litOptions.clusteredLightingCookiesEnabled = scene.lighting.cookiesEnabled;\n      options.litOptions.clusteredLightingShadowsEnabled = scene.lighting.shadowsEnabled;\n      options.litOptions.clusteredLightingShadowType = scene.lighting.shadowType;\n      options.litOptions.clusteredLightingAreaLightsEnabled = scene.lighting.areaLightsEnabled;\n    } else {\n      options.litOptions.clusteredLightingEnabled = false;\n      options.litOptions.clusteredLightingCookiesEnabled = false;\n      options.litOptions.clusteredLightingShadowsEnabled = false;\n      options.litOptions.clusteredLightingAreaLightsEnabled = false;\n    }\n  }\n  _updateUVOptions(options, stdMat, objDefs, minimalOptions) {\n    let hasUv0 = false;\n    let hasUv1 = false;\n    let hasVcolor = false;\n    if (objDefs) {\n      hasUv0 = (objDefs & _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADERDEF_UV0) !== 0;\n      hasUv1 = (objDefs & _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADERDEF_UV1) !== 0;\n      hasVcolor = (objDefs & _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADERDEF_VCOLOR) !== 0;\n    }\n    options.litOptions.vertexColors = false;\n    this._mapXForms = [];\n    const uniqueTextureMap = {};\n    for (const p in _shader_lib_programs_standard_js__WEBPACK_IMPORTED_MODULE_1__._matTex2D) {\n      this._updateTexOptions(options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions, uniqueTextureMap);\n    }\n    this._mapXForms = null;\n    options.litOptions.lightMapEnabled = options.lightMap;\n    options.litOptions.useLightMapVertexColors = options.lightVertexColors;\n    options.litOptions.dirLightMapEnabled = options.dirLightMap;\n    options.litOptions.heightMapEnabled = options.heightMap;\n    options.litOptions.normalMapEnabled = options.normalMap;\n    options.litOptions.clearCoatNormalMapEnabled = options.clearCoatNormalMap;\n    options.litOptions.aoMapEnabled = options.aoMap;\n    options.litOptions.useAoVertexColors = options.aoVertexColors;\n    options.litOptions.diffuseMapEnabled = options.diffuseMap;\n  }\n  _updateTexOptions(options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions, uniqueTextureMap) {\n    const mname = p + 'Map';\n    const vname = p + 'VertexColor';\n    const vcname = p + 'VertexColorChannel';\n    const cname = mname + 'Channel';\n    const tname = mname + 'Transform';\n    const uname = mname + 'Uv';\n    const iname = mname + 'Identifier';\n    if (p !== 'light') {\n      options[mname] = false;\n      options[iname] = undefined;\n      options[cname] = '';\n      options[tname] = 0;\n      options[uname] = 0;\n    }\n    options[vname] = false;\n    options[vcname] = '';\n    const isOpacity = p === 'opacity';\n    if (isOpacity && stdMat.blendType === _constants_js__WEBPACK_IMPORTED_MODULE_0__.BLEND_NONE && stdMat.alphaTest === 0.0 && !stdMat.alphaToCoverage) {\n      return;\n    }\n    if (!minimalOptions || isOpacity) {\n      if (p !== 'height' && stdMat[vname]) {\n        if (hasVcolor) {\n          options[vname] = stdMat[vname];\n          options[vcname] = stdMat[vcname];\n          options.litOptions.vertexColors = true;\n        }\n      }\n      if (stdMat[mname]) {\n        let allow = true;\n        if (stdMat[uname] === 0 && !hasUv0) allow = false;\n        if (stdMat[uname] === 1 && !hasUv1) allow = false;\n        if (allow) {\n          const mapId = stdMat[mname].id;\n          let identifier = uniqueTextureMap[mapId];\n          if (identifier === undefined) {\n            uniqueTextureMap[mapId] = p;\n            identifier = p;\n          }\n          options[mname] = !!stdMat[mname];\n          options[iname] = identifier;\n          options[tname] = this._getMapTransformID(stdMat.getUniform(tname), stdMat[uname]);\n          options[cname] = stdMat[cname];\n          options[uname] = stdMat[uname];\n        }\n      }\n    }\n  }\n  _updateMinOptions(options, stdMat) {\n    options.opacityTint = stdMat.opacity !== 1 && stdMat.blendType !== _constants_js__WEBPACK_IMPORTED_MODULE_0__.BLEND_NONE;\n    options.litOptions.lights = [];\n  }\n  _updateMaterialOptions(options, stdMat) {\n    var _stdMat$diffuseMap, _stdMat$diffuseDetail, _stdMat$emissiveMap, _stdMat$lightMap;\n    const diffuseTint = (stdMat.diffuseTint || !stdMat.diffuseMap && !stdMat.diffuseVertexColor) && notWhite(stdMat.diffuse);\n    const useSpecular = !!(stdMat.useMetalness || stdMat.specularMap || stdMat.sphereMap || stdMat.cubeMap || notBlack(stdMat.specular) || stdMat.specularityFactor > 0 && stdMat.useMetalness || stdMat.enableGGXSpecular || stdMat.clearCoat > 0);\n    const useSpecularColor = !stdMat.useMetalness || stdMat.useMetalnessSpecularColor;\n    const specularTint = useSpecular && (stdMat.specularTint || !stdMat.specularMap && !stdMat.specularVertexColor) && notWhite(stdMat.specular);\n    const specularityFactorTint = useSpecular && stdMat.useMetalnessSpecularColor && (stdMat.specularityFactorTint || stdMat.specularityFactor < 1 && !stdMat.specularityFactorMap);\n    const emissiveTintColor = !stdMat.emissiveMap || notWhite(stdMat.emissive) && stdMat.emissiveTint;\n    const emissiveTintIntensity = stdMat.emissiveIntensity !== 1;\n    const isPackedNormalMap = stdMat.normalMap ? stdMat.normalMap.format === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.PIXELFORMAT_DXT5 || stdMat.normalMap.type === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.TEXTURETYPE_SWIZZLEGGGR : false;\n    options.opacityTint = stdMat.opacity !== 1 && stdMat.blendType !== _constants_js__WEBPACK_IMPORTED_MODULE_0__.BLEND_NONE ? 1 : 0;\n    options.ambientTint = stdMat.ambientTint;\n    options.diffuseTint = diffuseTint ? 2 : 0;\n    options.specularTint = specularTint ? 2 : 0;\n    options.specularityFactorTint = specularityFactorTint ? 1 : 0;\n    options.metalnessTint = stdMat.useMetalness && stdMat.metalness < 1 ? 1 : 0;\n    options.glossTint = 1;\n    options.emissiveTint = (emissiveTintColor ? 2 : 0) + (emissiveTintIntensity ? 1 : 0);\n    options.diffuseEncoding = (_stdMat$diffuseMap = stdMat.diffuseMap) == null ? void 0 : _stdMat$diffuseMap.encoding;\n    options.diffuseDetailEncoding = (_stdMat$diffuseDetail = stdMat.diffuseDetailMap) == null ? void 0 : _stdMat$diffuseDetail.encoding;\n    options.emissiveEncoding = (_stdMat$emissiveMap = stdMat.emissiveMap) == null ? void 0 : _stdMat$emissiveMap.encoding;\n    options.lightMapEncoding = (_stdMat$lightMap = stdMat.lightMap) == null ? void 0 : _stdMat$lightMap.encoding;\n    options.packedNormal = isPackedNormalMap;\n    options.refractionTint = stdMat.refraction !== 1.0 ? 1 : 0;\n    options.refractionIndexTint = stdMat.refractionIndex !== 1.0 / 1.5 ? 1 : 0;\n    options.thicknessTint = stdMat.useDynamicRefraction && stdMat.thickness !== 1.0 ? 1 : 0;\n    options.specularEncoding = stdMat.specularEncoding || 'linear';\n    options.sheenEncoding = stdMat.sheenEncoding || 'linear';\n    options.aoMapUv = stdMat.aoUvSet;\n    options.diffuseDetail = !!stdMat.diffuseMap;\n    options.normalDetail = !!stdMat.normalMap;\n    options.diffuseDetailMode = stdMat.diffuseDetailMode;\n    options.clearCoatTint = stdMat.clearCoat !== 1.0 ? 1 : 0;\n    options.clearCoatGloss = !!stdMat.clearCoatGloss;\n    options.clearCoatGlossTint = stdMat.clearCoatGloss !== 1.0 ? 1 : 0;\n    options.iridescenceTint = stdMat.iridescence !== 1.0 ? 1 : 0;\n    options.sheenTint = stdMat.useSheen && notWhite(stdMat.sheen) ? 2 : 0;\n    options.sheenGlossTint = 1;\n    options.glossInvert = stdMat.glossInvert;\n    options.sheenGlossInvert = stdMat.sheenGlossInvert;\n    options.clearCoatGlossInvert = stdMat.clearCoatGlossInvert;\n    options.litOptions.useAmbientTint = options.ambientTint;\n    options.litOptions.customFragmentShader = stdMat.customFragmentShader;\n    options.litOptions.pixelSnap = stdMat.pixelSnap;\n    options.litOptions.useClearCoatNormalMap = !!stdMat.clearCoatNormalMap;\n    options.litOptions.useDiffuseMap = !!stdMat.diffuseMap;\n    options.litOptions.useAoMap = !!stdMat.aoMap;\n    options.litOptions.detailModes = !!options.diffuseDetail;\n    options.litOptions.shadingModel = stdMat.shadingModel;\n    options.litOptions.ambientSH = !!stdMat.ambientSH;\n    options.litOptions.fastTbn = stdMat.fastTbn;\n    options.litOptions.twoSidedLighting = stdMat.twoSidedLighting;\n    options.litOptions.occludeSpecular = stdMat.occludeSpecular;\n    options.litOptions.occludeSpecularFloat = stdMat.occludeSpecularIntensity !== 1.0;\n    options.litOptions.useMsdf = !!stdMat.msdfMap;\n    options.litOptions.msdfTextAttribute = !!stdMat.msdfTextAttribute;\n    options.litOptions.alphaToCoverage = stdMat.alphaToCoverage;\n    options.litOptions.opacityFadesSpecular = stdMat.opacityFadesSpecular;\n    options.litOptions.cubeMapProjection = stdMat.cubeMapProjection;\n    options.litOptions.occludeDirect = stdMat.occludeDirect;\n    options.litOptions.conserveEnergy = stdMat.conserveEnergy && stdMat.shadingModel !== _constants_js__WEBPACK_IMPORTED_MODULE_0__.SPECULAR_PHONG;\n    options.litOptions.useSpecular = useSpecular;\n    options.litOptions.useSpecularityFactor = (specularityFactorTint || !!stdMat.specularityFactorMap) && stdMat.useMetalnessSpecularColor;\n    options.litOptions.useSpecularColor = useSpecularColor;\n    options.litOptions.enableGGXSpecular = stdMat.enableGGXSpecular;\n    options.litOptions.fresnelModel = stdMat.fresnelModel;\n    options.litOptions.useRefraction = (stdMat.refraction || !!stdMat.refractionMap) && (stdMat.useDynamicRefraction || !!options.litOptions.reflectionSource);\n    options.litOptions.useClearCoat = !!stdMat.clearCoat;\n    options.litOptions.useSheen = stdMat.useSheen;\n    options.litOptions.useIridescence = stdMat.useIridescence && stdMat.iridescence !== 0.0;\n    options.litOptions.useMetalness = stdMat.useMetalness;\n    options.litOptions.useDynamicRefraction = stdMat.useDynamicRefraction;\n  }\n  _updateEnvOptions(options, stdMat, scene) {\n    options.litOptions.fog = stdMat.useFog ? scene.fog : 'none';\n    options.litOptions.gamma = stdMat.useGammaTonemap ? scene.gammaCorrection : _constants_js__WEBPACK_IMPORTED_MODULE_0__.GAMMA_NONE;\n    options.litOptions.toneMap = stdMat.useGammaTonemap ? scene.toneMapping : -1;\n    options.litOptions.fixSeams = stdMat.cubeMap ? stdMat.cubeMap.fixCubemapSeams : false;\n    const isPhong = stdMat.shadingModel === _constants_js__WEBPACK_IMPORTED_MODULE_0__.SPECULAR_PHONG;\n    let usingSceneEnv = false;\n    if (stdMat.envAtlas && stdMat.cubeMap && !isPhong) {\n      options.litOptions.reflectionSource = 'envAtlasHQ';\n      options.litOptions.reflectionEncoding = stdMat.envAtlas.encoding;\n    } else if (stdMat.envAtlas && !isPhong) {\n      options.litOptions.reflectionSource = 'envAtlas';\n      options.litOptions.reflectionEncoding = stdMat.envAtlas.encoding;\n    } else if (stdMat.cubeMap) {\n      options.litOptions.reflectionSource = 'cubeMap';\n      options.litOptions.reflectionEncoding = stdMat.cubeMap.encoding;\n    } else if (stdMat.sphereMap) {\n      options.litOptions.reflectionSource = 'sphereMap';\n      options.litOptions.reflectionEncoding = stdMat.sphereMap.encoding;\n    } else if (stdMat.useSkybox && scene.envAtlas && scene.skybox && !isPhong) {\n      options.litOptions.reflectionSource = 'envAtlasHQ';\n      options.litOptions.reflectionEncoding = scene.envAtlas.encoding;\n      usingSceneEnv = true;\n    } else if (stdMat.useSkybox && scene.envAtlas && !isPhong) {\n      options.litOptions.reflectionSource = 'envAtlas';\n      options.litOptions.reflectionEncoding = scene.envAtlas.encoding;\n      usingSceneEnv = true;\n    } else if (stdMat.useSkybox && scene.skybox) {\n      options.litOptions.reflectionSource = 'cubeMap';\n      options.litOptions.reflectionEncoding = scene.skybox.encoding;\n      usingSceneEnv = true;\n    } else {\n      options.litOptions.reflectionSource = null;\n      options.litOptions.reflectionEncoding = null;\n    }\n    if (stdMat.ambientSH && !isPhong) {\n      options.litOptions.ambientSource = 'ambientSH';\n      options.litOptions.ambientEncoding = null;\n    } else {\n      const envAtlas = stdMat.envAtlas || (stdMat.useSkybox && scene.envAtlas ? scene.envAtlas : null);\n      if (envAtlas && !isPhong) {\n        options.litOptions.ambientSource = 'envAtlas';\n        options.litOptions.ambientEncoding = envAtlas.encoding;\n      } else {\n        options.litOptions.ambientSource = 'constant';\n        options.litOptions.ambientEncoding = null;\n      }\n    }\n    options.litOptions.skyboxIntensity = usingSceneEnv && (scene.skyboxIntensity !== 1 || scene.physicalUnits);\n    options.litOptions.useCubeMapRotation = usingSceneEnv && scene.skyboxRotation && !scene.skyboxRotation.equals(_core_math_quat_js__WEBPACK_IMPORTED_MODULE_3__.Quat.IDENTITY);\n  }\n  _updateLightOptions(options, scene, stdMat, objDefs, sortedLights, staticLightList) {\n    options.lightMap = false;\n    options.lightMapChannel = '';\n    options.lightMapUv = 0;\n    options.lightMapTransform = 0;\n    options.litOptions.lightMapWithoutAmbient = false;\n    options.dirLightMap = false;\n    if (objDefs) {\n      options.litOptions.noShadow = (objDefs & _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADERDEF_NOSHADOW) !== 0;\n      if ((objDefs & _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADERDEF_LM) !== 0) {\n        options.lightMapEncoding = scene.lightmapPixelFormat === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_2__.PIXELFORMAT_RGBA8 ? 'rgbm' : 'linear';\n        options.lightMap = true;\n        options.lightMapChannel = 'rgb';\n        options.lightMapUv = 1;\n        options.lightMapTransform = 0;\n        options.litOptions.lightMapWithoutAmbient = !stdMat.lightMap;\n        if ((objDefs & _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADERDEF_DIRLM) !== 0) {\n          options.dirLightMap = true;\n        }\n        if ((objDefs & _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADERDEF_LMAMBIENT) !== 0) {\n          options.litOptions.lightMapWithoutAmbient = false;\n        }\n      }\n    }\n    if (stdMat.useLighting) {\n      const lightsFiltered = [];\n      const mask = objDefs ? objDefs >> 16 : _constants_js__WEBPACK_IMPORTED_MODULE_0__.MASK_AFFECT_DYNAMIC;\n      options.litOptions.lightMaskDynamic = !!(mask & _constants_js__WEBPACK_IMPORTED_MODULE_0__.MASK_AFFECT_DYNAMIC);\n      if (sortedLights) {\n        this._collectLights(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LIGHTTYPE_DIRECTIONAL, sortedLights[_constants_js__WEBPACK_IMPORTED_MODULE_0__.LIGHTTYPE_DIRECTIONAL], lightsFiltered, mask);\n        this._collectLights(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LIGHTTYPE_OMNI, sortedLights[_constants_js__WEBPACK_IMPORTED_MODULE_0__.LIGHTTYPE_OMNI], lightsFiltered, mask, staticLightList);\n        this._collectLights(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LIGHTTYPE_SPOT, sortedLights[_constants_js__WEBPACK_IMPORTED_MODULE_0__.LIGHTTYPE_SPOT], lightsFiltered, mask, staticLightList);\n      }\n      options.litOptions.lights = lightsFiltered;\n    } else {\n      options.litOptions.lights = [];\n    }\n    if (options.litOptions.lights.length === 0) {\n      options.litOptions.noShadow = true;\n    }\n  }\n  _collectLights(lType, lights, lightsFiltered, mask, staticLightList) {\n    for (let i = 0; i < lights.length; i++) {\n      const light = lights[i];\n      if (light.enabled) {\n        if (light.mask & mask) {\n          if (lType !== _constants_js__WEBPACK_IMPORTED_MODULE_0__.LIGHTTYPE_DIRECTIONAL) {\n            if (light.isStatic) {\n              continue;\n            }\n          }\n          lightsFiltered.push(light);\n        }\n      }\n    }\n    if (staticLightList) {\n      for (let i = 0; i < staticLightList.length; i++) {\n        const light = staticLightList[i];\n        if (light._type === lType) {\n          lightsFiltered.push(light);\n        }\n      }\n    }\n  }\n  _getMapTransformID(xform, uv) {\n    if (!xform) return 0;\n    let xforms = this._mapXForms[uv];\n    if (!xforms) {\n      xforms = [];\n      this._mapXForms[uv] = xforms;\n    }\n    for (let i = 0; i < xforms.length; i++) {\n      if (arraysEqual(xforms[i][0].value, xform[0].value) && arraysEqual(xforms[i][1].value, xform[1].value)) {\n        return i + 1;\n      }\n    }\n    return xforms.push(xform);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material-options-builder.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material-options.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material-options.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"StandardMaterialOptions\": () => (/* binding */ StandardMaterialOptions)\n/* harmony export */ });\n/* harmony import */ var _lit_options_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lit-options.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/lit-options.js\");\n\n\nclass StandardMaterialOptions {\n  constructor() {\n    this.chunks = [];\n    this._pass = 0;\n    this.forceUv1 = false;\n    this.ambientTint = false;\n    this.diffuseTint = false;\n    this.specularTint = false;\n    this.metalnessTint = false;\n    this.glossTint = false;\n    this.emissiveTint = false;\n    this.opacityTint = false;\n    this.emissiveEncoding = 'linear';\n    this.lightMapEncoding = 'linear';\n    this.packedNormal = false;\n    this.glossInvert = false;\n    this.sheenGlossInvert = false;\n    this.clearCoatGlossInvert = false;\n    this.litOptions = new _lit_options_js__WEBPACK_IMPORTED_MODULE_0__.LitOptions();\n  }\n  set pass(p) {\n    this._pass = p;\n    this.litOptions._pass = p;\n  }\n  get pass() {\n    return this._pass;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material-options.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material-parameters.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material-parameters.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"standardMaterialCubemapParameters\": () => (/* binding */ standardMaterialCubemapParameters),\n/* harmony export */   \"standardMaterialParameterTypes\": () => (/* binding */ standardMaterialParameterTypes),\n/* harmony export */   \"standardMaterialRemovedParameters\": () => (/* binding */ standardMaterialRemovedParameters),\n/* harmony export */   \"standardMaterialTextureParameters\": () => (/* binding */ standardMaterialTextureParameters)\n/* harmony export */ });\n/* harmony import */ var _virtual_rollupPluginBabelHelpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_virtual/_rollupPluginBabelHelpers.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/_virtual/_rollupPluginBabelHelpers.js\");\n\n\nfunction _textureParameter(name, channel = true, vertexColor = true) {\n  const result = {};\n  result[`${name}Map`] = 'texture';\n  result[`${name}MapTiling`] = 'vec2';\n  result[`${name}MapOffset`] = 'vec2';\n  result[`${name}MapRotation`] = 'number';\n  result[`${name}MapUv`] = 'number';\n  if (channel) {\n    result[`${name}MapChannel`] = 'string';\n    if (vertexColor) {\n      result[`${name}VertexColor`] = 'boolean';\n      result[`${name}VertexColorChannel`] = 'string';\n    }\n  }\n  return result;\n}\nconst standardMaterialParameterTypes = (0,_virtual_rollupPluginBabelHelpers_js__WEBPACK_IMPORTED_MODULE_0__[\"extends\"])({\n  name: 'string',\n  chunks: 'chunks',\n  mappingFormat: 'string',\n  _engine: 'boolean',\n  ambient: 'rgb',\n  ambientTint: 'boolean'\n}, _textureParameter('ao'), {\n  diffuse: 'rgb',\n  diffuseTint: 'boolean'\n}, _textureParameter('diffuse'), _textureParameter('diffuseDetail', true, false), {\n  diffuseDetailMode: 'string',\n  specular: 'rgb',\n  specularTint: 'boolean'\n}, _textureParameter('specular'), {\n  occludeSpecular: 'enum:occludeSpecular',\n  specularityFactor: 'number',\n  specularityFactorTint: 'boolean'\n}, _textureParameter('specularityFactor'), {\n  useMetalness: 'boolean',\n  metalness: 'number',\n  enableGGXSpecular: 'boolean',\n  anisotropy: 'number',\n  metalnessTint: 'boolean'\n}, _textureParameter('metalness'), {\n  useMetalnessSpecularColor: 'boolean',\n  conserveEnergy: 'boolean',\n  shininess: 'number',\n  gloss: 'number',\n  glossInvert: 'boolean'\n}, _textureParameter('gloss'), {\n  clearCoat: 'number'\n}, _textureParameter('clearCoat'), {\n  clearCoatGloss: 'number',\n  clearCoatGlossInvert: 'boolean'\n}, _textureParameter('clearCoatGloss'), {\n  clearCoatBumpiness: 'number'\n}, _textureParameter('clearCoatNormal', false), {\n  useSheen: 'boolean',\n  sheen: 'rgb',\n  sheenTint: 'boolean'\n}, _textureParameter('sheen'), {\n  sheenGloss: 'number',\n  sheenGlossTint: 'boolean',\n  sheenGlossInvert: 'boolean'\n}, _textureParameter('sheenGloss'), {\n  fresnelModel: 'number',\n  emissive: 'rgb',\n  emissiveTint: 'boolean'\n}, _textureParameter('emissive'), {\n  emissiveIntensity: 'number'\n}, _textureParameter('normal', false), {\n  bumpiness: 'number'\n}, _textureParameter('normalDetail', false), {\n  normalDetailMapBumpiness: 'number'\n}, _textureParameter('height', true, false), {\n  heightMapFactor: 'number',\n  alphaToCoverage: 'boolean',\n  alphaTest: 'number',\n  alphaFade: 'number',\n  opacity: 'number'\n}, _textureParameter('opacity'), {\n  opacityFadesSpecular: 'boolean',\n  reflectivity: 'number',\n  refraction: 'number',\n  refractionTint: 'boolean'\n}, _textureParameter('refraction'), {\n  refractionIndex: 'number',\n  thickness: 'number',\n  thicknessTint: 'boolean'\n}, _textureParameter('thickness'), {\n  attenuation: 'rgb',\n  attenuationDistance: 'number',\n  useDynamicRefraction: 'boolean',\n  sphereMap: 'texture',\n  cubeMap: 'cubemap',\n  cubeMapProjection: 'number',\n  cubeMapProjectionBox: 'boundingbox',\n  useIridescence: 'boolean',\n  iridescence: 'number',\n  iridescenceTint: 'boolean'\n}, _textureParameter('iridescence'), {\n  iridescenceThicknessTint: 'boolean',\n  iridescenceThicknessMin: 'number',\n  iridescenceThicknessMax: 'number',\n  iridescenceRefractionIndex: 'number'\n}, _textureParameter('iridescenceThickness'), _textureParameter('light'), {\n  depthTest: 'boolean',\n  depthFunc: 'enum:depthFunc',\n  depthWrite: 'boolean',\n  depthBias: 'number',\n  slopeDepthBias: 'number',\n  cull: 'enum:cull',\n  blendType: 'enum:blendType',\n  shadingModel: 'enum:shadingModel',\n  useFog: 'boolean',\n  useLighting: 'boolean',\n  useSkybox: 'boolean',\n  useGammaTonemap: 'boolean',\n  envAtlas: 'texture',\n  twoSidedLighting: 'boolean'\n});\nconst standardMaterialTextureParameters = [];\nfor (const key in standardMaterialParameterTypes) {\n  const type = standardMaterialParameterTypes[key];\n  if (type === 'texture') {\n    standardMaterialTextureParameters.push(key);\n  }\n}\nconst standardMaterialCubemapParameters = [];\nfor (const key in standardMaterialParameterTypes) {\n  const type = standardMaterialParameterTypes[key];\n  if (type === 'cubemap') {\n    standardMaterialCubemapParameters.push(key);\n  }\n}\nconst standardMaterialRemovedParameters = {\n  aoMapVertexColor: 'boolean',\n  diffuseMapTint: 'boolean',\n  diffuseMapVertexColor: 'boolean',\n  emissiveMapTint: 'boolean',\n  emissiveMapVertexColor: 'boolean',\n  glossMapVertexColor: 'boolean',\n  metalnessMapVertexColor: 'boolean',\n  opacityMapVertexColor: 'boolean',\n  specularAntialias: 'boolean',\n  specularMapTint: 'boolean',\n  specularMapVertexColor: 'boolean'\n};\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material-parameters.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material-validator.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material-validator.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"StandardMaterialValidator\": () => (/* binding */ StandardMaterialValidator)\n/* harmony export */ });\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../platform/graphics/texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _standard_material_parameters_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./standard-material-parameters.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material-parameters.js\");\n\n\n\n\n\n\nclass StandardMaterialValidator {\n  constructor() {\n    this.removeInvalid = true;\n    this.valid = true;\n    this.enumValidators = {\n      occludeSpecular: this._createEnumValidator([_constants_js__WEBPACK_IMPORTED_MODULE_0__.SPECOCC_NONE, _constants_js__WEBPACK_IMPORTED_MODULE_0__.SPECOCC_AO, _constants_js__WEBPACK_IMPORTED_MODULE_0__.SPECOCC_GLOSSDEPENDENT]),\n      cull: this._createEnumValidator([_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.CULLFACE_NONE, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.CULLFACE_BACK, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.CULLFACE_FRONT, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.CULLFACE_FRONTANDBACK]),\n      blendType: this._createEnumValidator([_constants_js__WEBPACK_IMPORTED_MODULE_0__.BLEND_SUBTRACTIVE, _constants_js__WEBPACK_IMPORTED_MODULE_0__.BLEND_ADDITIVE, _constants_js__WEBPACK_IMPORTED_MODULE_0__.BLEND_NORMAL, _constants_js__WEBPACK_IMPORTED_MODULE_0__.BLEND_NONE, _constants_js__WEBPACK_IMPORTED_MODULE_0__.BLEND_PREMULTIPLIED, _constants_js__WEBPACK_IMPORTED_MODULE_0__.BLEND_MULTIPLICATIVE, _constants_js__WEBPACK_IMPORTED_MODULE_0__.BLEND_ADDITIVEALPHA, _constants_js__WEBPACK_IMPORTED_MODULE_0__.BLEND_MULTIPLICATIVE2X, _constants_js__WEBPACK_IMPORTED_MODULE_0__.BLEND_SCREEN, _constants_js__WEBPACK_IMPORTED_MODULE_0__.BLEND_MIN, _constants_js__WEBPACK_IMPORTED_MODULE_0__.BLEND_MAX]),\n      depthFunc: this._createEnumValidator([_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.FUNC_NEVER, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.FUNC_LESS, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.FUNC_EQUAL, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.FUNC_LESSEQUAL, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.FUNC_GREATER, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.FUNC_NOTEQUAL, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.FUNC_GREATEREQUAL, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.FUNC_ALWAYS]),\n      shadingModel: this._createEnumValidator([_constants_js__WEBPACK_IMPORTED_MODULE_0__.SPECULAR_PHONG, _constants_js__WEBPACK_IMPORTED_MODULE_0__.SPECULAR_BLINN])\n    };\n  }\n  setInvalid(key, data) {\n    this.valid = false;\n    if (this.removeInvalid) {\n      delete data[key];\n    }\n  }\n  validate(data) {\n    const TYPES = _standard_material_parameters_js__WEBPACK_IMPORTED_MODULE_2__.standardMaterialParameterTypes;\n    const REMOVED = _standard_material_parameters_js__WEBPACK_IMPORTED_MODULE_2__.standardMaterialRemovedParameters;\n    const pathMapping = data.mappingFormat === 'path';\n    for (const key in data) {\n      const type = TYPES[key];\n      if (!type) {\n        if (REMOVED[key]) {\n          delete data[key];\n        } else {\n          this.valid = false;\n        }\n        continue;\n      }\n      if (type.startsWith('enum')) {\n        const enumType = type.split(':')[1];\n        if (this.enumValidators[enumType]) {\n          if (!this.enumValidators[enumType](data[key])) {\n            this.setInvalid(key, data);\n          }\n        }\n      } else if (type === 'number') {\n        if (typeof data[key] !== 'number') {\n          this.setInvalid(key, data);\n        }\n      } else if (type === 'boolean') {\n        if (typeof data[key] !== 'boolean') {\n          this.setInvalid(key, data);\n        }\n      } else if (type === 'string') {\n        if (typeof data[key] !== 'string') {\n          this.setInvalid(key, data);\n        }\n      } else if (type === 'vec2') {\n        if (!(data[key] instanceof Array && data[key].length === 2)) {\n          this.setInvalid(key, data);\n        }\n      } else if (type === 'rgb') {\n        if (!(data[key] instanceof Array && data[key].length === 3)) {\n          this.setInvalid(key, data);\n        }\n      } else if (type === 'texture') {\n        if (!pathMapping) {\n          if (!(typeof data[key] === 'number' || data[key] === null)) {\n            if (!(data[key] instanceof _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_3__.Texture)) {\n              this.setInvalid(key, data);\n            }\n          }\n        } else {\n          if (!(typeof data[key] === 'string' || data[key] === null)) {\n            if (!(data[key] instanceof _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_3__.Texture)) {\n              this.setInvalid(key, data);\n            }\n          }\n        }\n      } else if (type === 'boundingbox') {\n        if (!(data[key].center && data[key].center instanceof Array && data[key].center.length === 3)) {\n          this.setInvalid(key, data);\n        }\n        if (!(data[key].halfExtents && data[key].halfExtents instanceof Array && data[key].halfExtents.length === 3)) {\n          this.setInvalid(key, data);\n        }\n      } else if (type === 'cubemap') {\n        if (!(typeof data[key] === 'number' || data[key] === null || data[key] === undefined)) {\n          if (!(data[key] instanceof _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_3__.Texture && data[key].cubemap)) {\n            this.setInvalid(key, data);\n          }\n        }\n      } else if (type === 'chunks') {\n        const chunkNames = Object.keys(data[key]);\n        for (let i = 0; i < chunkNames.length; i++) {\n          if (typeof data[key][chunkNames[i]] !== 'string') {\n            this.setInvalid(chunkNames[i], data[key]);\n          }\n        }\n      } else {\n        console.error('Unknown material type: ' + type);\n      }\n    }\n    data.validated = true;\n    return this.valid;\n  }\n  _createEnumValidator(values) {\n    return function (value) {\n      return values.indexOf(value) >= 0;\n    };\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material-validator.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"StandardMaterial\": () => (/* binding */ StandardMaterial)\n/* harmony export */ });\n/* harmony import */ var _core_math_color_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/math/color.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _platform_graphics_shader_processor_options_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../platform/graphics/shader-processor-options.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-processor-options.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _shader_pass_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shader-pass.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-pass.js\");\n/* harmony import */ var _graphics_env_lighting_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../graphics/env-lighting.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/graphics/env-lighting.js\");\n/* harmony import */ var _shader_lib_get_program_library_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../shader-lib/get-program-library.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/get-program-library.js\");\n/* harmony import */ var _shader_lib_programs_standard_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shader-lib/programs/standard.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/programs/standard.js\");\n/* harmony import */ var _material_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./material.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/material.js\");\n/* harmony import */ var _standard_material_options_builder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./standard-material-options-builder.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material-options-builder.js\");\n/* harmony import */ var _standard_material_parameters_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./standard-material-parameters.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material-parameters.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst _props = {};\nconst _uniforms = {};\nlet _params = new Set();\nclass StandardMaterial extends _material_js__WEBPACK_IMPORTED_MODULE_0__.Material {\n  constructor() {\n    super();\n    this._dirtyShader = true;\n    this._assetReferences = {};\n    this._activeParams = new Set();\n    this._activeLightingParams = new Set();\n    this.shaderOptBuilder = new _standard_material_options_builder_js__WEBPACK_IMPORTED_MODULE_1__.StandardMaterialOptionsBuilder();\n    this.reset();\n  }\n  reset() {\n    Object.keys(_props).forEach(name => {\n      this[`_${name}`] = _props[name].value();\n    });\n    this._chunks = {};\n    this._uniformCache = {};\n  }\n  set shader(shader) {}\n  get shader() {\n    return null;\n  }\n  set chunks(value) {\n    this._dirtyShader = true;\n    this._chunks = value;\n  }\n  get chunks() {\n    this._dirtyShader = true;\n    return this._chunks;\n  }\n  copy(source) {\n    super.copy(source);\n    Object.keys(_props).forEach(k => {\n      this[k] = source[k];\n    });\n    for (const p in source._chunks) {\n      if (source._chunks.hasOwnProperty(p)) this._chunks[p] = source._chunks[p];\n    }\n    return this;\n  }\n  _setParameter(name, value) {\n    _params.add(name);\n    this.setParameter(name, value);\n  }\n  _setParameters(parameters) {\n    parameters.forEach(v => {\n      this._setParameter(v.name, v.value);\n    });\n  }\n  _processParameters(paramsName) {\n    const prevParams = this[paramsName];\n    prevParams.forEach(param => {\n      if (!_params.has(param)) {\n        delete this.parameters[param];\n      }\n    });\n    this[paramsName] = _params;\n    _params = prevParams;\n    _params.clear();\n  }\n  _updateMap(p) {\n    const mname = p + 'Map';\n    const map = this[mname];\n    if (map) {\n      this._setParameter('texture_' + mname, map);\n      const tname = mname + 'Transform';\n      const uniform = this.getUniform(tname);\n      if (uniform) {\n        this._setParameters(uniform);\n      }\n    }\n  }\n  _allocUniform(name, allocFunc) {\n    let uniform = this._uniformCache[name];\n    if (!uniform) {\n      uniform = allocFunc();\n      this._uniformCache[name] = uniform;\n    }\n    return uniform;\n  }\n  getUniform(name, device, scene) {\n    return _uniforms[name](this, device, scene);\n  }\n  updateUniforms(device, scene) {\n    const getUniform = name => {\n      return this.getUniform(name, device, scene);\n    };\n    this._setParameter('material_ambient', getUniform('ambient'));\n    if (!this.diffuseMap || this.diffuseTint) {\n      this._setParameter('material_diffuse', getUniform('diffuse'));\n    }\n    if (!this.useMetalness) {\n      if (!this.specularMap || this.specularTint) {\n        this._setParameter('material_specular', getUniform('specular'));\n      }\n    } else {\n      if (!this.metalnessMap || this.metalness < 1) {\n        this._setParameter('material_metalness', this.metalness);\n      }\n      if (!this.specularMap || this.specularTint) {\n        this._setParameter('material_specular', getUniform('specular'));\n      }\n      if (!this.specularityFactorMap || this.specularityFactorTint) {\n        this._setParameter('material_specularityFactor', this.specularityFactor);\n      }\n      if (!this.sheenMap || this.sheenTint) {\n        this._setParameter('material_sheen', getUniform('sheen'));\n      }\n      if (!this.sheenGlossMap || this.sheenGlossTint) {\n        this._setParameter('material_sheenGloss', this.sheenGloss);\n      }\n      if (this.refractionIndex !== 1.0 / 1.5) {\n        const oneOverRefractionIndex = 1.0 / this.refractionIndex;\n        const f0 = (oneOverRefractionIndex - 1) / (oneOverRefractionIndex + 1);\n        this._setParameter('material_f0', f0 * f0);\n      } else {\n        this._setParameter('material_f0', 0.04);\n      }\n    }\n    if (this.enableGGXSpecular) {\n      this._setParameter('material_anisotropy', this.anisotropy);\n    }\n    if (this.clearCoat > 0) {\n      this._setParameter('material_clearCoat', this.clearCoat);\n      this._setParameter('material_clearCoatGloss', this.clearCoatGloss);\n      this._setParameter('material_clearCoatBumpiness', this.clearCoatBumpiness);\n    }\n    this._setParameter('material_gloss', getUniform('gloss'));\n    if (!this.emissiveMap || this.emissiveTint) {\n      this._setParameter('material_emissive', getUniform('emissive'));\n    }\n    if (this.emissiveIntensity !== 1) {\n      this._setParameter('material_emissiveIntensity', this.emissiveIntensity);\n    }\n    if (this.refraction > 0) {\n      this._setParameter('material_refraction', this.refraction);\n      this._setParameter('material_refractionIndex', this.refractionIndex);\n    }\n    if (this.useDynamicRefraction) {\n      this._setParameter('material_thickness', this.thickness);\n      this._setParameter('material_attenuation', getUniform('attenuation'));\n      this._setParameter('material_invAttenuationDistance', this.attenuationDistance === 0 ? 0 : 1.0 / this.attenuationDistance);\n    }\n    if (this.useIridescence) {\n      this._setParameter('material_iridescence', this.iridescence);\n      this._setParameter('material_iridescenceRefractionIndex', this.iridescenceRefractionIndex);\n      this._setParameter('material_iridescenceThicknessMin', this.iridescenceThicknessMin);\n      this._setParameter('material_iridescenceThicknessMax', this.iridescenceThicknessMax);\n    }\n    this._setParameter('material_opacity', this.opacity);\n    if (this.opacityFadesSpecular === false) {\n      this._setParameter('material_alphaFade', this.alphaFade);\n    }\n    if (this.occludeSpecular) {\n      this._setParameter('material_occludeSpecularIntensity', this.occludeSpecularIntensity);\n    }\n    if (this.cubeMapProjection === _constants_js__WEBPACK_IMPORTED_MODULE_2__.CUBEPROJ_BOX) {\n      this._setParameter(getUniform('cubeMapProjectionBox'));\n    }\n    for (const p in _shader_lib_programs_standard_js__WEBPACK_IMPORTED_MODULE_3__._matTex2D) {\n      this._updateMap(p);\n    }\n    if (this.ambientSH) {\n      this._setParameter('ambientSH[0]', this.ambientSH);\n    }\n    if (this.normalMap) {\n      this._setParameter('material_bumpiness', this.bumpiness);\n    }\n    if (this.normalMap && this.normalDetailMap) {\n      this._setParameter('material_normalDetailMapBumpiness', this.normalDetailMapBumpiness);\n    }\n    if (this.heightMap) {\n      this._setParameter('material_heightMapFactor', getUniform('heightMapFactor'));\n    }\n    const isPhong = this.shadingModel === _constants_js__WEBPACK_IMPORTED_MODULE_2__.SPECULAR_PHONG;\n    if (this.envAtlas && this.cubeMap && !isPhong) {\n      this._setParameter('texture_envAtlas', this.envAtlas);\n      this._setParameter('texture_cubeMap', this.cubeMap);\n    } else if (this.envAtlas && !isPhong) {\n      this._setParameter('texture_envAtlas', this.envAtlas);\n    } else if (this.cubeMap) {\n      this._setParameter('texture_cubeMap', this.cubeMap);\n    } else if (this.sphereMap) {\n      this._setParameter('texture_sphereMap', this.sphereMap);\n    }\n    this._setParameter('material_reflectivity', this.reflectivity);\n    this._processParameters('_activeParams');\n    if (this._dirtyShader) {\n      this.clearVariants();\n    }\n  }\n  updateEnvUniforms(device, scene) {\n    const isPhong = this.shadingModel === _constants_js__WEBPACK_IMPORTED_MODULE_2__.SPECULAR_PHONG;\n    const hasLocalEnvOverride = this.envAtlas && !isPhong || this.cubeMap || this.sphereMap;\n    if (!hasLocalEnvOverride && this.useSkybox) {\n      if (scene.envAtlas && scene.skybox && !isPhong) {\n        this._setParameter('texture_envAtlas', scene.envAtlas);\n        this._setParameter('texture_cubeMap', scene.skybox);\n      } else if (scene.envAtlas && !isPhong) {\n        this._setParameter('texture_envAtlas', scene.envAtlas);\n      } else if (scene.skybox) {\n        this._setParameter('texture_cubeMap', scene.skybox);\n      }\n    }\n    this._processParameters('_activeLightingParams');\n  }\n  getShaderVariant(device, scene, objDefs, staticLightList, pass, sortedLights, viewUniformFormat, viewBindGroupFormat) {\n    this.updateEnvUniforms(device, scene);\n    const minimalOptions = pass === _constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADER_DEPTH || pass === _constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADER_PICK || _shader_pass_js__WEBPACK_IMPORTED_MODULE_4__.ShaderPass.isShadow(pass);\n    let options = minimalOptions ? _shader_lib_programs_standard_js__WEBPACK_IMPORTED_MODULE_3__.standard.optionsContextMin : _shader_lib_programs_standard_js__WEBPACK_IMPORTED_MODULE_3__.standard.optionsContext;\n    if (minimalOptions) this.shaderOptBuilder.updateMinRef(options, scene, this, objDefs, staticLightList, pass, sortedLights);else this.shaderOptBuilder.updateRef(options, scene, this, objDefs, staticLightList, pass, sortedLights);\n    if (this.onUpdateShader) {\n      options = this.onUpdateShader(options);\n    }\n    const processingOptions = new _platform_graphics_shader_processor_options_js__WEBPACK_IMPORTED_MODULE_5__.ShaderProcessorOptions(viewUniformFormat, viewBindGroupFormat);\n    const library = (0,_shader_lib_get_program_library_js__WEBPACK_IMPORTED_MODULE_6__.getProgramLibrary)(device);\n    library.register('standard', _shader_lib_programs_standard_js__WEBPACK_IMPORTED_MODULE_3__.standard);\n    const shader = library.getProgram('standard', options, processingOptions);\n    this._dirtyShader = false;\n    return shader;\n  }\n  destroy() {\n    for (const asset in this._assetReferences) {\n      this._assetReferences[asset]._unbind();\n    }\n    this._assetReferences = null;\n    super.destroy();\n  }\n}\nStandardMaterial.TEXTURE_PARAMETERS = _standard_material_parameters_js__WEBPACK_IMPORTED_MODULE_7__.standardMaterialTextureParameters;\nStandardMaterial.CUBEMAP_PARAMETERS = _standard_material_parameters_js__WEBPACK_IMPORTED_MODULE_7__.standardMaterialCubemapParameters;\nconst defineUniform = (name, getUniformFunc) => {\n  _uniforms[name] = getUniformFunc;\n};\nconst definePropInternal = (name, constructorFunc, setterFunc, getterFunc) => {\n  Object.defineProperty(StandardMaterial.prototype, name, {\n    get: getterFunc || function () {\n      return this[`_${name}`];\n    },\n    set: setterFunc\n  });\n  _props[name] = {\n    value: constructorFunc\n  };\n};\nconst defineValueProp = prop => {\n  const internalName = `_${prop.name}`;\n  const dirtyShaderFunc = prop.dirtyShaderFunc || (() => true);\n  const setterFunc = function setterFunc(value) {\n    const oldValue = this[internalName];\n    if (oldValue !== value) {\n      this._dirtyShader = this._dirtyShader || dirtyShaderFunc(oldValue, value);\n      this[internalName] = value;\n    }\n  };\n  definePropInternal(prop.name, () => prop.defaultValue, setterFunc, prop.getterFunc);\n};\nconst defineAggProp = prop => {\n  const internalName = `_${prop.name}`;\n  const dirtyShaderFunc = prop.dirtyShaderFunc || (() => true);\n  const setterFunc = function setterFunc(value) {\n    const oldValue = this[internalName];\n    if (!oldValue.equals(value)) {\n      this._dirtyShader = this._dirtyShader || dirtyShaderFunc(oldValue, value);\n      this[internalName] = oldValue.copy(value);\n    }\n  };\n  definePropInternal(prop.name, () => prop.defaultValue.clone(), setterFunc, prop.getterFunc);\n};\nconst defineProp = prop => {\n  return prop.defaultValue && prop.defaultValue.clone ? defineAggProp(prop) : defineValueProp(prop);\n};\nfunction _defineTex2D(name, channel = \"rgb\", vertexColor = true, uv = 0) {\n  _shader_lib_programs_standard_js__WEBPACK_IMPORTED_MODULE_3__._matTex2D[name] = channel.length || -1;\n  defineProp({\n    name: `${name}Map`,\n    defaultValue: null,\n    dirtyShaderFunc: (oldValue, newValue) => {\n      return !!oldValue !== !!newValue || oldValue && (oldValue.type !== newValue.type || oldValue.fixCubemapSeams !== newValue.fixCubemapSeams || oldValue.format !== newValue.format);\n    }\n  });\n  defineProp({\n    name: `${name}MapTiling`,\n    defaultValue: new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_8__.Vec2(1, 1)\n  });\n  defineProp({\n    name: `${name}MapOffset`,\n    defaultValue: new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_8__.Vec2(0, 0)\n  });\n  defineProp({\n    name: `${name}MapRotation`,\n    defaultValue: 0\n  });\n  defineProp({\n    name: `${name}MapUv`,\n    defaultValue: uv\n  });\n  if (channel) {\n    defineProp({\n      name: `${name}MapChannel`,\n      defaultValue: channel\n    });\n    if (vertexColor) {\n      defineProp({\n        name: `${name}VertexColor`,\n        defaultValue: false\n      });\n      defineProp({\n        name: `${name}VertexColorChannel`,\n        defaultValue: channel\n      });\n    }\n  }\n  const mapTiling = `${name}MapTiling`;\n  const mapOffset = `${name}MapOffset`;\n  const mapRotation = `${name}MapRotation`;\n  const mapTransform = `${name}MapTransform`;\n  defineUniform(mapTransform, (material, device, scene) => {\n    const tiling = material[mapTiling];\n    const offset = material[mapOffset];\n    const rotation = material[mapRotation];\n    if (tiling.x === 1 && tiling.y === 1 && offset.x === 0 && offset.y === 0 && rotation === 0) {\n      return null;\n    }\n    const uniform = material._allocUniform(mapTransform, () => {\n      return [{\n        name: `texture_${mapTransform}0`,\n        value: new Float32Array(3)\n      }, {\n        name: `texture_${mapTransform}1`,\n        value: new Float32Array(3)\n      }];\n    });\n    const cr = Math.cos(rotation * _core_math_math_js__WEBPACK_IMPORTED_MODULE_9__.math.DEG_TO_RAD);\n    const sr = Math.sin(rotation * _core_math_math_js__WEBPACK_IMPORTED_MODULE_9__.math.DEG_TO_RAD);\n    const uniform0 = uniform[0].value;\n    uniform0[0] = cr * tiling.x;\n    uniform0[1] = -sr * tiling.y;\n    uniform0[2] = offset.x;\n    const uniform1 = uniform[1].value;\n    uniform1[0] = sr * tiling.x;\n    uniform1[1] = cr * tiling.y;\n    uniform1[2] = 1.0 - tiling.y - offset.y;\n    return uniform;\n  });\n}\nfunction _defineColor(name, defaultValue) {\n  defineProp({\n    name: name,\n    defaultValue: defaultValue,\n    getterFunc: function () {\n      this._dirtyShader = true;\n      return this[`_${name}`];\n    }\n  });\n  defineUniform(name, (material, device, scene) => {\n    const uniform = material._allocUniform(name, () => new Float32Array(3));\n    const color = material[name];\n    const gamma = material.useGammaTonemap && scene.gammaCorrection;\n    if (gamma) {\n      uniform[0] = Math.pow(color.r, 2.2);\n      uniform[1] = Math.pow(color.g, 2.2);\n      uniform[2] = Math.pow(color.b, 2.2);\n    } else {\n      uniform[0] = color.r;\n      uniform[1] = color.g;\n      uniform[2] = color.b;\n    }\n    return uniform;\n  });\n}\nfunction _defineFloat(name, defaultValue, getUniformFunc) {\n  defineProp({\n    name: name,\n    defaultValue: defaultValue,\n    dirtyShaderFunc: (oldValue, newValue) => {\n      return (oldValue === 0 || oldValue === 1) !== (newValue === 0 || newValue === 1);\n    }\n  });\n  defineUniform(name, getUniformFunc);\n}\nfunction _defineObject(name, getUniformFunc) {\n  defineProp({\n    name: name,\n    defaultValue: null,\n    dirtyShaderFunc: (oldValue, newValue) => {\n      return !!oldValue === !!newValue;\n    }\n  });\n  defineUniform(name, getUniformFunc);\n}\nfunction _defineFlag(name, defaultValue) {\n  defineProp({\n    name: name,\n    defaultValue: defaultValue\n  });\n}\nfunction _defineMaterialProps() {\n  _defineColor('ambient', new _core_math_color_js__WEBPACK_IMPORTED_MODULE_10__.Color(0.7, 0.7, 0.7));\n  _defineColor('diffuse', new _core_math_color_js__WEBPACK_IMPORTED_MODULE_10__.Color(1, 1, 1));\n  _defineColor('specular', new _core_math_color_js__WEBPACK_IMPORTED_MODULE_10__.Color(0, 0, 0));\n  _defineColor('emissive', new _core_math_color_js__WEBPACK_IMPORTED_MODULE_10__.Color(0, 0, 0));\n  _defineColor('sheen', new _core_math_color_js__WEBPACK_IMPORTED_MODULE_10__.Color(1, 1, 1));\n  _defineColor('attenuation', new _core_math_color_js__WEBPACK_IMPORTED_MODULE_10__.Color(1, 1, 1));\n  _defineFloat('emissiveIntensity', 1);\n  _defineFloat('specularityFactor', 1);\n  _defineFloat('sheenGloss', 0.0);\n  _defineFloat('gloss', 0.25, (material, device, scene) => {\n    return material.shadingModel === _constants_js__WEBPACK_IMPORTED_MODULE_2__.SPECULAR_PHONG ? Math.pow(2, material.gloss * 11) : material.gloss;\n  });\n  Object.defineProperty(StandardMaterial.prototype, 'shininess', {\n    get: function () {\n      return this.gloss * 100;\n    },\n    set: function (value) {\n      this.gloss = value * 0.01;\n    }\n  });\n  _defineFloat('heightMapFactor', 1, (material, device, scene) => {\n    return material.heightMapFactor * 0.025;\n  });\n  _defineFloat('opacity', 1);\n  _defineFloat('alphaFade', 1);\n  _defineFloat('alphaTest', 0);\n  _defineFloat('bumpiness', 1);\n  _defineFloat('normalDetailMapBumpiness', 1);\n  _defineFloat('reflectivity', 1);\n  _defineFloat('occludeSpecularIntensity', 1);\n  _defineFloat('refraction', 0);\n  _defineFloat('refractionIndex', 1.0 / 1.5);\n  _defineFloat('thickness', 0);\n  _defineFloat('attenuationDistance', 0);\n  _defineFloat('metalness', 1);\n  _defineFloat('anisotropy', 0);\n  _defineFloat('clearCoat', 0);\n  _defineFloat('clearCoatGloss', 1);\n  _defineFloat('clearCoatBumpiness', 1);\n  _defineFloat('aoUvSet', 0, null);\n  _defineFloat('iridescence', 0);\n  _defineFloat('iridescenceRefractionIndex', 1.0 / 1.5);\n  _defineFloat('iridescenceThicknessMin', 0);\n  _defineFloat('iridescenceThicknessMax', 0);\n  _defineObject('ambientSH');\n  _defineObject('cubeMapProjectionBox', (material, device, scene) => {\n    const uniform = material._allocUniform('cubeMapProjectionBox', () => {\n      return [{\n        name: 'envBoxMin',\n        value: new Float32Array(3)\n      }, {\n        name: 'envBoxMax',\n        value: new Float32Array(3)\n      }];\n    });\n    const bboxMin = material.cubeMapProjectionBox.getMin();\n    const minUniform = uniform[0].value;\n    minUniform[0] = bboxMin.x;\n    minUniform[1] = bboxMin.y;\n    minUniform[2] = bboxMin.z;\n    const bboxMax = material.cubeMapProjectionBox.getMax();\n    const maxUniform = uniform[1].value;\n    maxUniform[0] = bboxMax.x;\n    maxUniform[1] = bboxMax.y;\n    maxUniform[2] = bboxMax.z;\n    return uniform;\n  });\n  _defineFlag('ambientTint', false);\n  _defineFlag('diffuseTint', false);\n  _defineFlag('specularTint', false);\n  _defineFlag('specularityFactorTint', false);\n  _defineFlag('emissiveTint', false);\n  _defineFlag('fastTbn', false);\n  _defineFlag('useMetalness', false);\n  _defineFlag('useMetalnessSpecularColor', false);\n  _defineFlag('useSheen', false);\n  _defineFlag('enableGGXSpecular', false);\n  _defineFlag('occludeDirect', false);\n  _defineFlag('normalizeNormalMap', true);\n  _defineFlag('conserveEnergy', true);\n  _defineFlag('opacityFadesSpecular', true);\n  _defineFlag('occludeSpecular', _constants_js__WEBPACK_IMPORTED_MODULE_2__.SPECOCC_AO);\n  _defineFlag('shadingModel', _constants_js__WEBPACK_IMPORTED_MODULE_2__.SPECULAR_BLINN);\n  _defineFlag('fresnelModel', _constants_js__WEBPACK_IMPORTED_MODULE_2__.FRESNEL_SCHLICK);\n  _defineFlag('useDynamicRefraction', false);\n  _defineFlag('cubeMapProjection', _constants_js__WEBPACK_IMPORTED_MODULE_2__.CUBEPROJ_NONE);\n  _defineFlag('customFragmentShader', null);\n  _defineFlag('forceFragmentPrecision', null);\n  _defineFlag('useFog', true);\n  _defineFlag('useLighting', true);\n  _defineFlag('useGammaTonemap', true);\n  _defineFlag('useSkybox', true);\n  _defineFlag('forceUv1', false);\n  _defineFlag('pixelSnap', false);\n  _defineFlag('twoSidedLighting', false);\n  _defineFlag('nineSlicedMode', undefined);\n  _defineFlag('msdfTextAttribute', false);\n  _defineFlag('useIridescence', false);\n  _defineFlag('glossInvert', false);\n  _defineFlag('sheenGlossInvert', false);\n  _defineFlag('clearCoatGlossInvert', false);\n  _defineTex2D('diffuse');\n  _defineTex2D('specular');\n  _defineTex2D('emissive');\n  _defineTex2D('thickness', 'g');\n  _defineTex2D('specularityFactor', 'g');\n  _defineTex2D('normal', '');\n  _defineTex2D('metalness', 'g');\n  _defineTex2D('gloss', 'g');\n  _defineTex2D('opacity', 'a');\n  _defineTex2D('refraction', 'g');\n  _defineTex2D('height', 'g', false);\n  _defineTex2D('ao', 'g');\n  _defineTex2D('light', 'rgb', true, 1);\n  _defineTex2D('msdf', '');\n  _defineTex2D('diffuseDetail', 'rgb', false);\n  _defineTex2D('normalDetail', '');\n  _defineTex2D('clearCoat', 'g');\n  _defineTex2D('clearCoatGloss', 'g');\n  _defineTex2D('clearCoatNormal', '');\n  _defineTex2D('sheen', 'rgb');\n  _defineTex2D('sheenGloss', 'g');\n  _defineTex2D('iridescence', 'g');\n  _defineTex2D('iridescenceThickness', 'g');\n  _defineFlag('diffuseDetailMode', _constants_js__WEBPACK_IMPORTED_MODULE_2__.DETAILMODE_MUL);\n  _defineObject('cubeMap');\n  _defineObject('sphereMap');\n  _defineObject('envAtlas');\n  const getterFunc = function getterFunc() {\n    return this._prefilteredCubemaps;\n  };\n  const setterFunc = function setterFunc(value) {\n    const cubemaps = this._prefilteredCubemaps;\n    value = value || [];\n    let changed = false;\n    let complete = true;\n    for (let i = 0; i < 6; ++i) {\n      const v = value[i] || null;\n      if (cubemaps[i] !== v) {\n        cubemaps[i] = v;\n        changed = true;\n      }\n      complete = complete && !!cubemaps[i];\n    }\n    if (changed) {\n      if (complete) {\n        this.envAtlas = _graphics_env_lighting_js__WEBPACK_IMPORTED_MODULE_11__.EnvLighting.generatePrefilteredAtlas(cubemaps, {\n          target: this.envAtlas\n        });\n      } else {\n        if (this.envAtlas) {\n          this.envAtlas.destroy();\n          this.envAtlas = null;\n        }\n      }\n      this._dirtyShader = true;\n    }\n  };\n  const empty = [null, null, null, null, null, null];\n  definePropInternal('prefilteredCubemaps', () => empty.slice(), setterFunc, getterFunc);\n}\n_defineMaterialProps();\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh-instance.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh-instance.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Command\": () => (/* binding */ Command),\n/* harmony export */   \"MeshInstance\": () => (/* binding */ MeshInstance)\n/* harmony export */ });\n/* harmony import */ var _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/shape/bounding-box.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/shape/bounding-box.js\");\n/* harmony import */ var _core_shape_bounding_sphere_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/shape/bounding-sphere.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/shape/bounding-sphere.js\");\n/* harmony import */ var _platform_graphics_bind_group_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../platform/graphics/bind-group.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/bind-group.js\");\n/* harmony import */ var _platform_graphics_uniform_buffer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../platform/graphics/uniform-buffer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/uniform-buffer.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _graph_node_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./graph-node.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/graph-node.js\");\n/* harmony import */ var _materials_default_material_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./materials/default-material.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/default-material.js\");\n/* harmony import */ var _graphics_lightmap_cache_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./graphics/lightmap-cache.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/graphics/lightmap-cache.js\");\n\n\n\n\n\n\n\n\n\n\nconst _tmpAabb = new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_0__.BoundingBox();\nconst _tempBoneAabb = new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_0__.BoundingBox();\nconst _tempSphere = new _core_shape_bounding_sphere_js__WEBPACK_IMPORTED_MODULE_1__.BoundingSphere();\nconst _meshSet = new Set();\nclass InstancingData {\n  constructor(numObjects) {\n    this.vertexBuffer = null;\n    this.count = numObjects;\n  }\n}\nclass Command {\n  constructor(layer, blendType, command) {\n    this._key = [];\n    this._key[_constants_js__WEBPACK_IMPORTED_MODULE_2__.SORTKEY_FORWARD] = getKey(layer, blendType, true, 0);\n    this.command = command;\n  }\n  set key(val) {\n    this._key[_constants_js__WEBPACK_IMPORTED_MODULE_2__.SORTKEY_FORWARD] = val;\n  }\n  get key() {\n    return this._key[_constants_js__WEBPACK_IMPORTED_MODULE_2__.SORTKEY_FORWARD];\n  }\n}\nclass MeshInstance {\n  constructor(mesh, material, node = null) {\n    this._material = void 0;\n    this._shader = [];\n    this._bindGroups = [];\n    if (mesh instanceof _graph_node_js__WEBPACK_IMPORTED_MODULE_3__.GraphNode) {\n      const temp = mesh;\n      mesh = material;\n      material = node;\n      node = temp;\n    }\n    this._key = [0, 0];\n    this.isStatic = false;\n    this._staticLightList = null;\n    this._staticSource = null;\n    this.node = node;\n    this._mesh = mesh;\n    mesh.incRefCount();\n    this.material = material;\n    this._shaderDefs = _constants_js__WEBPACK_IMPORTED_MODULE_2__.MASK_AFFECT_DYNAMIC << 16;\n    this._shaderDefs |= mesh.vertexBuffer.format.hasUv0 ? _constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADERDEF_UV0 : 0;\n    this._shaderDefs |= mesh.vertexBuffer.format.hasUv1 ? _constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADERDEF_UV1 : 0;\n    this._shaderDefs |= mesh.vertexBuffer.format.hasColor ? _constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADERDEF_VCOLOR : 0;\n    this._shaderDefs |= mesh.vertexBuffer.format.hasTangents ? _constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADERDEF_TANGENTS : 0;\n    this._lightHash = 0;\n    this.visible = true;\n    this.layer = _constants_js__WEBPACK_IMPORTED_MODULE_2__.LAYER_WORLD;\n    this._renderStyle = _constants_js__WEBPACK_IMPORTED_MODULE_2__.RENDERSTYLE_SOLID;\n    this.castShadow = false;\n    this._receiveShadow = true;\n    this._screenSpace = false;\n    this._noDepthDrawGl1 = false;\n    this.cull = true;\n    this.pick = true;\n    this._updateAabb = true;\n    this._updateAabbFunc = null;\n    this._calculateSortDistance = null;\n    this.updateKey();\n    this._skinInstance = null;\n    this._morphInstance = null;\n    this.instancingData = null;\n    this._customAabb = null;\n    this.aabb = new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_0__.BoundingBox();\n    this._aabbVer = -1;\n    this.drawOrder = 0;\n    this.visibleThisFrame = false;\n    this.isVisibleFunc = null;\n    this.parameters = {};\n    this.stencilFront = null;\n    this.stencilBack = null;\n    this.flipFaces = false;\n  }\n  set renderStyle(renderStyle) {\n    this._renderStyle = renderStyle;\n    this.mesh.prepareRenderState(renderStyle);\n  }\n  get renderStyle() {\n    return this._renderStyle;\n  }\n  set mesh(mesh) {\n    if (mesh === this._mesh) return;\n    if (this._mesh) {\n      this._mesh.decRefCount();\n    }\n    this._mesh = mesh;\n    if (mesh) {\n      mesh.incRefCount();\n    }\n  }\n  get mesh() {\n    return this._mesh;\n  }\n  set aabb(aabb) {\n    this._aabb = aabb;\n  }\n  get aabb() {\n    if (!this._updateAabb) {\n      return this._aabb;\n    }\n    if (this._updateAabbFunc) {\n      return this._updateAabbFunc(this._aabb);\n    }\n    let localAabb = this._customAabb;\n    let toWorldSpace = !!localAabb;\n    if (!localAabb) {\n      localAabb = _tmpAabb;\n      if (this.skinInstance) {\n        if (!this.mesh.boneAabb) {\n          const morphTargets = this._morphInstance ? this._morphInstance.morph._targets : null;\n          this.mesh._initBoneAabbs(morphTargets);\n        }\n        const boneUsed = this.mesh.boneUsed;\n        let first = true;\n        for (let i = 0; i < this.mesh.boneAabb.length; i++) {\n          if (boneUsed[i]) {\n            _tempBoneAabb.setFromTransformedAabb(this.mesh.boneAabb[i], this.skinInstance.matrices[i]);\n            if (first) {\n              first = false;\n              localAabb.center.copy(_tempBoneAabb.center);\n              localAabb.halfExtents.copy(_tempBoneAabb.halfExtents);\n            } else {\n              localAabb.add(_tempBoneAabb);\n            }\n          }\n        }\n        toWorldSpace = true;\n      } else if (this.node._aabbVer !== this._aabbVer) {\n        if (this.mesh) {\n          localAabb.center.copy(this.mesh.aabb.center);\n          localAabb.halfExtents.copy(this.mesh.aabb.halfExtents);\n        } else {\n          localAabb.center.set(0, 0, 0);\n          localAabb.halfExtents.set(0, 0, 0);\n        }\n        if (this.mesh && this.mesh.morph) {\n          localAabb._expand(this.mesh.morph.aabb.getMin(), this.mesh.morph.aabb.getMax());\n        }\n        toWorldSpace = true;\n        this._aabbVer = this.node._aabbVer;\n      }\n    }\n    if (toWorldSpace) {\n      this._aabb.setFromTransformedAabb(localAabb, this.node.getWorldTransform());\n    }\n    return this._aabb;\n  }\n  clearShaders() {\n    const shaders = this._shader;\n    for (let i = 0; i < shaders.length; i++) {\n      shaders[i] = null;\n    }\n    this.destroyBindGroups();\n  }\n  destroyBindGroups() {\n    const groups = this._bindGroups;\n    for (let i = 0; i < groups.length; i++) {\n      const group = groups[i];\n      if (group) {\n        const uniformBuffer = group.defaultUniformBuffer;\n        if (uniformBuffer) {\n          uniformBuffer.destroy();\n        }\n        group.destroy();\n      }\n    }\n    groups.length = 0;\n  }\n  getBindGroup(device, pass) {\n    let bindGroup = this._bindGroups[pass];\n    if (!bindGroup) {\n      const shader = this._shader[pass];\n      const ubFormat = shader.meshUniformBufferFormat;\n      const uniformBuffer = new _platform_graphics_uniform_buffer_js__WEBPACK_IMPORTED_MODULE_4__.UniformBuffer(device, ubFormat);\n      const bingGroupFormat = shader.meshBindGroupFormat;\n      bindGroup = new _platform_graphics_bind_group_js__WEBPACK_IMPORTED_MODULE_5__.BindGroup(device, bingGroupFormat, uniformBuffer);\n      this._bindGroups[pass] = bindGroup;\n    }\n    return bindGroup;\n  }\n  set material(material) {\n    this.clearShaders();\n    const prevMat = this._material;\n    if (prevMat) {\n      prevMat.removeMeshInstanceRef(this);\n    }\n    this._material = material;\n    if (material) {\n      material.addMeshInstanceRef(this);\n      this.updateKey();\n      const prevBlend = prevMat && prevMat.transparent;\n      if (material.transparent !== prevBlend) {\n        const scene = this._material._scene || (prevMat == null ? void 0 : prevMat._scene);\n        if (scene) {\n          scene.layers._dirtyBlend = true;\n        } else {\n          material._dirtyBlend = true;\n        }\n      }\n    }\n  }\n  get material() {\n    return this._material;\n  }\n  set layer(layer) {\n    this._layer = layer;\n    this.updateKey();\n  }\n  get layer() {\n    return this._layer;\n  }\n  set calculateSortDistance(calculateSortDistance) {\n    this._calculateSortDistance = calculateSortDistance;\n  }\n  get calculateSortDistance() {\n    return this._calculateSortDistance;\n  }\n  set receiveShadow(val) {\n    this._receiveShadow = val;\n    this._shaderDefs = val ? this._shaderDefs & ~_constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADERDEF_NOSHADOW : this._shaderDefs | _constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADERDEF_NOSHADOW;\n    this._shader[_constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADER_FORWARD] = null;\n    this._shader[_constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADER_FORWARDHDR] = null;\n  }\n  get receiveShadow() {\n    return this._receiveShadow;\n  }\n  set skinInstance(val) {\n    this._skinInstance = val;\n    let shaderDefs = this._shaderDefs;\n    shaderDefs = val ? shaderDefs | _constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADERDEF_SKIN : shaderDefs & ~_constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADERDEF_SKIN;\n    if (shaderDefs !== this._shaderDefs) {\n      this._shaderDefs = shaderDefs;\n      this.clearShaders();\n    }\n    this._setupSkinUpdate();\n  }\n  get skinInstance() {\n    return this._skinInstance;\n  }\n  set morphInstance(val) {\n    var _this$_morphInstance;\n    (_this$_morphInstance = this._morphInstance) == null ? void 0 : _this$_morphInstance.destroy();\n    this._morphInstance = val;\n    let shaderDefs = this._shaderDefs;\n    shaderDefs = val && val.morph.useTextureMorph ? shaderDefs | _constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADERDEF_MORPH_TEXTURE_BASED : shaderDefs & ~_constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADERDEF_MORPH_TEXTURE_BASED;\n    shaderDefs = val && val.morph.morphPositions ? shaderDefs | _constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADERDEF_MORPH_POSITION : shaderDefs & ~_constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADERDEF_MORPH_POSITION;\n    shaderDefs = val && val.morph.morphNormals ? shaderDefs | _constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADERDEF_MORPH_NORMAL : shaderDefs & ~_constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADERDEF_MORPH_NORMAL;\n    if (shaderDefs !== this._shaderDefs) {\n      this._shaderDefs = shaderDefs;\n      this.clearShaders();\n    }\n  }\n  get morphInstance() {\n    return this._morphInstance;\n  }\n  set screenSpace(val) {\n    this._screenSpace = val;\n    this._shaderDefs = val ? this._shaderDefs | _constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADERDEF_SCREENSPACE : this._shaderDefs & ~_constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADERDEF_SCREENSPACE;\n    this._shader[_constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADER_FORWARD] = null;\n  }\n  get screenSpace() {\n    return this._screenSpace;\n  }\n  set key(val) {\n    this._key[_constants_js__WEBPACK_IMPORTED_MODULE_2__.SORTKEY_FORWARD] = val;\n  }\n  get key() {\n    return this._key[_constants_js__WEBPACK_IMPORTED_MODULE_2__.SORTKEY_FORWARD];\n  }\n  set mask(val) {\n    const toggles = this._shaderDefs & 0x0000FFFF;\n    this._shaderDefs = toggles | val << 16;\n    this._shader[_constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADER_FORWARD] = null;\n    this._shader[_constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADER_FORWARDHDR] = null;\n  }\n  get mask() {\n    return this._shaderDefs >> 16;\n  }\n  set instancingCount(value) {\n    if (this.instancingData) this.instancingData.count = value;\n  }\n  get instancingCount() {\n    return this.instancingData ? this.instancingData.count : 0;\n  }\n  destroy() {\n    var _this$_skinInstance, _this$morphInstance;\n    const mesh = this.mesh;\n    if (mesh) {\n      this.mesh = null;\n      if (mesh.refCount < 1) {\n        mesh.destroy();\n      }\n    }\n    this.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], null);\n    this.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], null);\n    (_this$_skinInstance = this._skinInstance) == null ? void 0 : _this$_skinInstance.destroy();\n    this._skinInstance = null;\n    (_this$morphInstance = this.morphInstance) == null ? void 0 : _this$morphInstance.destroy();\n    this.morphInstance = null;\n    this.clearShaders();\n    this.material = null;\n  }\n  static _prepareRenderStyleForArray(meshInstances, renderStyle) {\n    if (meshInstances) {\n      for (let i = 0; i < meshInstances.length; i++) {\n        meshInstances[i]._renderStyle = renderStyle;\n        const mesh = meshInstances[i].mesh;\n        if (!_meshSet.has(mesh)) {\n          _meshSet.add(mesh);\n          mesh.prepareRenderState(renderStyle);\n        }\n      }\n      _meshSet.clear();\n    }\n  }\n  _isVisible(camera) {\n    if (this.visible) {\n      if (this.isVisibleFunc) {\n        return this.isVisibleFunc(camera);\n      }\n      _tempSphere.center = this.aabb.center;\n      _tempSphere.radius = this._aabb.halfExtents.length();\n      return camera.frustum.containsSphere(_tempSphere);\n    }\n    return false;\n  }\n  updateKey() {\n    const material = this.material;\n    this._key[_constants_js__WEBPACK_IMPORTED_MODULE_2__.SORTKEY_FORWARD] = getKey(this.layer, material.alphaToCoverage || material.alphaTest ? _constants_js__WEBPACK_IMPORTED_MODULE_2__.BLEND_NORMAL : material.blendType, false, material.id);\n  }\n  setInstancing(vertexBuffer) {\n    if (vertexBuffer) {\n      this.instancingData = new InstancingData(vertexBuffer.numVertices);\n      this.instancingData.vertexBuffer = vertexBuffer;\n      vertexBuffer.format.instancing = true;\n      this.cull = false;\n    } else {\n      this.instancingData = null;\n      this.cull = true;\n    }\n  }\n  updatePassShader(scene, pass, staticLightList, sortedLights, viewUniformFormat, viewBindGroupFormat) {\n    this._shader[pass] = this.material.getShaderVariant(this.mesh.device, scene, this._shaderDefs, staticLightList, pass, sortedLights, viewUniformFormat, viewBindGroupFormat);\n  }\n  ensureMaterial(device) {\n    if (!this.material) {\n      this.material = (0,_materials_default_material_js__WEBPACK_IMPORTED_MODULE_6__.getDefaultMaterial)(device);\n    }\n  }\n  clearParameters() {\n    this.parameters = {};\n  }\n  getParameters() {\n    return this.parameters;\n  }\n  getParameter(name) {\n    return this.parameters[name];\n  }\n  setParameter(name, data, passFlags = -262141) {\n    if (data === undefined && typeof name === 'object') {\n      const uniformObject = name;\n      if (uniformObject.length) {\n        for (let i = 0; i < uniformObject.length; i++) {\n          this.setParameter(uniformObject[i]);\n        }\n        return;\n      }\n      name = uniformObject.name;\n      data = uniformObject.value;\n    }\n    const param = this.parameters[name];\n    if (param) {\n      param.data = data;\n      param.passFlags = passFlags;\n    } else {\n      this.parameters[name] = {\n        scopeId: null,\n        data: data,\n        passFlags: passFlags\n      };\n    }\n  }\n  setRealtimeLightmap(name, texture) {\n    const old = this.getParameter(name);\n    if (old === texture) return;\n    if (old) {\n      _graphics_lightmap_cache_js__WEBPACK_IMPORTED_MODULE_7__.LightmapCache.decRef(old.data);\n    }\n    if (texture) {\n      _graphics_lightmap_cache_js__WEBPACK_IMPORTED_MODULE_7__.LightmapCache.incRef(texture);\n      this.setParameter(name, texture);\n    } else {\n      this.deleteParameter(name);\n    }\n  }\n  deleteParameter(name) {\n    if (this.parameters[name]) {\n      delete this.parameters[name];\n    }\n  }\n  setParameters(device, passFlag) {\n    const parameters = this.parameters;\n    for (const paramName in parameters) {\n      const parameter = parameters[paramName];\n      if (parameter.passFlags & passFlag) {\n        if (!parameter.scopeId) {\n          parameter.scopeId = device.scope.resolve(paramName);\n        }\n        parameter.scopeId.setValue(parameter.data);\n      }\n    }\n  }\n  setLightmapped(value) {\n    if (value) {\n      this.mask = (this.mask | _constants_js__WEBPACK_IMPORTED_MODULE_2__.MASK_AFFECT_LIGHTMAPPED) & ~(_constants_js__WEBPACK_IMPORTED_MODULE_2__.MASK_AFFECT_DYNAMIC | _constants_js__WEBPACK_IMPORTED_MODULE_2__.MASK_BAKE);\n    } else {\n      this.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], null);\n      this.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], null);\n      this._shaderDefs &= ~(_constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADERDEF_LM | _constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADERDEF_DIRLM | _constants_js__WEBPACK_IMPORTED_MODULE_2__.SHADERDEF_LMAMBIENT);\n      this.mask = (this.mask | _constants_js__WEBPACK_IMPORTED_MODULE_2__.MASK_AFFECT_DYNAMIC) & ~(_constants_js__WEBPACK_IMPORTED_MODULE_2__.MASK_AFFECT_LIGHTMAPPED | _constants_js__WEBPACK_IMPORTED_MODULE_2__.MASK_BAKE);\n    }\n  }\n  setCustomAabb(aabb) {\n    if (aabb) {\n      if (this._customAabb) {\n        this._customAabb.copy(aabb);\n      } else {\n        this._customAabb = aabb.clone();\n      }\n    } else {\n      this._customAabb = null;\n      this._aabbVer = -1;\n    }\n    this._setupSkinUpdate();\n  }\n  _setupSkinUpdate() {\n    if (this._skinInstance) {\n      this._skinInstance._updateBeforeCull = !this._customAabb;\n    }\n  }\n}\nMeshInstance.lightmapParamNames = ['texture_lightMap', 'texture_dirLightMap'];\nfunction getKey(layer, blendType, isCommand, materialId) {\n  return (layer & 0x0f) << 27 | (blendType === _constants_js__WEBPACK_IMPORTED_MODULE_2__.BLEND_NONE ? 1 : 0) << 26 | (isCommand ? 1 : 0) << 25 | (materialId & 0x1ffffff) << 0;\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh-instance.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh.js":
/*!********************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Mesh\": () => (/* binding */ Mesh)\n/* harmony export */ });\n/* harmony import */ var _core_ref_counted_object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/ref-counted-object.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/ref-counted-object.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/shape/bounding-box.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/shape/bounding-box.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_index_buffer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../platform/graphics/index-buffer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/index-buffer.js\");\n/* harmony import */ var _platform_graphics_vertex_buffer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../platform/graphics/vertex-buffer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/vertex-buffer.js\");\n/* harmony import */ var _platform_graphics_vertex_format_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../platform/graphics/vertex-format.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/vertex-format.js\");\n/* harmony import */ var _platform_graphics_vertex_iterator_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../platform/graphics/vertex-iterator.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/vertex-iterator.js\");\n/* harmony import */ var _platform_graphics_graphics_device_access_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../platform/graphics/graphics-device-access.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/graphics-device-access.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nlet id = 0;\nclass GeometryData {\n  constructor() {\n    this.initDefaults();\n  }\n  initDefaults() {\n    this.recreate = false;\n    this.verticesUsage = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BUFFER_STATIC;\n    this.indicesUsage = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BUFFER_STATIC;\n    this.maxVertices = 0;\n    this.maxIndices = 0;\n    this.vertexCount = 0;\n    this.indexCount = 0;\n    this.vertexStreamsUpdated = false;\n    this.indexStreamUpdated = false;\n    this.vertexStreamDictionary = {};\n    this.indices = null;\n  }\n  _changeVertexCount(count, semantic) {\n    if (!this.vertexCount) {\n      this.vertexCount = count;\n    }\n  }\n}\nGeometryData.DEFAULT_COMPONENTS_POSITION = 3;\nGeometryData.DEFAULT_COMPONENTS_NORMAL = 3;\nGeometryData.DEFAULT_COMPONENTS_UV = 2;\nGeometryData.DEFAULT_COMPONENTS_COLORS = 4;\nclass GeometryVertexStream {\n  constructor(data, componentCount, dataType, dataTypeNormalize) {\n    this.data = data;\n    this.componentCount = componentCount;\n    this.dataType = dataType;\n    this.dataTypeNormalize = dataTypeNormalize;\n  }\n}\nclass Mesh extends _core_ref_counted_object_js__WEBPACK_IMPORTED_MODULE_1__.RefCountedObject {\n  constructor(graphicsDevice) {\n    super();\n    this.id = id++;\n    this.device = graphicsDevice || _platform_graphics_graphics_device_access_js__WEBPACK_IMPORTED_MODULE_2__.GraphicsDeviceAccess.get();\n    this.vertexBuffer = null;\n    this.indexBuffer = [null];\n    this.primitive = [{\n      type: 0,\n      base: 0,\n      count: 0\n    }];\n    this.skin = null;\n    this._morph = null;\n    this._geometryData = null;\n    this._aabb = new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_3__.BoundingBox();\n    this.boneAabb = null;\n  }\n  set morph(morph) {\n    if (morph !== this._morph) {\n      if (this._morph) {\n        this._morph.decRefCount();\n      }\n      this._morph = morph;\n      if (morph) {\n        morph.incRefCount();\n      }\n    }\n  }\n  get morph() {\n    return this._morph;\n  }\n  set aabb(aabb) {\n    this._aabb = aabb;\n  }\n  get aabb() {\n    return this._aabb;\n  }\n  destroy() {\n    const morph = this.morph;\n    if (morph) {\n      this.morph = null;\n      if (morph.refCount < 1) {\n        morph.destroy();\n      }\n    }\n    if (this.vertexBuffer) {\n      this.vertexBuffer.destroy();\n      this.vertexBuffer = null;\n    }\n    for (let j = 0; j < this.indexBuffer.length; j++) {\n      this._destroyIndexBuffer(j);\n    }\n    this.indexBuffer.length = 0;\n    this._geometryData = null;\n  }\n  _destroyIndexBuffer(index) {\n    if (this.indexBuffer[index]) {\n      this.indexBuffer[index].destroy();\n      this.indexBuffer[index] = null;\n    }\n  }\n  _initBoneAabbs(morphTargets) {\n    this.boneAabb = [];\n    this.boneUsed = [];\n    let x, y, z;\n    let bMax, bMin;\n    const boneMin = [];\n    const boneMax = [];\n    const boneUsed = this.boneUsed;\n    const numBones = this.skin.boneNames.length;\n    let maxMorphX, maxMorphY, maxMorphZ;\n    for (let i = 0; i < numBones; i++) {\n      boneMin[i] = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_4__.Vec3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n      boneMax[i] = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_4__.Vec3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n    }\n    const iterator = new _platform_graphics_vertex_iterator_js__WEBPACK_IMPORTED_MODULE_5__.VertexIterator(this.vertexBuffer);\n    const posElement = iterator.element[_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_POSITION];\n    const weightsElement = iterator.element[_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_BLENDWEIGHT];\n    const indicesElement = iterator.element[_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_BLENDINDICES];\n    const numVerts = this.vertexBuffer.numVertices;\n    for (let j = 0; j < numVerts; j++) {\n      for (let k = 0; k < 4; k++) {\n        const boneWeight = weightsElement.array[weightsElement.index + k];\n        if (boneWeight > 0) {\n          const boneIndex = indicesElement.array[indicesElement.index + k];\n          boneUsed[boneIndex] = true;\n          x = posElement.array[posElement.index];\n          y = posElement.array[posElement.index + 1];\n          z = posElement.array[posElement.index + 2];\n          bMax = boneMax[boneIndex];\n          bMin = boneMin[boneIndex];\n          if (bMin.x > x) bMin.x = x;\n          if (bMin.y > y) bMin.y = y;\n          if (bMin.z > z) bMin.z = z;\n          if (bMax.x < x) bMax.x = x;\n          if (bMax.y < y) bMax.y = y;\n          if (bMax.z < z) bMax.z = z;\n          if (morphTargets) {\n            let minMorphX = maxMorphX = x;\n            let minMorphY = maxMorphY = y;\n            let minMorphZ = maxMorphZ = z;\n            for (let l = 0; l < morphTargets.length; l++) {\n              const target = morphTargets[l];\n              const dx = target.deltaPositions[j * 3];\n              const dy = target.deltaPositions[j * 3 + 1];\n              const dz = target.deltaPositions[j * 3 + 2];\n              if (dx < 0) {\n                minMorphX += dx;\n              } else {\n                maxMorphX += dx;\n              }\n              if (dy < 0) {\n                minMorphY += dy;\n              } else {\n                maxMorphY += dy;\n              }\n              if (dz < 0) {\n                minMorphZ += dz;\n              } else {\n                maxMorphZ += dz;\n              }\n            }\n            if (bMin.x > minMorphX) bMin.x = minMorphX;\n            if (bMin.y > minMorphY) bMin.y = minMorphY;\n            if (bMin.z > minMorphZ) bMin.z = minMorphZ;\n            if (bMax.x < maxMorphX) bMax.x = maxMorphX;\n            if (bMax.y < maxMorphY) bMax.y = maxMorphY;\n            if (bMax.z < maxMorphZ) bMax.z = maxMorphZ;\n          }\n        }\n      }\n      iterator.next();\n    }\n    const positionElement = this.vertexBuffer.getFormat().elements.find(e => e.name === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_POSITION);\n    if (positionElement && positionElement.normalize) {\n      const func = (() => {\n        switch (positionElement.dataType) {\n          case _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_INT8:\n            return x => Math.max(x / 127.0, -1.0);\n          case _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_UINT8:\n            return x => x / 255.0;\n          case _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_INT16:\n            return x => Math.max(x / 32767.0, -1.0);\n          case _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_UINT16:\n            return x => x / 65535.0;\n          default:\n            return x => x;\n        }\n      })();\n      for (let i = 0; i < numBones; i++) {\n        if (boneUsed[i]) {\n          const min = boneMin[i];\n          const max = boneMax[i];\n          min.set(func(min.x), func(min.y), func(min.z));\n          max.set(func(max.x), func(max.y), func(max.z));\n        }\n      }\n    }\n    for (let i = 0; i < numBones; i++) {\n      const aabb = new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_3__.BoundingBox();\n      aabb.setMinMax(boneMin[i], boneMax[i]);\n      this.boneAabb.push(aabb);\n    }\n  }\n  _initGeometryData() {\n    if (!this._geometryData) {\n      this._geometryData = new GeometryData();\n      if (this.vertexBuffer) {\n        this._geometryData.vertexCount = this.vertexBuffer.numVertices;\n        this._geometryData.maxVertices = this.vertexBuffer.numVertices;\n      }\n      if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {\n        this._geometryData.indexCount = this.indexBuffer[0].numIndices;\n        this._geometryData.maxIndices = this.indexBuffer[0].numIndices;\n      }\n    }\n  }\n  clear(verticesDynamic, indicesDynamic, maxVertices = 0, maxIndices = 0) {\n    this._initGeometryData();\n    this._geometryData.initDefaults();\n    this._geometryData.recreate = true;\n    this._geometryData.maxVertices = maxVertices;\n    this._geometryData.maxIndices = maxIndices;\n    this._geometryData.verticesUsage = verticesDynamic ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BUFFER_STATIC : _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BUFFER_DYNAMIC;\n    this._geometryData.indicesUsage = indicesDynamic ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BUFFER_STATIC : _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BUFFER_DYNAMIC;\n  }\n  setVertexStream(semantic, data, componentCount, numVertices, dataType = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_FLOAT32, dataTypeNormalize = false) {\n    this._initGeometryData();\n    const vertexCount = numVertices || data.length / componentCount;\n    this._geometryData._changeVertexCount(vertexCount, semantic);\n    this._geometryData.vertexStreamsUpdated = true;\n    this._geometryData.vertexStreamDictionary[semantic] = new GeometryVertexStream(data, componentCount, dataType, dataTypeNormalize);\n  }\n  getVertexStream(semantic, data) {\n    let count = 0;\n    let done = false;\n    if (this._geometryData) {\n      const stream = this._geometryData.vertexStreamDictionary[semantic];\n      if (stream) {\n        done = true;\n        count = this._geometryData.vertexCount;\n        if (ArrayBuffer.isView(data)) {\n          data.set(stream.data);\n        } else {\n          data.length = 0;\n          data.push(stream.data);\n        }\n      }\n    }\n    if (!done) {\n      if (this.vertexBuffer) {\n        const iterator = new _platform_graphics_vertex_iterator_js__WEBPACK_IMPORTED_MODULE_5__.VertexIterator(this.vertexBuffer);\n        count = iterator.readData(semantic, data);\n      }\n    }\n    return count;\n  }\n  setPositions(positions, componentCount = GeometryData.DEFAULT_COMPONENTS_POSITION, numVertices) {\n    this.setVertexStream(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_POSITION, positions, componentCount, numVertices, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_FLOAT32, false);\n  }\n  setNormals(normals, componentCount = GeometryData.DEFAULT_COMPONENTS_NORMAL, numVertices) {\n    this.setVertexStream(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_NORMAL, normals, componentCount, numVertices, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_FLOAT32, false);\n  }\n  setUvs(channel, uvs, componentCount = GeometryData.DEFAULT_COMPONENTS_UV, numVertices) {\n    this.setVertexStream(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD + channel, uvs, componentCount, numVertices, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_FLOAT32, false);\n  }\n  setColors(colors, componentCount = GeometryData.DEFAULT_COMPONENTS_COLORS, numVertices) {\n    this.setVertexStream(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_COLOR, colors, componentCount, numVertices, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_FLOAT32, false);\n  }\n  setColors32(colors, numVertices) {\n    this.setVertexStream(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_COLOR, colors, GeometryData.DEFAULT_COMPONENTS_COLORS, numVertices, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_UINT8, true);\n  }\n  setIndices(indices, numIndices) {\n    this._initGeometryData();\n    this._geometryData.indexStreamUpdated = true;\n    this._geometryData.indices = indices;\n    this._geometryData.indexCount = numIndices || indices.length;\n  }\n  getPositions(positions) {\n    return this.getVertexStream(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_POSITION, positions);\n  }\n  getNormals(normals) {\n    return this.getVertexStream(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_NORMAL, normals);\n  }\n  getUvs(channel, uvs) {\n    return this.getVertexStream(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD + channel, uvs);\n  }\n  getColors(colors) {\n    return this.getVertexStream(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_COLOR, colors);\n  }\n  getIndices(indices) {\n    let count = 0;\n    if (this._geometryData && this._geometryData.indices) {\n      const streamIndices = this._geometryData.indices;\n      count = this._geometryData.indexCount;\n      if (ArrayBuffer.isView(indices)) {\n        indices.set(streamIndices);\n      } else {\n        indices.length = 0;\n        indices.push(streamIndices);\n      }\n    } else {\n      if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {\n        const indexBuffer = this.indexBuffer[0];\n        count = indexBuffer.readData(indices);\n      }\n    }\n    return count;\n  }\n  update(primitiveType = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PRIMITIVE_TRIANGLES, updateBoundingBox = true) {\n    if (this._geometryData) {\n      if (updateBoundingBox) {\n        const stream = this._geometryData.vertexStreamDictionary[_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_POSITION];\n        if (stream) {\n          if (stream.componentCount === 3) {\n            this._aabb.compute(stream.data, this._geometryData.vertexCount);\n          }\n        }\n      }\n      let destroyVB = this._geometryData.recreate;\n      if (this._geometryData.vertexCount > this._geometryData.maxVertices) {\n        destroyVB = true;\n        this._geometryData.maxVertices = this._geometryData.vertexCount;\n      }\n      if (destroyVB) {\n        if (this.vertexBuffer) {\n          this.vertexBuffer.destroy();\n          this.vertexBuffer = null;\n        }\n      }\n      let destroyIB = this._geometryData.recreate;\n      if (this._geometryData.indexCount > this._geometryData.maxIndices) {\n        destroyIB = true;\n        this._geometryData.maxIndices = this._geometryData.indexCount;\n      }\n      if (destroyIB) {\n        if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {\n          this.indexBuffer[0].destroy();\n          this.indexBuffer[0] = null;\n        }\n      }\n      if (this._geometryData.vertexStreamsUpdated) {\n        this._updateVertexBuffer();\n      }\n      if (this._geometryData.indexStreamUpdated) {\n        this._updateIndexBuffer();\n      }\n      this.primitive[0].type = primitiveType;\n      if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {\n        if (this._geometryData.indexStreamUpdated) {\n          this.primitive[0].count = this._geometryData.indexCount;\n          this.primitive[0].indexed = true;\n        }\n      } else {\n        if (this._geometryData.vertexStreamsUpdated) {\n          this.primitive[0].count = this._geometryData.vertexCount;\n          this.primitive[0].indexed = false;\n        }\n      }\n      this._geometryData.vertexCount = 0;\n      this._geometryData.indexCount = 0;\n      this._geometryData.vertexStreamsUpdated = false;\n      this._geometryData.indexStreamUpdated = false;\n      this._geometryData.recreate = false;\n      this.updateRenderStates();\n    }\n  }\n  _buildVertexFormat(vertexCount) {\n    const vertexDesc = [];\n    for (const semantic in this._geometryData.vertexStreamDictionary) {\n      const stream = this._geometryData.vertexStreamDictionary[semantic];\n      vertexDesc.push({\n        semantic: semantic,\n        components: stream.componentCount,\n        type: stream.dataType,\n        normalize: stream.dataTypeNormalize\n      });\n    }\n    return new _platform_graphics_vertex_format_js__WEBPACK_IMPORTED_MODULE_6__.VertexFormat(this.device, vertexDesc, vertexCount);\n  }\n  _updateVertexBuffer() {\n    if (!this.vertexBuffer) {\n      const allocateVertexCount = this._geometryData.maxVertices;\n      const format = this._buildVertexFormat(allocateVertexCount);\n      this.vertexBuffer = new _platform_graphics_vertex_buffer_js__WEBPACK_IMPORTED_MODULE_7__.VertexBuffer(this.device, format, allocateVertexCount, this._geometryData.verticesUsage);\n    }\n    const iterator = new _platform_graphics_vertex_iterator_js__WEBPACK_IMPORTED_MODULE_5__.VertexIterator(this.vertexBuffer);\n    const numVertices = this._geometryData.vertexCount;\n    for (const semantic in this._geometryData.vertexStreamDictionary) {\n      const stream = this._geometryData.vertexStreamDictionary[semantic];\n      iterator.writeData(semantic, stream.data, numVertices);\n      delete this._geometryData.vertexStreamDictionary[semantic];\n    }\n    iterator.end();\n  }\n  _updateIndexBuffer() {\n    if (this.indexBuffer.length <= 0 || !this.indexBuffer[0]) {\n      const createFormat = this._geometryData.maxVertices > 0xffff ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.INDEXFORMAT_UINT32 : _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.INDEXFORMAT_UINT16;\n      this.indexBuffer[0] = new _platform_graphics_index_buffer_js__WEBPACK_IMPORTED_MODULE_8__.IndexBuffer(this.device, createFormat, this._geometryData.maxIndices, this._geometryData.indicesUsage);\n    }\n    const srcIndices = this._geometryData.indices;\n    if (srcIndices) {\n      const indexBuffer = this.indexBuffer[0];\n      indexBuffer.writeData(srcIndices, this._geometryData.indexCount);\n      this._geometryData.indices = null;\n    }\n  }\n  prepareRenderState(renderStyle) {\n    if (renderStyle === _constants_js__WEBPACK_IMPORTED_MODULE_9__.RENDERSTYLE_WIREFRAME) {\n      this.generateWireframe();\n    } else if (renderStyle === _constants_js__WEBPACK_IMPORTED_MODULE_9__.RENDERSTYLE_POINTS) {\n      this.primitive[_constants_js__WEBPACK_IMPORTED_MODULE_9__.RENDERSTYLE_POINTS] = {\n        type: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PRIMITIVE_POINTS,\n        base: 0,\n        count: this.vertexBuffer ? this.vertexBuffer.numVertices : 0,\n        indexed: false\n      };\n    }\n  }\n  updateRenderStates() {\n    if (this.primitive[_constants_js__WEBPACK_IMPORTED_MODULE_9__.RENDERSTYLE_POINTS]) {\n      this.prepareRenderState(_constants_js__WEBPACK_IMPORTED_MODULE_9__.RENDERSTYLE_POINTS);\n    }\n    if (this.primitive[_constants_js__WEBPACK_IMPORTED_MODULE_9__.RENDERSTYLE_WIREFRAME]) {\n      this.prepareRenderState(_constants_js__WEBPACK_IMPORTED_MODULE_9__.RENDERSTYLE_WIREFRAME);\n    }\n  }\n  generateWireframe() {\n    this._destroyIndexBuffer(_constants_js__WEBPACK_IMPORTED_MODULE_9__.RENDERSTYLE_WIREFRAME);\n    const lines = [];\n    let format;\n    if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {\n      const offsets = [[0, 1], [1, 2], [2, 0]];\n      const base = this.primitive[_constants_js__WEBPACK_IMPORTED_MODULE_9__.RENDERSTYLE_SOLID].base;\n      const count = this.primitive[_constants_js__WEBPACK_IMPORTED_MODULE_9__.RENDERSTYLE_SOLID].count;\n      const indexBuffer = this.indexBuffer[_constants_js__WEBPACK_IMPORTED_MODULE_9__.RENDERSTYLE_SOLID];\n      const srcIndices = new _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.typedArrayIndexFormats[indexBuffer.format](indexBuffer.storage);\n      const uniqueLineIndices = {};\n      for (let j = base; j < base + count; j += 3) {\n        for (let k = 0; k < 3; k++) {\n          const i1 = srcIndices[j + offsets[k][0]];\n          const i2 = srcIndices[j + offsets[k][1]];\n          const line = i1 > i2 ? i2 << 16 | i1 : i1 << 16 | i2;\n          if (uniqueLineIndices[line] === undefined) {\n            uniqueLineIndices[line] = 0;\n            lines.push(i1, i2);\n          }\n        }\n      }\n      format = indexBuffer.format;\n    } else {\n      for (let i = 0; i < this.vertexBuffer.numVertices; i += 3) {\n        lines.push(i, i + 1, i + 1, i + 2, i + 2, i);\n      }\n      format = lines.length > 65535 ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.INDEXFORMAT_UINT32 : _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.INDEXFORMAT_UINT16;\n    }\n    const wireBuffer = new _platform_graphics_index_buffer_js__WEBPACK_IMPORTED_MODULE_8__.IndexBuffer(this.vertexBuffer.device, format, lines.length);\n    const dstIndices = new _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.typedArrayIndexFormats[wireBuffer.format](wireBuffer.storage);\n    dstIndices.set(lines);\n    wireBuffer.unlock();\n    this.primitive[_constants_js__WEBPACK_IMPORTED_MODULE_9__.RENDERSTYLE_WIREFRAME] = {\n      type: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PRIMITIVE_LINES,\n      base: 0,\n      count: lines.length,\n      indexed: true\n    };\n    this.indexBuffer[_constants_js__WEBPACK_IMPORTED_MODULE_9__.RENDERSTYLE_WIREFRAME] = wireBuffer;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/model.js":
/*!*********************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/model.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Model\": () => (/* binding */ Model)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _mesh_instance_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mesh-instance.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh-instance.js\");\n/* harmony import */ var _morph_instance_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./morph-instance.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/morph-instance.js\");\n/* harmony import */ var _skin_instance_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./skin-instance.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/skin-instance.js\");\n\n\n\n\n\nclass Model {\n  constructor() {\n    this.graph = null;\n    this.meshInstances = [];\n    this.skinInstances = [];\n    this.morphInstances = [];\n    this.cameras = [];\n    this.lights = [];\n    this._shadersVersion = 0;\n    this._immutable = false;\n  }\n  getGraph() {\n    return this.graph;\n  }\n  setGraph(graph) {\n    this.graph = graph;\n  }\n  getCameras() {\n    return this.cameras;\n  }\n  setCameras(cameras) {\n    this.cameras = cameras;\n  }\n  getLights() {\n    return this.lights;\n  }\n  setLights(lights) {\n    this.lights = lights;\n  }\n  getMaterials() {\n    const materials = [];\n    for (let i = 0; i < this.meshInstances.length; i++) {\n      const meshInstance = this.meshInstances[i];\n      if (materials.indexOf(meshInstance.material) === -1) {\n        materials.push(meshInstance.material);\n      }\n    }\n    return materials;\n  }\n  clone() {\n    const srcNodes = [];\n    const cloneNodes = [];\n    const _duplicate = function _duplicate(node) {\n      const newNode = node.clone();\n      srcNodes.push(node);\n      cloneNodes.push(newNode);\n      for (let idx = 0; idx < node._children.length; idx++) {\n        newNode.addChild(_duplicate(node._children[idx]));\n      }\n      return newNode;\n    };\n    const cloneGraph = _duplicate(this.graph);\n    const cloneMeshInstances = [];\n    const cloneSkinInstances = [];\n    const cloneMorphInstances = [];\n    for (let i = 0; i < this.skinInstances.length; i++) {\n      const skin = this.skinInstances[i].skin;\n      const cloneSkinInstance = new _skin_instance_js__WEBPACK_IMPORTED_MODULE_0__.SkinInstance(skin);\n      const bones = [];\n      for (let j = 0; j < skin.boneNames.length; j++) {\n        const boneName = skin.boneNames[j];\n        const bone = cloneGraph.findByName(boneName);\n        bones.push(bone);\n      }\n      cloneSkinInstance.bones = bones;\n      cloneSkinInstances.push(cloneSkinInstance);\n    }\n    for (let i = 0; i < this.morphInstances.length; i++) {\n      const morph = this.morphInstances[i].morph;\n      const cloneMorphInstance = new _morph_instance_js__WEBPACK_IMPORTED_MODULE_1__.MorphInstance(morph);\n      cloneMorphInstances.push(cloneMorphInstance);\n    }\n    for (let i = 0; i < this.meshInstances.length; i++) {\n      const meshInstance = this.meshInstances[i];\n      const nodeIndex = srcNodes.indexOf(meshInstance.node);\n      const cloneMeshInstance = new _mesh_instance_js__WEBPACK_IMPORTED_MODULE_2__.MeshInstance(meshInstance.mesh, meshInstance.material, cloneNodes[nodeIndex]);\n      if (meshInstance.skinInstance) {\n        const skinInstanceIndex = this.skinInstances.indexOf(meshInstance.skinInstance);\n        cloneMeshInstance.skinInstance = cloneSkinInstances[skinInstanceIndex];\n      }\n      if (meshInstance.morphInstance) {\n        const morphInstanceIndex = this.morphInstances.indexOf(meshInstance.morphInstance);\n        cloneMeshInstance.morphInstance = cloneMorphInstances[morphInstanceIndex];\n      }\n      cloneMeshInstances.push(cloneMeshInstance);\n    }\n    const clone = new Model();\n    clone.graph = cloneGraph;\n    clone.meshInstances = cloneMeshInstances;\n    clone.skinInstances = cloneSkinInstances;\n    clone.morphInstances = cloneMorphInstances;\n    clone.getGraph().syncHierarchy();\n    return clone;\n  }\n  destroy() {\n    const meshInstances = this.meshInstances;\n    for (let i = 0; i < meshInstances.length; i++) {\n      meshInstances[i].destroy();\n    }\n    this.meshInstances.length = 0;\n  }\n  generateWireframe() {\n    _mesh_instance_js__WEBPACK_IMPORTED_MODULE_2__.MeshInstance._prepareRenderStyleForArray(this.meshInstances, _constants_js__WEBPACK_IMPORTED_MODULE_3__.RENDERSTYLE_WIREFRAME);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/model.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/morph-instance.js":
/*!******************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/morph-instance.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MorphInstance\": () => (/* binding */ MorphInstance)\n/* harmony export */ });\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_simple_post_effect_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../platform/graphics/simple-post-effect.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/simple-post-effect.js\");\n/* harmony import */ var _platform_graphics_render_target_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../platform/graphics/render-target.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/render-target.js\");\n/* harmony import */ var _shader_lib_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shader-lib/utils.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/utils.js\");\n/* harmony import */ var _morph_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./morph.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/morph.js\");\n\n\n\n\n\n\n\nconst textureMorphVertexShader = `\n    attribute vec2 vertex_position;\n    varying vec2 uv0;\n    void main(void) {\n        gl_Position = vec4(vertex_position, 0.5, 1.0);\n        uv0 = vertex_position.xy * 0.5 + 0.5;\n    }\n    `;\nclass MorphInstance {\n  constructor(morph) {\n    this.morph = morph;\n    morph.incRefCount();\n    this.device = morph.device;\n    this._weights = [];\n    this._weightMap = new Map();\n    for (let v = 0; v < morph._targets.length; v++) {\n      const target = morph._targets[v];\n      if (target.name) {\n        this._weightMap.set(target.name, v);\n      }\n      this.setWeight(v, target.defaultWeight);\n    }\n    this._activeTargets = [];\n    if (morph.useTextureMorph) {\n      this.shaderCache = {};\n      this.maxSubmitCount = this.device.maxTextures;\n      this._shaderMorphWeights = new Float32Array(this.maxSubmitCount);\n      const createRT = (name, textureVar) => {\n        const format = morph._renderTextureFormat === _morph_js__WEBPACK_IMPORTED_MODULE_0__.Morph.FORMAT_FLOAT ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.PIXELFORMAT_RGBA32F : _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.PIXELFORMAT_RGBA16F;\n        this[textureVar] = morph._createTexture(name, format);\n        return new _platform_graphics_render_target_js__WEBPACK_IMPORTED_MODULE_2__.RenderTarget({\n          colorBuffer: this[textureVar],\n          depth: false\n        });\n      };\n      if (morph.morphPositions) {\n        this.rtPositions = createRT('MorphRTPos', 'texturePositions');\n      }\n      if (morph.morphNormals) {\n        this.rtNormals = createRT('MorphRTNrm', 'textureNormals');\n      }\n      this._textureParams = new Float32Array([morph.morphTextureWidth, morph.morphTextureHeight, 1 / morph.morphTextureWidth, 1 / morph.morphTextureHeight]);\n      for (let i = 0; i < this.maxSubmitCount; i++) {\n        this['morphBlendTex' + i] = this.device.scope.resolve('morphBlendTex' + i);\n      }\n      this.morphFactor = this.device.scope.resolve('morphFactor[0]');\n      this.zeroTextures = false;\n    } else {\n      this.maxSubmitCount = 8;\n      this._shaderMorphWeights = new Float32Array(this.maxSubmitCount);\n      this._shaderMorphWeightsA = new Float32Array(this._shaderMorphWeights.buffer, 0, 4);\n      this._shaderMorphWeightsB = new Float32Array(this._shaderMorphWeights.buffer, 4 * 4, 4);\n      this._activeVertexBuffers = new Array(this.maxSubmitCount);\n    }\n  }\n  destroy() {\n    this.shader = null;\n    const morph = this.morph;\n    if (morph) {\n      this.morph = null;\n      morph.decRefCount();\n      if (morph.refCount < 1) {\n        morph.destroy();\n      }\n    }\n    if (this.rtPositions) {\n      this.rtPositions.destroy();\n      this.rtPositions = null;\n    }\n    if (this.texturePositions) {\n      this.texturePositions.destroy();\n      this.texturePositions = null;\n    }\n    if (this.rtNormals) {\n      this.rtNormals.destroy();\n      this.rtNormals = null;\n    }\n    if (this.textureNormals) {\n      this.textureNormals.destroy();\n      this.textureNormals = null;\n    }\n  }\n  clone() {\n    return new MorphInstance(this.morph);\n  }\n  _getWeightIndex(key) {\n    if (typeof key === 'string') {\n      const index = this._weightMap.get(key);\n      return index;\n    }\n    return key;\n  }\n  getWeight(key) {\n    const index = this._getWeightIndex(key);\n    return this._weights[index];\n  }\n  setWeight(key, weight) {\n    const index = this._getWeightIndex(key);\n    this._weights[index] = weight;\n    this._dirty = true;\n  }\n  _getFragmentShader(numTextures) {\n    let fragmentShader = '';\n    if (numTextures > 0) {\n      fragmentShader += 'varying vec2 uv0;\\n' + 'uniform highp float morphFactor[' + numTextures + '];\\n';\n    }\n    for (let i = 0; i < numTextures; i++) {\n      fragmentShader += 'uniform highp sampler2D morphBlendTex' + i + ';\\n';\n    }\n    fragmentShader += 'void main (void) {\\n' + '    highp vec4 color = vec4(0, 0, 0, 1);\\n';\n    for (let i = 0; i < numTextures; i++) {\n      fragmentShader += '    color.xyz += morphFactor[' + i + '] * texture2D(morphBlendTex' + i + ', uv0).xyz;\\n';\n    }\n    fragmentShader += '    gl_FragColor = color;\\n' + '}\\n';\n    return fragmentShader;\n  }\n  _getShader(count) {\n    let shader = this.shaderCache[count];\n    if (!shader) {\n      const fs = this._getFragmentShader(count);\n      shader = (0,_shader_lib_utils_js__WEBPACK_IMPORTED_MODULE_3__.createShaderFromCode)(this.device, textureMorphVertexShader, fs, 'textureMorph' + count);\n      this.shaderCache[count] = shader;\n    }\n    return shader;\n  }\n  _updateTextureRenderTarget(renderTarget, srcTextureName) {\n    const device = this.device;\n    const submitBatch = (usedCount, blending) => {\n      this.morphFactor.setValue(this._shaderMorphWeights);\n      device.setBlending(blending);\n      if (blending) {\n        device.setBlendFunction(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.BLENDMODE_ONE, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.BLENDMODE_ONE);\n        device.setBlendEquation(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.BLENDEQUATION_ADD);\n      }\n      const shader = this._getShader(usedCount);\n      (0,_platform_graphics_simple_post_effect_js__WEBPACK_IMPORTED_MODULE_4__.drawQuadWithShader)(device, renderTarget, shader, undefined, undefined, blending);\n    };\n    let usedCount = 0;\n    let blending = false;\n    const count = this._activeTargets.length;\n    for (let i = 0; i < count; i++) {\n      const activeTarget = this._activeTargets[i];\n      const tex = activeTarget.target[srcTextureName];\n      if (tex) {\n        this['morphBlendTex' + usedCount].setValue(tex);\n        this._shaderMorphWeights[usedCount] = activeTarget.weight;\n        usedCount++;\n        if (usedCount >= this.maxSubmitCount) {\n          submitBatch(usedCount, blending);\n          usedCount = 0;\n          blending = true;\n        }\n      }\n    }\n    if (usedCount > 0 || count === 0 && !this.zeroTextures) {\n      submitBatch(usedCount, blending);\n    }\n  }\n  _updateTextureMorph() {\n    this.device;\n    if (this._activeTargets.length > 0 || !this.zeroTextures) {\n      this._updateTextureRenderTarget(this.rtPositions, 'texturePositions');\n      this._updateTextureRenderTarget(this.rtNormals, 'textureNormals');\n      this.zeroTextures = this._activeTargets.length === 0;\n    }\n  }\n  _updateVertexMorph() {\n    const count = this.maxSubmitCount;\n    for (let i = 0; i < count; i++) {\n      this._shaderMorphWeights[i] = 0;\n      this._activeVertexBuffers[i] = null;\n    }\n    let posIndex = 0;\n    let nrmIndex = this.morph.morphPositions ? 4 : 0;\n    for (let i = 0; i < this._activeTargets.length; i++) {\n      const target = this._activeTargets[i].target;\n      if (target._vertexBufferPositions) {\n        this._activeVertexBuffers[posIndex] = target._vertexBufferPositions;\n        this._shaderMorphWeights[posIndex] = this._activeTargets[i].weight;\n        posIndex++;\n      }\n      if (target._vertexBufferNormals) {\n        this._activeVertexBuffers[nrmIndex] = target._vertexBufferNormals;\n        this._shaderMorphWeights[nrmIndex] = this._activeTargets[i].weight;\n        nrmIndex++;\n      }\n    }\n  }\n  update() {\n    this._dirty = false;\n    const targets = this.morph._targets;\n    let activeCount = 0;\n    const epsilon = 0.00001;\n    for (let i = 0; i < targets.length; i++) {\n      const absWeight = Math.abs(this.getWeight(i));\n      if (absWeight > epsilon) {\n        if (this._activeTargets.length <= activeCount) {\n          this._activeTargets[activeCount] = {};\n        }\n        const activeTarget = this._activeTargets[activeCount++];\n        activeTarget.absWeight = absWeight;\n        activeTarget.weight = this.getWeight(i);\n        activeTarget.target = targets[i];\n      }\n    }\n    this._activeTargets.length = activeCount;\n    const maxActiveTargets = this.morph.maxActiveTargets;\n    if (this._activeTargets.length > maxActiveTargets) {\n      this._activeTargets.sort(function (l, r) {\n        return l.absWeight < r.absWeight ? 1 : r.absWeight < l.absWeight ? -1 : 0;\n      });\n      this._activeTargets.length = maxActiveTargets;\n    }\n    if (this.morph.useTextureMorph) {\n      this._updateTextureMorph();\n    } else {\n      this._updateVertexMorph();\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/morph-instance.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/morph-target.js":
/*!****************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/morph-target.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MorphTarget\": () => (/* binding */ MorphTarget)\n/* harmony export */ });\n/* harmony import */ var _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/shape/bounding-box.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/shape/bounding-box.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_vertex_buffer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../platform/graphics/vertex-buffer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/vertex-buffer.js\");\n/* harmony import */ var _platform_graphics_vertex_format_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../platform/graphics/vertex-format.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/vertex-format.js\");\n\n\n\n\n\n\nclass MorphTarget {\n  constructor(options) {\n    this.used = false;\n    if (arguments.length === 2) {\n      options = arguments[1];\n    }\n    this.options = options;\n    this._name = options.name;\n    this._defaultWeight = options.defaultWeight || 0;\n    this.aabb = options.aabb;\n    if (!this.aabb) {\n      this.aabb = new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_0__.BoundingBox();\n      if (options.deltaPositions) this.aabb.compute(options.deltaPositions);\n    }\n    this.deltaPositions = options.deltaPositions;\n  }\n  destroy() {\n    var _this$_vertexBufferPo, _this$_vertexBufferNo, _this$texturePosition, _this$textureNormals;\n    (_this$_vertexBufferPo = this._vertexBufferPositions) == null ? void 0 : _this$_vertexBufferPo.destroy();\n    this._vertexBufferPositions = null;\n    (_this$_vertexBufferNo = this._vertexBufferNormals) == null ? void 0 : _this$_vertexBufferNo.destroy();\n    this._vertexBufferNormals = null;\n    (_this$texturePosition = this.texturePositions) == null ? void 0 : _this$texturePosition.destroy();\n    this.texturePositions = null;\n    (_this$textureNormals = this.textureNormals) == null ? void 0 : _this$textureNormals.destroy();\n    this.textureNormals = null;\n  }\n  get name() {\n    return this._name;\n  }\n  get defaultWeight() {\n    return this._defaultWeight;\n  }\n  get morphPositions() {\n    return !!this._vertexBufferPositions || !!this.texturePositions;\n  }\n  get morphNormals() {\n    return !!this._vertexBufferNormals || !!this.textureNormals;\n  }\n  clone() {\n    return new MorphTarget(this.options);\n  }\n  _postInit() {\n    if (!this.options.preserveData) {\n      this.options = null;\n    }\n    this.used = true;\n  }\n  _initVertexBuffers(graphicsDevice) {\n    const options = this.options;\n    this._vertexBufferPositions = this._createVertexBuffer(graphicsDevice, options.deltaPositions, options.deltaPositionsType);\n    this._vertexBufferNormals = this._createVertexBuffer(graphicsDevice, options.deltaNormals, options.deltaNormalsType);\n    if (this._vertexBufferPositions) {\n      this.deltaPositions = this._vertexBufferPositions.lock();\n    }\n  }\n  _createVertexBuffer(device, data, dataType = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.TYPE_FLOAT32) {\n    if (data) {\n      const formatDesc = [{\n        semantic: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.SEMANTIC_ATTR0,\n        components: 3,\n        type: dataType\n      }];\n      return new _platform_graphics_vertex_buffer_js__WEBPACK_IMPORTED_MODULE_2__.VertexBuffer(device, new _platform_graphics_vertex_format_js__WEBPACK_IMPORTED_MODULE_3__.VertexFormat(device, formatDesc), data.length / 3, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.BUFFER_STATIC, data);\n    }\n    return null;\n  }\n  _setTexture(name, texture) {\n    this[name] = texture;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/morph-target.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/morph.js":
/*!*********************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/morph.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Morph\": () => (/* binding */ Morph)\n/* harmony export */ });\n/* harmony import */ var _core_ref_counted_object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ref-counted-object.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/ref-counted-object.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_math_float_packing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/math/float-packing.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/float-packing.js\");\n/* harmony import */ var _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/shape/bounding-box.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/shape/bounding-box.js\");\n/* harmony import */ var _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../platform/graphics/texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js\");\n/* harmony import */ var _platform_graphics_vertex_buffer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../platform/graphics/vertex-buffer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/vertex-buffer.js\");\n/* harmony import */ var _platform_graphics_vertex_format_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../platform/graphics/vertex-format.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/vertex-format.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_graphics_device_access_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/graphics/graphics-device-access.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/graphics-device-access.js\");\n\n\n\n\n\n\n\n\n\n\n\nconst _floatRounding = 0.2;\nclass Morph extends _core_ref_counted_object_js__WEBPACK_IMPORTED_MODULE_0__.RefCountedObject {\n  constructor(targets, graphicsDevice) {\n    super();\n    this.device = graphicsDevice || _platform_graphics_graphics_device_access_js__WEBPACK_IMPORTED_MODULE_1__.GraphicsDeviceAccess.get();\n    targets.forEach(target => void 0);\n    this._targets = targets.slice();\n    if (this.device.supportsMorphTargetTexturesCore) {\n      if (this.device.extTextureHalfFloat && this.device.textureHalfFloatRenderable) {\n        this._renderTextureFormat = Morph.FORMAT_HALF_FLOAT;\n      } else if (this.device.extTextureFloat && this.device.textureFloatRenderable) {\n        this._renderTextureFormat = Morph.FORMAT_FLOAT;\n      }\n      if (this.device.extTextureHalfFloat && this.device.textureHalfFloatUpdatable) {\n        this._textureFormat = Morph.FORMAT_HALF_FLOAT;\n      } else if (this.device.extTextureFloat) {\n        this._textureFormat = Morph.FORMAT_FLOAT;\n      }\n      if (this._renderTextureFormat !== undefined && this._textureFormat !== undefined) {\n        this._useTextureMorph = true;\n      }\n    }\n    this._init();\n    this._updateMorphFlags();\n    this._calculateAabb();\n  }\n  get morphPositions() {\n    return this._morphPositions;\n  }\n  get morphNormals() {\n    return this._morphNormals;\n  }\n  get maxActiveTargets() {\n    if (this._useTextureMorph) return this._targets.length;\n    return this._morphPositions && this._morphNormals ? 4 : 8;\n  }\n  get useTextureMorph() {\n    return this._useTextureMorph;\n  }\n  _init() {\n    if (this._useTextureMorph) {\n      this._useTextureMorph = this._initTextureBased();\n    }\n    if (!this._useTextureMorph) {\n      for (let i = 0; i < this._targets.length; i++) {\n        this._targets[i]._initVertexBuffers(this.device);\n      }\n    }\n    for (let i = 0; i < this._targets.length; i++) {\n      this._targets[i]._postInit();\n    }\n  }\n  _initTextureBased() {\n    const deltaArrays = [],\n      deltaInfos = [];\n    for (let i = 0; i < this._targets.length; i++) {\n      const target = this._targets[i];\n      if (target.options.deltaPositions) {\n        deltaArrays.push(target.options.deltaPositions);\n        deltaInfos.push({\n          target: target,\n          name: 'texturePositions'\n        });\n      }\n      if (target.options.deltaNormals) {\n        deltaArrays.push(target.options.deltaNormals);\n        deltaInfos.push({\n          target: target,\n          name: 'textureNormals'\n        });\n      }\n    }\n    const ids = [],\n      usedDataIndices = [];\n    let freeIndex = 1;\n    const dataCount = deltaArrays[0].length;\n    for (let v = 0; v < dataCount; v += 3) {\n      let vertexUsed = false;\n      for (let i = 0; i < deltaArrays.length; i++) {\n        const data = deltaArrays[i];\n        if (data[v] !== 0 || data[v + 1] !== 0 || data[v + 2] !== 0) {\n          vertexUsed = true;\n          break;\n        }\n      }\n      if (vertexUsed) {\n        ids.push(freeIndex + _floatRounding);\n        usedDataIndices.push(v / 3);\n        freeIndex++;\n      } else {\n        ids.push(0 + _floatRounding);\n      }\n    }\n    const maxTextureSize = Math.min(this.device.maxTextureSize, 4096);\n    let morphTextureWidth = Math.ceil(Math.sqrt(freeIndex));\n    morphTextureWidth = Math.min(morphTextureWidth, maxTextureSize);\n    const morphTextureHeight = Math.ceil(freeIndex / morphTextureWidth);\n    if (morphTextureHeight > maxTextureSize) {\n      return false;\n    }\n    this.morphTextureWidth = morphTextureWidth;\n    this.morphTextureHeight = morphTextureHeight;\n    let halfFloat = false;\n    let numComponents = 3;\n    const float2Half = _core_math_float_packing_js__WEBPACK_IMPORTED_MODULE_2__.FloatPacking.float2Half;\n    if (this._textureFormat === Morph.FORMAT_HALF_FLOAT) {\n      halfFloat = true;\n      numComponents = 4;\n    }\n    const arraySize = this.morphTextureWidth * this.morphTextureHeight * numComponents;\n    const packedDeltas = halfFloat ? new Uint16Array(arraySize) : new Float32Array(arraySize);\n    for (let i = 0; i < deltaArrays.length; i++) {\n      const data = deltaArrays[i];\n      for (let v = 0; v < usedDataIndices.length; v++) {\n        const index = usedDataIndices[v];\n        if (halfFloat) {\n          packedDeltas[v * numComponents + numComponents] = float2Half(data[index * 3]);\n          packedDeltas[v * numComponents + numComponents + 1] = float2Half(data[index * 3 + 1]);\n          packedDeltas[v * numComponents + numComponents + 2] = float2Half(data[index * 3 + 2]);\n        } else {\n          packedDeltas[v * numComponents + numComponents] = data[index * 3];\n          packedDeltas[v * numComponents + numComponents + 1] = data[index * 3 + 1];\n          packedDeltas[v * numComponents + numComponents + 2] = data[index * 3 + 2];\n        }\n      }\n      const target = deltaInfos[i].target;\n      const format = this._textureFormat === Morph.FORMAT_FLOAT ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.PIXELFORMAT_RGB32F : _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.PIXELFORMAT_RGBA16F;\n      target._setTexture(deltaInfos[i].name, this._createTexture('MorphTarget', format, packedDeltas));\n    }\n    const formatDesc = [{\n      semantic: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.SEMANTIC_ATTR15,\n      components: 1,\n      type: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.TYPE_FLOAT32\n    }];\n    this.vertexBufferIds = new _platform_graphics_vertex_buffer_js__WEBPACK_IMPORTED_MODULE_4__.VertexBuffer(this.device, new _platform_graphics_vertex_format_js__WEBPACK_IMPORTED_MODULE_5__.VertexFormat(this.device, formatDesc), ids.length, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.BUFFER_STATIC, new Float32Array(ids));\n    return true;\n  }\n  destroy() {\n    var _this$vertexBufferIds;\n    (_this$vertexBufferIds = this.vertexBufferIds) == null ? void 0 : _this$vertexBufferIds.destroy();\n    this.vertexBufferIds = null;\n    for (let i = 0; i < this._targets.length; i++) {\n      this._targets[i].destroy();\n    }\n    this._targets.length = 0;\n  }\n  get targets() {\n    return this._targets;\n  }\n  _updateMorphFlags() {\n    this._morphPositions = false;\n    this._morphNormals = false;\n    for (let i = 0; i < this._targets.length; i++) {\n      const target = this._targets[i];\n      if (target.morphPositions) {\n        this._morphPositions = true;\n      }\n      if (target.morphNormals) {\n        this._morphNormals = true;\n      }\n    }\n  }\n  _calculateAabb() {\n    const min = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_6__.Vec3();\n    const max = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_6__.Vec3();\n    for (let i = 0; i < this._targets.length; i++) {\n      const targetAabb = this._targets[i].aabb;\n      min.min(targetAabb.getMin());\n      max.max(targetAabb.getMax());\n    }\n    this.aabb = new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_7__.BoundingBox();\n    this.aabb.setMinMax(min, max);\n  }\n  _createTexture(name, format, pixelData) {\n    const texture = new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_8__.Texture(this.device, {\n      width: this.morphTextureWidth,\n      height: this.morphTextureHeight,\n      format: format,\n      cubemap: false,\n      mipmaps: false,\n      minFilter: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.FILTER_NEAREST,\n      magFilter: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.FILTER_NEAREST,\n      addressU: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.ADDRESS_CLAMP_TO_EDGE,\n      addressV: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.ADDRESS_CLAMP_TO_EDGE,\n      name: name\n    });\n    if (pixelData) {\n      texture.lock().set(pixelData);\n      texture.unlock();\n    }\n    return texture;\n  }\n}\nMorph.FORMAT_FLOAT = 0;\nMorph.FORMAT_HALF_FLOAT = 1;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/morph.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/particle-system/cpu-updater.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/particle-system/cpu-updater.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ParticleCPUUpdater\": () => (/* binding */ ParticleCPUUpdater)\n/* harmony export */ });\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/math/mat4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n\n\n\n\n\nlet nonUniformScale;\nlet uniformScale = 1;\nconst particleTexChannels = 4;\nconst rotMat = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\nconst rotMatInv = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\nconst randomPosTformed = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst randomPos = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst rndFactor3Vec = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst particlePosPrev = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst velocityVec = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst localVelocityVec = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst velocityVec2 = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst localVelocityVec2 = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst radialVelocityVec = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst particlePos = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst particleFinalPos = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst moveDirVec = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst tmpVec3 = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nfunction frac(f) {\n  return f - Math.floor(f);\n}\nfunction saturate(x) {\n  return Math.max(Math.min(x, 1), 0);\n}\nfunction glMod(x, y) {\n  return x - y * Math.floor(x / y);\n}\nfunction encodeFloatRGBA(v) {\n  let encX = frac(v);\n  let encY = frac(255.0 * v);\n  let encZ = frac(65025.0 * v);\n  let encW = frac(160581375.0 * v);\n  encX -= encY / 255.0;\n  encY -= encZ / 255.0;\n  encZ -= encW / 255.0;\n  encW -= encW / 255.0;\n  return [encX, encY, encZ, encW];\n}\nfunction encodeFloatRG(v) {\n  let encX = frac(v);\n  let encY = frac(255.0 * v);\n  encX -= encY / 255.0;\n  encY -= encY / 255.0;\n  return [encX, encY];\n}\nclass ParticleCPUUpdater {\n  constructor(emitter) {\n    this._emitter = emitter;\n  }\n  calcSpawnPosition(particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, i) {\n    const emitter = this._emitter;\n    const rX = Math.random();\n    const rY = Math.random();\n    const rZ = Math.random();\n    const rW = Math.random();\n    if (emitter.useCpu) {\n      particleTex[i * particleTexChannels + 0 + emitter.numParticlesPot * 2 * particleTexChannels] = rX;\n      particleTex[i * particleTexChannels + 1 + emitter.numParticlesPot * 2 * particleTexChannels] = rY;\n      particleTex[i * particleTexChannels + 2 + emitter.numParticlesPot * 2 * particleTexChannels] = rZ;\n    }\n    randomPos.x = rX - 0.5;\n    randomPos.y = rY - 0.5;\n    randomPos.z = rZ - 0.5;\n    if (emitter.emitterShape === _constants_js__WEBPACK_IMPORTED_MODULE_2__.EMITTERSHAPE_BOX) {\n      const max = Math.max(Math.abs(randomPos.x), Math.max(Math.abs(randomPos.y), Math.abs(randomPos.z)));\n      const edgeX = max + (0.5 - max) * extentsInnerRatioUniform[0];\n      const edgeY = max + (0.5 - max) * extentsInnerRatioUniform[1];\n      const edgeZ = max + (0.5 - max) * extentsInnerRatioUniform[2];\n      randomPos.x = edgeX * (max === Math.abs(randomPos.x) ? Math.sign(randomPos.x) : 2 * randomPos.x);\n      randomPos.y = edgeY * (max === Math.abs(randomPos.y) ? Math.sign(randomPos.y) : 2 * randomPos.y);\n      randomPos.z = edgeZ * (max === Math.abs(randomPos.z) ? Math.sign(randomPos.z) : 2 * randomPos.z);\n      if (!emitter.localSpace) randomPosTformed.copy(emitterPos).add(spawnMatrix.transformPoint(randomPos));else randomPosTformed.copy(spawnMatrix.transformPoint(randomPos));\n    } else {\n      randomPos.normalize();\n      const spawnBoundsSphereInnerRatio = emitter.emitterRadius === 0 ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius;\n      const r = rW * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;\n      if (!emitter.localSpace) randomPosTformed.copy(emitterPos).add(randomPos.mulScalar(r * emitter.emitterRadius));else randomPosTformed.copy(randomPos.mulScalar(r * emitter.emitterRadius));\n    }\n    const particleRate = _core_math_math_js__WEBPACK_IMPORTED_MODULE_3__.math.lerp(emitter.rate, emitter.rate2, rX);\n    let startSpawnTime = -particleRate * i;\n    if (emitter.pack8) {\n      const packX = (randomPosTformed.x - emitter.worldBounds.center.x) / emitter.worldBoundsSize.x + 0.5;\n      const packY = (randomPosTformed.y - emitter.worldBounds.center.y) / emitter.worldBoundsSize.y + 0.5;\n      const packZ = (randomPosTformed.z - emitter.worldBounds.center.z) / emitter.worldBoundsSize.z + 0.5;\n      let packA = _core_math_math_js__WEBPACK_IMPORTED_MODULE_3__.math.lerp(emitter.startAngle * _core_math_math_js__WEBPACK_IMPORTED_MODULE_3__.math.DEG_TO_RAD, emitter.startAngle2 * _core_math_math_js__WEBPACK_IMPORTED_MODULE_3__.math.DEG_TO_RAD, rX);\n      packA = packA % (Math.PI * 2) / (Math.PI * 2);\n      const rg0 = encodeFloatRG(packX);\n      particleTex[i * particleTexChannels] = rg0[0];\n      particleTex[i * particleTexChannels + 1] = rg0[1];\n      const ba0 = encodeFloatRG(packY);\n      particleTex[i * particleTexChannels + 2] = ba0[0];\n      particleTex[i * particleTexChannels + 3] = ba0[1];\n      const rg1 = encodeFloatRG(packZ);\n      particleTex[i * particleTexChannels + 0 + emitter.numParticlesPot * particleTexChannels] = rg1[0];\n      particleTex[i * particleTexChannels + 1 + emitter.numParticlesPot * particleTexChannels] = rg1[1];\n      const ba1 = encodeFloatRG(packA);\n      particleTex[i * particleTexChannels + 2 + emitter.numParticlesPot * particleTexChannels] = ba1[0];\n      particleTex[i * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels] = ba1[1];\n      const a2 = 1.0;\n      particleTex[i * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels * 2] = a2;\n      const maxNegLife = Math.max(emitter.lifetime, (emitter.numParticles - 1.0) * Math.max(emitter.rate, emitter.rate2));\n      const maxPosLife = emitter.lifetime + 1.0;\n      startSpawnTime = (startSpawnTime + maxNegLife) / (maxNegLife + maxPosLife);\n      const rgba3 = encodeFloatRGBA(startSpawnTime);\n      particleTex[i * particleTexChannels + 0 + emitter.numParticlesPot * particleTexChannels * 3] = rgba3[0];\n      particleTex[i * particleTexChannels + 1 + emitter.numParticlesPot * particleTexChannels * 3] = rgba3[1];\n      particleTex[i * particleTexChannels + 2 + emitter.numParticlesPot * particleTexChannels * 3] = rgba3[2];\n      particleTex[i * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels * 3] = rgba3[3];\n    } else {\n      particleTex[i * particleTexChannels] = randomPosTformed.x;\n      particleTex[i * particleTexChannels + 1] = randomPosTformed.y;\n      particleTex[i * particleTexChannels + 2] = randomPosTformed.z;\n      particleTex[i * particleTexChannels + 3] = _core_math_math_js__WEBPACK_IMPORTED_MODULE_3__.math.lerp(emitter.startAngle * _core_math_math_js__WEBPACK_IMPORTED_MODULE_3__.math.DEG_TO_RAD, emitter.startAngle2 * _core_math_math_js__WEBPACK_IMPORTED_MODULE_3__.math.DEG_TO_RAD, rX);\n      particleTex[i * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels] = startSpawnTime;\n    }\n  }\n  update(data, vbToSort, particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, delta, isOnStop) {\n    let a, b, c;\n    const emitter = this._emitter;\n    if (emitter.meshInstance.node) {\n      const fullMat = emitter.meshInstance.node.worldTransform;\n      for (let j = 0; j < 12; j++) {\n        rotMat.data[j] = fullMat.data[j];\n      }\n      rotMatInv.copy(rotMat);\n      rotMatInv.invert();\n      nonUniformScale = emitter.meshInstance.node.localScale;\n      uniformScale = Math.max(Math.max(nonUniformScale.x, nonUniformScale.y), nonUniformScale.z);\n    }\n    emitterPos = emitter.meshInstance.node === null || emitter.localSpace ? _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3.ZERO : emitter.meshInstance.node.getPosition();\n    const posCam = emitter.camera ? emitter.camera._node.getPosition() : _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3.ZERO;\n    const vertSize = !emitter.useMesh ? 15 : 17;\n    let cf, cc;\n    let rotSpeed, rotSpeed2, scale2, alpha, alpha2, radialSpeed, radialSpeed2;\n    const precision1 = emitter.precision - 1;\n    for (let i = 0; i < emitter.numParticles; i++) {\n      const id = Math.floor(emitter.vbCPU[i * emitter.numParticleVerts * (emitter.useMesh ? 6 : 4) + 3]);\n      const rndFactor = particleTex[id * particleTexChannels + 0 + emitter.numParticlesPot * 2 * particleTexChannels];\n      rndFactor3Vec.x = rndFactor;\n      rndFactor3Vec.y = particleTex[id * particleTexChannels + 1 + emitter.numParticlesPot * 2 * particleTexChannels];\n      rndFactor3Vec.z = particleTex[id * particleTexChannels + 2 + emitter.numParticlesPot * 2 * particleTexChannels];\n      const particleRate = emitter.rate + (emitter.rate2 - emitter.rate) * rndFactor;\n      const particleLifetime = emitter.lifetime;\n      let life = particleTex[id * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels] + delta;\n      const nlife = saturate(life / particleLifetime);\n      let scale = 0;\n      let alphaDiv = 0;\n      const angle = 0;\n      const respawn = life - delta <= 0.0 || life >= particleLifetime;\n      if (respawn) {\n        this.calcSpawnPosition(particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, id);\n      }\n      let particleEnabled = life > 0.0 && life < particleLifetime;\n      if (particleEnabled) {\n        c = nlife * precision1;\n        cf = Math.floor(c);\n        cc = Math.ceil(c);\n        c %= 1;\n        a = emitter.qRotSpeed[cf];\n        b = emitter.qRotSpeed[cc];\n        rotSpeed = a + (b - a) * c;\n        a = emitter.qRotSpeed2[cf];\n        b = emitter.qRotSpeed2[cc];\n        rotSpeed2 = a + (b - a) * c;\n        a = emitter.qScale[cf];\n        b = emitter.qScale[cc];\n        scale = a + (b - a) * c;\n        a = emitter.qScale2[cf];\n        b = emitter.qScale2[cc];\n        scale2 = a + (b - a) * c;\n        a = emitter.qAlpha[cf];\n        b = emitter.qAlpha[cc];\n        alpha = a + (b - a) * c;\n        a = emitter.qAlpha2[cf];\n        b = emitter.qAlpha2[cc];\n        alpha2 = a + (b - a) * c;\n        a = emitter.qRadialSpeed[cf];\n        b = emitter.qRadialSpeed[cc];\n        radialSpeed = a + (b - a) * c;\n        a = emitter.qRadialSpeed2[cf];\n        b = emitter.qRadialSpeed2[cc];\n        radialSpeed2 = a + (b - a) * c;\n        radialSpeed += (radialSpeed2 - radialSpeed) * (rndFactor * 100.0 % 1.0);\n        particlePosPrev.x = particleTex[id * particleTexChannels];\n        particlePosPrev.y = particleTex[id * particleTexChannels + 1];\n        particlePosPrev.z = particleTex[id * particleTexChannels + 2];\n        if (!emitter.localSpace) radialVelocityVec.copy(particlePosPrev).sub(emitterPos);else radialVelocityVec.copy(particlePosPrev);\n        radialVelocityVec.normalize().mulScalar(radialSpeed);\n        cf *= 3;\n        cc *= 3;\n        a = emitter.qLocalVelocity[cf];\n        b = emitter.qLocalVelocity[cc];\n        localVelocityVec.x = a + (b - a) * c;\n        a = emitter.qLocalVelocity[cf + 1];\n        b = emitter.qLocalVelocity[cc + 1];\n        localVelocityVec.y = a + (b - a) * c;\n        a = emitter.qLocalVelocity[cf + 2];\n        b = emitter.qLocalVelocity[cc + 2];\n        localVelocityVec.z = a + (b - a) * c;\n        a = emitter.qLocalVelocity2[cf];\n        b = emitter.qLocalVelocity2[cc];\n        localVelocityVec2.x = a + (b - a) * c;\n        a = emitter.qLocalVelocity2[cf + 1];\n        b = emitter.qLocalVelocity2[cc + 1];\n        localVelocityVec2.y = a + (b - a) * c;\n        a = emitter.qLocalVelocity2[cf + 2];\n        b = emitter.qLocalVelocity2[cc + 2];\n        localVelocityVec2.z = a + (b - a) * c;\n        a = emitter.qVelocity[cf];\n        b = emitter.qVelocity[cc];\n        velocityVec.x = a + (b - a) * c;\n        a = emitter.qVelocity[cf + 1];\n        b = emitter.qVelocity[cc + 1];\n        velocityVec.y = a + (b - a) * c;\n        a = emitter.qVelocity[cf + 2];\n        b = emitter.qVelocity[cc + 2];\n        velocityVec.z = a + (b - a) * c;\n        a = emitter.qVelocity2[cf];\n        b = emitter.qVelocity2[cc];\n        velocityVec2.x = a + (b - a) * c;\n        a = emitter.qVelocity2[cf + 1];\n        b = emitter.qVelocity2[cc + 1];\n        velocityVec2.y = a + (b - a) * c;\n        a = emitter.qVelocity2[cf + 2];\n        b = emitter.qVelocity2[cc + 2];\n        velocityVec2.z = a + (b - a) * c;\n        localVelocityVec.x += (localVelocityVec2.x - localVelocityVec.x) * rndFactor3Vec.x;\n        localVelocityVec.y += (localVelocityVec2.y - localVelocityVec.y) * rndFactor3Vec.y;\n        localVelocityVec.z += (localVelocityVec2.z - localVelocityVec.z) * rndFactor3Vec.z;\n        if (emitter.initialVelocity > 0) {\n          if (emitter.emitterShape === _constants_js__WEBPACK_IMPORTED_MODULE_2__.EMITTERSHAPE_SPHERE) {\n            randomPos.copy(rndFactor3Vec).mulScalar(2).sub(_core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3.ONE).normalize();\n            localVelocityVec.add(randomPos.mulScalar(emitter.initialVelocity));\n          } else {\n            localVelocityVec.add(_core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3.FORWARD.mulScalar(emitter.initialVelocity));\n          }\n        }\n        velocityVec.x += (velocityVec2.x - velocityVec.x) * rndFactor3Vec.x;\n        velocityVec.y += (velocityVec2.y - velocityVec.y) * rndFactor3Vec.y;\n        velocityVec.z += (velocityVec2.z - velocityVec.z) * rndFactor3Vec.z;\n        rotSpeed += (rotSpeed2 - rotSpeed) * rndFactor3Vec.y;\n        scale = (scale + (scale2 - scale) * (rndFactor * 10000.0 % 1.0)) * uniformScale;\n        alphaDiv = (alpha2 - alpha) * (rndFactor * 1000.0 % 1.0);\n        if (emitter.meshInstance.node) {\n          if (!emitter.localSpace) {\n            rotMat.transformPoint(localVelocityVec, localVelocityVec);\n          } else {\n            localVelocityVec.x /= nonUniformScale.x;\n            localVelocityVec.y /= nonUniformScale.y;\n            localVelocityVec.z /= nonUniformScale.z;\n          }\n        }\n        if (!emitter.localSpace) {\n          localVelocityVec.add(velocityVec.mul(nonUniformScale));\n          localVelocityVec.add(radialVelocityVec.mul(nonUniformScale));\n        } else {\n          rotMatInv.transformPoint(velocityVec, velocityVec);\n          localVelocityVec.add(velocityVec).add(radialVelocityVec);\n        }\n        moveDirVec.copy(localVelocityVec);\n        particlePos.copy(particlePosPrev).add(localVelocityVec.mulScalar(delta));\n        particleFinalPos.copy(particlePos);\n        particleTex[id * particleTexChannels] = particleFinalPos.x;\n        particleTex[id * particleTexChannels + 1] = particleFinalPos.y;\n        particleTex[id * particleTexChannels + 2] = particleFinalPos.z;\n        particleTex[id * particleTexChannels + 3] += rotSpeed * delta;\n        if (emitter.wrap && emitter.wrapBounds) {\n          if (!emitter.localSpace) particleFinalPos.sub(emitterPos);\n          particleFinalPos.x = glMod(particleFinalPos.x, emitter.wrapBounds.x) - emitter.wrapBounds.x * 0.5;\n          particleFinalPos.y = glMod(particleFinalPos.y, emitter.wrapBounds.y) - emitter.wrapBounds.y * 0.5;\n          particleFinalPos.z = glMod(particleFinalPos.z, emitter.wrapBounds.z) - emitter.wrapBounds.z * 0.5;\n          if (!emitter.localSpace) particleFinalPos.add(emitterPos);\n        }\n        if (emitter.sort > 0) {\n          if (emitter.sort === 1) {\n            tmpVec3.copy(particleFinalPos).sub(posCam);\n            emitter.particleDistance[id] = -(tmpVec3.x * tmpVec3.x + tmpVec3.y * tmpVec3.y + tmpVec3.z * tmpVec3.z);\n          } else if (emitter.sort === 2) {\n            emitter.particleDistance[id] = life;\n          } else if (emitter.sort === 3) {\n            emitter.particleDistance[id] = -life;\n          }\n        }\n      }\n      if (isOnStop) {\n        if (life < 0) {\n          particleTex[id * particleTexChannels + 3 + emitter.numParticlesPot * 2 * particleTexChannels] = -1;\n        }\n      } else {\n        if (life >= particleLifetime) {\n          life -= Math.max(particleLifetime, (emitter.numParticles - 1) * particleRate);\n          particleTex[id * particleTexChannels + 3 + emitter.numParticlesPot * 2 * particleTexChannels] = emitter.loop ? 1 : -1;\n        }\n        if (life < 0 && emitter.loop) {\n          particleTex[id * particleTexChannels + 3 + emitter.numParticlesPot * 2 * particleTexChannels] = 1;\n        }\n      }\n      if (particleTex[id * particleTexChannels + 3 + emitter.numParticlesPot * 2 * particleTexChannels] < 0) particleEnabled = false;\n      particleTex[id * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels] = life;\n      for (let v = 0; v < emitter.numParticleVerts; v++) {\n        const vbOffset = (i * emitter.numParticleVerts + v) * (emitter.useMesh ? 6 : 4);\n        let quadX = emitter.vbCPU[vbOffset];\n        let quadY = emitter.vbCPU[vbOffset + 1];\n        let quadZ = emitter.vbCPU[vbOffset + 2];\n        if (!particleEnabled) {\n          quadX = quadY = quadZ = 0;\n        }\n        const w = i * emitter.numParticleVerts * vertSize + v * vertSize;\n        data[w] = particleFinalPos.x;\n        data[w + 1] = particleFinalPos.y;\n        data[w + 2] = particleFinalPos.z;\n        data[w + 3] = nlife;\n        data[w + 4] = emitter.alignToMotion ? angle : particleTex[id * particleTexChannels + 3];\n        data[w + 5] = scale;\n        data[w + 6] = alphaDiv;\n        data[w + 7] = moveDirVec.x;\n        data[w + 8] = quadX;\n        data[w + 9] = quadY;\n        data[w + 10] = quadZ;\n        data[w + 11] = moveDirVec.y;\n        data[w + 12] = id;\n        data[w + 13] = moveDirVec.z;\n        data[w + 14] = emitter.vbCPU[vbOffset + 3];\n        if (emitter.useMesh) {\n          data[w + 15] = emitter.vbCPU[vbOffset + 4];\n          data[w + 16] = emitter.vbCPU[vbOffset + 5];\n        }\n      }\n    }\n    if (emitter.sort > _constants_js__WEBPACK_IMPORTED_MODULE_2__.PARTICLESORT_NONE && emitter.camera) {\n      const vbStride = emitter.useMesh ? 6 : 4;\n      const particleDistance = emitter.particleDistance;\n      for (let i = 0; i < emitter.numParticles; i++) {\n        vbToSort[i][0] = i;\n        vbToSort[i][1] = particleDistance[Math.floor(emitter.vbCPU[i * emitter.numParticleVerts * vbStride + 3])];\n      }\n      emitter.vbOld.set(emitter.vbCPU);\n      vbToSort.sort(function (p1, p2) {\n        return p1[1] - p2[1];\n      });\n      for (let i = 0; i < emitter.numParticles; i++) {\n        const src = vbToSort[i][0] * emitter.numParticleVerts * vbStride;\n        const dest = i * emitter.numParticleVerts * vbStride;\n        for (let j = 0; j < emitter.numParticleVerts * vbStride; j++) {\n          emitter.vbCPU[dest + j] = emitter.vbOld[src + j];\n        }\n      }\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/particle-system/cpu-updater.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/particle-system/gpu-updater.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/particle-system/gpu-updater.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ParticleGPUUpdater\": () => (/* binding */ ParticleGPUUpdater)\n/* harmony export */ });\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _core_math_mat3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/math/mat3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat3.js\");\n/* harmony import */ var _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/math/mat4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_simple_post_effect_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../platform/graphics/simple-post-effect.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/simple-post-effect.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n\n\n\n\n\n\n\n\nconst spawnMatrix3 = new _core_math_mat3_js__WEBPACK_IMPORTED_MODULE_0__.Mat3();\nconst emitterMatrix3 = new _core_math_mat3_js__WEBPACK_IMPORTED_MODULE_0__.Mat3();\nconst emitterMatrix3Inv = new _core_math_mat3_js__WEBPACK_IMPORTED_MODULE_0__.Mat3();\nclass ParticleGPUUpdater {\n  constructor(emitter, gd) {\n    this._emitter = emitter;\n    this.frameRandomUniform = new Float32Array(3);\n    this.emitterPosUniform = new Float32Array(3);\n    this.emitterScaleUniform = new Float32Array([1, 1, 1]);\n    this.worldBoundsMulUniform = new Float32Array(3);\n    this.worldBoundsAddUniform = new Float32Array(3);\n    this.inBoundsSizeUniform = new Float32Array(3);\n    this.inBoundsCenterUniform = new Float32Array(3);\n    this.constantParticleTexIN = gd.scope.resolve('particleTexIN');\n    this.constantParticleTexOUT = gd.scope.resolve('particleTexOUT');\n    this.constantEmitterPos = gd.scope.resolve('emitterPos');\n    this.constantEmitterScale = gd.scope.resolve('emitterScale');\n    this.constantSpawnBounds = gd.scope.resolve('spawnBounds');\n    this.constantSpawnPosInnerRatio = gd.scope.resolve('spawnPosInnerRatio');\n    this.constantSpawnBoundsSphere = gd.scope.resolve('spawnBoundsSphere');\n    this.constantSpawnBoundsSphereInnerRatio = gd.scope.resolve('spawnBoundsSphereInnerRatio');\n    this.constantInitialVelocity = gd.scope.resolve('initialVelocity');\n    this.constantFrameRandom = gd.scope.resolve('frameRandom');\n    this.constantDelta = gd.scope.resolve('delta');\n    this.constantRate = gd.scope.resolve('rate');\n    this.constantRateDiv = gd.scope.resolve('rateDiv');\n    this.constantLifetime = gd.scope.resolve('lifetime');\n    this.constantGraphSampleSize = gd.scope.resolve('graphSampleSize');\n    this.constantGraphNumSamples = gd.scope.resolve('graphNumSamples');\n    this.constantInternalTex0 = gd.scope.resolve('internalTex0');\n    this.constantInternalTex1 = gd.scope.resolve('internalTex1');\n    this.constantInternalTex2 = gd.scope.resolve('internalTex2');\n    this.constantInternalTex3 = gd.scope.resolve('internalTex3');\n    this.constantEmitterMatrix = gd.scope.resolve('emitterMatrix');\n    this.constantEmitterMatrixInv = gd.scope.resolve('emitterMatrixInv');\n    this.constantNumParticles = gd.scope.resolve('numParticles');\n    this.constantNumParticlesPot = gd.scope.resolve('numParticlesPot');\n    this.constantLocalVelocityDivMult = gd.scope.resolve('localVelocityDivMult');\n    this.constantVelocityDivMult = gd.scope.resolve('velocityDivMult');\n    this.constantRotSpeedDivMult = gd.scope.resolve('rotSpeedDivMult');\n    this.constantSeed = gd.scope.resolve('seed');\n    this.constantStartAngle = gd.scope.resolve('startAngle');\n    this.constantStartAngle2 = gd.scope.resolve('startAngle2');\n    this.constantOutBoundsMul = gd.scope.resolve('outBoundsMul');\n    this.constantOutBoundsAdd = gd.scope.resolve('outBoundsAdd');\n    this.constantInBoundsSize = gd.scope.resolve('inBoundsSize');\n    this.constantInBoundsCenter = gd.scope.resolve('inBoundsCenter');\n    this.constantMaxVel = gd.scope.resolve('maxVel');\n    this.constantFaceTangent = gd.scope.resolve('faceTangent');\n    this.constantFaceBinorm = gd.scope.resolve('faceBinorm');\n  }\n  _setInputBounds() {\n    this.inBoundsSizeUniform[0] = this._emitter.prevWorldBoundsSize.x;\n    this.inBoundsSizeUniform[1] = this._emitter.prevWorldBoundsSize.y;\n    this.inBoundsSizeUniform[2] = this._emitter.prevWorldBoundsSize.z;\n    this.constantInBoundsSize.setValue(this.inBoundsSizeUniform);\n    this.inBoundsCenterUniform[0] = this._emitter.prevWorldBoundsCenter.x;\n    this.inBoundsCenterUniform[1] = this._emitter.prevWorldBoundsCenter.y;\n    this.inBoundsCenterUniform[2] = this._emitter.prevWorldBoundsCenter.z;\n    this.constantInBoundsCenter.setValue(this.inBoundsCenterUniform);\n  }\n  randomize() {\n    this.frameRandomUniform[0] = Math.random();\n    this.frameRandomUniform[1] = Math.random();\n    this.frameRandomUniform[2] = Math.random();\n  }\n  update(device, spawnMatrix, extentsInnerRatioUniform, delta, isOnStop) {\n    const emitter = this._emitter;\n    device.setBlending(false);\n    device.setColorWrite(true, true, true, true);\n    device.setCullMode(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.CULLFACE_NONE);\n    device.setDepthTest(false);\n    device.setDepthWrite(false);\n    this.randomize();\n    this.constantGraphSampleSize.setValue(1.0 / emitter.precision);\n    this.constantGraphNumSamples.setValue(emitter.precision);\n    this.constantNumParticles.setValue(emitter.numParticles);\n    this.constantNumParticlesPot.setValue(emitter.numParticlesPot);\n    this.constantInternalTex0.setValue(emitter.internalTex0);\n    this.constantInternalTex1.setValue(emitter.internalTex1);\n    this.constantInternalTex2.setValue(emitter.internalTex2);\n    this.constantInternalTex3.setValue(emitter.internalTex3);\n    const node = emitter.meshInstance.node;\n    const emitterScale = node === null ? _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_2__.Vec3.ONE : node.localScale;\n    if (emitter.pack8) {\n      this.worldBoundsMulUniform[0] = emitter.worldBoundsMul.x;\n      this.worldBoundsMulUniform[1] = emitter.worldBoundsMul.y;\n      this.worldBoundsMulUniform[2] = emitter.worldBoundsMul.z;\n      this.constantOutBoundsMul.setValue(this.worldBoundsMulUniform);\n      this.worldBoundsAddUniform[0] = emitter.worldBoundsAdd.x;\n      this.worldBoundsAddUniform[1] = emitter.worldBoundsAdd.y;\n      this.worldBoundsAddUniform[2] = emitter.worldBoundsAdd.z;\n      this.constantOutBoundsAdd.setValue(this.worldBoundsAddUniform);\n      this._setInputBounds();\n      let maxVel = emitter.maxVel * Math.max(Math.max(emitterScale.x, emitterScale.y), emitterScale.z);\n      maxVel = Math.max(maxVel, 1);\n      this.constantMaxVel.setValue(maxVel);\n    }\n    const emitterPos = node === null || emitter.localSpace ? _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_2__.Vec3.ZERO : node.getPosition();\n    const emitterMatrix = node === null ? _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_3__.Mat4.IDENTITY : node.getWorldTransform();\n    if (emitter.emitterShape === _constants_js__WEBPACK_IMPORTED_MODULE_4__.EMITTERSHAPE_BOX) {\n      spawnMatrix3.setFromMat4(spawnMatrix);\n      this.constantSpawnBounds.setValue(spawnMatrix3.data);\n      this.constantSpawnPosInnerRatio.setValue(extentsInnerRatioUniform);\n    } else {\n      this.constantSpawnBoundsSphere.setValue(emitter.emitterRadius);\n      this.constantSpawnBoundsSphereInnerRatio.setValue(emitter.emitterRadius === 0 ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius);\n    }\n    this.constantInitialVelocity.setValue(emitter.initialVelocity);\n    emitterMatrix3.setFromMat4(emitterMatrix);\n    emitterMatrix.invertTo3x3(emitterMatrix3Inv);\n    this.emitterPosUniform[0] = emitterPos.x;\n    this.emitterPosUniform[1] = emitterPos.y;\n    this.emitterPosUniform[2] = emitterPos.z;\n    this.constantEmitterPos.setValue(this.emitterPosUniform);\n    this.constantFrameRandom.setValue(this.frameRandomUniform);\n    this.constantDelta.setValue(delta);\n    this.constantRate.setValue(emitter.rate);\n    this.constantRateDiv.setValue(emitter.rate2 - emitter.rate);\n    this.constantStartAngle.setValue(emitter.startAngle * _core_math_math_js__WEBPACK_IMPORTED_MODULE_5__.math.DEG_TO_RAD);\n    this.constantStartAngle2.setValue(emitter.startAngle2 * _core_math_math_js__WEBPACK_IMPORTED_MODULE_5__.math.DEG_TO_RAD);\n    this.constantSeed.setValue(emitter.seed);\n    this.constantLifetime.setValue(emitter.lifetime);\n    this.emitterScaleUniform[0] = emitterScale.x;\n    this.emitterScaleUniform[1] = emitterScale.y;\n    this.emitterScaleUniform[2] = emitterScale.z;\n    this.constantEmitterScale.setValue(this.emitterScaleUniform);\n    this.constantEmitterMatrix.setValue(emitterMatrix3.data);\n    this.constantEmitterMatrixInv.setValue(emitterMatrix3Inv.data);\n    this.constantLocalVelocityDivMult.setValue(emitter.localVelocityUMax);\n    this.constantVelocityDivMult.setValue(emitter.velocityUMax);\n    this.constantRotSpeedDivMult.setValue(emitter.rotSpeedUMax[0]);\n    let texIN = emitter.swapTex ? emitter.particleTexOUT : emitter.particleTexIN;\n    texIN = emitter.beenReset ? emitter.particleTexStart : texIN;\n    const texOUT = emitter.swapTex ? emitter.particleTexIN : emitter.particleTexOUT;\n    this.constantParticleTexIN.setValue(texIN);\n    (0,_platform_graphics_simple_post_effect_js__WEBPACK_IMPORTED_MODULE_6__.drawQuadWithShader)(device, emitter.swapTex ? emitter.rtParticleTexIN : emitter.rtParticleTexOUT, !isOnStop ? emitter.loop ? emitter.shaderParticleUpdateRespawn : emitter.shaderParticleUpdateNoRespawn : emitter.shaderParticleUpdateOnStop);\n    emitter.material.setParameter('particleTexOUT', texIN);\n    emitter.material.setParameter('particleTexIN', texOUT);\n    emitter.beenReset = false;\n    emitter.swapTex = !emitter.swapTex;\n    device.setDepthTest(true);\n    device.setDepthWrite(true);\n    emitter.prevWorldBoundsSize.copy(emitter.worldBoundsSize);\n    emitter.prevWorldBoundsCenter.copy(emitter.worldBounds.center);\n    if (emitter.pack8) this._setInputBounds();\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/particle-system/gpu-updater.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/particle-system/particle-emitter.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/particle-system/particle-emitter.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ParticleEmitter\": () => (/* binding */ ParticleEmitter)\n/* harmony export */ });\n/* harmony import */ var _core_math_curve_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/math/curve.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/curve.js\");\n/* harmony import */ var _core_math_curve_set_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/math/curve-set.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/curve-set.js\");\n/* harmony import */ var _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/math/mat4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js\");\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _core_math_quat_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../core/math/quat.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/quat.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/shape/bounding-box.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/shape/bounding-box.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_device_cache_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../platform/graphics/device-cache.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/device-cache.js\");\n/* harmony import */ var _platform_graphics_index_buffer_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../../platform/graphics/index-buffer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/index-buffer.js\");\n/* harmony import */ var _platform_graphics_render_target_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../platform/graphics/render-target.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/render-target.js\");\n/* harmony import */ var _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../platform/graphics/texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js\");\n/* harmony import */ var _platform_graphics_vertex_buffer_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../../platform/graphics/vertex-buffer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/vertex-buffer.js\");\n/* harmony import */ var _platform_graphics_vertex_format_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../../platform/graphics/vertex-format.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/vertex-format.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _mesh_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../mesh.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh.js\");\n/* harmony import */ var _mesh_instance_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../mesh-instance.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh-instance.js\");\n/* harmony import */ var _materials_material_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../materials/material.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/material.js\");\n/* harmony import */ var _shader_lib_get_program_library_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../shader-lib/get-program-library.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/get-program-library.js\");\n/* harmony import */ var _shader_lib_utils_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../shader-lib/utils.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/utils.js\");\n/* harmony import */ var _shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../shader-lib/chunks/chunks.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/chunks.js\");\n/* harmony import */ var _shader_lib_programs_particle_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../shader-lib/programs/particle.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/programs/particle.js\");\n/* harmony import */ var _cpu_updater_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./cpu-updater.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/particle-system/cpu-updater.js\");\n/* harmony import */ var _gpu_updater_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./gpu-updater.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/particle-system/gpu-updater.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst particleVerts = [[-1, -1], [1, -1], [1, 1], [-1, 1]];\nfunction _createTexture(device, width, height, pixelData, format = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA32F, mult8Bit, filter) {\n  let mipFilter = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_NEAREST;\n  if (filter && format === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA8) mipFilter = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_LINEAR;\n  const texture = new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture(device, {\n    width: width,\n    height: height,\n    format: format,\n    cubemap: false,\n    mipmaps: false,\n    minFilter: mipFilter,\n    magFilter: mipFilter,\n    addressU: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_CLAMP_TO_EDGE,\n    addressV: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.ADDRESS_CLAMP_TO_EDGE,\n    name: 'ParticleSystemTexture'\n  });\n  const pixels = texture.lock();\n  if (format === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA8) {\n    const temp = new Uint8Array(pixelData.length);\n    for (let i = 0; i < pixelData.length; i++) {\n      temp[i] = pixelData[i] * mult8Bit * 255;\n    }\n    pixelData = temp;\n  }\n  pixels.set(pixelData);\n  texture.unlock();\n  return texture;\n}\nfunction saturate(x) {\n  return Math.max(Math.min(x, 1), 0);\n}\nconst default0Curve = new _core_math_curve_js__WEBPACK_IMPORTED_MODULE_2__.Curve([0, 0, 1, 0]);\nconst default1Curve = new _core_math_curve_js__WEBPACK_IMPORTED_MODULE_2__.Curve([0, 1, 1, 1]);\nconst default0Curve3 = new _core_math_curve_set_js__WEBPACK_IMPORTED_MODULE_3__.CurveSet([0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0]);\nconst default1Curve3 = new _core_math_curve_set_js__WEBPACK_IMPORTED_MODULE_3__.CurveSet([0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1]);\nlet particleTexHeight = 2;\nconst particleTexChannels = 4;\nconst extentsInnerRatioUniform = new Float32Array(3);\nconst spawnMatrix = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_4__.Mat4();\nconst tmpVec3 = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3();\nconst bMin = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3();\nconst bMax = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3();\nlet setPropertyTarget;\nlet setPropertyOptions;\nfunction setProperty(pName, defaultVal) {\n  if (setPropertyOptions[pName] !== undefined && setPropertyOptions[pName] !== null) {\n    setPropertyTarget[pName] = setPropertyOptions[pName];\n  } else {\n    setPropertyTarget[pName] = defaultVal;\n  }\n}\nfunction pack3NFloats(a, b, c) {\n  const packed = a * 255 << 16 | b * 255 << 8 | c * 255;\n  return packed / (1 << 24);\n}\nfunction packTextureXYZ_NXYZ(qXYZ, qXYZ2) {\n  const num = qXYZ.length / 3;\n  const colors = new Array(num * 4);\n  for (let i = 0; i < num; i++) {\n    colors[i * 4] = qXYZ[i * 3];\n    colors[i * 4 + 1] = qXYZ[i * 3 + 1];\n    colors[i * 4 + 2] = qXYZ[i * 3 + 2];\n    colors[i * 4 + 3] = pack3NFloats(qXYZ2[i * 3], qXYZ2[i * 3 + 1], qXYZ2[i * 3 + 2]);\n  }\n  return colors;\n}\nfunction packTextureRGBA(qRGB, qA) {\n  const colors = new Array(qA.length * 4);\n  for (let i = 0; i < qA.length; i++) {\n    colors[i * 4] = qRGB[i * 3];\n    colors[i * 4 + 1] = qRGB[i * 3 + 1];\n    colors[i * 4 + 2] = qRGB[i * 3 + 2];\n    colors[i * 4 + 3] = qA[i];\n  }\n  return colors;\n}\nfunction packTexture5Floats(qA, qB, qC, qD, qE) {\n  const colors = new Array(qA.length * 4);\n  for (let i = 0; i < qA.length; i++) {\n    colors[i * 4] = qA[i];\n    colors[i * 4 + 1] = qB[i];\n    colors[i * 4 + 2] = 0;\n    colors[i * 4 + 3] = pack3NFloats(qC[i], qD[i], qE[i]);\n  }\n  return colors;\n}\nfunction packTexture2Floats(qA, qB) {\n  const colors = new Array(qA.length * 4);\n  for (let i = 0; i < qA.length; i++) {\n    colors[i * 4] = qA[i];\n    colors[i * 4 + 1] = qB[i];\n    colors[i * 4 + 2] = 0;\n    colors[i * 4 + 3] = 0;\n  }\n  return colors;\n}\nfunction calcEndTime(emitter) {\n  const interval = Math.max(emitter.rate, emitter.rate2) * emitter.numParticles + emitter.lifetime;\n  return Date.now() + interval * 1000;\n}\nfunction subGraph(A, B) {\n  const r = new Float32Array(A.length);\n  for (let i = 0; i < A.length; i++) {\n    r[i] = A[i] - B[i];\n  }\n  return r;\n}\nfunction maxUnsignedGraphValue(A, outUMax) {\n  const chans = outUMax.length;\n  const values = A.length / chans;\n  for (let i = 0; i < values; i++) {\n    for (let j = 0; j < chans; j++) {\n      const a = Math.abs(A[i * chans + j]);\n      outUMax[j] = Math.max(outUMax[j], a);\n    }\n  }\n}\nfunction normalizeGraph(A, uMax) {\n  const chans = uMax.length;\n  const values = A.length / chans;\n  for (let i = 0; i < values; i++) {\n    for (let j = 0; j < chans; j++) {\n      A[i * chans + j] /= uMax[j] === 0 ? 1 : uMax[j];\n      A[i * chans + j] *= 0.5;\n      A[i * chans + j] += 0.5;\n    }\n  }\n}\nfunction divGraphFrom2Curves(curve1, curve2, outUMax) {\n  const sub = subGraph(curve2, curve1);\n  maxUnsignedGraphValue(sub, outUMax);\n  normalizeGraph(sub, outUMax);\n  return sub;\n}\nconst particleEmitterDeviceCache = new _platform_graphics_device_cache_js__WEBPACK_IMPORTED_MODULE_6__.DeviceCache();\nclass ParticleEmitter {\n  constructor(graphicsDevice, options) {\n    this.graphicsDevice = graphicsDevice;\n    const gd = graphicsDevice;\n    const precision = 32;\n    this.precision = precision;\n    this._addTimeTime = 0;\n    setPropertyTarget = this;\n    setPropertyOptions = options;\n    setProperty('numParticles', 1);\n    if (this.numParticles > graphicsDevice.maxTextureSize) {\n      this.numParticles = graphicsDevice.maxTextureSize;\n    }\n    setProperty('rate', 1);\n    setProperty('rate2', this.rate);\n    setProperty('lifetime', 50);\n    setProperty('emitterExtents', new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3(0, 0, 0));\n    setProperty('emitterExtentsInner', new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3(0, 0, 0));\n    setProperty('emitterRadius', 0);\n    setProperty('emitterRadiusInner', 0);\n    setProperty('emitterShape', _constants_js__WEBPACK_IMPORTED_MODULE_7__.EMITTERSHAPE_BOX);\n    setProperty('initialVelocity', 1);\n    setProperty('wrap', false);\n    setProperty('localSpace', false);\n    setProperty('screenSpace', false);\n    setProperty('wrapBounds', null);\n    setProperty('colorMap', this.defaultParamTexture);\n    setProperty('normalMap', null);\n    setProperty('loop', true);\n    setProperty('preWarm', false);\n    setProperty('sort', _constants_js__WEBPACK_IMPORTED_MODULE_7__.PARTICLESORT_NONE);\n    setProperty('mode', _constants_js__WEBPACK_IMPORTED_MODULE_7__.PARTICLEMODE_GPU);\n    setProperty('scene', null);\n    setProperty('lighting', false);\n    setProperty('halfLambert', false);\n    setProperty('intensity', 1.0);\n    setProperty('stretch', 0.0);\n    setProperty('alignToMotion', false);\n    setProperty('depthSoftening', 0);\n    setProperty('mesh', null);\n    setProperty('particleNormal', new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3(0, 1, 0));\n    setProperty('orientation', _constants_js__WEBPACK_IMPORTED_MODULE_7__.PARTICLEORIENTATION_SCREEN);\n    setProperty('depthWrite', false);\n    setProperty('noFog', false);\n    setProperty('blendType', _constants_js__WEBPACK_IMPORTED_MODULE_7__.BLEND_NORMAL);\n    setProperty('node', null);\n    setProperty('startAngle', 0);\n    setProperty('startAngle2', this.startAngle);\n    setProperty('animTilesX', 1);\n    setProperty('animTilesY', 1);\n    setProperty('animStartFrame', 0);\n    setProperty('animNumFrames', 1);\n    setProperty('animNumAnimations', 1);\n    setProperty('animIndex', 0);\n    setProperty('randomizeAnimIndex', false);\n    setProperty('animSpeed', 1);\n    setProperty('animLoop', true);\n    this._gpuUpdater = new _gpu_updater_js__WEBPACK_IMPORTED_MODULE_8__.ParticleGPUUpdater(this, gd);\n    this._cpuUpdater = new _cpu_updater_js__WEBPACK_IMPORTED_MODULE_9__.ParticleCPUUpdater(this);\n    this.constantLightCube = gd.scope.resolve('lightCube[0]');\n    this.emitterPosUniform = new Float32Array(3);\n    this.wrapBoundsUniform = new Float32Array(3);\n    this.emitterScaleUniform = new Float32Array([1, 1, 1]);\n    setProperty('colorGraph', default1Curve3);\n    setProperty('colorGraph2', this.colorGraph);\n    setProperty('scaleGraph', default1Curve);\n    setProperty('scaleGraph2', this.scaleGraph);\n    setProperty('alphaGraph', default1Curve);\n    setProperty('alphaGraph2', this.alphaGraph);\n    setProperty('localVelocityGraph', default0Curve3);\n    setProperty('localVelocityGraph2', this.localVelocityGraph);\n    setProperty('velocityGraph', default0Curve3);\n    setProperty('velocityGraph2', this.velocityGraph);\n    setProperty('rotationSpeedGraph', default0Curve);\n    setProperty('rotationSpeedGraph2', this.rotationSpeedGraph);\n    setProperty('radialSpeedGraph', default0Curve);\n    setProperty('radialSpeedGraph2', this.radialSpeedGraph);\n    this.lightCube = new Float32Array(6 * 3);\n    this.lightCubeDir = new Array(6);\n    this.lightCubeDir[0] = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3(-1, 0, 0);\n    this.lightCubeDir[1] = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3(1, 0, 0);\n    this.lightCubeDir[2] = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3(0, -1, 0);\n    this.lightCubeDir[3] = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3(0, 1, 0);\n    this.lightCubeDir[4] = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3(0, 0, -1);\n    this.lightCubeDir[5] = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3(0, 0, 1);\n    this.animTilesParams = new Float32Array(2);\n    this.animParams = new Float32Array(4);\n    this.animIndexParams = new Float32Array(2);\n    this.internalTex0 = null;\n    this.internalTex1 = null;\n    this.internalTex2 = null;\n    this.colorParam = null;\n    this.vbToSort = null;\n    this.vbOld = null;\n    this.particleDistance = null;\n    this.camera = null;\n    this.swapTex = false;\n    this.useMesh = true;\n    this.useCpu = !graphicsDevice.supportsGpuParticles;\n    this.pack8 = true;\n    this.localBounds = new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_10__.BoundingBox();\n    this.worldBoundsNoTrail = new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_10__.BoundingBox();\n    this.worldBoundsTrail = [new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_10__.BoundingBox(), new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_10__.BoundingBox()];\n    this.worldBounds = new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_10__.BoundingBox();\n    this.worldBoundsSize = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3();\n    this.prevWorldBoundsSize = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3();\n    this.prevWorldBoundsCenter = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3();\n    this.prevEmitterExtents = this.emitterExtents;\n    this.prevEmitterRadius = this.emitterRadius;\n    this.worldBoundsMul = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3();\n    this.worldBoundsAdd = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3();\n    this.timeToSwitchBounds = 0;\n    this.shaderParticleUpdateRespawn = null;\n    this.shaderParticleUpdateNoRespawn = null;\n    this.shaderParticleUpdateOnStop = null;\n    this.numParticleVerts = 0;\n    this.numParticleIndices = 0;\n    this.material = null;\n    this.meshInstance = null;\n    this.drawOrder = 0;\n    this.seed = Math.random();\n    this.fixedTimeStep = 1.0 / 60;\n    this.maxSubSteps = 10;\n    this.simTime = 0;\n    this.simTimeTotal = 0;\n    this.beenReset = false;\n    this._layer = null;\n    this.rebuild();\n  }\n  get defaultParamTexture() {\n    return particleEmitterDeviceCache.get(this.graphicsDevice, () => {\n      const resolution = 16;\n      const centerPoint = resolution * 0.5 + 0.5;\n      const dtex = new Float32Array(resolution * resolution * 4);\n      for (let y = 0; y < resolution; y++) {\n        for (let x = 0; x < resolution; x++) {\n          const xgrad = x + 1 - centerPoint;\n          const ygrad = y + 1 - centerPoint;\n          const c = saturate(1 - saturate(Math.sqrt(xgrad * xgrad + ygrad * ygrad) / resolution) - 0.5);\n          const p = y * resolution + x;\n          dtex[p * 4] = 1;\n          dtex[p * 4 + 1] = 1;\n          dtex[p * 4 + 2] = 1;\n          dtex[p * 4 + 3] = c;\n        }\n      }\n      const texture = _createTexture(this.graphicsDevice, resolution, resolution, dtex, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA8, 1.0, true);\n      texture.minFilter = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_LINEAR;\n      texture.magFilter = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FILTER_LINEAR;\n      return texture;\n    });\n  }\n  onChangeCamera() {\n    this.regenShader();\n    this.resetMaterial();\n  }\n  calculateBoundsMad() {\n    this.worldBoundsMul.x = 1.0 / this.worldBoundsSize.x;\n    this.worldBoundsMul.y = 1.0 / this.worldBoundsSize.y;\n    this.worldBoundsMul.z = 1.0 / this.worldBoundsSize.z;\n    this.worldBoundsAdd.copy(this.worldBounds.center).mul(this.worldBoundsMul).mulScalar(-1);\n    this.worldBoundsAdd.x += 0.5;\n    this.worldBoundsAdd.y += 0.5;\n    this.worldBoundsAdd.z += 0.5;\n  }\n  calculateWorldBounds() {\n    if (!this.node) return;\n    this.prevWorldBoundsSize.copy(this.worldBoundsSize);\n    this.prevWorldBoundsCenter.copy(this.worldBounds.center);\n    if (!this.useCpu) {\n      let recalculateLocalBounds = false;\n      if (this.emitterShape === _constants_js__WEBPACK_IMPORTED_MODULE_7__.EMITTERSHAPE_BOX) {\n        recalculateLocalBounds = !this.emitterExtents.equals(this.prevEmitterExtents);\n      } else {\n        recalculateLocalBounds = !(this.emitterRadius === this.prevEmitterRadius);\n      }\n      if (recalculateLocalBounds) {\n        this.calculateLocalBounds();\n      }\n    }\n    const nodeWT = this.node.getWorldTransform();\n    if (this.localSpace) {\n      this.worldBoundsNoTrail.copy(this.localBounds);\n    } else {\n      this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, nodeWT);\n    }\n    this.worldBoundsTrail[0].add(this.worldBoundsNoTrail);\n    this.worldBoundsTrail[1].add(this.worldBoundsNoTrail);\n    const now = this.simTimeTotal;\n    if (now >= this.timeToSwitchBounds) {\n      this.worldBoundsTrail[0].copy(this.worldBoundsTrail[1]);\n      this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);\n      this.timeToSwitchBounds = now + this.lifetime;\n    }\n    this.worldBounds.copy(this.worldBoundsTrail[0]);\n    this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);\n    if (this.localSpace) {\n      this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);\n      this.meshInstance.mesh.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);\n    } else {\n      this.meshInstance.aabb.copy(this.worldBounds);\n      this.meshInstance.mesh.aabb.copy(this.worldBounds);\n    }\n    this.meshInstance._aabbVer = 1 - this.meshInstance._aabbVer;\n    if (this.pack8) this.calculateBoundsMad();\n  }\n  resetWorldBounds() {\n    if (!this.node) return;\n    this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, this.localSpace ? _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_4__.Mat4.IDENTITY : this.node.getWorldTransform());\n    this.worldBoundsTrail[0].copy(this.worldBoundsNoTrail);\n    this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);\n    this.worldBounds.copy(this.worldBoundsTrail[0]);\n    this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);\n    this.prevWorldBoundsSize.copy(this.worldBoundsSize);\n    this.prevWorldBoundsCenter.copy(this.worldBounds.center);\n    this.simTimeTotal = 0;\n    this.timeToSwitchBounds = 0;\n  }\n  calculateLocalBounds() {\n    let minx = Number.MAX_VALUE;\n    let miny = Number.MAX_VALUE;\n    let minz = Number.MAX_VALUE;\n    let maxx = -Number.MAX_VALUE;\n    let maxy = -Number.MAX_VALUE;\n    let maxz = -Number.MAX_VALUE;\n    let maxR = 0;\n    let maxScale = 0;\n    const stepWeight = this.lifetime / this.precision;\n    const wVels = [this.qVelocity, this.qVelocity2];\n    const lVels = [this.qLocalVelocity, this.qLocalVelocity2];\n    const accumX = [0, 0];\n    const accumY = [0, 0];\n    const accumZ = [0, 0];\n    const accumR = [0, 0];\n    const accumW = [0, 0];\n    let x, y, z;\n    for (let i = 0; i < this.precision + 1; i++) {\n      const index = Math.min(i, this.precision - 1);\n      for (let j = 0; j < 2; j++) {\n        x = lVels[j][index * 3 + 0] * stepWeight + accumX[j];\n        y = lVels[j][index * 3 + 1] * stepWeight + accumY[j];\n        z = lVels[j][index * 3 + 2] * stepWeight + accumZ[j];\n        minx = Math.min(x, minx);\n        miny = Math.min(y, miny);\n        minz = Math.min(z, minz);\n        maxx = Math.max(x, maxx);\n        maxy = Math.max(y, maxy);\n        maxz = Math.max(z, maxz);\n        accumX[j] = x;\n        accumY[j] = y;\n        accumZ[j] = z;\n      }\n      for (let j = 0; j < 2; j++) {\n        accumW[j] += stepWeight * Math.sqrt(wVels[j][index * 3 + 0] * wVels[j][index * 3 + 0] + wVels[j][index * 3 + 1] * wVels[j][index * 3 + 1] + wVels[j][index * 3 + 2] * wVels[j][index * 3 + 2]);\n      }\n      accumR[0] += this.qRadialSpeed[index] * stepWeight;\n      accumR[1] += this.qRadialSpeed2[index] * stepWeight;\n      maxR = Math.max(maxR, Math.max(Math.abs(accumR[0]), Math.abs(accumR[1])));\n      maxScale = Math.max(maxScale, this.qScale[index]);\n    }\n    if (this.emitterShape === _constants_js__WEBPACK_IMPORTED_MODULE_7__.EMITTERSHAPE_BOX) {\n      x = this.emitterExtents.x * 0.5;\n      y = this.emitterExtents.y * 0.5;\n      z = this.emitterExtents.z * 0.5;\n    } else {\n      x = this.emitterRadius;\n      y = this.emitterRadius;\n      z = this.emitterRadius;\n    }\n    const w = Math.max(accumW[0], accumW[1]);\n    bMin.x = minx - maxScale - x - maxR - w;\n    bMin.y = miny - maxScale - y - maxR - w;\n    bMin.z = minz - maxScale - z - maxR - w;\n    bMax.x = maxx + maxScale + x + maxR + w;\n    bMax.y = maxy + maxScale + y + maxR + w;\n    bMax.z = maxz + maxScale + z + maxR + w;\n    this.localBounds.setMinMax(bMin, bMax);\n  }\n  rebuild() {\n    const gd = this.graphicsDevice;\n    if (this.colorMap === null) this.colorMap = this.defaultParamTexture;\n    this.spawnBounds = this.emitterShape === _constants_js__WEBPACK_IMPORTED_MODULE_7__.EMITTERSHAPE_BOX ? this.emitterExtents : this.emitterRadius;\n    this.useCpu = this.useCpu || this.sort > _constants_js__WEBPACK_IMPORTED_MODULE_7__.PARTICLESORT_NONE || gd.maxVertexTextures <= 1 || gd.fragmentUniformsCount < 64 || gd.forceCpuParticles || !gd.extTextureFloat;\n    this._destroyResources();\n    this.pack8 = (this.pack8 || !gd.textureFloatRenderable) && !this.useCpu;\n    particleTexHeight = this.useCpu || this.pack8 ? 4 : 2;\n    this.useMesh = false;\n    if (this.mesh) {\n      const totalVertCount = this.numParticles * this.mesh.vertexBuffer.numVertices;\n      if (totalVertCount > 65535) ; else {\n        this.useMesh = true;\n      }\n    }\n    this.numParticlesPot = _core_math_math_js__WEBPACK_IMPORTED_MODULE_11__.math.nextPowerOfTwo(this.numParticles);\n    this.rebuildGraphs();\n    this.calculateLocalBounds();\n    this.resetWorldBounds();\n    if (this.node) {\n      this.worldBounds.setFromTransformedAabb(this.localBounds, this.localSpace ? _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_4__.Mat4.IDENTITY : this.node.getWorldTransform());\n      this.worldBoundsTrail[0].copy(this.worldBounds);\n      this.worldBoundsTrail[1].copy(this.worldBounds);\n      this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);\n      this.prevWorldBoundsSize.copy(this.worldBoundsSize);\n      this.prevWorldBoundsCenter.copy(this.worldBounds.center);\n      if (this.pack8) this.calculateBoundsMad();\n    }\n    this.vbToSort = new Array(this.numParticles);\n    for (let iSort = 0; iSort < this.numParticles; iSort++) this.vbToSort[iSort] = [0, 0];\n    this.particleDistance = new Float32Array(this.numParticles);\n    this._gpuUpdater.randomize();\n    this.particleTex = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels);\n    const emitterPos = this.node === null || this.localSpace ? _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3.ZERO : this.node.getPosition();\n    if (this.emitterShape === _constants_js__WEBPACK_IMPORTED_MODULE_7__.EMITTERSHAPE_BOX) {\n      if (this.node === null || this.localSpace) {\n        spawnMatrix.setTRS(_core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3.ZERO, _core_math_quat_js__WEBPACK_IMPORTED_MODULE_12__.Quat.IDENTITY, this.spawnBounds);\n      } else {\n        spawnMatrix.setTRS(_core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3.ZERO, this.node.getRotation(), tmpVec3.copy(this.spawnBounds).mul(this.node.localScale));\n      }\n      extentsInnerRatioUniform[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;\n      extentsInnerRatioUniform[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;\n      extentsInnerRatioUniform[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;\n    }\n    for (let i = 0; i < this.numParticles; i++) {\n      this._cpuUpdater.calcSpawnPosition(this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, i);\n      if (this.useCpu) this.particleTex[i * particleTexChannels + 3 + this.numParticlesPot * 2 * particleTexChannels] = 1;\n    }\n    this.particleTexStart = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels);\n    for (let i = 0; i < this.particleTexStart.length; i++) {\n      this.particleTexStart[i] = this.particleTex[i];\n    }\n    if (!this.useCpu) {\n      if (this.pack8) {\n        this.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA8, 1, false);\n        this.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA8, 1, false);\n        this.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA8, 1, false);\n      } else {\n        this.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);\n        this.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);\n        this.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart);\n      }\n      this.rtParticleTexIN = new _platform_graphics_render_target_js__WEBPACK_IMPORTED_MODULE_13__.RenderTarget({\n        colorBuffer: this.particleTexIN,\n        depth: false\n      });\n      this.rtParticleTexOUT = new _platform_graphics_render_target_js__WEBPACK_IMPORTED_MODULE_13__.RenderTarget({\n        colorBuffer: this.particleTexOUT,\n        depth: false\n      });\n      this.swapTex = false;\n    }\n    const shaderCodeStart = (this.localSpace ? '#define LOCAL_SPACE\\n' : '') + _shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_14__.shaderChunks.particleUpdaterInitPS + (this.pack8 ? _shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_14__.shaderChunks.particleInputRgba8PS + _shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_14__.shaderChunks.particleOutputRgba8PS : _shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_14__.shaderChunks.particleInputFloatPS + _shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_14__.shaderChunks.particleOutputFloatPS) + (this.emitterShape === _constants_js__WEBPACK_IMPORTED_MODULE_7__.EMITTERSHAPE_BOX ? _shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_14__.shaderChunks.particleUpdaterAABBPS : _shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_14__.shaderChunks.particleUpdaterSpherePS) + _shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_14__.shaderChunks.particleUpdaterStartPS;\n    const shaderCodeRespawn = shaderCodeStart + _shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_14__.shaderChunks.particleUpdaterRespawnPS + _shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_14__.shaderChunks.particleUpdaterEndPS;\n    const shaderCodeNoRespawn = shaderCodeStart + _shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_14__.shaderChunks.particleUpdaterNoRespawnPS + _shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_14__.shaderChunks.particleUpdaterEndPS;\n    const shaderCodeOnStop = shaderCodeStart + _shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_14__.shaderChunks.particleUpdaterOnStopPS + _shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_14__.shaderChunks.particleUpdaterEndPS;\n    const params = this.emitterShape + '' + this.pack8 + '' + this.localSpace;\n    this.shaderParticleUpdateRespawn = (0,_shader_lib_utils_js__WEBPACK_IMPORTED_MODULE_15__.createShaderFromCode)(gd, _shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_14__.shaderChunks.fullscreenQuadVS, shaderCodeRespawn, 'fsQuad0' + params);\n    this.shaderParticleUpdateNoRespawn = (0,_shader_lib_utils_js__WEBPACK_IMPORTED_MODULE_15__.createShaderFromCode)(gd, _shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_14__.shaderChunks.fullscreenQuadVS, shaderCodeNoRespawn, 'fsQuad1' + params);\n    this.shaderParticleUpdateOnStop = (0,_shader_lib_utils_js__WEBPACK_IMPORTED_MODULE_15__.createShaderFromCode)(gd, _shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_14__.shaderChunks.fullscreenQuadVS, shaderCodeOnStop, 'fsQuad2' + params);\n    this.numParticleVerts = this.useMesh ? this.mesh.vertexBuffer.numVertices : 4;\n    this.numParticleIndices = this.useMesh ? this.mesh.indexBuffer[0].numIndices : 6;\n    this._allocate(this.numParticles);\n    const mesh = new _mesh_js__WEBPACK_IMPORTED_MODULE_16__.Mesh(gd);\n    mesh.vertexBuffer = this.vertexBuffer;\n    mesh.indexBuffer[0] = this.indexBuffer;\n    mesh.primitive[0].type = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PRIMITIVE_TRIANGLES;\n    mesh.primitive[0].base = 0;\n    mesh.primitive[0].count = this.numParticles * this.numParticleIndices;\n    mesh.primitive[0].indexed = true;\n    this.material = new _materials_material_js__WEBPACK_IMPORTED_MODULE_17__.Material();\n    this.material.name = this.node.name;\n    this.material.cull = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.CULLFACE_NONE;\n    this.material.alphaWrite = false;\n    this.material.blend = true;\n    this.material.blendType = this.blendType;\n    this.material.depthWrite = this.depthWrite;\n    this.material.emitter = this;\n    this.regenShader();\n    this.resetMaterial();\n    const wasVisible = this.meshInstance ? this.meshInstance.visible : true;\n    this.meshInstance = new _mesh_instance_js__WEBPACK_IMPORTED_MODULE_18__.MeshInstance(mesh, this.material, this.node);\n    this.meshInstance.pick = false;\n    this.meshInstance.updateKey();\n    this.meshInstance.cull = true;\n    this.meshInstance._noDepthDrawGl1 = true;\n    if (this.localSpace) {\n      this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, this.node.getWorldTransform());\n    } else {\n      this.meshInstance.aabb.copy(this.worldBounds);\n    }\n    this.meshInstance._updateAabb = false;\n    this.meshInstance.visible = wasVisible;\n    this._initializeTextures();\n    this.resetTime();\n    this.addTime(0, false);\n    if (this.preWarm) this.prewarm(this.lifetime);\n  }\n  _isAnimated() {\n    return this.animNumFrames >= 1 && (this.animTilesX > 1 || this.animTilesY > 1) && (this.colorMap && this.colorMap !== this.defaultParamTexture || this.normalMap);\n  }\n  rebuildGraphs() {\n    const precision = this.precision;\n    const gd = this.graphicsDevice;\n    this.qLocalVelocity = this.localVelocityGraph.quantize(precision);\n    this.qVelocity = this.velocityGraph.quantize(precision);\n    this.qColor = this.colorGraph.quantizeClamped(precision, 0, 1);\n    this.qRotSpeed = this.rotationSpeedGraph.quantize(precision);\n    this.qScale = this.scaleGraph.quantize(precision);\n    this.qAlpha = this.alphaGraph.quantize(precision);\n    this.qRadialSpeed = this.radialSpeedGraph.quantize(precision);\n    this.qLocalVelocity2 = this.localVelocityGraph2.quantize(precision);\n    this.qVelocity2 = this.velocityGraph2.quantize(precision);\n    this.qColor2 = this.colorGraph2.quantizeClamped(precision, 0, 1);\n    this.qRotSpeed2 = this.rotationSpeedGraph2.quantize(precision);\n    this.qScale2 = this.scaleGraph2.quantize(precision);\n    this.qAlpha2 = this.alphaGraph2.quantize(precision);\n    this.qRadialSpeed2 = this.radialSpeedGraph2.quantize(precision);\n    for (let i = 0; i < precision; i++) {\n      this.qRotSpeed[i] *= _core_math_math_js__WEBPACK_IMPORTED_MODULE_11__.math.DEG_TO_RAD;\n      this.qRotSpeed2[i] *= _core_math_math_js__WEBPACK_IMPORTED_MODULE_11__.math.DEG_TO_RAD;\n    }\n    this.localVelocityUMax = new Float32Array(3);\n    this.velocityUMax = new Float32Array(3);\n    this.colorUMax = new Float32Array(3);\n    this.rotSpeedUMax = [0];\n    this.scaleUMax = [0];\n    this.alphaUMax = [0];\n    this.radialSpeedUMax = [0];\n    this.qLocalVelocityDiv = divGraphFrom2Curves(this.qLocalVelocity, this.qLocalVelocity2, this.localVelocityUMax);\n    this.qVelocityDiv = divGraphFrom2Curves(this.qVelocity, this.qVelocity2, this.velocityUMax);\n    this.qColorDiv = divGraphFrom2Curves(this.qColor, this.qColor2, this.colorUMax);\n    this.qRotSpeedDiv = divGraphFrom2Curves(this.qRotSpeed, this.qRotSpeed2, this.rotSpeedUMax);\n    this.qScaleDiv = divGraphFrom2Curves(this.qScale, this.qScale2, this.scaleUMax);\n    this.qAlphaDiv = divGraphFrom2Curves(this.qAlpha, this.qAlpha2, this.alphaUMax);\n    this.qRadialSpeedDiv = divGraphFrom2Curves(this.qRadialSpeed, this.qRadialSpeed2, this.radialSpeedUMax);\n    if (this.pack8) {\n      const umax = [0, 0, 0];\n      maxUnsignedGraphValue(this.qVelocity, umax);\n      const umax2 = [0, 0, 0];\n      maxUnsignedGraphValue(this.qVelocity2, umax2);\n      const lumax = [0, 0, 0];\n      maxUnsignedGraphValue(this.qLocalVelocity, lumax);\n      const lumax2 = [0, 0, 0];\n      maxUnsignedGraphValue(this.qLocalVelocity2, lumax2);\n      const rumax = [0];\n      maxUnsignedGraphValue(this.qRadialSpeed, rumax);\n      const rumax2 = [0];\n      maxUnsignedGraphValue(this.qRadialSpeed2, rumax2);\n      let maxVel = Math.max(umax[0], umax2[0]);\n      maxVel = Math.max(maxVel, umax[1]);\n      maxVel = Math.max(maxVel, umax2[1]);\n      maxVel = Math.max(maxVel, umax[2]);\n      maxVel = Math.max(maxVel, umax2[2]);\n      let lmaxVel = Math.max(lumax[0], lumax2[0]);\n      lmaxVel = Math.max(lmaxVel, lumax[1]);\n      lmaxVel = Math.max(lmaxVel, lumax2[1]);\n      lmaxVel = Math.max(lmaxVel, lumax[2]);\n      lmaxVel = Math.max(lmaxVel, lumax2[2]);\n      const maxRad = Math.max(rumax[0], rumax2[0]);\n      this.maxVel = maxVel + lmaxVel + maxRad;\n    }\n    if (!this.useCpu) {\n      this.internalTex0 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qLocalVelocity, this.qLocalVelocityDiv));\n      this.internalTex1 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qVelocity, this.qVelocityDiv));\n      this.internalTex2 = _createTexture(gd, precision, 1, packTexture5Floats(this.qRotSpeed, this.qScale, this.qScaleDiv, this.qRotSpeedDiv, this.qAlphaDiv));\n      this.internalTex3 = _createTexture(gd, precision, 1, packTexture2Floats(this.qRadialSpeed, this.qRadialSpeedDiv));\n    }\n    this.colorParam = _createTexture(gd, precision, 1, packTextureRGBA(this.qColor, this.qAlpha), _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA8, 1.0, true);\n  }\n  _initializeTextures() {\n    if (this.colorMap) {\n      this.material.setParameter('colorMap', this.colorMap);\n      if (this.lighting && this.normalMap) {\n        this.material.setParameter('normalMap', this.normalMap);\n      }\n    }\n  }\n  regenShader() {\n    const programLib = (0,_shader_lib_get_program_library_js__WEBPACK_IMPORTED_MODULE_19__.getProgramLibrary)(this.graphicsDevice);\n    programLib.register('particle', _shader_lib_programs_particle_js__WEBPACK_IMPORTED_MODULE_20__.particle);\n    const hasNormal = this.normalMap !== null;\n    this.normalOption = 0;\n    if (this.lighting) {\n      this.normalOption = hasNormal ? 2 : 1;\n    }\n    this.material.getShaderVariant = function (dev, sc, defs, staticLightList, pass, sortedLights, viewUniformFormat, viewBindGroupFormat) {\n      if (this.emitter.scene) {\n        if (this.emitter.camera !== this.emitter.scene._activeCamera) {\n          this.emitter.camera = this.emitter.scene._activeCamera;\n          this.emitter.onChangeCamera();\n        }\n      }\n      const inTools = this.emitter.inTools;\n      const shader = programLib.getProgram('particle', {\n        useCpu: this.emitter.useCpu,\n        normal: this.emitter.normalOption,\n        halflambert: this.emitter.halfLambert,\n        stretch: this.emitter.stretch,\n        alignToMotion: this.emitter.alignToMotion,\n        soft: this.emitter.depthSoftening,\n        mesh: this.emitter.useMesh,\n        gamma: this.emitter.scene ? this.emitter.scene.gammaCorrection : 0,\n        toneMap: this.emitter.scene ? this.emitter.scene.toneMapping : 0,\n        fog: this.emitter.scene && !this.emitter.noFog ? this.emitter.scene.fog : 'none',\n        wrap: this.emitter.wrap && this.emitter.wrapBounds,\n        localSpace: this.emitter.localSpace,\n        screenSpace: inTools ? false : this.emitter.screenSpace,\n        blend: this.blendType,\n        animTex: this.emitter._isAnimated(),\n        animTexLoop: this.emitter.animLoop,\n        pack8: this.emitter.pack8,\n        customFace: this.emitter.orientation !== _constants_js__WEBPACK_IMPORTED_MODULE_7__.PARTICLEORIENTATION_SCREEN\n      });\n      return shader;\n    };\n    this.material.shader = this.material.getShaderVariant();\n  }\n  resetMaterial() {\n    const material = this.material;\n    material.setParameter('stretch', this.stretch);\n    if (this._isAnimated()) {\n      material.setParameter('animTexTilesParams', this.animTilesParams);\n      material.setParameter('animTexParams', this.animParams);\n      material.setParameter('animTexIndexParams', this.animIndexParams);\n    }\n    material.setParameter('colorMult', this.intensity);\n    if (!this.useCpu) {\n      material.setParameter('internalTex0', this.internalTex0);\n      material.setParameter('internalTex1', this.internalTex1);\n      material.setParameter('internalTex2', this.internalTex2);\n      material.setParameter('internalTex3', this.internalTex3);\n    }\n    material.setParameter('colorParam', this.colorParam);\n    material.setParameter('numParticles', this.numParticles);\n    material.setParameter('numParticlesPot', this.numParticlesPot);\n    material.setParameter('lifetime', this.lifetime);\n    material.setParameter('rate', this.rate);\n    material.setParameter('rateDiv', this.rate2 - this.rate);\n    material.setParameter('seed', this.seed);\n    material.setParameter('scaleDivMult', this.scaleUMax[0]);\n    material.setParameter('alphaDivMult', this.alphaUMax[0]);\n    material.setParameter('radialSpeedDivMult', this.radialSpeedUMax[0]);\n    material.setParameter('graphNumSamples', this.precision);\n    material.setParameter('graphSampleSize', 1.0 / this.precision);\n    material.setParameter('emitterScale', new Float32Array([1, 1, 1]));\n    if (this.pack8) {\n      this._gpuUpdater._setInputBounds();\n      material.setParameter('inBoundsSize', this._gpuUpdater.inBoundsSizeUniform);\n      material.setParameter('inBoundsCenter', this._gpuUpdater.inBoundsCenterUniform);\n      material.setParameter('maxVel', this.maxVel);\n    }\n    if (this.wrap && this.wrapBounds) {\n      this.wrapBoundsUniform[0] = this.wrapBounds.x;\n      this.wrapBoundsUniform[1] = this.wrapBounds.y;\n      this.wrapBoundsUniform[2] = this.wrapBounds.z;\n      material.setParameter('wrapBounds', this.wrapBoundsUniform);\n    }\n    if (this.colorMap) {\n      material.setParameter('colorMap', this.colorMap);\n    }\n    if (this.lighting) {\n      if (this.normalMap) {\n        material.setParameter('normalMap', this.normalMap);\n      }\n    }\n    if (this.depthSoftening > 0) {\n      material.setParameter('softening', 1.0 / (this.depthSoftening * this.depthSoftening * 100));\n    }\n    if (this.stretch > 0.0) material.cull = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.CULLFACE_NONE;\n    this._compParticleFaceParams();\n  }\n  _compParticleFaceParams() {\n    let tangent, binormal;\n    if (this.orientation === _constants_js__WEBPACK_IMPORTED_MODULE_7__.PARTICLEORIENTATION_SCREEN) {\n      tangent = new Float32Array([1, 0, 0]);\n      binormal = new Float32Array([0, 0, 1]);\n    } else {\n      let n;\n      if (this.orientation === _constants_js__WEBPACK_IMPORTED_MODULE_7__.PARTICLEORIENTATION_WORLD) {\n        n = this.particleNormal.normalize();\n      } else {\n        const emitterMat = this.node === null ? _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_4__.Mat4.IDENTITY : this.node.getWorldTransform();\n        n = emitterMat.transformVector(this.particleNormal).normalize();\n      }\n      const t = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3(1, 0, 0);\n      if (Math.abs(t.dot(n)) === 1) t.set(0, 0, 1);\n      const b = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3().cross(n, t).normalize();\n      t.cross(b, n).normalize();\n      tangent = new Float32Array([t.x, t.y, t.z]);\n      binormal = new Float32Array([b.x, b.y, b.z]);\n    }\n    this.material.setParameter('faceTangent', tangent);\n    this.material.setParameter('faceBinorm', binormal);\n  }\n  _allocate(numParticles) {\n    const psysVertCount = numParticles * this.numParticleVerts;\n    const psysIndexCount = numParticles * this.numParticleIndices;\n    if (this.vertexBuffer === undefined || this.vertexBuffer.getNumVertices() !== psysVertCount) {\n      if (!this.useCpu) {\n        const elements = [{\n          semantic: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR0,\n          components: 4,\n          type: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_FLOAT32\n        }];\n        if (this.useMesh) {\n          elements.push({\n            semantic: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR1,\n            components: 2,\n            type: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_FLOAT32\n          });\n        }\n        const particleFormat = new _platform_graphics_vertex_format_js__WEBPACK_IMPORTED_MODULE_21__.VertexFormat(this.graphicsDevice, elements);\n        this.vertexBuffer = new _platform_graphics_vertex_buffer_js__WEBPACK_IMPORTED_MODULE_22__.VertexBuffer(this.graphicsDevice, particleFormat, psysVertCount, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BUFFER_DYNAMIC);\n        this.indexBuffer = new _platform_graphics_index_buffer_js__WEBPACK_IMPORTED_MODULE_23__.IndexBuffer(this.graphicsDevice, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.INDEXFORMAT_UINT16, psysIndexCount);\n      } else {\n        const elements = [{\n          semantic: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR0,\n          components: 4,\n          type: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_FLOAT32\n        }, {\n          semantic: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR1,\n          components: 4,\n          type: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_FLOAT32\n        }, {\n          semantic: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR2,\n          components: 4,\n          type: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_FLOAT32\n        }, {\n          semantic: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR3,\n          components: 1,\n          type: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_FLOAT32\n        }, {\n          semantic: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR4,\n          components: this.useMesh ? 4 : 2,\n          type: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.TYPE_FLOAT32\n        }];\n        const particleFormat = new _platform_graphics_vertex_format_js__WEBPACK_IMPORTED_MODULE_21__.VertexFormat(this.graphicsDevice, elements);\n        this.vertexBuffer = new _platform_graphics_vertex_buffer_js__WEBPACK_IMPORTED_MODULE_22__.VertexBuffer(this.graphicsDevice, particleFormat, psysVertCount, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.BUFFER_DYNAMIC);\n        this.indexBuffer = new _platform_graphics_index_buffer_js__WEBPACK_IMPORTED_MODULE_23__.IndexBuffer(this.graphicsDevice, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.INDEXFORMAT_UINT16, psysIndexCount);\n      }\n      const data = new Float32Array(this.vertexBuffer.lock());\n      let meshData, stride, texCoordOffset;\n      if (this.useMesh) {\n        meshData = new Float32Array(this.mesh.vertexBuffer.lock());\n        stride = meshData.length / this.mesh.vertexBuffer.numVertices;\n        for (let elem = 0; elem < this.mesh.vertexBuffer.format.elements.length; elem++) {\n          if (this.mesh.vertexBuffer.format.elements[elem].name === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD0) {\n            texCoordOffset = this.mesh.vertexBuffer.format.elements[elem].offset / 4;\n            break;\n          }\n        }\n      }\n      for (let i = 0; i < psysVertCount; i++) {\n        const id = Math.floor(i / this.numParticleVerts);\n        if (!this.useMesh) {\n          const vertID = i % 4;\n          data[i * 4] = particleVerts[vertID][0];\n          data[i * 4 + 1] = particleVerts[vertID][1];\n          data[i * 4 + 2] = 0;\n          data[i * 4 + 3] = id;\n        } else {\n          const vert = i % this.numParticleVerts;\n          data[i * 6] = meshData[vert * stride];\n          data[i * 6 + 1] = meshData[vert * stride + 1];\n          data[i * 6 + 2] = meshData[vert * stride + 2];\n          data[i * 6 + 3] = id;\n          data[i * 6 + 4] = meshData[vert * stride + texCoordOffset + 0];\n          data[i * 6 + 5] = 1.0 - meshData[vert * stride + texCoordOffset + 1];\n        }\n      }\n      if (this.useCpu) {\n        this.vbCPU = new Float32Array(data);\n        this.vbOld = new Float32Array(this.vbCPU.length);\n      }\n      this.vertexBuffer.unlock();\n      if (this.useMesh) {\n        this.mesh.vertexBuffer.unlock();\n      }\n      let dst = 0;\n      const indices = new Uint16Array(this.indexBuffer.lock());\n      if (this.useMesh) meshData = new Uint16Array(this.mesh.indexBuffer[0].lock());\n      for (let i = 0; i < numParticles; i++) {\n        if (!this.useMesh) {\n          const baseIndex = i * 4;\n          indices[dst++] = baseIndex;\n          indices[dst++] = baseIndex + 1;\n          indices[dst++] = baseIndex + 2;\n          indices[dst++] = baseIndex;\n          indices[dst++] = baseIndex + 2;\n          indices[dst++] = baseIndex + 3;\n        } else {\n          for (let j = 0; j < this.numParticleIndices; j++) {\n            indices[i * this.numParticleIndices + j] = meshData[j] + i * this.numParticleVerts;\n          }\n        }\n      }\n      this.indexBuffer.unlock();\n      if (this.useMesh) this.mesh.indexBuffer[0].unlock();\n    }\n  }\n  reset() {\n    this.beenReset = true;\n    this.seed = Math.random();\n    this.material.setParameter('seed', this.seed);\n    if (this.useCpu) {\n      for (let i = 0; i < this.particleTexStart.length; i++) {\n        this.particleTex[i] = this.particleTexStart[i];\n      }\n    } else {\n      this._initializeTextures();\n    }\n    this.resetWorldBounds();\n    this.resetTime();\n    const origLoop = this.loop;\n    this.loop = true;\n    this.addTime(0, false);\n    this.loop = origLoop;\n    if (this.preWarm) {\n      this.prewarm(this.lifetime);\n    }\n  }\n  prewarm(time) {\n    const lifetimeFraction = time / this.lifetime;\n    const iterations = Math.min(Math.floor(lifetimeFraction * this.precision), this.precision);\n    const stepDelta = time / iterations;\n    for (let i = 0; i < iterations; i++) {\n      this.addTime(stepDelta, false);\n    }\n  }\n  resetTime() {\n    this.endTime = calcEndTime(this);\n  }\n  finishFrame() {\n    if (this.useCpu) this.vertexBuffer.unlock();\n  }\n  addTime(delta, isOnStop) {\n    const device = this.graphicsDevice;\n    this.simTimeTotal += delta;\n    this.calculateWorldBounds();\n    if (this._isAnimated()) {\n      const tilesParams = this.animTilesParams;\n      tilesParams[0] = 1.0 / this.animTilesX;\n      tilesParams[1] = 1.0 / this.animTilesY;\n      const params = this.animParams;\n      params[0] = this.animStartFrame;\n      params[1] = this.animNumFrames * this.animSpeed;\n      params[2] = this.animNumFrames - 1;\n      params[3] = this.animNumAnimations - 1;\n      const animIndexParams = this.animIndexParams;\n      animIndexParams[0] = this.animIndex;\n      animIndexParams[1] = this.randomizeAnimIndex;\n    }\n    if (this.scene) {\n      if (this.camera !== this.scene._activeCamera) {\n        this.camera = this.scene._activeCamera;\n        this.onChangeCamera();\n      }\n    }\n    if (this.emitterShape === _constants_js__WEBPACK_IMPORTED_MODULE_7__.EMITTERSHAPE_BOX) {\n      extentsInnerRatioUniform[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;\n      extentsInnerRatioUniform[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;\n      extentsInnerRatioUniform[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;\n      if (this.meshInstance.node === null) {\n        spawnMatrix.setTRS(_core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3.ZERO, _core_math_quat_js__WEBPACK_IMPORTED_MODULE_12__.Quat.IDENTITY, this.emitterExtents);\n      } else {\n        spawnMatrix.setTRS(_core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3.ZERO, this.meshInstance.node.getRotation(), tmpVec3.copy(this.emitterExtents).mul(this.meshInstance.node.localScale));\n      }\n    }\n    let emitterPos;\n    const emitterScale = this.meshInstance.node === null ? _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_5__.Vec3.ONE : this.meshInstance.node.localScale;\n    this.emitterScaleUniform[0] = emitterScale.x;\n    this.emitterScaleUniform[1] = emitterScale.y;\n    this.emitterScaleUniform[2] = emitterScale.z;\n    this.material.setParameter('emitterScale', this.emitterScaleUniform);\n    if (this.localSpace && this.meshInstance.node) {\n      emitterPos = this.meshInstance.node.getPosition();\n      this.emitterPosUniform[0] = emitterPos.x;\n      this.emitterPosUniform[1] = emitterPos.y;\n      this.emitterPosUniform[2] = emitterPos.z;\n      this.material.setParameter('emitterPos', this.emitterPosUniform);\n    }\n    this._compParticleFaceParams();\n    if (!this.useCpu) {\n      this._gpuUpdater.update(device, spawnMatrix, extentsInnerRatioUniform, delta, isOnStop);\n    } else {\n      const data = new Float32Array(this.vertexBuffer.lock());\n      this._cpuUpdater.update(data, this.vbToSort, this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, delta, isOnStop);\n    }\n    if (!this.loop) {\n      if (Date.now() > this.endTime) {\n        if (this.onFinished) this.onFinished();\n        this.meshInstance.visible = false;\n      }\n    }\n    if (this.meshInstance) {\n      this.meshInstance.drawOrder = this.drawOrder;\n    }\n  }\n  _destroyResources() {\n    if (this.particleTexIN) {\n      this.particleTexIN.destroy();\n      this.particleTexIN = null;\n    }\n    if (this.particleTexOUT) {\n      this.particleTexOUT.destroy();\n      this.particleTexOUT = null;\n    }\n    if (this.particleTexStart && this.particleTexStart.destroy) {\n      this.particleTexStart.destroy();\n      this.particleTexStart = null;\n    }\n    if (this.rtParticleTexIN) {\n      this.rtParticleTexIN.destroy();\n      this.rtParticleTexIN = null;\n    }\n    if (this.rtParticleTexOUT) {\n      this.rtParticleTexOUT.destroy();\n      this.rtParticleTexOUT = null;\n    }\n    if (this.internalTex0) {\n      this.internalTex0.destroy();\n      this.internalTex0 = null;\n    }\n    if (this.internalTex1) {\n      this.internalTex1.destroy();\n      this.internalTex1 = null;\n    }\n    if (this.internalTex2) {\n      this.internalTex2.destroy();\n      this.internalTex2 = null;\n    }\n    if (this.internalTex3) {\n      this.internalTex3.destroy();\n      this.internalTex3 = null;\n    }\n    if (this.colorParam) {\n      this.colorParam.destroy();\n      this.colorParam = null;\n    }\n    if (this.vertexBuffer) {\n      this.vertexBuffer.destroy();\n      this.vertexBuffer = undefined;\n    }\n    if (this.indexBuffer) {\n      this.indexBuffer.destroy();\n      this.indexBuffer = undefined;\n    }\n    if (this.material) {\n      this.material.destroy();\n      this.material = null;\n    }\n  }\n  destroy() {\n    this.camera = null;\n    this._destroyResources();\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/particle-system/particle-emitter.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/procedural.js":
/*!**************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/procedural.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"calculateNormals\": () => (/* binding */ calculateNormals),\n/* harmony export */   \"calculateTangents\": () => (/* binding */ calculateTangents),\n/* harmony export */   \"createBox\": () => (/* binding */ createBox),\n/* harmony export */   \"createCapsule\": () => (/* binding */ createCapsule),\n/* harmony export */   \"createCone\": () => (/* binding */ createCone),\n/* harmony export */   \"createCylinder\": () => (/* binding */ createCylinder),\n/* harmony export */   \"createMesh\": () => (/* binding */ createMesh),\n/* harmony export */   \"createPlane\": () => (/* binding */ createPlane),\n/* harmony export */   \"createSphere\": () => (/* binding */ createSphere),\n/* harmony export */   \"createTorus\": () => (/* binding */ createTorus),\n/* harmony export */   \"getShapePrimitive\": () => (/* binding */ getShapePrimitive)\n/* harmony export */ });\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _mesh_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mesh.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh.js\");\n\n\n\n\n\n\nconst primitiveUv1Padding = 4.0 / 64;\nconst primitiveUv1PaddingScale = 1.0 - primitiveUv1Padding * 2;\nconst shapePrimitives = [];\nfunction calculateNormals(positions, indices) {\n  const triangleCount = indices.length / 3;\n  const vertexCount = positions.length / 3;\n  const p1 = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n  const p2 = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n  const p3 = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n  const p1p2 = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n  const p1p3 = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n  const faceNormal = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n  const normals = [];\n  for (let i = 0; i < positions.length; i++) {\n    normals[i] = 0;\n  }\n  for (let i = 0; i < triangleCount; i++) {\n    const i1 = indices[i * 3];\n    const i2 = indices[i * 3 + 1];\n    const i3 = indices[i * 3 + 2];\n    p1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);\n    p2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);\n    p3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);\n    p1p2.sub2(p2, p1);\n    p1p3.sub2(p3, p1);\n    faceNormal.cross(p1p2, p1p3).normalize();\n    normals[i1 * 3] += faceNormal.x;\n    normals[i1 * 3 + 1] += faceNormal.y;\n    normals[i1 * 3 + 2] += faceNormal.z;\n    normals[i2 * 3] += faceNormal.x;\n    normals[i2 * 3 + 1] += faceNormal.y;\n    normals[i2 * 3 + 2] += faceNormal.z;\n    normals[i3 * 3] += faceNormal.x;\n    normals[i3 * 3 + 1] += faceNormal.y;\n    normals[i3 * 3 + 2] += faceNormal.z;\n  }\n  for (let i = 0; i < vertexCount; i++) {\n    const nx = normals[i * 3];\n    const ny = normals[i * 3 + 1];\n    const nz = normals[i * 3 + 2];\n    const invLen = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);\n    normals[i * 3] *= invLen;\n    normals[i * 3 + 1] *= invLen;\n    normals[i * 3 + 2] *= invLen;\n  }\n  return normals;\n}\nfunction calculateTangents(positions, normals, uvs, indices) {\n  const triangleCount = indices.length / 3;\n  const vertexCount = positions.length / 3;\n  const v1 = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n  const v2 = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n  const v3 = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n  const w1 = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_1__.Vec2();\n  const w2 = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_1__.Vec2();\n  const w3 = new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_1__.Vec2();\n  const sdir = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n  const tdir = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n  const tan1 = new Float32Array(vertexCount * 3);\n  const tan2 = new Float32Array(vertexCount * 3);\n  const tangents = [];\n  for (let i = 0; i < triangleCount; i++) {\n    const i1 = indices[i * 3];\n    const i2 = indices[i * 3 + 1];\n    const i3 = indices[i * 3 + 2];\n    v1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);\n    v2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);\n    v3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);\n    w1.set(uvs[i1 * 2], uvs[i1 * 2 + 1]);\n    w2.set(uvs[i2 * 2], uvs[i2 * 2 + 1]);\n    w3.set(uvs[i3 * 2], uvs[i3 * 2 + 1]);\n    const x1 = v2.x - v1.x;\n    const x2 = v3.x - v1.x;\n    const y1 = v2.y - v1.y;\n    const y2 = v3.y - v1.y;\n    const z1 = v2.z - v1.z;\n    const z2 = v3.z - v1.z;\n    const s1 = w2.x - w1.x;\n    const s2 = w3.x - w1.x;\n    const _t = w2.y - w1.y;\n    const _t2 = w3.y - w1.y;\n    const area = s1 * _t2 - s2 * _t;\n    if (area === 0) {\n      sdir.set(0, 1, 0);\n      tdir.set(1, 0, 0);\n    } else {\n      const r = 1 / area;\n      sdir.set((_t2 * x1 - _t * x2) * r, (_t2 * y1 - _t * y2) * r, (_t2 * z1 - _t * z2) * r);\n      tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);\n    }\n    tan1[i1 * 3 + 0] += sdir.x;\n    tan1[i1 * 3 + 1] += sdir.y;\n    tan1[i1 * 3 + 2] += sdir.z;\n    tan1[i2 * 3 + 0] += sdir.x;\n    tan1[i2 * 3 + 1] += sdir.y;\n    tan1[i2 * 3 + 2] += sdir.z;\n    tan1[i3 * 3 + 0] += sdir.x;\n    tan1[i3 * 3 + 1] += sdir.y;\n    tan1[i3 * 3 + 2] += sdir.z;\n    tan2[i1 * 3 + 0] += tdir.x;\n    tan2[i1 * 3 + 1] += tdir.y;\n    tan2[i1 * 3 + 2] += tdir.z;\n    tan2[i2 * 3 + 0] += tdir.x;\n    tan2[i2 * 3 + 1] += tdir.y;\n    tan2[i2 * 3 + 2] += tdir.z;\n    tan2[i3 * 3 + 0] += tdir.x;\n    tan2[i3 * 3 + 1] += tdir.y;\n    tan2[i3 * 3 + 2] += tdir.z;\n  }\n  const t1 = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n  const t2 = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n  const n = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n  const temp = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n  for (let i = 0; i < vertexCount; i++) {\n    n.set(normals[i * 3], normals[i * 3 + 1], normals[i * 3 + 2]);\n    t1.set(tan1[i * 3], tan1[i * 3 + 1], tan1[i * 3 + 2]);\n    t2.set(tan2[i * 3], tan2[i * 3 + 1], tan2[i * 3 + 2]);\n    const ndott = n.dot(t1);\n    temp.copy(n).mulScalar(ndott);\n    temp.sub2(t1, temp).normalize();\n    tangents[i * 4] = temp.x;\n    tangents[i * 4 + 1] = temp.y;\n    tangents[i * 4 + 2] = temp.z;\n    temp.cross(n, t1);\n    tangents[i * 4 + 3] = temp.dot(t2) < 0.0 ? -1.0 : 1.0;\n  }\n  return tangents;\n}\nfunction createMesh(device, positions, opts) {\n  const mesh = new _mesh_js__WEBPACK_IMPORTED_MODULE_2__.Mesh(device);\n  mesh.setPositions(positions);\n  if (opts) {\n    if (opts.normals) {\n      mesh.setNormals(opts.normals);\n    }\n    if (opts.tangents) {\n      mesh.setVertexStream(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.SEMANTIC_TANGENT, opts.tangents, 4);\n    }\n    if (opts.colors) {\n      mesh.setColors32(opts.colors);\n    }\n    if (opts.uvs) {\n      mesh.setUvs(0, opts.uvs);\n    }\n    if (opts.uvs1) {\n      mesh.setUvs(1, opts.uvs1);\n    }\n    if (opts.blendIndices) {\n      mesh.setVertexStream(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.SEMANTIC_BLENDINDICES, opts.blendIndices, 4, opts.blendIndices.length / 4, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.TYPE_UINT8);\n    }\n    if (opts.blendWeights) {\n      mesh.setVertexStream(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.SEMANTIC_BLENDWEIGHT, opts.blendWeights, 4);\n    }\n    if (opts.indices) {\n      mesh.setIndices(opts.indices);\n    }\n  }\n  mesh.update();\n  return mesh;\n}\nfunction createTorus(device, opts) {\n  const rc = opts && opts.tubeRadius !== undefined ? opts.tubeRadius : 0.2;\n  const rt = opts && opts.ringRadius !== undefined ? opts.ringRadius : 0.3;\n  const segments = opts && opts.segments !== undefined ? opts.segments : 30;\n  const sides = opts && opts.sides !== undefined ? opts.sides : 20;\n  const calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;\n  const positions = [];\n  const normals = [];\n  const uvs = [];\n  const indices = [];\n  for (let i = 0; i <= sides; i++) {\n    for (let j = 0; j <= segments; j++) {\n      const x = Math.cos(2 * Math.PI * j / segments) * (rt + rc * Math.cos(2 * Math.PI * i / sides));\n      const y = Math.sin(2 * Math.PI * i / sides) * rc;\n      const z = Math.sin(2 * Math.PI * j / segments) * (rt + rc * Math.cos(2 * Math.PI * i / sides));\n      const nx = Math.cos(2 * Math.PI * j / segments) * Math.cos(2 * Math.PI * i / sides);\n      const ny = Math.sin(2 * Math.PI * i / sides);\n      const nz = Math.sin(2 * Math.PI * j / segments) * Math.cos(2 * Math.PI * i / sides);\n      const u = i / sides;\n      const v = 1 - j / segments;\n      positions.push(x, y, z);\n      normals.push(nx, ny, nz);\n      uvs.push(u, 1.0 - v);\n      if (i < sides && j < segments) {\n        const first = i * (segments + 1) + j;\n        const second = (i + 1) * (segments + 1) + j;\n        const third = i * (segments + 1) + (j + 1);\n        const fourth = (i + 1) * (segments + 1) + (j + 1);\n        indices.push(first, second, third);\n        indices.push(second, fourth, third);\n      }\n    }\n  }\n  const options = {\n    normals: normals,\n    uvs: uvs,\n    uvs1: uvs,\n    indices: indices\n  };\n  if (calcTangents) {\n    options.tangents = calculateTangents(positions, normals, uvs, indices);\n  }\n  return createMesh(device, positions, options);\n}\nfunction _createConeData(baseRadius, peakRadius, height, heightSegments, capSegments, roundedCaps) {\n  const pos = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n  const bottomToTop = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n  const norm = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n  const top = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n  const bottom = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n  const tangent = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n  const positions = [];\n  const normals = [];\n  const uvs = [];\n  const uvs1 = [];\n  const indices = [];\n  let offset;\n  if (height > 0) {\n    for (let i = 0; i <= heightSegments; i++) {\n      for (let j = 0; j <= capSegments; j++) {\n        const theta = j / capSegments * 2 * Math.PI - Math.PI;\n        const sinTheta = Math.sin(theta);\n        const cosTheta = Math.cos(theta);\n        bottom.set(sinTheta * baseRadius, -height / 2, cosTheta * baseRadius);\n        top.set(sinTheta * peakRadius, height / 2, cosTheta * peakRadius);\n        pos.lerp(bottom, top, i / heightSegments);\n        bottomToTop.sub2(top, bottom).normalize();\n        tangent.set(cosTheta, 0, -sinTheta);\n        norm.cross(tangent, bottomToTop).normalize();\n        positions.push(pos.x, pos.y, pos.z);\n        normals.push(norm.x, norm.y, norm.z);\n        let u = j / capSegments;\n        let v = i / heightSegments;\n        uvs.push(u, 1 - v);\n        const _v = v;\n        v = u;\n        u = _v;\n        u = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n        v = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n        u /= 3;\n        uvs1.push(u, 1 - v);\n        if (i < heightSegments && j < capSegments) {\n          const first = i * (capSegments + 1) + j;\n          const second = i * (capSegments + 1) + (j + 1);\n          const third = (i + 1) * (capSegments + 1) + j;\n          const fourth = (i + 1) * (capSegments + 1) + (j + 1);\n          indices.push(first, second, third);\n          indices.push(second, fourth, third);\n        }\n      }\n    }\n  }\n  if (roundedCaps) {\n    const latitudeBands = Math.floor(capSegments / 2);\n    const longitudeBands = capSegments;\n    const capOffset = height / 2;\n    for (let lat = 0; lat <= latitudeBands; lat++) {\n      const theta = lat * Math.PI * 0.5 / latitudeBands;\n      const sinTheta = Math.sin(theta);\n      const cosTheta = Math.cos(theta);\n      for (let lon = 0; lon <= longitudeBands; lon++) {\n        const phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;\n        const sinPhi = Math.sin(phi);\n        const cosPhi = Math.cos(phi);\n        const x = cosPhi * sinTheta;\n        const y = cosTheta;\n        const z = sinPhi * sinTheta;\n        let u = 1 - lon / longitudeBands;\n        let v = 1 - lat / latitudeBands;\n        positions.push(x * peakRadius, y * peakRadius + capOffset, z * peakRadius);\n        normals.push(x, y, z);\n        uvs.push(u, 1 - v);\n        u = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n        v = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n        u /= 3;\n        v /= 3;\n        u += 1.0 / 3;\n        uvs1.push(u, 1 - v);\n      }\n    }\n    offset = (heightSegments + 1) * (capSegments + 1);\n    for (let lat = 0; lat < latitudeBands; ++lat) {\n      for (let lon = 0; lon < longitudeBands; ++lon) {\n        const first = lat * (longitudeBands + 1) + lon;\n        const second = first + longitudeBands + 1;\n        indices.push(offset + first + 1, offset + second, offset + first);\n        indices.push(offset + first + 1, offset + second + 1, offset + second);\n      }\n    }\n    for (let lat = 0; lat <= latitudeBands; lat++) {\n      const theta = Math.PI * 0.5 + lat * Math.PI * 0.5 / latitudeBands;\n      const sinTheta = Math.sin(theta);\n      const cosTheta = Math.cos(theta);\n      for (let lon = 0; lon <= longitudeBands; lon++) {\n        const phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;\n        const sinPhi = Math.sin(phi);\n        const cosPhi = Math.cos(phi);\n        const x = cosPhi * sinTheta;\n        const y = cosTheta;\n        const z = sinPhi * sinTheta;\n        let u = 1 - lon / longitudeBands;\n        let v = 1 - lat / latitudeBands;\n        positions.push(x * peakRadius, y * peakRadius - capOffset, z * peakRadius);\n        normals.push(x, y, z);\n        uvs.push(u, 1 - v);\n        u = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n        v = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n        u /= 3;\n        v /= 3;\n        u += 2.0 / 3;\n        uvs1.push(u, 1 - v);\n      }\n    }\n    offset = (heightSegments + 1) * (capSegments + 1) + (longitudeBands + 1) * (latitudeBands + 1);\n    for (let lat = 0; lat < latitudeBands; ++lat) {\n      for (let lon = 0; lon < longitudeBands; ++lon) {\n        const first = lat * (longitudeBands + 1) + lon;\n        const second = first + longitudeBands + 1;\n        indices.push(offset + first + 1, offset + second, offset + first);\n        indices.push(offset + first + 1, offset + second + 1, offset + second);\n      }\n    }\n  } else {\n    offset = (heightSegments + 1) * (capSegments + 1);\n    if (baseRadius > 0) {\n      for (let i = 0; i < capSegments; i++) {\n        const theta = i / capSegments * 2 * Math.PI;\n        const x = Math.sin(theta);\n        const y = -height / 2;\n        const z = Math.cos(theta);\n        let u = 1 - (x + 1) / 2;\n        let v = (z + 1) / 2;\n        positions.push(x * baseRadius, y, z * baseRadius);\n        normals.push(0, -1, 0);\n        uvs.push(u, 1 - v);\n        u = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n        v = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n        u /= 3;\n        v /= 3;\n        u += 1 / 3;\n        uvs1.push(u, 1 - v);\n        if (i > 1) {\n          indices.push(offset, offset + i, offset + i - 1);\n        }\n      }\n    }\n    offset += capSegments;\n    if (peakRadius > 0) {\n      for (let i = 0; i < capSegments; i++) {\n        const theta = i / capSegments * 2 * Math.PI;\n        const x = Math.sin(theta);\n        const y = height / 2;\n        const z = Math.cos(theta);\n        let u = 1 - (x + 1) / 2;\n        let v = (z + 1) / 2;\n        positions.push(x * peakRadius, y, z * peakRadius);\n        normals.push(0, 1, 0);\n        uvs.push(u, 1 - v);\n        u = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n        v = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n        u /= 3;\n        v /= 3;\n        u += 2 / 3;\n        uvs1.push(u, 1 - v);\n        if (i > 1) {\n          indices.push(offset, offset + i - 1, offset + i);\n        }\n      }\n    }\n  }\n  return {\n    positions: positions,\n    normals: normals,\n    uvs: uvs,\n    uvs1: uvs1,\n    indices: indices\n  };\n}\nfunction createCylinder(device, opts) {\n  let radius = opts && (opts.radius || opts.baseRadius);\n  radius = radius !== undefined ? radius : 0.5;\n  const height = opts && opts.height !== undefined ? opts.height : 1.0;\n  const heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 5;\n  const capSegments = opts && opts.capSegments !== undefined ? opts.capSegments : 20;\n  const calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;\n  const options = _createConeData(radius, radius, height, heightSegments, capSegments, false);\n  if (calcTangents) {\n    options.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);\n  }\n  return createMesh(device, options.positions, options);\n}\nfunction createCapsule(device, opts) {\n  const radius = opts && opts.radius !== undefined ? opts.radius : 0.3;\n  const height = opts && opts.height !== undefined ? opts.height : 1.0;\n  const heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 1;\n  const sides = opts && opts.sides !== undefined ? opts.sides : 20;\n  const calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;\n  const options = _createConeData(radius, radius, height - 2 * radius, heightSegments, sides, true);\n  if (calcTangents) {\n    options.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);\n  }\n  return createMesh(device, options.positions, options);\n}\nfunction createCone(device, opts) {\n  const baseRadius = opts && opts.baseRadius !== undefined ? opts.baseRadius : 0.5;\n  const peakRadius = opts && opts.peakRadius !== undefined ? opts.peakRadius : 0.0;\n  const height = opts && opts.height !== undefined ? opts.height : 1.0;\n  const heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 5;\n  const capSegments = opts && opts.capSegments !== undefined ? opts.capSegments : 18;\n  const calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;\n  const options = _createConeData(baseRadius, peakRadius, height, heightSegments, capSegments, false);\n  if (calcTangents) {\n    options.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);\n  }\n  return createMesh(device, options.positions, options);\n}\nfunction createSphere(device, opts) {\n  const radius = opts && opts.radius !== undefined ? opts.radius : 0.5;\n  const latitudeBands = opts && opts.latitudeBands !== undefined ? opts.latitudeBands : 16;\n  const longitudeBands = opts && opts.longitudeBands !== undefined ? opts.longitudeBands : 16;\n  const calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;\n  const positions = [];\n  const normals = [];\n  const uvs = [];\n  const indices = [];\n  for (let lat = 0; lat <= latitudeBands; lat++) {\n    const theta = lat * Math.PI / latitudeBands;\n    const sinTheta = Math.sin(theta);\n    const cosTheta = Math.cos(theta);\n    for (let lon = 0; lon <= longitudeBands; lon++) {\n      const phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;\n      const sinPhi = Math.sin(phi);\n      const cosPhi = Math.cos(phi);\n      const x = cosPhi * sinTheta;\n      const y = cosTheta;\n      const z = sinPhi * sinTheta;\n      const u = 1 - lon / longitudeBands;\n      const v = 1 - lat / latitudeBands;\n      positions.push(x * radius, y * radius, z * radius);\n      normals.push(x, y, z);\n      uvs.push(u, 1 - v);\n    }\n  }\n  for (let lat = 0; lat < latitudeBands; ++lat) {\n    for (let lon = 0; lon < longitudeBands; ++lon) {\n      const first = lat * (longitudeBands + 1) + lon;\n      const second = first + longitudeBands + 1;\n      indices.push(first + 1, second, first);\n      indices.push(first + 1, second + 1, second);\n    }\n  }\n  const options = {\n    normals: normals,\n    uvs: uvs,\n    uvs1: uvs,\n    indices: indices\n  };\n  if (calcTangents) {\n    options.tangents = calculateTangents(positions, normals, uvs, indices);\n  }\n  return createMesh(device, positions, options);\n}\nfunction createPlane(device, opts) {\n  const he = opts && opts.halfExtents !== undefined ? opts.halfExtents : new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_1__.Vec2(0.5, 0.5);\n  const ws = opts && opts.widthSegments !== undefined ? opts.widthSegments : 5;\n  const ls = opts && opts.lengthSegments !== undefined ? opts.lengthSegments : 5;\n  const calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;\n  const positions = [];\n  const normals = [];\n  const uvs = [];\n  const indices = [];\n  let vcounter = 0;\n  for (let i = 0; i <= ws; i++) {\n    for (let j = 0; j <= ls; j++) {\n      const x = -he.x + 2 * he.x * i / ws;\n      const y = 0.0;\n      const z = -(-he.y + 2 * he.y * j / ls);\n      const u = i / ws;\n      const v = j / ls;\n      positions.push(x, y, z);\n      normals.push(0, 1, 0);\n      uvs.push(u, 1 - v);\n      if (i < ws && j < ls) {\n        indices.push(vcounter + ls + 1, vcounter + 1, vcounter);\n        indices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);\n      }\n      vcounter++;\n    }\n  }\n  const options = {\n    normals: normals,\n    uvs: uvs,\n    uvs1: uvs,\n    indices: indices\n  };\n  if (calcTangents) {\n    options.tangents = calculateTangents(positions, normals, uvs, indices);\n  }\n  return createMesh(device, positions, options);\n}\nfunction createBox(device, opts) {\n  const he = opts && opts.halfExtents !== undefined ? opts.halfExtents : new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(0.5, 0.5, 0.5);\n  const ws = opts && opts.widthSegments !== undefined ? opts.widthSegments : 1;\n  const ls = opts && opts.lengthSegments !== undefined ? opts.lengthSegments : 1;\n  const hs = opts && opts.heightSegments !== undefined ? opts.heightSegments : 1;\n  const calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;\n  const corners = [new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(-he.x, -he.y, he.z), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(he.x, -he.y, he.z), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(he.x, he.y, he.z), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(-he.x, he.y, he.z), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(he.x, -he.y, -he.z), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(-he.x, -he.y, -he.z), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(-he.x, he.y, -he.z), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(he.x, he.y, -he.z)];\n  const faceAxes = [[0, 1, 3], [4, 5, 7], [3, 2, 6], [1, 0, 4], [1, 4, 2], [5, 0, 6]];\n  const faceNormals = [[0, 0, 1], [0, 0, -1], [0, 1, 0], [0, -1, 0], [1, 0, 0], [-1, 0, 0]];\n  const sides = {\n    FRONT: 0,\n    BACK: 1,\n    TOP: 2,\n    BOTTOM: 3,\n    RIGHT: 4,\n    LEFT: 5\n  };\n  const positions = [];\n  const normals = [];\n  const uvs = [];\n  const uvs1 = [];\n  const indices = [];\n  let vcounter = 0;\n  const generateFace = (side, uSegments, vSegments) => {\n    const temp1 = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n    const temp2 = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n    const temp3 = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n    const r = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3();\n    for (let i = 0; i <= uSegments; i++) {\n      for (let j = 0; j <= vSegments; j++) {\n        temp1.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][1]], i / uSegments);\n        temp2.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][2]], j / vSegments);\n        temp3.sub2(temp2, corners[faceAxes[side][0]]);\n        r.add2(temp1, temp3);\n        let u = i / uSegments;\n        let v = j / vSegments;\n        positions.push(r.x, r.y, r.z);\n        normals.push(faceNormals[side][0], faceNormals[side][1], faceNormals[side][2]);\n        uvs.push(u, 1 - v);\n        u = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n        v = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n        u /= 3;\n        v /= 3;\n        u += side % 3 / 3;\n        v += Math.floor(side / 3) / 3;\n        uvs1.push(u, 1 - v);\n        if (i < uSegments && j < vSegments) {\n          indices.push(vcounter + vSegments + 1, vcounter + 1, vcounter);\n          indices.push(vcounter + vSegments + 1, vcounter + vSegments + 2, vcounter + 1);\n        }\n        vcounter++;\n      }\n    }\n  };\n  generateFace(sides.FRONT, ws, hs);\n  generateFace(sides.BACK, ws, hs);\n  generateFace(sides.TOP, ws, ls);\n  generateFace(sides.BOTTOM, ws, ls);\n  generateFace(sides.RIGHT, ls, hs);\n  generateFace(sides.LEFT, ls, hs);\n  const options = {\n    normals: normals,\n    uvs: uvs,\n    uvs1: uvs1,\n    indices: indices\n  };\n  if (calcTangents) {\n    options.tangents = calculateTangents(positions, normals, uvs, indices);\n  }\n  return createMesh(device, positions, options);\n}\nfunction getShapePrimitive(device, type) {\n  let primData = null;\n  for (let i = 0; i < shapePrimitives.length; i++) {\n    if (shapePrimitives[i].type === type && shapePrimitives[i].device === device) {\n      primData = shapePrimitives[i].primData;\n    }\n  }\n  if (!primData) {\n    let mesh, area;\n    switch (type) {\n      case 'box':\n        mesh = createBox(device, {\n          halfExtents: new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(0.5, 0.5, 0.5)\n        });\n        area = {\n          x: 2,\n          y: 2,\n          z: 2,\n          uv: 2.0 / 3\n        };\n        break;\n      case 'capsule':\n        mesh = createCapsule(device, {\n          radius: 0.5,\n          height: 2\n        });\n        area = {\n          x: Math.PI * 2,\n          y: Math.PI,\n          z: Math.PI * 2,\n          uv: 1.0 / 3 + 1.0 / 3 / 3 * 2\n        };\n        break;\n      case 'cone':\n        mesh = createCone(device, {\n          baseRadius: 0.5,\n          peakRadius: 0,\n          height: 1\n        });\n        area = {\n          x: 2.54,\n          y: 2.54,\n          z: 2.54,\n          uv: 1.0 / 3 + 1.0 / 3 / 3\n        };\n        break;\n      case 'cylinder':\n        mesh = createCylinder(device, {\n          radius: 0.5,\n          height: 1\n        });\n        area = {\n          x: Math.PI,\n          y: 0.79 * 2,\n          z: Math.PI,\n          uv: 1.0 / 3 + 1.0 / 3 / 3 * 2\n        };\n        break;\n      case 'plane':\n        mesh = createPlane(device, {\n          halfExtents: new _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_1__.Vec2(0.5, 0.5),\n          widthSegments: 1,\n          lengthSegments: 1\n        });\n        area = {\n          x: 0,\n          y: 1,\n          z: 0,\n          uv: 1\n        };\n        break;\n      case 'sphere':\n        mesh = createSphere(device, {\n          radius: 0.5\n        });\n        area = {\n          x: Math.PI,\n          y: Math.PI,\n          z: Math.PI,\n          uv: 1\n        };\n        break;\n      case 'torus':\n        mesh = createTorus(device, {\n          tubeRadius: 0.2,\n          ringRadius: 0.3\n        });\n        area = {\n          x: Math.PI * 0.5 * 0.5 - Math.PI * 0.1 * 0.1,\n          y: 0.4,\n          z: 0.4,\n          uv: 1\n        };\n        break;\n      default:\n        throw new Error('Invalid primitive type: ' + type);\n    }\n    mesh.incRefCount();\n    primData = {\n      mesh: mesh,\n      area: area\n    };\n    shapePrimitives.push({\n      type: type,\n      device: device,\n      primData: primData\n    });\n  }\n  return primData;\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/procedural.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/render.js":
/*!**********************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/render.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Render\": () => (/* binding */ Render)\n/* harmony export */ });\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n\n\nclass Render extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor() {\n    super();\n    this._meshes = null;\n  }\n  set meshes(value) {\n    this.decRefMeshes();\n    this._meshes = value;\n    this.incRefMeshes();\n    this.fire('set:meshes', value);\n  }\n  get meshes() {\n    return this._meshes;\n  }\n  destroy() {\n    this.meshes = null;\n  }\n  decRefMeshes() {\n    if (this._meshes) {\n      const count = this._meshes.length;\n      for (let i = 0; i < count; i++) {\n        const mesh = this._meshes[i];\n        if (mesh) {\n          mesh.decRefCount();\n          if (mesh.refCount < 1) {\n            mesh.destroy();\n            this._meshes[i] = null;\n          }\n        }\n      }\n    }\n  }\n  incRefMeshes() {\n    if (this._meshes) {\n      const count = this._meshes.length;\n      for (let i = 0; i < count; i++) {\n        if (this._meshes[i]) {\n          this._meshes[i].incRefCount();\n        }\n      }\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/render.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/cookie-renderer.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/cookie-renderer.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CookieRenderer\": () => (/* binding */ CookieRenderer)\n/* harmony export */ });\n/* harmony import */ var _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/math/vec4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec4.js\");\n/* harmony import */ var _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/math/mat4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_simple_post_effect_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../platform/graphics/simple-post-effect.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/simple-post-effect.js\");\n/* harmony import */ var _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../platform/graphics/texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _shader_lib_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shader-lib/utils.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/utils.js\");\n/* harmony import */ var _light_camera_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./light-camera.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/light-camera.js\");\n\n\n\n\n\n\n\n\n\nconst textureBlitVertexShader = `\n    attribute vec2 vertex_position;\n    varying vec2 uv0;\n    void main(void) {\n        gl_Position = vec4(vertex_position, 0.5, 1.0);\n        uv0 = vertex_position.xy * 0.5 + 0.5;\n    }`;\nconst textureBlitFragmentShader = `\n    varying vec2 uv0;\n    uniform sampler2D blitTexture;\n    void main(void) {\n        gl_FragColor = texture2D(blitTexture, uv0);\n    }`;\nconst textureCubeBlitFragmentShader = `\n    varying vec2 uv0;\n    uniform samplerCube blitTexture;\n    uniform mat4 invViewProj;\n    void main(void) {\n        vec4 projPos = vec4(uv0 * 2.0 - 1.0, 0.5, 1.0);\n        vec4 worldPos = invViewProj * projPos;\n        gl_FragColor = textureCube(blitTexture, worldPos.xyz);\n    }`;\nconst _viewport = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_0__.Vec4();\nclass CookieRenderer {\n  constructor(device, lightTextureAtlas) {\n    this.device = device;\n    this.lightTextureAtlas = lightTextureAtlas;\n    this.blitShader2d = null;\n    this.blitShaderCube = null;\n    this.blitTextureId = null;\n    this.invViewProjId = null;\n  }\n  destroy() {}\n  getShader(shader, fragment) {\n    if (!this[shader]) this[shader] = (0,_shader_lib_utils_js__WEBPACK_IMPORTED_MODULE_1__.createShaderFromCode)(this.device, textureBlitVertexShader, fragment, `cookie_renderer_${shader}`);\n    if (!this.blitTextureId) this.blitTextureId = this.device.scope.resolve('blitTexture');\n    if (!this.invViewProjId) this.invViewProjId = this.device.scope.resolve('invViewProj');\n    return this[shader];\n  }\n  get shader2d() {\n    return this.getShader('blitShader2d', textureBlitFragmentShader);\n  }\n  get shaderCube() {\n    return this.getShader('blitShaderCube', textureCubeBlitFragmentShader);\n  }\n  static createTexture(device, resolution) {\n    const texture = new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_2__.Texture(device, {\n      name: 'CookieAtlas',\n      width: resolution,\n      height: resolution,\n      format: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.PIXELFORMAT_RGBA8,\n      cubemap: false,\n      mipmaps: false,\n      minFilter: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.FILTER_NEAREST,\n      magFilter: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.FILTER_NEAREST,\n      addressU: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.ADDRESS_CLAMP_TO_EDGE,\n      addressV: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.ADDRESS_CLAMP_TO_EDGE\n    });\n    return texture;\n  }\n  initInvViewProjMatrices() {\n    if (!CookieRenderer._invViewProjMatrices) {\n      CookieRenderer._invViewProjMatrices = [];\n      for (let face = 0; face < 6; face++) {\n        const camera = _light_camera_js__WEBPACK_IMPORTED_MODULE_4__.LightCamera.create(null, _constants_js__WEBPACK_IMPORTED_MODULE_5__.LIGHTTYPE_OMNI, face);\n        const projMat = camera.projectionMatrix;\n        const viewMat = camera.node.getLocalTransform().clone().invert();\n        CookieRenderer._invViewProjMatrices[face] = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_6__.Mat4().mul2(projMat, viewMat).invert();\n      }\n    }\n  }\n  render(light, renderTarget) {\n    if (light.enabled && light.cookie && light.visibleThisFrame) {\n      const faceCount = light.numShadowFaces;\n      const shader = faceCount > 1 ? this.shaderCube : this.shader2d;\n      const device = this.device;\n      if (faceCount > 1) {\n        this.initInvViewProjMatrices();\n      }\n      this.blitTextureId.setValue(light.cookie);\n      for (let face = 0; face < faceCount; face++) {\n        _viewport.copy(light.atlasViewport);\n        if (faceCount > 1) {\n          const smallSize = _viewport.z / 3;\n          const offset = this.lightTextureAtlas.cubeSlotsOffsets[face];\n          _viewport.x += smallSize * offset.x;\n          _viewport.y += smallSize * offset.y;\n          _viewport.z = smallSize;\n          _viewport.w = smallSize;\n          this.invViewProjId.setValue(CookieRenderer._invViewProjMatrices[face].data);\n        }\n        _viewport.mulScalar(renderTarget.colorBuffer.width);\n        (0,_platform_graphics_simple_post_effect_js__WEBPACK_IMPORTED_MODULE_7__.drawQuadWithShader)(device, renderTarget, shader, _viewport);\n      }\n    }\n  }\n}\nCookieRenderer._invViewProjMatrices = null;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/cookie-renderer.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/forward-renderer.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/forward-renderer.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ForwardRenderer\": () => (/* binding */ ForwardRenderer)\n/* harmony export */ });\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_math_color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/math/color.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_render_pass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../platform/graphics/render-pass.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/render-pass.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _renderer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./renderer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/renderer.js\");\n/* harmony import */ var _light_camera_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./light-camera.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/light-camera.js\");\n/* harmony import */ var _graphics_scene_grab_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../graphics/scene-grab.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/graphics/scene-grab.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst webgl1DepthClearColor = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_0__.Color(254.0 / 255, 254.0 / 255, 254.0 / 255, 254.0 / 255);\nconst _drawCallList = {\n  drawCalls: [],\n  isNewMaterial: [],\n  lightMaskChanged: []\n};\nclass ForwardRenderer extends _renderer_js__WEBPACK_IMPORTED_MODULE_1__.Renderer {\n  constructor(graphicsDevice) {\n    super(graphicsDevice);\n    const device = this.device;\n    this._forwardDrawCalls = 0;\n    this._materialSwitches = 0;\n    this._depthMapTime = 0;\n    this._forwardTime = 0;\n    this._sortTime = 0;\n    const scope = device.scope;\n    this.fogColorId = scope.resolve('fog_color');\n    this.fogStartId = scope.resolve('fog_start');\n    this.fogEndId = scope.resolve('fog_end');\n    this.fogDensityId = scope.resolve('fog_density');\n    this.ambientId = scope.resolve('light_globalAmbient');\n    this.skyboxIntensityId = scope.resolve('skyboxIntensity');\n    this.cubeMapRotationMatrixId = scope.resolve('cubeMapRotationMatrix');\n    this.lightColorId = [];\n    this.lightDir = [];\n    this.lightDirId = [];\n    this.lightShadowMapId = [];\n    this.lightShadowMatrixId = [];\n    this.lightShadowParamsId = [];\n    this.lightShadowIntensity = [];\n    this.lightRadiusId = [];\n    this.lightPos = [];\n    this.lightPosId = [];\n    this.lightWidth = [];\n    this.lightWidthId = [];\n    this.lightHeight = [];\n    this.lightHeightId = [];\n    this.lightInAngleId = [];\n    this.lightOutAngleId = [];\n    this.lightCookieId = [];\n    this.lightCookieIntId = [];\n    this.lightCookieMatrixId = [];\n    this.lightCookieOffsetId = [];\n    this.shadowMatrixPaletteId = [];\n    this.shadowCascadeDistancesId = [];\n    this.shadowCascadeCountId = [];\n    this.screenSizeId = scope.resolve('uScreenSize');\n    this._screenSize = new Float32Array(4);\n    this.fogColor = new Float32Array(3);\n    this.ambientColor = new Float32Array(3);\n  }\n  destroy() {\n    super.destroy();\n  }\n  dispatchGlobalLights(scene) {\n    this.ambientColor[0] = scene.ambientLight.r;\n    this.ambientColor[1] = scene.ambientLight.g;\n    this.ambientColor[2] = scene.ambientLight.b;\n    if (scene.gammaCorrection) {\n      for (let i = 0; i < 3; i++) {\n        this.ambientColor[i] = Math.pow(this.ambientColor[i], 2.2);\n      }\n    }\n    if (scene.physicalUnits) {\n      for (let i = 0; i < 3; i++) {\n        this.ambientColor[i] *= scene.ambientLuminance;\n      }\n    }\n    this.ambientId.setValue(this.ambientColor);\n    this.skyboxIntensityId.setValue(scene.physicalUnits ? scene.skyboxLuminance : scene.skyboxIntensity);\n    this.cubeMapRotationMatrixId.setValue(scene._skyboxRotationMat3.data);\n  }\n  _resolveLight(scope, i) {\n    const light = 'light' + i;\n    this.lightColorId[i] = scope.resolve(light + '_color');\n    this.lightDir[i] = new Float32Array(3);\n    this.lightDirId[i] = scope.resolve(light + '_direction');\n    this.lightShadowMapId[i] = scope.resolve(light + '_shadowMap');\n    this.lightShadowMatrixId[i] = scope.resolve(light + '_shadowMatrix');\n    this.lightShadowParamsId[i] = scope.resolve(light + '_shadowParams');\n    this.lightShadowIntensity[i] = scope.resolve(light + '_shadowIntensity');\n    this.lightRadiusId[i] = scope.resolve(light + '_radius');\n    this.lightPos[i] = new Float32Array(3);\n    this.lightPosId[i] = scope.resolve(light + '_position');\n    this.lightWidth[i] = new Float32Array(3);\n    this.lightWidthId[i] = scope.resolve(light + '_halfWidth');\n    this.lightHeight[i] = new Float32Array(3);\n    this.lightHeightId[i] = scope.resolve(light + '_halfHeight');\n    this.lightInAngleId[i] = scope.resolve(light + '_innerConeAngle');\n    this.lightOutAngleId[i] = scope.resolve(light + '_outerConeAngle');\n    this.lightCookieId[i] = scope.resolve(light + '_cookie');\n    this.lightCookieIntId[i] = scope.resolve(light + '_cookieIntensity');\n    this.lightCookieMatrixId[i] = scope.resolve(light + '_cookieMatrix');\n    this.lightCookieOffsetId[i] = scope.resolve(light + '_cookieOffset');\n    this.shadowMatrixPaletteId[i] = scope.resolve(light + '_shadowMatrixPalette[0]');\n    this.shadowCascadeDistancesId[i] = scope.resolve(light + '_shadowCascadeDistances[0]');\n    this.shadowCascadeCountId[i] = scope.resolve(light + '_shadowCascadeCount');\n  }\n  setLTCDirectionalLight(wtm, cnt, dir, campos, far) {\n    this.lightPos[cnt][0] = campos.x - dir.x * far;\n    this.lightPos[cnt][1] = campos.y - dir.y * far;\n    this.lightPos[cnt][2] = campos.z - dir.z * far;\n    this.lightPosId[cnt].setValue(this.lightPos[cnt]);\n    const hWidth = wtm.transformVector(new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_2__.Vec3(-0.5, 0, 0));\n    this.lightWidth[cnt][0] = hWidth.x * far;\n    this.lightWidth[cnt][1] = hWidth.y * far;\n    this.lightWidth[cnt][2] = hWidth.z * far;\n    this.lightWidthId[cnt].setValue(this.lightWidth[cnt]);\n    const hHeight = wtm.transformVector(new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_2__.Vec3(0, 0, 0.5));\n    this.lightHeight[cnt][0] = hHeight.x * far;\n    this.lightHeight[cnt][1] = hHeight.y * far;\n    this.lightHeight[cnt][2] = hHeight.z * far;\n    this.lightHeightId[cnt].setValue(this.lightHeight[cnt]);\n  }\n  dispatchDirectLights(dirs, scene, mask, camera) {\n    let cnt = 0;\n    const scope = this.device.scope;\n    for (let i = 0; i < dirs.length; i++) {\n      if (!(dirs[i].mask & mask)) continue;\n      const directional = dirs[i];\n      const wtm = directional._node.getWorldTransform();\n      if (!this.lightColorId[cnt]) {\n        this._resolveLight(scope, cnt);\n      }\n      this.lightColorId[cnt].setValue(scene.gammaCorrection ? directional._linearFinalColor : directional._finalColor);\n      wtm.getY(directional._direction).mulScalar(-1);\n      directional._direction.normalize();\n      this.lightDir[cnt][0] = directional._direction.x;\n      this.lightDir[cnt][1] = directional._direction.y;\n      this.lightDir[cnt][2] = directional._direction.z;\n      this.lightDirId[cnt].setValue(this.lightDir[cnt]);\n      if (directional.shape !== _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTSHAPE_PUNCTUAL) {\n        this.setLTCDirectionalLight(wtm, cnt, directional._direction, camera._node.getPosition(), camera.farClip);\n      }\n      if (directional.castShadows) {\n        const lightRenderData = directional.getRenderData(camera, 0);\n        const biases = directional._getUniformBiasValues(lightRenderData);\n        this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);\n        this.lightShadowMatrixId[cnt].setValue(lightRenderData.shadowMatrix.data);\n        this.shadowMatrixPaletteId[cnt].setValue(directional._shadowMatrixPalette);\n        this.shadowCascadeDistancesId[cnt].setValue(directional._shadowCascadeDistances);\n        this.shadowCascadeCountId[cnt].setValue(directional.numCascades);\n        this.lightShadowIntensity[cnt].setValue(directional.shadowIntensity);\n        const params = directional._shadowRenderParams;\n        params.length = 3;\n        params[0] = directional._shadowResolution;\n        params[1] = biases.normalBias;\n        params[2] = biases.bias;\n        this.lightShadowParamsId[cnt].setValue(params);\n      }\n      cnt++;\n    }\n    return cnt;\n  }\n  setLTCPositionalLight(wtm, cnt) {\n    const hWidth = wtm.transformVector(new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_2__.Vec3(-0.5, 0, 0));\n    this.lightWidth[cnt][0] = hWidth.x;\n    this.lightWidth[cnt][1] = hWidth.y;\n    this.lightWidth[cnt][2] = hWidth.z;\n    this.lightWidthId[cnt].setValue(this.lightWidth[cnt]);\n    const hHeight = wtm.transformVector(new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_2__.Vec3(0, 0, 0.5));\n    this.lightHeight[cnt][0] = hHeight.x;\n    this.lightHeight[cnt][1] = hHeight.y;\n    this.lightHeight[cnt][2] = hHeight.z;\n    this.lightHeightId[cnt].setValue(this.lightHeight[cnt]);\n  }\n  dispatchOmniLight(scene, scope, omni, cnt) {\n    const wtm = omni._node.getWorldTransform();\n    if (!this.lightColorId[cnt]) {\n      this._resolveLight(scope, cnt);\n    }\n    this.lightRadiusId[cnt].setValue(omni.attenuationEnd);\n    this.lightColorId[cnt].setValue(scene.gammaCorrection ? omni._linearFinalColor : omni._finalColor);\n    wtm.getTranslation(omni._position);\n    this.lightPos[cnt][0] = omni._position.x;\n    this.lightPos[cnt][1] = omni._position.y;\n    this.lightPos[cnt][2] = omni._position.z;\n    this.lightPosId[cnt].setValue(this.lightPos[cnt]);\n    if (omni.shape !== _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTSHAPE_PUNCTUAL) {\n      this.setLTCPositionalLight(wtm, cnt);\n    }\n    if (omni.castShadows) {\n      const lightRenderData = omni.getRenderData(null, 0);\n      this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);\n      const biases = omni._getUniformBiasValues(lightRenderData);\n      const params = omni._shadowRenderParams;\n      params.length = 4;\n      params[0] = omni._shadowResolution;\n      params[1] = biases.normalBias;\n      params[2] = biases.bias;\n      params[3] = 1.0 / omni.attenuationEnd;\n      this.lightShadowParamsId[cnt].setValue(params);\n      this.lightShadowIntensity[cnt].setValue(omni.shadowIntensity);\n    }\n    if (omni._cookie) {\n      this.lightCookieId[cnt].setValue(omni._cookie);\n      this.lightShadowMatrixId[cnt].setValue(wtm.data);\n      this.lightCookieIntId[cnt].setValue(omni.cookieIntensity);\n    }\n  }\n  dispatchSpotLight(scene, scope, spot, cnt) {\n    const wtm = spot._node.getWorldTransform();\n    if (!this.lightColorId[cnt]) {\n      this._resolveLight(scope, cnt);\n    }\n    this.lightInAngleId[cnt].setValue(spot._innerConeAngleCos);\n    this.lightOutAngleId[cnt].setValue(spot._outerConeAngleCos);\n    this.lightRadiusId[cnt].setValue(spot.attenuationEnd);\n    this.lightColorId[cnt].setValue(scene.gammaCorrection ? spot._linearFinalColor : spot._finalColor);\n    wtm.getTranslation(spot._position);\n    this.lightPos[cnt][0] = spot._position.x;\n    this.lightPos[cnt][1] = spot._position.y;\n    this.lightPos[cnt][2] = spot._position.z;\n    this.lightPosId[cnt].setValue(this.lightPos[cnt]);\n    if (spot.shape !== _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTSHAPE_PUNCTUAL) {\n      this.setLTCPositionalLight(wtm, cnt);\n    }\n    wtm.getY(spot._direction).mulScalar(-1);\n    spot._direction.normalize();\n    this.lightDir[cnt][0] = spot._direction.x;\n    this.lightDir[cnt][1] = spot._direction.y;\n    this.lightDir[cnt][2] = spot._direction.z;\n    this.lightDirId[cnt].setValue(this.lightDir[cnt]);\n    if (spot.castShadows) {\n      const lightRenderData = spot.getRenderData(null, 0);\n      this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);\n      this.lightShadowMatrixId[cnt].setValue(lightRenderData.shadowMatrix.data);\n      const biases = spot._getUniformBiasValues(lightRenderData);\n      const params = spot._shadowRenderParams;\n      params.length = 4;\n      params[0] = spot._shadowResolution;\n      params[1] = biases.normalBias;\n      params[2] = biases.bias;\n      params[3] = 1.0 / spot.attenuationEnd;\n      this.lightShadowParamsId[cnt].setValue(params);\n      this.lightShadowIntensity[cnt].setValue(spot.shadowIntensity);\n    }\n    if (spot._cookie) {\n      if (!spot.castShadows) {\n        const cookieMatrix = _light_camera_js__WEBPACK_IMPORTED_MODULE_4__.LightCamera.evalSpotCookieMatrix(spot);\n        this.lightShadowMatrixId[cnt].setValue(cookieMatrix.data);\n      }\n      this.lightCookieId[cnt].setValue(spot._cookie);\n      this.lightCookieIntId[cnt].setValue(spot.cookieIntensity);\n      if (spot._cookieTransform) {\n        spot._cookieTransformUniform[0] = spot._cookieTransform.x;\n        spot._cookieTransformUniform[1] = spot._cookieTransform.y;\n        spot._cookieTransformUniform[2] = spot._cookieTransform.z;\n        spot._cookieTransformUniform[3] = spot._cookieTransform.w;\n        this.lightCookieMatrixId[cnt].setValue(spot._cookieTransformUniform);\n        spot._cookieOffsetUniform[0] = spot._cookieOffset.x;\n        spot._cookieOffsetUniform[1] = spot._cookieOffset.y;\n        this.lightCookieOffsetId[cnt].setValue(spot._cookieOffsetUniform);\n      }\n    }\n  }\n  dispatchLocalLights(sortedLights, scene, mask, usedDirLights, staticLightList) {\n    let cnt = usedDirLights;\n    const scope = this.device.scope;\n    const omnis = sortedLights[_constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_OMNI];\n    const numOmnis = omnis.length;\n    for (let i = 0; i < numOmnis; i++) {\n      const omni = omnis[i];\n      if (!(omni.mask & mask)) continue;\n      if (omni.isStatic) continue;\n      this.dispatchOmniLight(scene, scope, omni, cnt);\n      cnt++;\n    }\n    let staticId = 0;\n    if (staticLightList) {\n      let omni = staticLightList[staticId];\n      while (omni && omni._type === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_OMNI) {\n        this.dispatchOmniLight(scene, scope, omni, cnt);\n        cnt++;\n        staticId++;\n        omni = staticLightList[staticId];\n      }\n    }\n    const spts = sortedLights[_constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_SPOT];\n    const numSpts = spts.length;\n    for (let i = 0; i < numSpts; i++) {\n      const spot = spts[i];\n      if (!(spot.mask & mask)) continue;\n      if (spot.isStatic) continue;\n      this.dispatchSpotLight(scene, scope, spot, cnt);\n      cnt++;\n    }\n    if (staticLightList) {\n      let spot = staticLightList[staticId];\n      while (spot && spot._type === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_SPOT) {\n        this.dispatchSpotLight(scene, scope, spot, cnt);\n        cnt++;\n        staticId++;\n        spot = staticLightList[staticId];\n      }\n    }\n  }\n  renderShadowsLocal(lights, camera) {\n    const isClustered = this.scene.clusteredLightingEnabled;\n    for (let i = 0; i < lights.length; i++) {\n      const light = lights[i];\n      if (isClustered && !light.atlasViewportAllocated) {\n        continue;\n      }\n      this.shadowRenderer.render(light, camera);\n    }\n  }\n  renderForwardPrepareMaterials(camera, drawCalls, drawCallsCount, sortedLights, cullingMask, layer, pass) {\n    const addCall = (drawCall, isNewMaterial, lightMaskChanged) => {\n      _drawCallList.drawCalls.push(drawCall);\n      _drawCallList.isNewMaterial.push(isNewMaterial);\n      _drawCallList.lightMaskChanged.push(lightMaskChanged);\n    };\n    _drawCallList.drawCalls.length = 0;\n    _drawCallList.isNewMaterial.length = 0;\n    _drawCallList.lightMaskChanged.length = 0;\n    const device = this.device;\n    const scene = this.scene;\n    const lightHash = layer ? layer._lightHash : 0;\n    let prevMaterial = null,\n      prevObjDefs,\n      prevStatic,\n      prevLightMask;\n    for (let i = 0; i < drawCallsCount; i++) {\n      const drawCall = drawCalls[i];\n      if (cullingMask && drawCall.mask && !(cullingMask & drawCall.mask)) continue;\n      if (drawCall.command) {\n        addCall(drawCall, false, false);\n      } else {\n        drawCall.ensureMaterial(device);\n        const material = drawCall.material;\n        const objDefs = drawCall._shaderDefs;\n        const lightMask = drawCall.mask;\n        if (material && material === prevMaterial && objDefs !== prevObjDefs) {\n          prevMaterial = null;\n        }\n        if (drawCall.isStatic || prevStatic) {\n          prevMaterial = null;\n        }\n        if (material !== prevMaterial) {\n          this._materialSwitches++;\n          material._scene = scene;\n          if (material.dirty) {\n            material.updateUniforms(device, scene);\n            material.dirty = false;\n          }\n          if (material._dirtyBlend) {\n            scene.layers._dirtyBlend = true;\n          }\n        }\n        if (!drawCall._shader[pass] || drawCall._shaderDefs !== objDefs || drawCall._lightHash !== lightHash) {\n          if (!drawCall.isStatic) {\n            const variantKey = pass + '_' + objDefs + '_' + lightHash;\n            drawCall._shader[pass] = material.variants[variantKey];\n            if (!drawCall._shader[pass]) {\n              drawCall.updatePassShader(scene, pass, null, sortedLights, this.viewUniformFormat, this.viewBindGroupFormat);\n              material.variants[variantKey] = drawCall._shader[pass];\n            }\n          } else {\n            drawCall.updatePassShader(scene, pass, drawCall._staticLightList, sortedLights, this.viewUniformFormat, this.viewBindGroupFormat);\n          }\n          drawCall._lightHash = lightHash;\n        }\n        addCall(drawCall, material !== prevMaterial, !prevMaterial || lightMask !== prevLightMask);\n        prevMaterial = material;\n        prevObjDefs = objDefs;\n        prevLightMask = lightMask;\n        prevStatic = drawCall.isStatic;\n      }\n    }\n    return _drawCallList;\n  }\n  renderForwardInternal(camera, preparedCalls, sortedLights, pass, drawCallback, flipFaces) {\n    const device = this.device;\n    const scene = this.scene;\n    const passFlag = 1 << pass;\n    let skipMaterial = false;\n    const preparedCallsCount = preparedCalls.drawCalls.length;\n    for (let i = 0; i < preparedCallsCount; i++) {\n      const drawCall = preparedCalls.drawCalls[i];\n      if (drawCall.command) {\n        drawCall.command();\n      } else {\n        const newMaterial = preparedCalls.isNewMaterial[i];\n        const lightMaskChanged = preparedCalls.lightMaskChanged[i];\n        const material = drawCall.material;\n        drawCall._shaderDefs;\n        const lightMask = drawCall.mask;\n        if (newMaterial) {\n          const shader = drawCall._shader[pass];\n          if (!shader.failed && !device.setShader(shader)) ;\n          skipMaterial = shader.failed;\n          if (skipMaterial) break;\n          material.setParameters(device);\n          if (lightMaskChanged) {\n            const usedDirLights = this.dispatchDirectLights(sortedLights[_constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_DIRECTIONAL], scene, lightMask, camera);\n            this.dispatchLocalLights(sortedLights, scene, lightMask, usedDirLights, drawCall._staticLightList);\n          }\n          this.alphaTestId.setValue(material.alphaTest);\n          device.setBlending(material.blend);\n          if (material.blend) {\n            if (material.separateAlphaBlend) {\n              device.setBlendFunctionSeparate(material.blendSrc, material.blendDst, material.blendSrcAlpha, material.blendDstAlpha);\n              device.setBlendEquationSeparate(material.blendEquation, material.blendAlphaEquation);\n            } else {\n              device.setBlendFunction(material.blendSrc, material.blendDst);\n              device.setBlendEquation(material.blendEquation);\n            }\n          }\n          device.setColorWrite(material.redWrite, material.greenWrite, material.blueWrite, material.alphaWrite);\n          device.setDepthWrite(material.depthWrite);\n          if (material.depthWrite && !material.depthTest) {\n            device.setDepthFunc(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.FUNC_ALWAYS);\n            device.setDepthTest(true);\n          } else {\n            device.setDepthFunc(material.depthFunc);\n            device.setDepthTest(material.depthTest);\n          }\n          device.setAlphaToCoverage(material.alphaToCoverage);\n          if (material.depthBias || material.slopeDepthBias) {\n            device.setDepthBias(true);\n            device.setDepthBiasValues(material.depthBias, material.slopeDepthBias);\n          } else {\n            device.setDepthBias(false);\n          }\n        }\n        this.setCullMode(camera._cullFaces, flipFaces, drawCall);\n        const stencilFront = drawCall.stencilFront || material.stencilFront;\n        const stencilBack = drawCall.stencilBack || material.stencilBack;\n        if (stencilFront || stencilBack) {\n          device.setStencilTest(true);\n          if (stencilFront === stencilBack) {\n            device.setStencilFunc(stencilFront.func, stencilFront.ref, stencilFront.readMask);\n            device.setStencilOperation(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);\n          } else {\n            if (stencilFront) {\n              device.setStencilFuncFront(stencilFront.func, stencilFront.ref, stencilFront.readMask);\n              device.setStencilOperationFront(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);\n            } else {\n              device.setStencilFuncFront(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.FUNC_ALWAYS, 0, 0xFF);\n              device.setStencilOperationFront(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.STENCILOP_KEEP, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.STENCILOP_KEEP, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.STENCILOP_KEEP, 0xFF);\n            }\n            if (stencilBack) {\n              device.setStencilFuncBack(stencilBack.func, stencilBack.ref, stencilBack.readMask);\n              device.setStencilOperationBack(stencilBack.fail, stencilBack.zfail, stencilBack.zpass, stencilBack.writeMask);\n            } else {\n              device.setStencilFuncBack(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.FUNC_ALWAYS, 0, 0xFF);\n              device.setStencilOperationBack(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.STENCILOP_KEEP, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.STENCILOP_KEEP, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.STENCILOP_KEEP, 0xFF);\n            }\n          }\n        } else {\n          device.setStencilTest(false);\n        }\n        const mesh = drawCall.mesh;\n        drawCall.setParameters(device, passFlag);\n        this.setVertexBuffers(device, mesh);\n        this.setMorphing(device, drawCall.morphInstance);\n        this.setSkinning(device, drawCall);\n        this.setupMeshUniformBuffers(drawCall, pass);\n        const style = drawCall.renderStyle;\n        device.setIndexBuffer(mesh.indexBuffer[style]);\n        if (drawCallback) {\n          drawCallback(drawCall, i);\n        }\n        if (camera.xr && camera.xr.session && camera.xr.views.length) {\n          const views = camera.xr.views;\n          for (let v = 0; v < views.length; v++) {\n            const view = views[v];\n            device.setViewport(view.viewport.x, view.viewport.y, view.viewport.z, view.viewport.w);\n            this.projId.setValue(view.projMat.data);\n            this.projSkyboxId.setValue(view.projMat.data);\n            this.viewId.setValue(view.viewOffMat.data);\n            this.viewInvId.setValue(view.viewInvOffMat.data);\n            this.viewId3.setValue(view.viewMat3.data);\n            this.viewProjId.setValue(view.projViewOffMat.data);\n            this.viewPosId.setValue(view.position);\n            if (v === 0) {\n              this.drawInstance(device, drawCall, mesh, style, true);\n            } else {\n              this.drawInstance2(device, drawCall, mesh, style);\n            }\n            this._forwardDrawCalls++;\n          }\n        } else {\n          this.drawInstance(device, drawCall, mesh, style, true);\n          this._forwardDrawCalls++;\n        }\n        if (i < preparedCallsCount - 1 && !preparedCalls.isNewMaterial[i + 1]) {\n          material.setParameters(device, drawCall.parameters);\n        }\n      }\n    }\n  }\n  renderForward(camera, allDrawCalls, allDrawCallsCount, sortedLights, pass, cullingMask, drawCallback, layer, flipFaces) {\n    const preparedCalls = this.renderForwardPrepareMaterials(camera, allDrawCalls, allDrawCallsCount, sortedLights, cullingMask, layer, pass);\n    this.renderForwardInternal(camera, preparedCalls, sortedLights, pass, drawCallback, flipFaces);\n    _drawCallList.length = 0;\n  }\n  setSceneConstants() {\n    const scene = this.scene;\n    this.dispatchGlobalLights(scene);\n    if (scene.fog !== _constants_js__WEBPACK_IMPORTED_MODULE_3__.FOG_NONE) {\n      this.fogColor[0] = scene.fogColor.r;\n      this.fogColor[1] = scene.fogColor.g;\n      this.fogColor[2] = scene.fogColor.b;\n      if (scene.gammaCorrection) {\n        for (let i = 0; i < 3; i++) {\n          this.fogColor[i] = Math.pow(this.fogColor[i], 2.2);\n        }\n      }\n      this.fogColorId.setValue(this.fogColor);\n      if (scene.fog === _constants_js__WEBPACK_IMPORTED_MODULE_3__.FOG_LINEAR) {\n        this.fogStartId.setValue(scene.fogStart);\n        this.fogEndId.setValue(scene.fogEnd);\n      } else {\n        this.fogDensityId.setValue(scene.fogDensity);\n      }\n    }\n    const device = this.device;\n    this._screenSize[0] = device.width;\n    this._screenSize[1] = device.height;\n    this._screenSize[2] = 1 / device.width;\n    this._screenSize[3] = 1 / device.height;\n    this.screenSizeId.setValue(this._screenSize);\n  }\n  updateLightStats(comp, compUpdatedFlags) {}\n  buildFrameGraph(frameGraph, layerComposition) {\n    frameGraph.reset();\n    this.update(layerComposition);\n    const clusteredLightingEnabled = this.scene.clusteredLightingEnabled;\n    if (clusteredLightingEnabled) {\n      const _renderPass = new _platform_graphics_render_pass_js__WEBPACK_IMPORTED_MODULE_6__.RenderPass(this.device, () => {\n        if (this.scene.lighting.cookiesEnabled) {\n          this.renderCookies(layerComposition._splitLights[_constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_SPOT]);\n          this.renderCookies(layerComposition._splitLights[_constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_OMNI]);\n        }\n      });\n      _renderPass.requiresCubemaps = false;\n      frameGraph.addRenderPass(_renderPass);\n    }\n    const renderPass = new _platform_graphics_render_pass_js__WEBPACK_IMPORTED_MODULE_6__.RenderPass(this.device, () => {\n      if (!clusteredLightingEnabled || clusteredLightingEnabled && this.scene.lighting.shadowsEnabled) {\n        this.renderShadowsLocal(layerComposition._splitLights[_constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_SPOT]);\n        this.renderShadowsLocal(layerComposition._splitLights[_constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_OMNI]);\n      }\n      if (clusteredLightingEnabled) {\n        this.updateClusters(layerComposition);\n      }\n    });\n    renderPass.requiresCubemaps = false;\n    frameGraph.addRenderPass(renderPass);\n    let startIndex = 0;\n    let newStart = true;\n    let renderTarget = null;\n    const renderActions = layerComposition._renderActions;\n    for (let i = startIndex; i < renderActions.length; i++) {\n      const renderAction = renderActions[i];\n      const layer = layerComposition.layerList[renderAction.layerIndex];\n      const camera = layer.cameras[renderAction.cameraIndex];\n      if (!renderAction.isLayerEnabled(layerComposition)) {\n        continue;\n      }\n      const isDepthLayer = layer.id === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LAYERID_DEPTH;\n      const isGrabPass = isDepthLayer && (camera.renderSceneColorMap || camera.renderSceneDepthMap);\n      if (renderAction.hasDirectionalShadowLights && camera) {\n        this._shadowRendererDirectional.buildFrameGraph(frameGraph, renderAction, camera);\n      }\n      if (newStart) {\n        newStart = false;\n        startIndex = i;\n        renderTarget = renderAction.renderTarget;\n      }\n      let nextIndex = i + 1;\n      while (renderActions[nextIndex] && !renderActions[nextIndex].isLayerEnabled(layerComposition)) {\n        nextIndex++;\n      }\n      const nextRenderAction = renderActions[nextIndex];\n      const isNextLayerDepth = nextRenderAction ? layerComposition.layerList[nextRenderAction.layerIndex].id === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LAYERID_DEPTH : false;\n      const isNextLayerGrabPass = isNextLayerDepth && (camera.renderSceneColorMap || camera.renderSceneDepthMap);\n      if (!nextRenderAction || nextRenderAction.renderTarget !== renderTarget || nextRenderAction.hasDirectionalShadowLights || isNextLayerGrabPass || isGrabPass) {\n        this.addMainRenderPass(frameGraph, layerComposition, renderTarget, startIndex, i, isGrabPass);\n        if (renderAction.triggerPostprocess && camera != null && camera.onPostprocessing) {\n          const _renderPass2 = new _platform_graphics_render_pass_js__WEBPACK_IMPORTED_MODULE_6__.RenderPass(this.device, () => {\n            this.renderPassPostprocessing(renderAction, layerComposition);\n          });\n          _renderPass2.requiresCubemaps = false;\n          frameGraph.addRenderPass(_renderPass2);\n        }\n        newStart = true;\n      }\n    }\n  }\n  addMainRenderPass(frameGraph, layerComposition, renderTarget, startIndex, endIndex, isGrabPass) {\n    const range = {\n      start: startIndex,\n      end: endIndex\n    };\n    const renderPass = new _platform_graphics_render_pass_js__WEBPACK_IMPORTED_MODULE_6__.RenderPass(this.device, () => {\n      this.renderPassRenderActions(layerComposition, range);\n    });\n    const renderActions = layerComposition._renderActions;\n    const startRenderAction = renderActions[startIndex];\n    const startLayer = layerComposition.layerList[startRenderAction.layerIndex];\n    const camera = startLayer.cameras[startRenderAction.cameraIndex];\n    const grabPassRequired = isGrabPass && _graphics_scene_grab_js__WEBPACK_IMPORTED_MODULE_7__.SceneGrab.requiresRenderPass(this.device, camera);\n    const isRealPass = !isGrabPass || grabPassRequired;\n    if (isRealPass) {\n      renderPass.init(renderTarget);\n      renderPass.fullSizeClearRect = camera.camera.fullSizeClearRect;\n      if (grabPassRequired) {\n        renderPass.setClearColor(webgl1DepthClearColor);\n        renderPass.setClearDepth(1.0);\n      } else if (renderPass.fullSizeClearRect) {\n        if (startRenderAction.clearColor) {\n          renderPass.setClearColor(camera.camera.clearColor);\n        }\n        if (startRenderAction.clearDepth) {\n          renderPass.setClearDepth(camera.camera.clearDepth);\n        }\n        if (startRenderAction.clearStencil) {\n          renderPass.setClearStencil(camera.camera.clearStencil);\n        }\n      }\n    }\n    frameGraph.addRenderPass(renderPass);\n  }\n  update(comp) {\n    this.frameUpdate();\n    this.shadowRenderer.frameUpdate();\n    const clusteredLightingEnabled = this.scene.clusteredLightingEnabled;\n    this.scene._updateSky(this.device);\n    const updated = this.updateLayerComposition(comp, clusteredLightingEnabled);\n    const lightsChanged = (updated & _constants_js__WEBPACK_IMPORTED_MODULE_3__.COMPUPDATED_LIGHTS) !== 0;\n    this.updateLightStats(comp, updated);\n    this.beginFrame(comp, lightsChanged);\n    this.setSceneConstants();\n    this.cullComposition(comp);\n    this.gpuUpdate(comp._meshInstances);\n  }\n  renderPassPostprocessing(renderAction, layerComposition) {\n    const layer = layerComposition.layerList[renderAction.layerIndex];\n    const camera = layer.cameras[renderAction.cameraIndex];\n    camera.onPostprocessing();\n  }\n  renderPassRenderActions(comp, range) {\n    const renderActions = comp._renderActions;\n    for (let i = range.start; i <= range.end; i++) {\n      this.renderRenderAction(comp, renderActions[i], i === range.start);\n    }\n  }\n  renderRenderAction(comp, renderAction, firstRenderAction) {\n    const clusteredLightingEnabled = this.scene.clusteredLightingEnabled;\n    const device = this.device;\n    const layerIndex = renderAction.layerIndex;\n    const layer = comp.layerList[layerIndex];\n    const transparent = comp.subLayerList[layerIndex];\n    const cameraPass = renderAction.cameraIndex;\n    const camera = layer.cameras[cameraPass];\n    if (!renderAction.isLayerEnabled(comp)) {\n      return;\n    }\n    if (camera) {\n      if (renderAction.firstCameraUse && camera.onPreRender) {\n        camera.onPreRender();\n      }\n    }\n    if (!transparent && layer.onPreRenderOpaque) {\n      layer.onPreRenderOpaque(cameraPass);\n    } else if (transparent && layer.onPreRenderTransparent) {\n      layer.onPreRenderTransparent(cameraPass);\n    }\n    if (!(layer._preRenderCalledForCameras & 1 << cameraPass)) {\n      if (layer.onPreRender) {\n        layer.onPreRender(cameraPass);\n      }\n      layer._preRenderCalledForCameras |= 1 << cameraPass;\n    }\n    if (camera) {\n      var _renderAction$renderT;\n      this.setupViewport(camera.camera, renderAction.renderTarget);\n      if (!firstRenderAction || !camera.camera.fullSizeClearRect) {\n        this.clear(renderAction, camera.camera);\n      }\n      layer._sortVisible(transparent, camera.camera.node, cameraPass);\n      const objects = layer.instances;\n      const visible = transparent ? objects.visibleTransparent[cameraPass] : objects.visibleOpaque[cameraPass];\n      this.scene.immediate.onPreRenderLayer(layer, visible, transparent);\n      if (clusteredLightingEnabled && renderAction.lightClusters) {\n        renderAction.lightClusters.activate(this.lightTextureAtlas);\n        if (!this.clustersDebugRendered && this.scene.lighting.debugLayer === layer.id) {\n          this.clustersDebugRendered = true;\n        }\n      }\n      this.scene._activeCamera = camera.camera;\n      const viewCount = this.setCameraUniforms(camera.camera, renderAction.renderTarget);\n      if (device.supportsUniformBuffers) {\n        this.setupViewUniformBuffers(renderAction.viewBindGroups, this.viewUniformFormat, this.viewBindGroupFormat, viewCount);\n      }\n      const flipFaces = !!(camera.camera._flipFaces ^ (renderAction == null ? void 0 : (_renderAction$renderT = renderAction.renderTarget) == null ? void 0 : _renderAction$renderT.flipY));\n      const draws = this._forwardDrawCalls;\n      this.renderForward(camera.camera, visible.list, visible.length, layer._splitLights, layer.shaderPass, layer.cullingMask, layer.onDrawCall, layer, flipFaces);\n      layer._forwardDrawCalls += this._forwardDrawCalls - draws;\n      device.setColorWrite(true, true, true, true);\n      device.setStencilTest(false);\n      device.setAlphaToCoverage(false);\n      device.setDepthBias(false);\n      if (renderAction.lastCameraUse && camera.onPostRender) {\n        camera.onPostRender();\n      }\n    }\n    if (!transparent && layer.onPostRenderOpaque) {\n      layer.onPostRenderOpaque(cameraPass);\n    } else if (transparent && layer.onPostRenderTransparent) {\n      layer.onPostRenderTransparent(cameraPass);\n    }\n    if (layer.onPostRender && !(layer._postRenderCalledForCameras & 1 << cameraPass)) {\n      layer._postRenderCounter &= ~(transparent ? 2 : 1);\n      if (layer._postRenderCounter === 0) {\n        layer.onPostRender(cameraPass);\n        layer._postRenderCalledForCameras |= 1 << cameraPass;\n        layer._postRenderCounter = layer._postRenderCounterMax;\n      }\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/forward-renderer.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/light-camera.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/light-camera.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LightCamera\": () => (/* binding */ LightCamera)\n/* harmony export */ });\n/* harmony import */ var _core_math_quat_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/math/quat.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/quat.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/math/mat4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _camera_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../camera.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/camera.js\");\n/* harmony import */ var _graph_node_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../graph-node.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/graph-node.js\");\n\n\n\n\n\n\n\nconst _viewMat = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\nconst _viewProjMat = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\nconst _viewportMatrix = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\nclass LightCamera {\n  static create(name, lightType, face) {\n    const camera = new _camera_js__WEBPACK_IMPORTED_MODULE_1__.Camera();\n    camera.node = new _graph_node_js__WEBPACK_IMPORTED_MODULE_2__.GraphNode(name);\n    camera.aspectRatio = 1;\n    camera.aspectRatioMode = _constants_js__WEBPACK_IMPORTED_MODULE_3__.ASPECT_MANUAL;\n    camera._scissorRectClear = true;\n    switch (lightType) {\n      case _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_OMNI:\n        camera.node.setRotation(LightCamera.pointLightRotations[face]);\n        camera.fov = 90;\n        camera.projection = _constants_js__WEBPACK_IMPORTED_MODULE_3__.PROJECTION_PERSPECTIVE;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_SPOT:\n        camera.projection = _constants_js__WEBPACK_IMPORTED_MODULE_3__.PROJECTION_PERSPECTIVE;\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_DIRECTIONAL:\n        camera.projection = _constants_js__WEBPACK_IMPORTED_MODULE_3__.PROJECTION_ORTHOGRAPHIC;\n        break;\n    }\n    return camera;\n  }\n  static evalSpotCookieMatrix(light) {\n    let cookieCamera = LightCamera._spotCookieCamera;\n    if (!cookieCamera) {\n      cookieCamera = LightCamera.create('SpotCookieCamera', _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_SPOT);\n      LightCamera._spotCookieCamera = cookieCamera;\n    }\n    cookieCamera.fov = light._outerConeAngle * 2;\n    const cookieNode = cookieCamera._node;\n    cookieNode.setPosition(light._node.getPosition());\n    cookieNode.setRotation(light._node.getRotation());\n    cookieNode.rotateLocal(-90, 0, 0);\n    _viewMat.setTRS(cookieNode.getPosition(), cookieNode.getRotation(), _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_4__.Vec3.ONE).invert();\n    _viewProjMat.mul2(cookieCamera.projectionMatrix, _viewMat);\n    const cookieMatrix = light.cookieMatrix;\n    const rectViewport = light.atlasViewport;\n    _viewportMatrix.setViewport(rectViewport.x, rectViewport.y, rectViewport.z, rectViewport.w);\n    cookieMatrix.mul2(_viewportMatrix, _viewProjMat);\n    return cookieMatrix;\n  }\n}\nLightCamera.pointLightRotations = [new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_5__.Quat().setFromEulerAngles(0, 90, 180), new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_5__.Quat().setFromEulerAngles(0, -90, 180), new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_5__.Quat().setFromEulerAngles(90, 0, 0), new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_5__.Quat().setFromEulerAngles(-90, 0, 0), new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_5__.Quat().setFromEulerAngles(0, 180, 180), new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_5__.Quat().setFromEulerAngles(0, 0, 180)];\nLightCamera._spotCookieCamera = null;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/light-camera.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/renderer.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/renderer.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Renderer\": () => (/* binding */ Renderer)\n/* harmony export */ });\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_math_mat3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/math/mat3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat3.js\");\n/* harmony import */ var _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/math/mat4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js\");\n/* harmony import */ var _core_shape_bounding_sphere_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/shape/bounding-sphere.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/shape/bounding-sphere.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _lighting_light_texture_atlas_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lighting/light-texture-atlas.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/lighting/light-texture-atlas.js\");\n/* harmony import */ var _materials_material_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../materials/material.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/material.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_uniform_buffer_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../platform/graphics/uniform-buffer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/uniform-buffer.js\");\n/* harmony import */ var _platform_graphics_bind_group_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../platform/graphics/bind-group.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/bind-group.js\");\n/* harmony import */ var _platform_graphics_uniform_buffer_format_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../platform/graphics/uniform-buffer-format.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/uniform-buffer-format.js\");\n/* harmony import */ var _platform_graphics_bind_group_format_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../platform/graphics/bind-group-format.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/bind-group-format.js\");\n/* harmony import */ var _shadow_map_cache_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shadow-map-cache.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/shadow-map-cache.js\");\n/* harmony import */ var _shadow_renderer_local_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./shadow-renderer-local.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/shadow-renderer-local.js\");\n/* harmony import */ var _shadow_renderer_directional_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./shadow-renderer-directional.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/shadow-renderer-directional.js\");\n/* harmony import */ var _cookie_renderer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./cookie-renderer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/cookie-renderer.js\");\n/* harmony import */ var _static_meshes_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./static-meshes.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/static-meshes.js\");\n/* harmony import */ var _shadow_renderer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./shadow-renderer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/shadow-renderer.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlet _skinUpdateIndex = 0;\nconst boneTextureSize = [0, 0, 0, 0];\nconst viewProjMat = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\nconst viewInvMat = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\nconst viewMat = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\nconst worldMatX = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst worldMatY = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst worldMatZ = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst viewMat3 = new _core_math_mat3_js__WEBPACK_IMPORTED_MODULE_2__.Mat3();\nconst tempSphere = new _core_shape_bounding_sphere_js__WEBPACK_IMPORTED_MODULE_3__.BoundingSphere();\nconst _flipYMat = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4().setScale(1, -1, 1);\nconst _fixProjRangeMat = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4().set([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 1]);\nconst _tempProjMat0 = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\nconst _tempProjMat1 = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\nconst _tempProjMat2 = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\nconst _tempProjMat3 = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\nconst _tempSet = new Set();\nclass Renderer {\n  constructor(graphicsDevice) {\n    this.clustersDebugRendered = false;\n    this.device = graphicsDevice;\n    this.scene = null;\n    this.lightTextureAtlas = new _lighting_light_texture_atlas_js__WEBPACK_IMPORTED_MODULE_4__.LightTextureAtlas(graphicsDevice);\n    this.shadowMapCache = new _shadow_map_cache_js__WEBPACK_IMPORTED_MODULE_5__.ShadowMapCache();\n    this.shadowRenderer = new _shadow_renderer_js__WEBPACK_IMPORTED_MODULE_6__.ShadowRenderer(this, this.lightTextureAtlas);\n    this._shadowRendererLocal = new _shadow_renderer_local_js__WEBPACK_IMPORTED_MODULE_7__.ShadowRendererLocal(this, this.shadowRenderer);\n    this._shadowRendererDirectional = new _shadow_renderer_directional_js__WEBPACK_IMPORTED_MODULE_8__.ShadowRendererDirectional(this, this.shadowRenderer);\n    this._cookieRenderer = new _cookie_renderer_js__WEBPACK_IMPORTED_MODULE_9__.CookieRenderer(graphicsDevice, this.lightTextureAtlas);\n    this.viewUniformFormat = null;\n    this.viewBindGroupFormat = null;\n    this._skinTime = 0;\n    this._morphTime = 0;\n    this._cullTime = 0;\n    this._shadowMapTime = 0;\n    this._lightClustersTime = 0;\n    this._layerCompositionUpdateTime = 0;\n    this._shadowDrawCalls = 0;\n    this._skinDrawCalls = 0;\n    this._instancedDrawCalls = 0;\n    this._shadowMapUpdates = 0;\n    this._numDrawCallsCulled = 0;\n    this._camerasRendered = 0;\n    this._lightClusters = 0;\n    const scope = graphicsDevice.scope;\n    this.boneTextureId = scope.resolve('texture_poseMap');\n    this.boneTextureSizeId = scope.resolve('texture_poseMapSize');\n    this.poseMatrixId = scope.resolve('matrix_pose[0]');\n    this.modelMatrixId = scope.resolve('matrix_model');\n    this.normalMatrixId = scope.resolve('matrix_normal');\n    this.viewInvId = scope.resolve('matrix_viewInverse');\n    this.viewPos = new Float32Array(3);\n    this.viewPosId = scope.resolve('view_position');\n    this.projId = scope.resolve('matrix_projection');\n    this.projSkyboxId = scope.resolve('matrix_projectionSkybox');\n    this.viewId = scope.resolve('matrix_view');\n    this.viewId3 = scope.resolve('matrix_view3');\n    this.viewProjId = scope.resolve('matrix_viewProjection');\n    this.flipYId = scope.resolve('projectionFlipY');\n    this.tbnBasis = scope.resolve('tbnBasis');\n    this.nearClipId = scope.resolve('camera_near');\n    this.farClipId = scope.resolve('camera_far');\n    this.cameraParams = new Float32Array(4);\n    this.cameraParamsId = scope.resolve('camera_params');\n    this.alphaTestId = scope.resolve('alpha_ref');\n    this.opacityMapId = scope.resolve('texture_opacityMap');\n    this.exposureId = scope.resolve('exposure');\n    this.twoSidedLightingNegScaleFactorId = scope.resolve('twoSidedLightingNegScaleFactor');\n    this.morphWeightsA = scope.resolve('morph_weights_a');\n    this.morphWeightsB = scope.resolve('morph_weights_b');\n    this.morphPositionTex = scope.resolve('morphPositionTex');\n    this.morphNormalTex = scope.resolve('morphNormalTex');\n    this.morphTexParams = scope.resolve('morph_tex_params');\n  }\n  destroy() {\n    this.shadowRenderer = null;\n    this._shadowRendererLocal = null;\n    this._shadowRendererDirectional = null;\n    this.shadowMapCache.destroy();\n    this.shadowMapCache = null;\n    this._cookieRenderer.destroy();\n    this._cookieRenderer = null;\n    this.lightTextureAtlas.destroy();\n    this.lightTextureAtlas = null;\n  }\n  sortCompare(drawCallA, drawCallB) {\n    if (drawCallA.layer === drawCallB.layer) {\n      if (drawCallA.drawOrder && drawCallB.drawOrder) {\n        return drawCallA.drawOrder - drawCallB.drawOrder;\n      } else if (drawCallA.zdist && drawCallB.zdist) {\n        return drawCallB.zdist - drawCallA.zdist;\n      } else if (drawCallA.zdist2 && drawCallB.zdist2) {\n        return drawCallA.zdist2 - drawCallB.zdist2;\n      }\n    }\n    return drawCallB._key[_constants_js__WEBPACK_IMPORTED_MODULE_10__.SORTKEY_FORWARD] - drawCallA._key[_constants_js__WEBPACK_IMPORTED_MODULE_10__.SORTKEY_FORWARD];\n  }\n  sortCompareMesh(drawCallA, drawCallB) {\n    if (drawCallA.layer === drawCallB.layer) {\n      if (drawCallA.drawOrder && drawCallB.drawOrder) {\n        return drawCallA.drawOrder - drawCallB.drawOrder;\n      } else if (drawCallA.zdist && drawCallB.zdist) {\n        return drawCallB.zdist - drawCallA.zdist;\n      }\n    }\n    const keyA = drawCallA._key[_constants_js__WEBPACK_IMPORTED_MODULE_10__.SORTKEY_FORWARD];\n    const keyB = drawCallB._key[_constants_js__WEBPACK_IMPORTED_MODULE_10__.SORTKEY_FORWARD];\n    if (keyA === keyB && drawCallA.mesh && drawCallB.mesh) {\n      return drawCallB.mesh.id - drawCallA.mesh.id;\n    }\n    return keyB - keyA;\n  }\n  sortCompareDepth(drawCallA, drawCallB) {\n    const keyA = drawCallA._key[_constants_js__WEBPACK_IMPORTED_MODULE_10__.SORTKEY_DEPTH];\n    const keyB = drawCallB._key[_constants_js__WEBPACK_IMPORTED_MODULE_10__.SORTKEY_DEPTH];\n    if (keyA === keyB && drawCallA.mesh && drawCallB.mesh) {\n      return drawCallB.mesh.id - drawCallA.mesh.id;\n    }\n    return keyB - keyA;\n  }\n  setupViewport(camera, renderTarget) {\n    const device = this.device;\n    const pixelWidth = renderTarget ? renderTarget.width : device.width;\n    const pixelHeight = renderTarget ? renderTarget.height : device.height;\n    const rect = camera.rect;\n    let x = Math.floor(rect.x * pixelWidth);\n    let y = Math.floor(rect.y * pixelHeight);\n    let w = Math.floor(rect.z * pixelWidth);\n    let h = Math.floor(rect.w * pixelHeight);\n    device.setViewport(x, y, w, h);\n    if (camera._scissorRectClear) {\n      const scissorRect = camera.scissorRect;\n      x = Math.floor(scissorRect.x * pixelWidth);\n      y = Math.floor(scissorRect.y * pixelHeight);\n      w = Math.floor(scissorRect.z * pixelWidth);\n      h = Math.floor(scissorRect.w * pixelHeight);\n    }\n    device.setScissor(x, y, w, h);\n  }\n  clear(renderAction, camera) {\n    const flags = (renderAction.clearColor ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.CLEARFLAG_COLOR : 0) | (renderAction.clearDepth ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.CLEARFLAG_DEPTH : 0) | (renderAction.clearStencil ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.CLEARFLAG_STENCIL : 0);\n    if (flags) {\n      const device = this.device;\n      device.clear({\n        color: [camera._clearColor.r, camera._clearColor.g, camera._clearColor.b, camera._clearColor.a],\n        depth: camera._clearDepth,\n        stencil: camera._clearStencil,\n        flags: flags\n      });\n    }\n  }\n  setCameraUniforms(camera, target) {\n    const flipY = target == null ? void 0 : target.flipY;\n    let viewCount = 1;\n    if (camera.xr && camera.xr.session) {\n      let transform;\n      const parent = camera._node.parent;\n      if (parent) transform = parent.getWorldTransform();\n      const views = camera.xr.views;\n      viewCount = views.length;\n      for (let v = 0; v < viewCount; v++) {\n        const view = views[v];\n        if (parent) {\n          view.viewInvOffMat.mul2(transform, view.viewInvMat);\n          view.viewOffMat.copy(view.viewInvOffMat).invert();\n        } else {\n          view.viewInvOffMat.copy(view.viewInvMat);\n          view.viewOffMat.copy(view.viewMat);\n        }\n        view.viewMat3.setFromMat4(view.viewOffMat);\n        view.projViewOffMat.mul2(view.projMat, view.viewOffMat);\n        view.position[0] = view.viewInvOffMat.data[12];\n        view.position[1] = view.viewInvOffMat.data[13];\n        view.position[2] = view.viewInvOffMat.data[14];\n        camera.frustum.setFromMat4(view.projViewOffMat);\n      }\n    } else {\n      let projMat = camera.projectionMatrix;\n      if (camera.calculateProjection) {\n        camera.calculateProjection(projMat, _constants_js__WEBPACK_IMPORTED_MODULE_10__.VIEW_CENTER);\n      }\n      let projMatSkybox = camera.getProjectionMatrixSkybox();\n      if (flipY) {\n        projMat = _tempProjMat0.mul2(_flipYMat, projMat);\n        projMatSkybox = _tempProjMat1.mul2(_flipYMat, projMatSkybox);\n      }\n      if (this.device.deviceType === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.DEVICETYPE_WEBGPU) {\n        projMat = _tempProjMat2.mul2(_fixProjRangeMat, projMat);\n        projMatSkybox = _tempProjMat3.mul2(_fixProjRangeMat, projMatSkybox);\n      }\n      this.projId.setValue(projMat.data);\n      this.projSkyboxId.setValue(projMatSkybox.data);\n      if (camera.calculateTransform) {\n        camera.calculateTransform(viewInvMat, _constants_js__WEBPACK_IMPORTED_MODULE_10__.VIEW_CENTER);\n      } else {\n        const pos = camera._node.getPosition();\n        const rot = camera._node.getRotation();\n        viewInvMat.setTRS(pos, rot, _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3.ONE);\n      }\n      this.viewInvId.setValue(viewInvMat.data);\n      viewMat.copy(viewInvMat).invert();\n      this.viewId.setValue(viewMat.data);\n      viewMat3.setFromMat4(viewMat);\n      this.viewId3.setValue(viewMat3.data);\n      viewProjMat.mul2(projMat, viewMat);\n      this.viewProjId.setValue(viewProjMat.data);\n      this.flipYId.setValue(flipY ? -1 : 1);\n      this.dispatchViewPos(camera._node.getPosition());\n      camera.frustum.setFromMat4(viewProjMat);\n    }\n    this.tbnBasis.setValue(flipY ? -1 : 1);\n    const n = camera._nearClip;\n    const f = camera._farClip;\n    this.nearClipId.setValue(n);\n    this.farClipId.setValue(f);\n    this.cameraParams[0] = 1 / f;\n    this.cameraParams[1] = f;\n    this.cameraParams[2] = n;\n    this.cameraParams[3] = camera.projection === _constants_js__WEBPACK_IMPORTED_MODULE_10__.PROJECTION_ORTHOGRAPHIC ? 1 : 0;\n    this.cameraParamsId.setValue(this.cameraParams);\n    this.exposureId.setValue(this.scene.physicalUnits ? camera.getExposure() : this.scene.exposure);\n    return viewCount;\n  }\n  setCamera(camera, target, clear, renderAction = null) {\n    this.setCameraUniforms(camera, target);\n    this.clearView(camera, target, clear, false);\n  }\n  clearView(camera, target, clear, forceWrite) {\n    const device = this.device;\n    device.setRenderTarget(target);\n    device.updateBegin();\n    if (forceWrite) {\n      device.setColorWrite(true, true, true, true);\n      device.setDepthWrite(true);\n    }\n    this.setupViewport(camera, target);\n    if (clear) {\n      const options = camera._clearOptions;\n      device.clear(options ? options : {\n        color: [camera._clearColor.r, camera._clearColor.g, camera._clearColor.b, camera._clearColor.a],\n        depth: camera._clearDepth,\n        flags: (camera._clearColorBuffer ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.CLEARFLAG_COLOR : 0) | (camera._clearDepthBuffer ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.CLEARFLAG_DEPTH : 0) | (camera._clearStencilBuffer ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.CLEARFLAG_STENCIL : 0),\n        stencil: camera._clearStencil\n      });\n    }\n  }\n  setCullMode(cullFaces, flip, drawCall) {\n    const material = drawCall.material;\n    let mode = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.CULLFACE_NONE;\n    if (cullFaces) {\n      let flipFaces = 1;\n      if (material.cull > _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.CULLFACE_NONE && material.cull < _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.CULLFACE_FRONTANDBACK) {\n        if (drawCall.flipFaces) flipFaces *= -1;\n        if (flip) flipFaces *= -1;\n        const wt = drawCall.node.worldTransform;\n        wt.getX(worldMatX);\n        wt.getY(worldMatY);\n        wt.getZ(worldMatZ);\n        worldMatX.cross(worldMatX, worldMatY);\n        if (worldMatX.dot(worldMatZ) < 0) {\n          flipFaces *= -1;\n        }\n      }\n      if (flipFaces < 0) {\n        mode = material.cull === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.CULLFACE_FRONT ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.CULLFACE_BACK : _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.CULLFACE_FRONT;\n      } else {\n        mode = material.cull;\n      }\n    }\n    this.device.setCullMode(mode);\n    if (mode === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.CULLFACE_NONE && material.cull === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.CULLFACE_NONE) {\n      const wt2 = drawCall.node.worldTransform;\n      wt2.getX(worldMatX);\n      wt2.getY(worldMatY);\n      wt2.getZ(worldMatZ);\n      worldMatX.cross(worldMatX, worldMatY);\n      this.twoSidedLightingNegScaleFactorId.setValue(worldMatX.dot(worldMatZ) < 0 ? -1.0 : 1.0);\n    }\n  }\n  updateCameraFrustum(camera) {\n    if (camera.xr && camera.xr.views.length) {\n      const view = camera.xr.views[0];\n      viewProjMat.mul2(view.projMat, view.viewOffMat);\n      camera.frustum.setFromMat4(viewProjMat);\n      return;\n    }\n    const projMat = camera.projectionMatrix;\n    if (camera.calculateProjection) {\n      camera.calculateProjection(projMat, _constants_js__WEBPACK_IMPORTED_MODULE_10__.VIEW_CENTER);\n    }\n    if (camera.calculateTransform) {\n      camera.calculateTransform(viewInvMat, _constants_js__WEBPACK_IMPORTED_MODULE_10__.VIEW_CENTER);\n    } else {\n      const pos = camera._node.getPosition();\n      const rot = camera._node.getRotation();\n      viewInvMat.setTRS(pos, rot, _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3.ONE);\n      this.viewInvId.setValue(viewInvMat.data);\n    }\n    viewMat.copy(viewInvMat).invert();\n    viewProjMat.mul2(projMat, viewMat);\n    camera.frustum.setFromMat4(viewProjMat);\n  }\n  setBaseConstants(device, material) {\n    device.setCullMode(material.cull);\n    if (material.opacityMap) {\n      this.opacityMapId.setValue(material.opacityMap);\n      this.alphaTestId.setValue(material.alphaTest);\n    }\n  }\n  updateCpuSkinMatrices(drawCalls) {\n    _skinUpdateIndex++;\n    const drawCallsCount = drawCalls.length;\n    if (drawCallsCount === 0) return;\n    for (let i = 0; i < drawCallsCount; i++) {\n      const si = drawCalls[i].skinInstance;\n      if (si) {\n        si.updateMatrices(drawCalls[i].node, _skinUpdateIndex);\n        si._dirty = true;\n      }\n    }\n  }\n  updateGpuSkinMatrices(drawCalls) {\n    const count = drawCalls.length;\n    for (let i = 0; i < count; i++) {\n      const drawCall = drawCalls[i];\n      if (drawCall.visibleThisFrame) {\n        const skin = drawCall.skinInstance;\n        if (skin && skin._dirty) {\n          skin.updateMatrixPalette(drawCall.node, _skinUpdateIndex);\n          skin._dirty = false;\n        }\n      }\n    }\n  }\n  updateMorphing(drawCalls) {\n    const drawCallsCount = drawCalls.length;\n    for (let i = 0; i < drawCallsCount; i++) {\n      const drawCall = drawCalls[i];\n      const morphInst = drawCall.morphInstance;\n      if (morphInst && morphInst._dirty && drawCall.visibleThisFrame) {\n        morphInst.update();\n      }\n    }\n  }\n  gpuUpdate(drawCalls) {\n    this.updateGpuSkinMatrices(drawCalls);\n    this.updateMorphing(drawCalls);\n  }\n  setVertexBuffers(device, mesh) {\n    device.setVertexBuffer(mesh.vertexBuffer);\n  }\n  setMorphing(device, morphInstance) {\n    if (morphInstance) {\n      if (morphInstance.morph.useTextureMorph) {\n        device.setVertexBuffer(morphInstance.morph.vertexBufferIds);\n        this.morphPositionTex.setValue(morphInstance.texturePositions);\n        this.morphNormalTex.setValue(morphInstance.textureNormals);\n        this.morphTexParams.setValue(morphInstance._textureParams);\n      } else {\n        for (let t = 0; t < morphInstance._activeVertexBuffers.length; t++) {\n          const vb = morphInstance._activeVertexBuffers[t];\n          if (vb) {\n            const semantic = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.SEMANTIC_ATTR + (t + 8);\n            vb.format.elements[0].name = semantic;\n            vb.format.elements[0].scopeId = device.scope.resolve(semantic);\n            vb.format.update();\n            device.setVertexBuffer(vb);\n          }\n        }\n        this.morphWeightsA.setValue(morphInstance._shaderMorphWeightsA);\n        this.morphWeightsB.setValue(morphInstance._shaderMorphWeightsB);\n      }\n    }\n  }\n  setSkinning(device, meshInstance) {\n    if (meshInstance.skinInstance) {\n      this._skinDrawCalls++;\n      if (device.supportsBoneTextures) {\n        const boneTexture = meshInstance.skinInstance.boneTexture;\n        this.boneTextureId.setValue(boneTexture);\n        boneTextureSize[0] = boneTexture.width;\n        boneTextureSize[1] = boneTexture.height;\n        boneTextureSize[2] = 1.0 / boneTexture.width;\n        boneTextureSize[3] = 1.0 / boneTexture.height;\n        this.boneTextureSizeId.setValue(boneTextureSize);\n      } else {\n        this.poseMatrixId.setValue(meshInstance.skinInstance.matrixPalette);\n      }\n    }\n  }\n  dispatchViewPos(position) {\n    const vp = this.viewPos;\n    vp[0] = position.x;\n    vp[1] = position.y;\n    vp[2] = position.z;\n    this.viewPosId.setValue(vp);\n  }\n  initViewBindGroupFormat() {\n    if (this.device.supportsUniformBuffers && !this.viewUniformFormat) {\n      this.viewUniformFormat = new _platform_graphics_uniform_buffer_format_js__WEBPACK_IMPORTED_MODULE_12__.UniformBufferFormat(this.device, [new _platform_graphics_uniform_buffer_format_js__WEBPACK_IMPORTED_MODULE_12__.UniformFormat(\"matrix_viewProjection\", _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.UNIFORMTYPE_MAT4)]);\n      this.viewBindGroupFormat = new _platform_graphics_bind_group_format_js__WEBPACK_IMPORTED_MODULE_13__.BindGroupFormat(this.device, [new _platform_graphics_bind_group_format_js__WEBPACK_IMPORTED_MODULE_13__.BindBufferFormat(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.UNIFORM_BUFFER_DEFAULT_SLOT_NAME, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.SHADERSTAGE_VERTEX | _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.SHADERSTAGE_FRAGMENT)], [new _platform_graphics_bind_group_format_js__WEBPACK_IMPORTED_MODULE_13__.BindTextureFormat('lightsTextureFloat', _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.SHADERSTAGE_FRAGMENT, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.TEXTUREDIMENSION_2D, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.SAMPLETYPE_UNFILTERABLE_FLOAT)]);\n    }\n  }\n  setupViewUniformBuffers(viewBindGroups, viewUniformFormat, viewBindGroupFormat, viewCount) {\n    const device = this.device;\n    while (viewBindGroups.length < viewCount) {\n      const ub = new _platform_graphics_uniform_buffer_js__WEBPACK_IMPORTED_MODULE_14__.UniformBuffer(device, viewUniformFormat);\n      const bg = new _platform_graphics_bind_group_js__WEBPACK_IMPORTED_MODULE_15__.BindGroup(device, viewBindGroupFormat, ub);\n      viewBindGroups.push(bg);\n    }\n    const viewBindGroup = viewBindGroups[0];\n    viewBindGroup.defaultUniformBuffer.update();\n    viewBindGroup.update();\n    device.setBindGroup(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.BINDGROUP_VIEW, viewBindGroup);\n  }\n  setupMeshUniformBuffers(meshInstance, pass) {\n    const device = this.device;\n    if (device.supportsUniformBuffers) {\n      this.modelMatrixId.setValue(meshInstance.node.worldTransform.data);\n      this.normalMatrixId.setValue(meshInstance.node.normalMatrix.data);\n      const meshBindGroup = meshInstance.getBindGroup(device, pass);\n      meshBindGroup.defaultUniformBuffer.update();\n      meshBindGroup.update();\n      device.setBindGroup(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.BINDGROUP_MESH, meshBindGroup);\n    }\n  }\n  drawInstance(device, meshInstance, mesh, style, normal) {\n    const instancingData = meshInstance.instancingData;\n    if (instancingData) {\n      if (instancingData.count > 0) {\n        this._instancedDrawCalls++;\n        device.setVertexBuffer(instancingData.vertexBuffer);\n        device.draw(mesh.primitive[style], instancingData.count);\n      }\n    } else {\n      const modelMatrix = meshInstance.node.worldTransform;\n      this.modelMatrixId.setValue(modelMatrix.data);\n      if (normal) {\n        this.normalMatrixId.setValue(meshInstance.node.normalMatrix.data);\n      }\n      device.draw(mesh.primitive[style]);\n    }\n  }\n  drawInstance2(device, meshInstance, mesh, style) {\n    const instancingData = meshInstance.instancingData;\n    if (instancingData) {\n      if (instancingData.count > 0) {\n        this._instancedDrawCalls++;\n        device.draw(mesh.primitive[style], instancingData.count, true);\n      }\n    } else {\n      device.draw(mesh.primitive[style], undefined, true);\n    }\n  }\n  cull(camera, drawCalls, visibleList) {\n    let visibleLength = 0;\n    const drawCallsCount = drawCalls.length;\n    const cullingMask = camera.cullingMask || 0xFFFFFFFF;\n    if (!camera.frustumCulling) {\n      for (let i = 0; i < drawCallsCount; i++) {\n        const drawCall = drawCalls[i];\n        if (!drawCall.visible && !drawCall.command) continue;\n        if (drawCall.mask && (drawCall.mask & cullingMask) === 0) continue;\n        visibleList[visibleLength] = drawCall;\n        visibleLength++;\n        drawCall.visibleThisFrame = true;\n      }\n      return visibleLength;\n    }\n    for (let i = 0; i < drawCallsCount; i++) {\n      const drawCall = drawCalls[i];\n      if (!drawCall.command) {\n        if (!drawCall.visible) continue;\n        let visible = true;\n        if (drawCall.mask && (drawCall.mask & cullingMask) === 0) continue;\n        if (drawCall.cull) {\n          visible = drawCall._isVisible(camera);\n        }\n        if (visible) {\n          visibleList[visibleLength] = drawCall;\n          visibleLength++;\n          drawCall.visibleThisFrame = true;\n        }\n      } else {\n        visibleList[visibleLength] = drawCall;\n        visibleLength++;\n        drawCall.visibleThisFrame = true;\n      }\n    }\n    return visibleLength;\n  }\n  cullLights(camera, lights) {\n    const clusteredLightingEnabled = this.scene.clusteredLightingEnabled;\n    const physicalUnits = this.scene.physicalUnits;\n    for (let i = 0; i < lights.length; i++) {\n      const light = lights[i];\n      if (light.enabled) {\n        if (light._type !== _constants_js__WEBPACK_IMPORTED_MODULE_10__.LIGHTTYPE_DIRECTIONAL) {\n          light.getBoundingSphere(tempSphere);\n          if (camera.frustum.containsSphere(tempSphere)) {\n            light.visibleThisFrame = true;\n            light.usePhysicalUnits = physicalUnits;\n            const screenSize = camera.getScreenSize(tempSphere);\n            light.maxScreenSize = Math.max(light.maxScreenSize, screenSize);\n          } else {\n            if (!clusteredLightingEnabled) {\n              if (light.castShadows && !light.shadowMap) {\n                light.visibleThisFrame = true;\n              }\n            }\n          }\n        } else {\n          light.usePhysicalUnits = this.scene.physicalUnits;\n        }\n      }\n    }\n  }\n  cullShadowmaps(comp) {\n    const isClustered = this.scene.clusteredLightingEnabled;\n    for (let i = 0; i < comp._lights.length; i++) {\n      const light = comp._lights[i];\n      if (light._type !== _constants_js__WEBPACK_IMPORTED_MODULE_10__.LIGHTTYPE_DIRECTIONAL) {\n        if (isClustered) {\n          if (light.atlasSlotUpdated && light.shadowUpdateMode === _constants_js__WEBPACK_IMPORTED_MODULE_10__.SHADOWUPDATE_NONE) {\n            light.shadowUpdateMode = _constants_js__WEBPACK_IMPORTED_MODULE_10__.SHADOWUPDATE_THISFRAME;\n          }\n        }\n        if (light.visibleThisFrame && light.castShadows && light.shadowUpdateMode !== _constants_js__WEBPACK_IMPORTED_MODULE_10__.SHADOWUPDATE_NONE) {\n          const casters = comp._lightCompositionData[i].shadowCastersList;\n          this._shadowRendererLocal.cull(light, casters);\n        }\n      }\n    }\n    const renderActions = comp._renderActions;\n    for (let i = 0; i < renderActions.length; i++) {\n      const renderAction = renderActions[i];\n      const count = renderAction.directionalLightsIndices.length;\n      for (let j = 0; j < count; j++) {\n        const lightIndex = renderAction.directionalLightsIndices[j];\n        const light = comp._lights[lightIndex];\n        const casters = comp._lightCompositionData[lightIndex].shadowCastersList;\n        this._shadowRendererDirectional.cull(light, casters, renderAction.camera.camera);\n      }\n    }\n  }\n  cullComposition(comp) {\n    const renderActions = comp._renderActions;\n    for (let i = 0; i < renderActions.length; i++) {\n      const renderAction = renderActions[i];\n      const layerIndex = renderAction.layerIndex;\n      const layer = comp.layerList[layerIndex];\n      if (!layer.enabled || !comp.subLayerEnabled[layerIndex]) continue;\n      const transparent = comp.subLayerList[layerIndex];\n      const cameraPass = renderAction.cameraIndex;\n      const camera = layer.cameras[cameraPass];\n      if (camera) {\n        camera.frameUpdate(renderAction.renderTarget);\n        if (renderAction.firstCameraUse) {\n          this.updateCameraFrustum(camera.camera);\n          this._camerasRendered++;\n        }\n        this.cullLights(camera.camera, layer._lights);\n        const objects = layer.instances;\n        const visible = transparent ? objects.visibleTransparent[cameraPass] : objects.visibleOpaque[cameraPass];\n        if (!visible.done) {\n          if (layer.onPreCull) {\n            layer.onPreCull(cameraPass);\n          }\n          const drawCalls = transparent ? layer.transparentMeshInstances : layer.opaqueMeshInstances;\n          visible.length = this.cull(camera.camera, drawCalls, visible.list);\n          visible.done = true;\n          if (layer.onPostCull) {\n            layer.onPostCull(cameraPass);\n          }\n        }\n      }\n    }\n    if (this.scene.clusteredLightingEnabled) {\n      this.updateLightTextureAtlas(comp);\n    }\n    this.cullShadowmaps(comp);\n  }\n  updateShaders(drawCalls, onlyLitShaders) {\n    const count = drawCalls.length;\n    for (let i = 0; i < count; i++) {\n      const mat = drawCalls[i].material;\n      if (mat) {\n        if (!_tempSet.has(mat)) {\n          _tempSet.add(mat);\n          if (mat.getShaderVariant !== _materials_material_js__WEBPACK_IMPORTED_MODULE_16__.Material.prototype.getShaderVariant) {\n            if (onlyLitShaders) {\n              if (!mat.useLighting || mat.emitter && !mat.emitter.lighting) continue;\n            }\n            mat.clearVariants();\n          }\n        }\n      }\n    }\n    _tempSet.clear();\n  }\n  renderCookies(lights) {\n    const cookieRenderTarget = this.lightTextureAtlas.cookieRenderTarget;\n    for (let i = 0; i < lights.length; i++) {\n      const light = lights[i];\n      if (!light.atlasViewportAllocated) continue;\n      if (!light.atlasSlotUpdated) continue;\n      this._cookieRenderer.render(light, cookieRenderTarget);\n    }\n  }\n  beginFrame(comp, lightsChanged) {\n    const meshInstances = comp._meshInstances;\n    const scene = this.scene;\n    if (scene.updateShaders || lightsChanged) {\n      const onlyLitShaders = !scene.updateShaders && lightsChanged;\n      this.updateShaders(meshInstances, onlyLitShaders);\n      scene.updateShaders = false;\n      scene._shaderVersion++;\n    }\n    this.updateCpuSkinMatrices(meshInstances);\n    const miCount = meshInstances.length;\n    for (let i = 0; i < miCount; i++) {\n      meshInstances[i].visibleThisFrame = false;\n    }\n    const lights = comp._lights;\n    const lightCount = lights.length;\n    for (let i = 0; i < lightCount; i++) {\n      lights[i].beginFrame();\n    }\n  }\n  updateLightTextureAtlas(comp) {\n    this.lightTextureAtlas.update(comp._splitLights[_constants_js__WEBPACK_IMPORTED_MODULE_10__.LIGHTTYPE_SPOT], comp._splitLights[_constants_js__WEBPACK_IMPORTED_MODULE_10__.LIGHTTYPE_OMNI], this.scene.lighting);\n  }\n  updateClusters(comp) {\n    const emptyWorldClusters = comp.getEmptyWorldClusters(this.device);\n    const renderActions = comp._renderActions;\n    for (let i = 0; i < renderActions.length; i++) {\n      const renderAction = renderActions[i];\n      const cluster = renderAction.lightClusters;\n      if (cluster && cluster !== emptyWorldClusters) {\n        if (!_tempSet.has(cluster)) {\n          _tempSet.add(cluster);\n          const layer = comp.layerList[renderAction.layerIndex];\n          cluster.update(layer.clusteredLightsSet, this.scene.gammaCorrection, this.scene.lighting);\n        }\n      }\n    }\n    _tempSet.clear();\n  }\n  updateLayerComposition(comp, clusteredLightingEnabled) {\n    const len = comp.layerList.length;\n    for (let i = 0; i < len; i++) {\n      comp.layerList[i]._postRenderCounter = 0;\n    }\n    const scene = this.scene;\n    const shaderVersion = scene._shaderVersion;\n    for (let i = 0; i < len; i++) {\n      const layer = comp.layerList[i];\n      layer._shaderVersion = shaderVersion;\n      layer._preRenderCalledForCameras = 0;\n      layer._postRenderCalledForCameras = 0;\n      const transparent = comp.subLayerList[i];\n      if (transparent) {\n        layer._postRenderCounter |= 2;\n      } else {\n        layer._postRenderCounter |= 1;\n      }\n      layer._postRenderCounterMax = layer._postRenderCounter;\n      for (let j = 0; j < layer.cameras.length; j++) {\n        layer.instances.prepare(j);\n      }\n      if (layer._needsStaticPrepare && layer._staticLightHash && !this.scene.clusteredLightingEnabled) {\n        if (layer._staticPrepareDone) {\n          _static_meshes_js__WEBPACK_IMPORTED_MODULE_17__.StaticMeshes.revert(layer.opaqueMeshInstances);\n          _static_meshes_js__WEBPACK_IMPORTED_MODULE_17__.StaticMeshes.revert(layer.transparentMeshInstances);\n        }\n        _static_meshes_js__WEBPACK_IMPORTED_MODULE_17__.StaticMeshes.prepare(this.device, scene, layer.opaqueMeshInstances, layer._lights);\n        _static_meshes_js__WEBPACK_IMPORTED_MODULE_17__.StaticMeshes.prepare(this.device, scene, layer.transparentMeshInstances, layer._lights);\n        comp._dirty = true;\n        scene.updateShaders = true;\n        layer._needsStaticPrepare = false;\n        layer._staticPrepareDone = true;\n      }\n    }\n    const updated = comp._update(this.device, clusteredLightingEnabled);\n    return updated;\n  }\n  frameUpdate() {\n    this.clustersDebugRendered = false;\n    this.initViewBindGroupFormat();\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/renderer.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/shadow-map-cache.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/shadow-map-cache.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ShadowMapCache\": () => (/* binding */ ShadowMapCache)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _shadow_map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shadow-map.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/shadow-map.js\");\n\n\n\nclass ShadowMapCache {\n  constructor() {\n    this.cache = new Map();\n  }\n  destroy() {\n    this.clear();\n    this.cache = null;\n  }\n  clear() {\n    this.cache.forEach(shadowMaps => {\n      shadowMaps.forEach(shadowMap => {\n        shadowMap.destroy();\n      });\n    });\n    this.cache.clear();\n  }\n  getKey(light) {\n    const isCubeMap = light._type === _constants_js__WEBPACK_IMPORTED_MODULE_0__.LIGHTTYPE_OMNI;\n    const shadowType = light._shadowType;\n    const resolution = light._shadowResolution;\n    return `${isCubeMap}-${shadowType}-${resolution}`;\n  }\n  get(device, light) {\n    const key = this.getKey(light);\n    const shadowMaps = this.cache.get(key);\n    if (shadowMaps && shadowMaps.length) {\n      return shadowMaps.pop();\n    }\n    const shadowMap = _shadow_map_js__WEBPACK_IMPORTED_MODULE_1__.ShadowMap.create(device, light);\n    shadowMap.cached = true;\n    return shadowMap;\n  }\n  add(light, shadowMap) {\n    const key = this.getKey(light);\n    const shadowMaps = this.cache.get(key);\n    if (shadowMaps) {\n      shadowMaps.push(shadowMap);\n    } else {\n      this.cache.set(key, [shadowMap]);\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/shadow-map-cache.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/shadow-map.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/shadow-map.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ShadowMap\": () => (/* binding */ ShadowMap)\n/* harmony export */ });\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_render_target_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../platform/graphics/render-target.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/render-target.js\");\n/* harmony import */ var _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../platform/graphics/texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n\n\n\n\n\nclass ShadowMap {\n  constructor(texture, targets) {\n    this.texture = texture;\n    this.cached = false;\n    this.renderTargets = targets;\n  }\n  destroy() {\n    if (this.texture) {\n      this.texture.destroy();\n      this.texture = null;\n    }\n    const targets = this.renderTargets;\n    for (let i = 0; i < targets.length; i++) {\n      targets[i].destroy();\n    }\n    this.renderTargets.length = 0;\n  }\n  static getShadowFormat(device, shadowType) {\n    if (shadowType === _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADOW_VSM32) {\n      return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.PIXELFORMAT_RGBA32F;\n    } else if (shadowType === _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADOW_VSM16) {\n      return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.PIXELFORMAT_RGBA16F;\n    } else if (shadowType === _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADOW_PCF5) {\n      return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.PIXELFORMAT_DEPTH;\n    } else if (shadowType === _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADOW_PCF3 && device.supportsDepthShadow) {\n      return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.PIXELFORMAT_DEPTH;\n    }\n    return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.PIXELFORMAT_RGBA8;\n  }\n  static getShadowFiltering(device, shadowType) {\n    if (shadowType === _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADOW_PCF3 && !device.supportsDepthShadow) {\n      return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.FILTER_NEAREST;\n    } else if (shadowType === _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADOW_VSM32) {\n      return device.extTextureFloatLinear ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.FILTER_LINEAR : _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.FILTER_NEAREST;\n    } else if (shadowType === _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADOW_VSM16) {\n      return device.extTextureHalfFloatLinear ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.FILTER_LINEAR : _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.FILTER_NEAREST;\n    }\n    return _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.FILTER_LINEAR;\n  }\n  static create(device, light) {\n    let shadowMap = null;\n    if (light._type === _constants_js__WEBPACK_IMPORTED_MODULE_0__.LIGHTTYPE_OMNI) {\n      shadowMap = this.createCubemap(device, light._shadowResolution);\n    } else {\n      shadowMap = this.create2dMap(device, light._shadowResolution, light._shadowType);\n    }\n    return shadowMap;\n  }\n  static createAtlas(device, resolution, shadowType) {\n    const shadowMap = this.create2dMap(device, resolution, shadowType);\n    const targets = shadowMap.renderTargets;\n    const rt = targets[0];\n    for (let i = 0; i < 5; i++) {\n      targets.push(rt);\n    }\n    return shadowMap;\n  }\n  static create2dMap(device, size, shadowType) {\n    const format = this.getShadowFormat(device, shadowType);\n    const filter = this.getShadowFiltering(device, shadowType);\n    const texture = new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_2__.Texture(device, {\n      format: format,\n      width: size,\n      height: size,\n      mipmaps: false,\n      minFilter: filter,\n      magFilter: filter,\n      addressU: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.ADDRESS_CLAMP_TO_EDGE,\n      addressV: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.ADDRESS_CLAMP_TO_EDGE,\n      name: 'ShadowMap2D'\n    });\n    let target = null;\n    if (shadowType === _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADOW_PCF5 || shadowType === _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADOW_PCF3 && device.supportsDepthShadow) {\n      texture.compareOnRead = true;\n      texture.compareFunc = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.FUNC_LESS;\n      target = new _platform_graphics_render_target_js__WEBPACK_IMPORTED_MODULE_3__.RenderTarget({\n        depthBuffer: texture\n      });\n    } else {\n      target = new _platform_graphics_render_target_js__WEBPACK_IMPORTED_MODULE_3__.RenderTarget({\n        colorBuffer: texture,\n        depth: true\n      });\n    }\n    if (device.deviceType === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.DEVICETYPE_WEBGPU) {\n      target.flipY = true;\n    }\n    return new ShadowMap(texture, [target]);\n  }\n  static createCubemap(device, size) {\n    const cubemap = new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_2__.Texture(device, {\n      format: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.PIXELFORMAT_RGBA8,\n      width: size,\n      height: size,\n      cubemap: true,\n      mipmaps: false,\n      minFilter: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.FILTER_NEAREST,\n      magFilter: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.FILTER_NEAREST,\n      addressU: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.ADDRESS_CLAMP_TO_EDGE,\n      addressV: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_1__.ADDRESS_CLAMP_TO_EDGE,\n      name: 'ShadowMapCube'\n    });\n    const targets = [];\n    for (let i = 0; i < 6; i++) {\n      const target = new _platform_graphics_render_target_js__WEBPACK_IMPORTED_MODULE_3__.RenderTarget({\n        colorBuffer: cubemap,\n        face: i,\n        depth: true\n      });\n      targets.push(target);\n    }\n    return new ShadowMap(cubemap, targets);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/shadow-map.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/shadow-renderer-directional.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/shadow-renderer-directional.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ShadowRendererDirectional\": () => (/* binding */ ShadowRendererDirectional)\n/* harmony export */ });\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/math/mat4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js\");\n/* harmony import */ var _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/shape/bounding-box.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/shape/bounding-box.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _platform_graphics_render_pass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../platform/graphics/render-pass.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/render-pass.js\");\n/* harmony import */ var _shadow_map_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shadow-map.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/shadow-map.js\");\n\n\n\n\n\n\n\n\n\nconst visibleSceneAabb = new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_0__.BoundingBox();\nconst center = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\nconst shadowCamView = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_2__.Mat4();\nconst aabbPoints = [new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3(), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3(), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3(), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3(), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3(), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3(), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3(), new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3()];\nconst _depthRange = {\n  min: 0,\n  max: 0\n};\nfunction getDepthRange(cameraViewMatrix, aabbMin, aabbMax) {\n  aabbPoints[0].x = aabbPoints[1].x = aabbPoints[2].x = aabbPoints[3].x = aabbMin.x;\n  aabbPoints[1].y = aabbPoints[3].y = aabbPoints[7].y = aabbPoints[5].y = aabbMin.y;\n  aabbPoints[2].z = aabbPoints[3].z = aabbPoints[6].z = aabbPoints[7].z = aabbMin.z;\n  aabbPoints[4].x = aabbPoints[5].x = aabbPoints[6].x = aabbPoints[7].x = aabbMax.x;\n  aabbPoints[0].y = aabbPoints[2].y = aabbPoints[4].y = aabbPoints[6].y = aabbMax.y;\n  aabbPoints[0].z = aabbPoints[1].z = aabbPoints[4].z = aabbPoints[5].z = aabbMax.z;\n  let minz = 9999999999;\n  let maxz = -9999999999;\n  for (let i = 0; i < 8; ++i) {\n    cameraViewMatrix.transformPoint(aabbPoints[i], aabbPoints[i]);\n    const z = aabbPoints[i].z;\n    if (z < minz) minz = z;\n    if (z > maxz) maxz = z;\n  }\n  _depthRange.min = minz;\n  _depthRange.max = maxz;\n  return _depthRange;\n}\nclass ShadowRendererDirectional {\n  constructor(renderer, shadowRenderer) {\n    this.renderer = renderer;\n    this.shadowRenderer = shadowRenderer;\n    this.device = renderer.device;\n  }\n  cull(light, drawCalls, camera) {\n    light.visibleThisFrame = true;\n    if (!light._shadowMap) {\n      light._shadowMap = _shadow_map_js__WEBPACK_IMPORTED_MODULE_3__.ShadowMap.create(this.device, light);\n    }\n    const nearDist = camera._nearClip;\n    this.generateSplitDistances(light, nearDist, light.shadowDistance);\n    const shadowUpdateOverrides = light.shadowUpdateOverrides;\n    for (let cascade = 0; cascade < light.numCascades; cascade++) {\n      if ((shadowUpdateOverrides == null ? void 0 : shadowUpdateOverrides[cascade]) === _constants_js__WEBPACK_IMPORTED_MODULE_4__.SHADOWUPDATE_NONE) {\n        break;\n      }\n      const lightRenderData = light.getRenderData(camera, cascade);\n      const shadowCam = lightRenderData.shadowCamera;\n      shadowCam.renderTarget = light._shadowMap.renderTargets[0];\n      lightRenderData.shadowViewport.copy(light.cascades[cascade]);\n      lightRenderData.shadowScissor.copy(light.cascades[cascade]);\n      const shadowCamNode = shadowCam._node;\n      const lightNode = light._node;\n      shadowCamNode.setPosition(lightNode.getPosition());\n      shadowCamNode.setRotation(lightNode.getRotation());\n      shadowCamNode.rotateLocal(-90, 0, 0);\n      const frustumNearDist = cascade === 0 ? nearDist : light._shadowCascadeDistances[cascade - 1];\n      const frustumFarDist = light._shadowCascadeDistances[cascade];\n      const frustumPoints = camera.getFrustumCorners(frustumNearDist, frustumFarDist);\n      center.set(0, 0, 0);\n      const cameraWorldMat = camera.node.getWorldTransform();\n      for (let i = 0; i < 8; i++) {\n        cameraWorldMat.transformPoint(frustumPoints[i], frustumPoints[i]);\n        center.add(frustumPoints[i]);\n      }\n      center.mulScalar(1 / 8);\n      let radius = 0;\n      for (let i = 0; i < 8; i++) {\n        const dist = frustumPoints[i].sub(center).length();\n        if (dist > radius) radius = dist;\n      }\n      const right = shadowCamNode.right;\n      const up = shadowCamNode.up;\n      const lightDir = shadowCamNode.forward;\n      const sizeRatio = 0.25 * light._shadowResolution / radius;\n      const x = Math.ceil(center.dot(up) * sizeRatio) / sizeRatio;\n      const y = Math.ceil(center.dot(right) * sizeRatio) / sizeRatio;\n      const scaledUp = up.mulScalar(x);\n      const scaledRight = right.mulScalar(y);\n      const dot = center.dot(lightDir);\n      const scaledDir = lightDir.mulScalar(dot);\n      center.add2(scaledUp, scaledRight).add(scaledDir);\n      shadowCamNode.setPosition(center);\n      shadowCamNode.translateLocal(0, 0, 1000000);\n      shadowCam.nearClip = 0.01;\n      shadowCam.farClip = 2000000;\n      shadowCam.orthoHeight = radius;\n      this.renderer.updateCameraFrustum(shadowCam);\n      this.shadowRenderer.cullShadowCasters(drawCalls, lightRenderData.visibleCasters, shadowCam);\n      let emptyAabb = true;\n      const visibleCasters = lightRenderData.visibleCasters;\n      for (let i = 0; i < visibleCasters.length; i++) {\n        const meshInstance = visibleCasters[i];\n        if (emptyAabb) {\n          emptyAabb = false;\n          visibleSceneAabb.copy(meshInstance.aabb);\n        } else {\n          visibleSceneAabb.add(meshInstance.aabb);\n        }\n      }\n      shadowCamView.copy(shadowCamNode.getWorldTransform()).invert();\n      const depthRange = getDepthRange(shadowCamView, visibleSceneAabb.getMin(), visibleSceneAabb.getMax());\n      shadowCamNode.translateLocal(0, 0, depthRange.max + 0.1);\n      shadowCam.farClip = depthRange.max - depthRange.min + 0.2;\n    }\n  }\n  generateSplitDistances(light, nearDist, farDist) {\n    light._shadowCascadeDistances.fill(farDist);\n    for (let i = 1; i < light.numCascades; i++) {\n      const fraction = i / light.numCascades;\n      const linearDist = nearDist + (farDist - nearDist) * fraction;\n      const logDist = nearDist * (farDist / nearDist) ** fraction;\n      const dist = _core_math_math_js__WEBPACK_IMPORTED_MODULE_5__.math.lerp(linearDist, logDist, light.cascadeDistribution);\n      light._shadowCascadeDistances[i - 1] = dist;\n    }\n  }\n  addLightRenderPasses(frameGraph, light, camera) {\n    const faceCount = light.numShadowFaces;\n    const shadowUpdateOverrides = light.shadowUpdateOverrides;\n    let allCascadesRendering = true;\n    let shadowCamera;\n    for (let face = 0; face < faceCount; face++) {\n      if ((shadowUpdateOverrides == null ? void 0 : shadowUpdateOverrides[face]) === _constants_js__WEBPACK_IMPORTED_MODULE_4__.SHADOWUPDATE_NONE) allCascadesRendering = false;\n      shadowCamera = this.shadowRenderer.prepareFace(light, camera, face);\n    }\n    const renderPass = new _platform_graphics_render_pass_js__WEBPACK_IMPORTED_MODULE_6__.RenderPass(this.device, () => {\n      for (let face = 0; face < faceCount; face++) {\n        if ((shadowUpdateOverrides == null ? void 0 : shadowUpdateOverrides[face]) !== _constants_js__WEBPACK_IMPORTED_MODULE_4__.SHADOWUPDATE_NONE) {\n          this.shadowRenderer.renderFace(light, camera, face, !allCascadesRendering);\n        }\n        if ((shadowUpdateOverrides == null ? void 0 : shadowUpdateOverrides[face]) === _constants_js__WEBPACK_IMPORTED_MODULE_4__.SHADOWUPDATE_THISFRAME) {\n          shadowUpdateOverrides[face] = _constants_js__WEBPACK_IMPORTED_MODULE_4__.SHADOWUPDATE_NONE;\n        }\n      }\n    }, () => {\n      this.shadowRenderer.renderVms(light, camera);\n    });\n    this.shadowRenderer.setupRenderPass(renderPass, shadowCamera, allCascadesRendering);\n    frameGraph.addRenderPass(renderPass);\n  }\n  buildFrameGraph(frameGraph, renderAction, camera) {\n    const lights = renderAction.directionalLights;\n    for (let i = 0; i < lights.length; i++) {\n      const light = lights[i];\n      if (this.shadowRenderer.needsShadowRendering(light)) {\n        this.addLightRenderPasses(frameGraph, light, camera.camera);\n      }\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/shadow-renderer-directional.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/shadow-renderer-local.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/shadow-renderer-local.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ShadowRendererLocal\": () => (/* binding */ ShadowRendererLocal)\n/* harmony export */ });\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _shadow_map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shadow-map.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/shadow-map.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n\n\n\n\nclass ShadowRendererLocal {\n  constructor(renderer, shadowRenderer) {\n    this.renderer = renderer;\n    this.shadowRenderer = shadowRenderer;\n    this.device = renderer.device;\n  }\n  cull(light, drawCalls) {\n    const isClustered = this.renderer.scene.clusteredLightingEnabled;\n    light.visibleThisFrame = true;\n    if (!isClustered) {\n      if (!light._shadowMap) {\n        light._shadowMap = _shadow_map_js__WEBPACK_IMPORTED_MODULE_0__.ShadowMap.create(this.device, light);\n      }\n    }\n    const type = light._type;\n    const faceCount = type === _constants_js__WEBPACK_IMPORTED_MODULE_1__.LIGHTTYPE_SPOT ? 1 : 6;\n    for (let face = 0; face < faceCount; face++) {\n      const lightRenderData = light.getRenderData(null, face);\n      const shadowCam = lightRenderData.shadowCamera;\n      shadowCam.nearClip = light.attenuationEnd / 1000;\n      shadowCam.farClip = light.attenuationEnd;\n      const shadowCamNode = shadowCam._node;\n      const lightNode = light._node;\n      shadowCamNode.setPosition(lightNode.getPosition());\n      if (type === _constants_js__WEBPACK_IMPORTED_MODULE_1__.LIGHTTYPE_SPOT) {\n        shadowCam.fov = light._outerConeAngle * 2;\n        shadowCamNode.setRotation(lightNode.getRotation());\n        shadowCamNode.rotateLocal(-90, 0, 0);\n      } else if (type === _constants_js__WEBPACK_IMPORTED_MODULE_1__.LIGHTTYPE_OMNI) {\n        if (isClustered) {\n          const tileSize = this.shadowRenderer.lightTextureAtlas.shadowAtlasResolution * light.atlasViewport.z / 3;\n          const texelSize = 2 / tileSize;\n          const filterSize = texelSize * this.shadowRenderer.lightTextureAtlas.shadowEdgePixels;\n          shadowCam.fov = Math.atan(1 + filterSize) * _core_math_math_js__WEBPACK_IMPORTED_MODULE_2__.math.RAD_TO_DEG * 2;\n        } else {\n          shadowCam.fov = 90;\n        }\n      }\n      this.renderer.updateCameraFrustum(shadowCam);\n      this.shadowRenderer.cullShadowCasters(drawCalls, lightRenderData.visibleCasters, shadowCam);\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/shadow-renderer-local.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/shadow-renderer.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/shadow-renderer.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ShadowRenderer\": () => (/* binding */ ShadowRenderer)\n/* harmony export */ });\n/* harmony import */ var _core_math_color_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/math/color.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n/* harmony import */ var _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/math/mat4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/math/vec4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec4.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_simple_post_effect_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../platform/graphics/simple-post-effect.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/simple-post-effect.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _shader_pass_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../shader-pass.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-pass.js\");\n/* harmony import */ var _shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shader-lib/chunks/chunks.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/chunks.js\");\n/* harmony import */ var _shader_lib_utils_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../shader-lib/utils.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/utils.js\");\n/* harmony import */ var _light_camera_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./light-camera.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/light-camera.js\");\n/* harmony import */ var _platform_graphics_uniform_buffer_format_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../platform/graphics/uniform-buffer-format.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/uniform-buffer-format.js\");\n/* harmony import */ var _platform_graphics_bind_group_format_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../platform/graphics/bind-group-format.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/bind-group-format.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction gauss(x, sigma) {\n  return Math.exp(-(x * x) / (2.0 * sigma * sigma));\n}\nconst maxBlurSize = 25;\nfunction gaussWeights(kernelSize) {\n  if (kernelSize > maxBlurSize) {\n    kernelSize = maxBlurSize;\n  }\n  const sigma = (kernelSize - 1) / (2 * 3);\n  const halfWidth = (kernelSize - 1) * 0.5;\n  const values = new Array(kernelSize);\n  let sum = 0.0;\n  for (let i = 0; i < kernelSize; ++i) {\n    values[i] = gauss(i - halfWidth, sigma);\n    sum += values[i];\n  }\n  for (let i = 0; i < kernelSize; ++i) {\n    values[i] /= sum;\n  }\n  return values;\n}\nconst shadowCamView = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\nconst shadowCamViewProj = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\nconst pixelOffset = new Float32Array(2);\nconst blurScissorRect = new _core_math_vec4_js__WEBPACK_IMPORTED_MODULE_1__.Vec4(1, 1, 0, 0);\nconst opChanId = {\n  r: 1,\n  g: 2,\n  b: 3,\n  a: 4\n};\nconst viewportMatrix = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\nfunction getDepthKey(meshInstance) {\n  const material = meshInstance.material;\n  const x = meshInstance.skinInstance ? 10 : 0;\n  let y = 0;\n  if (material.opacityMap) {\n    const opChan = material.opacityMapChannel;\n    if (opChan) {\n      y = opChanId[opChan];\n    }\n  }\n  return x + y;\n}\nclass ShadowRenderer {\n  constructor(renderer, lightTextureAtlas) {\n    this.device = renderer.device;\n    this.renderer = renderer;\n    this.lightTextureAtlas = lightTextureAtlas;\n    const scope = this.device.scope;\n    this.polygonOffsetId = scope.resolve('polygonOffset');\n    this.polygonOffset = new Float32Array(2);\n    this.sourceId = scope.resolve('source');\n    this.pixelOffsetId = scope.resolve('pixelOffset');\n    this.weightId = scope.resolve('weight[0]');\n    this.blurVsmShaderCode = [_shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_2__.shaderChunks.blurVSMPS, '#define GAUSS\\n' + _shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_2__.shaderChunks.blurVSMPS];\n    const packed = '#define PACKED\\n';\n    this.blurPackedVsmShaderCode = [packed + this.blurVsmShaderCode[0], packed + this.blurVsmShaderCode[1]];\n    this.blurVsmShader = [{}, {}];\n    this.blurPackedVsmShader = [{}, {}];\n    this.blurVsmWeights = {};\n    this.shadowMapLightRadiusId = scope.resolve('light_radius');\n    this.viewUniformFormat = null;\n    this.viewBindGroupFormat = null;\n  }\n  static createShadowCamera(device, shadowType, type, face) {\n    const shadowCam = _light_camera_js__WEBPACK_IMPORTED_MODULE_3__.LightCamera.create('ShadowCamera', type, face);\n    if (shadowType >= _constants_js__WEBPACK_IMPORTED_MODULE_4__.SHADOW_VSM8 && shadowType <= _constants_js__WEBPACK_IMPORTED_MODULE_4__.SHADOW_VSM32) {\n      shadowCam.clearColor = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_5__.Color(0, 0, 0, 0);\n    } else {\n      shadowCam.clearColor = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_5__.Color(1, 1, 1, 1);\n    }\n    shadowCam.clearDepthBuffer = true;\n    shadowCam.clearStencilBuffer = false;\n    return shadowCam;\n  }\n  static setShadowCameraSettings(shadowCam, device, shadowType, type, isClustered) {\n    let hwPcf = shadowType === _constants_js__WEBPACK_IMPORTED_MODULE_4__.SHADOW_PCF5 || shadowType === _constants_js__WEBPACK_IMPORTED_MODULE_4__.SHADOW_PCF3 && device.supportsDepthShadow;\n    if (type === _constants_js__WEBPACK_IMPORTED_MODULE_4__.LIGHTTYPE_OMNI && !isClustered) {\n      hwPcf = false;\n    }\n    shadowCam.clearColorBuffer = !hwPcf;\n  }\n  cullShadowCasters(meshInstances, visible, camera) {\n    let count = 0;\n    const numInstances = meshInstances.length;\n    for (let i = 0; i < numInstances; i++) {\n      const meshInstance = meshInstances[i];\n      if (!meshInstance.cull || meshInstance._isVisible(camera)) {\n        meshInstance.visibleThisFrame = true;\n        visible[count] = meshInstance;\n        count++;\n      }\n    }\n    visible.length = count;\n    visible.sort(this.renderer.sortCompareDepth);\n  }\n  setupRenderState(device, light) {\n    const isClustered = this.renderer.scene.clusteredLightingEnabled;\n    if (device.webgl2 || device.deviceType === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_6__.DEVICETYPE_WEBGPU) {\n      if (light._type === _constants_js__WEBPACK_IMPORTED_MODULE_4__.LIGHTTYPE_OMNI && !isClustered) {\n        device.setDepthBias(false);\n      } else {\n        device.setDepthBias(true);\n        device.setDepthBiasValues(light.shadowBias * -1000.0, light.shadowBias * -1000.0);\n      }\n    } else if (device.extStandardDerivatives) {\n      if (light._type === _constants_js__WEBPACK_IMPORTED_MODULE_4__.LIGHTTYPE_OMNI) {\n        this.polygonOffset[0] = 0;\n        this.polygonOffset[1] = 0;\n        this.polygonOffsetId.setValue(this.polygonOffset);\n      } else {\n        this.polygonOffset[0] = light.shadowBias * -1000.0;\n        this.polygonOffset[1] = light.shadowBias * -1000.0;\n        this.polygonOffsetId.setValue(this.polygonOffset);\n      }\n    }\n    device.setBlending(false);\n    device.setDepthWrite(true);\n    device.setDepthTest(true);\n    device.setDepthFunc(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_6__.FUNC_LESSEQUAL);\n    const useShadowSampler = isClustered ? light._isPcf && device.webgl2 : light._isPcf && device.webgl2 && light._type !== _constants_js__WEBPACK_IMPORTED_MODULE_4__.LIGHTTYPE_OMNI;\n    if (useShadowSampler) {\n      device.setColorWrite(false, false, false, false);\n    } else {\n      device.setColorWrite(true, true, true, true);\n    }\n  }\n  restoreRenderState(device) {\n    if (device.webgl2) {\n      device.setDepthBias(false);\n    } else if (device.extStandardDerivatives) {\n      this.polygonOffset[0] = 0;\n      this.polygonOffset[1] = 0;\n      this.polygonOffsetId.setValue(this.polygonOffset);\n    }\n  }\n  dispatchUniforms(light, shadowCam, lightRenderData, face) {\n    const shadowCamNode = shadowCam._node;\n    if (light._type !== _constants_js__WEBPACK_IMPORTED_MODULE_4__.LIGHTTYPE_DIRECTIONAL) {\n      this.renderer.dispatchViewPos(shadowCamNode.getPosition());\n      this.shadowMapLightRadiusId.setValue(light.attenuationEnd);\n    }\n    shadowCamView.setTRS(shadowCamNode.getPosition(), shadowCamNode.getRotation(), _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_7__.Vec3.ONE).invert();\n    shadowCamViewProj.mul2(shadowCam.projectionMatrix, shadowCamView);\n    const rectViewport = lightRenderData.shadowViewport;\n    shadowCam.rect = rectViewport;\n    shadowCam.scissorRect = lightRenderData.shadowScissor;\n    viewportMatrix.setViewport(rectViewport.x, rectViewport.y, rectViewport.z, rectViewport.w);\n    lightRenderData.shadowMatrix.mul2(viewportMatrix, shadowCamViewProj);\n    if (light._type === _constants_js__WEBPACK_IMPORTED_MODULE_4__.LIGHTTYPE_DIRECTIONAL) {\n      light._shadowMatrixPalette.set(lightRenderData.shadowMatrix.data, face * 16);\n    }\n  }\n  submitCasters(visibleCasters, light) {\n    const device = this.device;\n    const renderer = this.renderer;\n    const scene = renderer.scene;\n    const passFlags = 1 << _constants_js__WEBPACK_IMPORTED_MODULE_4__.SHADER_SHADOW;\n    const shadowPass = _shader_pass_js__WEBPACK_IMPORTED_MODULE_8__.ShaderPass.getShadow(light._type, light._shadowType);\n    const count = visibleCasters.length;\n    for (let i = 0; i < count; i++) {\n      const meshInstance = visibleCasters[i];\n      const mesh = meshInstance.mesh;\n      meshInstance.ensureMaterial(device);\n      const material = meshInstance.material;\n      renderer.setBaseConstants(device, material);\n      renderer.setSkinning(device, meshInstance);\n      if (material.dirty) {\n        material.updateUniforms(device, scene);\n        material.dirty = false;\n      }\n      if (material.chunks) {\n        renderer.setCullMode(true, false, meshInstance);\n        material.setParameters(device);\n        meshInstance.setParameters(device, passFlags);\n      }\n      let shadowShader = meshInstance._shader[shadowPass];\n      if (!shadowShader) {\n        meshInstance.updatePassShader(scene, shadowPass, null, null, this.viewUniformFormat, this.viewBindGroupFormat);\n        shadowShader = meshInstance._shader[shadowPass];\n        meshInstance._key[_constants_js__WEBPACK_IMPORTED_MODULE_4__.SORTKEY_DEPTH] = getDepthKey(meshInstance);\n      }\n      if (!shadowShader.failed && !device.setShader(shadowShader)) ;\n      renderer.setVertexBuffers(device, mesh);\n      renderer.setMorphing(device, meshInstance.morphInstance);\n      this.renderer.setupMeshUniformBuffers(meshInstance, shadowPass);\n      const style = meshInstance.renderStyle;\n      device.setIndexBuffer(mesh.indexBuffer[style]);\n      renderer.drawInstance(device, meshInstance, mesh, style);\n      renderer._shadowDrawCalls++;\n    }\n  }\n  needsShadowRendering(light) {\n    const needs = light.enabled && light.castShadows && light.shadowUpdateMode !== _constants_js__WEBPACK_IMPORTED_MODULE_4__.SHADOWUPDATE_NONE && light.visibleThisFrame;\n    if (light.shadowUpdateMode === _constants_js__WEBPACK_IMPORTED_MODULE_4__.SHADOWUPDATE_THISFRAME) {\n      light.shadowUpdateMode = _constants_js__WEBPACK_IMPORTED_MODULE_4__.SHADOWUPDATE_NONE;\n    }\n    if (needs) {\n      this.renderer._shadowMapUpdates += light.numShadowFaces;\n    }\n    return needs;\n  }\n  getLightRenderData(light, camera, face) {\n    return light.getRenderData(light._type === _constants_js__WEBPACK_IMPORTED_MODULE_4__.LIGHTTYPE_DIRECTIONAL ? camera : null, face);\n  }\n  setupRenderPass(renderPass, shadowCamera, clearRenderTarget) {\n    const rt = shadowCamera.renderTarget;\n    renderPass.init(rt);\n    if (clearRenderTarget) {\n      const clearColor = shadowCamera.clearColorBuffer;\n      renderPass.colorOps.clear = clearColor;\n      if (clearColor) renderPass.colorOps.clearValue.copy(shadowCamera.clearColor);\n      renderPass.depthStencilOps.storeDepth = !clearColor;\n      renderPass.setClearDepth(1.0);\n    }\n    renderPass.requiresCubemaps = false;\n  }\n  prepareFace(light, camera, face) {\n    const type = light._type;\n    const shadowType = light._shadowType;\n    const isClustered = this.renderer.scene.clusteredLightingEnabled;\n    const lightRenderData = this.getLightRenderData(light, camera, face);\n    const shadowCam = lightRenderData.shadowCamera;\n    ShadowRenderer.setShadowCameraSettings(shadowCam, this.device, shadowType, type, isClustered);\n    const renderTargetIndex = type === _constants_js__WEBPACK_IMPORTED_MODULE_4__.LIGHTTYPE_DIRECTIONAL ? 0 : face;\n    shadowCam.renderTarget = light._shadowMap.renderTargets[renderTargetIndex];\n    return shadowCam;\n  }\n  renderFace(light, camera, face, clear) {\n    const device = this.device;\n    this.setupRenderState(device, light);\n    const lightRenderData = this.getLightRenderData(light, camera, face);\n    const shadowCam = lightRenderData.shadowCamera;\n    this.dispatchUniforms(light, shadowCam, lightRenderData, face);\n    const rt = shadowCam.renderTarget;\n    this.renderer.setCameraUniforms(shadowCam, rt);\n    if (device.supportsUniformBuffers) {\n      this.renderer.setupViewUniformBuffers(lightRenderData.viewBindGroups, this.viewUniformFormat, this.viewBindGroupFormat, 1);\n    }\n    if (clear) {\n      this.renderer.clearView(shadowCam, rt, true, false);\n    } else {\n      this.renderer.setupViewport(shadowCam, rt);\n    }\n    this.submitCasters(lightRenderData.visibleCasters, light);\n    this.restoreRenderState(device);\n  }\n  render(light, camera) {\n    if (this.needsShadowRendering(light)) {\n      const faceCount = light.numShadowFaces;\n      for (let face = 0; face < faceCount; face++) {\n        this.prepareFace(light, camera, face);\n        this.renderFace(light, camera, face, true);\n      }\n      this.renderVms(light, camera);\n    }\n  }\n  renderVms(light, camera) {\n    if (light._isVsm && light._vsmBlurSize > 1) {\n      const isClustered = this.renderer.scene.clusteredLightingEnabled;\n      if (!isClustered || light._type === _constants_js__WEBPACK_IMPORTED_MODULE_4__.LIGHTTYPE_DIRECTIONAL) {\n        this.applyVsmBlur(light, camera);\n      }\n    }\n  }\n  getVsmBlurShader(isVsm8, blurMode, filterSize) {\n    let blurShader = (isVsm8 ? this.blurPackedVsmShader : this.blurVsmShader)[blurMode][filterSize];\n    if (!blurShader) {\n      this.blurVsmWeights[filterSize] = gaussWeights(filterSize);\n      const blurVS = _shader_lib_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_2__.shaderChunks.fullscreenQuadVS;\n      let blurFS = '#define SAMPLES ' + filterSize + '\\n';\n      if (isVsm8) {\n        blurFS += this.blurPackedVsmShaderCode[blurMode];\n      } else {\n        blurFS += this.blurVsmShaderCode[blurMode];\n      }\n      const blurShaderName = 'blurVsm' + blurMode + '' + filterSize + '' + isVsm8;\n      blurShader = (0,_shader_lib_utils_js__WEBPACK_IMPORTED_MODULE_9__.createShaderFromCode)(this.device, blurVS, blurFS, blurShaderName);\n      if (isVsm8) {\n        this.blurPackedVsmShader[blurMode][filterSize] = blurShader;\n      } else {\n        this.blurVsmShader[blurMode][filterSize] = blurShader;\n      }\n    }\n    return blurShader;\n  }\n  applyVsmBlur(light, camera) {\n    const device = this.device;\n    const lightRenderData = light.getRenderData(light._type === _constants_js__WEBPACK_IMPORTED_MODULE_4__.LIGHTTYPE_DIRECTIONAL ? camera : null, 0);\n    const shadowCam = lightRenderData.shadowCamera;\n    const origShadowMap = shadowCam.renderTarget;\n    const tempShadowMap = this.renderer.shadowMapCache.get(device, light);\n    const tempRt = tempShadowMap.renderTargets[0];\n    const isVsm8 = light._shadowType === _constants_js__WEBPACK_IMPORTED_MODULE_4__.SHADOW_VSM8;\n    const blurMode = light.vsmBlurMode;\n    const filterSize = light._vsmBlurSize;\n    const blurShader = this.getVsmBlurShader(isVsm8, blurMode, filterSize);\n    blurScissorRect.z = light._shadowResolution - 2;\n    blurScissorRect.w = blurScissorRect.z;\n    this.sourceId.setValue(origShadowMap.colorBuffer);\n    pixelOffset[0] = 1 / light._shadowResolution;\n    pixelOffset[1] = 0;\n    this.pixelOffsetId.setValue(pixelOffset);\n    if (blurMode === _constants_js__WEBPACK_IMPORTED_MODULE_4__.BLUR_GAUSSIAN) this.weightId.setValue(this.blurVsmWeights[filterSize]);\n    (0,_platform_graphics_simple_post_effect_js__WEBPACK_IMPORTED_MODULE_10__.drawQuadWithShader)(device, tempRt, blurShader, null, blurScissorRect);\n    this.sourceId.setValue(tempRt.colorBuffer);\n    pixelOffset[1] = pixelOffset[0];\n    pixelOffset[0] = 0;\n    this.pixelOffsetId.setValue(pixelOffset);\n    (0,_platform_graphics_simple_post_effect_js__WEBPACK_IMPORTED_MODULE_10__.drawQuadWithShader)(device, origShadowMap, blurShader, null, blurScissorRect);\n    this.renderer.shadowMapCache.add(light, tempShadowMap);\n  }\n  initViewBindGroupFormat() {\n    if (this.device.supportsUniformBuffers && !this.viewUniformFormat) {\n      this.viewUniformFormat = new _platform_graphics_uniform_buffer_format_js__WEBPACK_IMPORTED_MODULE_11__.UniformBufferFormat(this.device, [new _platform_graphics_uniform_buffer_format_js__WEBPACK_IMPORTED_MODULE_11__.UniformFormat(\"matrix_viewProjection\", _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_6__.UNIFORMTYPE_MAT4)]);\n      this.viewBindGroupFormat = new _platform_graphics_bind_group_format_js__WEBPACK_IMPORTED_MODULE_12__.BindGroupFormat(this.device, [new _platform_graphics_bind_group_format_js__WEBPACK_IMPORTED_MODULE_12__.BindBufferFormat(_platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_6__.UNIFORM_BUFFER_DEFAULT_SLOT_NAME, _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_6__.SHADERSTAGE_VERTEX | _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_6__.SHADERSTAGE_FRAGMENT)], []);\n    }\n  }\n  frameUpdate() {\n    this.initViewBindGroupFormat();\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/shadow-renderer.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/static-meshes.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/static-meshes.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"StaticMeshes\": () => (/* binding */ StaticMeshes)\n/* harmony export */ });\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/math/mat4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js\");\n/* harmony import */ var _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/shape/bounding-box.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/shape/bounding-box.js\");\n/* harmony import */ var _core_shape_bounding_sphere_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/shape/bounding-sphere.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/shape/bounding-sphere.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_index_buffer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../platform/graphics/index-buffer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/index-buffer.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _mesh_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../mesh.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh.js\");\n/* harmony import */ var _mesh_instance_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../mesh-instance.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh-instance.js\");\n\n\n\n\n\n\n\n\n\n\n\nconst tempSphere = new _core_shape_bounding_sphere_js__WEBPACK_IMPORTED_MODULE_0__.BoundingSphere();\nclass StaticMeshes {\n  static lightCompare(lightA, lightB) {\n    return lightA.key - lightB.key;\n  }\n  static prepare(device, scene, meshInstances, lights) {\n    const drawCalls = meshInstances;\n    const drawCallsCount = drawCalls.length;\n    const newDrawCalls = [];\n    const minVec = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n    const maxVec = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_1__.Vec3();\n    const localLightBounds = new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_2__.BoundingBox();\n    const invMatrix = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_3__.Mat4();\n    const triLightComb = [];\n    const lightAabb = [];\n    const triBounds = [];\n    const staticLights = [];\n    for (let i = 0; i < drawCallsCount; i++) {\n      const drawCall = drawCalls[i];\n      if (!drawCall.isStatic) {\n        newDrawCalls.push(drawCall);\n      } else {\n        const aabb = drawCall.aabb;\n        staticLights.length = 0;\n        for (let lightTypePass = _constants_js__WEBPACK_IMPORTED_MODULE_4__.LIGHTTYPE_OMNI; lightTypePass <= _constants_js__WEBPACK_IMPORTED_MODULE_4__.LIGHTTYPE_SPOT; lightTypePass++) {\n          for (let j = 0; j < lights.length; j++) {\n            const light = lights[j];\n            if (light._type !== lightTypePass) continue;\n            if (light.enabled) {\n              if (light.mask & drawCall.mask) {\n                if (light.isStatic) {\n                  if (!lightAabb[j]) {\n                    lightAabb[j] = new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_2__.BoundingBox();\n                    light._node.getWorldTransform();\n                    light.getBoundingSphere(tempSphere);\n                    lightAabb[j].center.copy(tempSphere.center);\n                    lightAabb[j].halfExtents.set(tempSphere.radius, tempSphere.radius, tempSphere.radius);\n                  }\n                  if (!lightAabb[j].intersects(aabb)) continue;\n                  staticLights.push(j);\n                }\n              }\n            }\n          }\n        }\n        if (staticLights.length === 0) {\n          newDrawCalls.push(drawCall);\n          continue;\n        }\n        const mesh = drawCall.mesh;\n        const vertexBuffer = mesh.vertexBuffer;\n        const indexBuffer = mesh.indexBuffer[drawCall.renderStyle];\n        const indices = indexBuffer.bytesPerIndex === 2 ? new Uint16Array(indexBuffer.lock()) : new Uint32Array(indexBuffer.lock());\n        const numTris = mesh.primitive[drawCall.renderStyle].count / 3;\n        const baseIndex = mesh.primitive[drawCall.renderStyle].base;\n        const elems = vertexBuffer.format.elements;\n        const vertSize = vertexBuffer.format.size / 4;\n        const verts = new Float32Array(vertexBuffer.storage);\n        let offsetP;\n        for (let k = 0; k < elems.length; k++) {\n          if (elems[k].name === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.SEMANTIC_POSITION) {\n            offsetP = elems[k].offset / 4;\n          }\n        }\n        triLightComb.length = numTris;\n        for (let k = 0; k < numTris; k++) {\n          triLightComb[k] = 0;\n        }\n        let triLightCombUsed = false;\n        triBounds.length = numTris * 6;\n        for (let k = 0; k < numTris; k++) {\n          let minx = Number.MAX_VALUE;\n          let miny = Number.MAX_VALUE;\n          let minz = Number.MAX_VALUE;\n          let maxx = -Number.MAX_VALUE;\n          let maxy = -Number.MAX_VALUE;\n          let maxz = -Number.MAX_VALUE;\n          for (let v = 0; v < 3; v++) {\n            let _index = indices[k * 3 + v + baseIndex];\n            _index = _index * vertSize + offsetP;\n            const _x = verts[_index];\n            const _y = verts[_index + 1];\n            const _z = verts[_index + 2];\n            if (_x < minx) minx = _x;\n            if (_y < miny) miny = _y;\n            if (_z < minz) minz = _z;\n            if (_x > maxx) maxx = _x;\n            if (_y > maxy) maxy = _y;\n            if (_z > maxz) maxz = _z;\n          }\n          const index = k * 6;\n          triBounds[index] = minx;\n          triBounds[index + 1] = miny;\n          triBounds[index + 2] = minz;\n          triBounds[index + 3] = maxx;\n          triBounds[index + 4] = maxy;\n          triBounds[index + 5] = maxz;\n        }\n        for (let s = 0; s < staticLights.length; s++) {\n          const j = staticLights[s];\n          invMatrix.copy(drawCall.node.worldTransform).invert();\n          localLightBounds.setFromTransformedAabb(lightAabb[j], invMatrix);\n          const minv = localLightBounds.getMin();\n          const maxv = localLightBounds.getMax();\n          const bit = 1 << s;\n          for (let k = 0; k < numTris; k++) {\n            const index = k * 6;\n            if (triBounds[index] <= maxv.x && triBounds[index + 3] >= minv.x && triBounds[index + 1] <= maxv.y && triBounds[index + 4] >= minv.y && triBounds[index + 2] <= maxv.z && triBounds[index + 5] >= minv.z) {\n              triLightComb[k] |= bit;\n              triLightCombUsed = true;\n            }\n          }\n        }\n        if (triLightCombUsed) {\n          const combIndices = {};\n          for (let k = 0; k < numTris; k++) {\n            const j = k * 3 + baseIndex;\n            const combIbName = triLightComb[k];\n            if (!combIndices[combIbName]) combIndices[combIbName] = [];\n            const combIb = combIndices[combIbName];\n            combIb.push(indices[j]);\n            combIb.push(indices[j + 1]);\n            combIb.push(indices[j + 2]);\n          }\n          for (const combIbName in combIndices) {\n            const combIb = combIndices[combIbName];\n            const ib = new _platform_graphics_index_buffer_js__WEBPACK_IMPORTED_MODULE_6__.IndexBuffer(device, indexBuffer.format, combIb.length, indexBuffer.usage);\n            const ib2 = ib.bytesPerIndex === 2 ? new Uint16Array(ib.lock()) : new Uint32Array(ib.lock());\n            ib2.set(combIb);\n            ib.unlock();\n            let minx = Number.MAX_VALUE;\n            let miny = Number.MAX_VALUE;\n            let minz = Number.MAX_VALUE;\n            let maxx = -Number.MAX_VALUE;\n            let maxy = -Number.MAX_VALUE;\n            let maxz = -Number.MAX_VALUE;\n            for (let k = 0; k < combIb.length; k++) {\n              const index = combIb[k];\n              const _x = verts[index * vertSize + offsetP];\n              const _y = verts[index * vertSize + offsetP + 1];\n              const _z = verts[index * vertSize + offsetP + 2];\n              if (_x < minx) minx = _x;\n              if (_y < miny) miny = _y;\n              if (_z < minz) minz = _z;\n              if (_x > maxx) maxx = _x;\n              if (_y > maxy) maxy = _y;\n              if (_z > maxz) maxz = _z;\n            }\n            minVec.set(minx, miny, minz);\n            maxVec.set(maxx, maxy, maxz);\n            const chunkAabb = new _core_shape_bounding_box_js__WEBPACK_IMPORTED_MODULE_2__.BoundingBox();\n            chunkAabb.setMinMax(minVec, maxVec);\n            const mesh2 = new _mesh_js__WEBPACK_IMPORTED_MODULE_7__.Mesh(device);\n            mesh2.vertexBuffer = vertexBuffer;\n            mesh2.indexBuffer[0] = ib;\n            mesh2.primitive[0].type = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.PRIMITIVE_TRIANGLES;\n            mesh2.primitive[0].base = 0;\n            mesh2.primitive[0].count = combIb.length;\n            mesh2.primitive[0].indexed = true;\n            mesh2.aabb = chunkAabb;\n            const instance = new _mesh_instance_js__WEBPACK_IMPORTED_MODULE_8__.MeshInstance(mesh2, drawCall.material, drawCall.node);\n            instance.isStatic = drawCall.isStatic;\n            instance.visible = drawCall.visible;\n            instance.layer = drawCall.layer;\n            instance.castShadow = drawCall.castShadow;\n            instance._receiveShadow = drawCall._receiveShadow;\n            instance.cull = drawCall.cull;\n            instance.pick = drawCall.pick;\n            instance.mask = drawCall.mask;\n            instance.parameters = drawCall.parameters;\n            instance._shaderDefs = drawCall._shaderDefs;\n            instance._staticSource = drawCall;\n            if (drawCall._staticLightList) {\n              instance._staticLightList = drawCall._staticLightList;\n            } else {\n              instance._staticLightList = [];\n            }\n            for (let k = 0; k < staticLights.length; k++) {\n              const bit = 1 << k;\n              if (combIbName & bit) {\n                const lht = lights[staticLights[k]];\n                if (instance._staticLightList.indexOf(lht) < 0) {\n                  instance._staticLightList.push(lht);\n                }\n              }\n            }\n            instance._staticLightList.sort(StaticMeshes.lightCompare);\n            newDrawCalls.push(instance);\n          }\n        } else {\n          newDrawCalls.push(drawCall);\n        }\n      }\n    }\n    meshInstances.length = newDrawCalls.length;\n    for (let i = 0; i < newDrawCalls.length; i++) {\n      meshInstances[i] = newDrawCalls[i];\n    }\n  }\n  static revert(meshInstances) {\n    const drawCalls = meshInstances;\n    const drawCallsCount = drawCalls.length;\n    const newDrawCalls = [];\n    let prevStaticSource;\n    for (let i = 0; i < drawCallsCount; i++) {\n      const drawCall = drawCalls[i];\n      if (drawCall._staticSource) {\n        if (drawCall._staticSource !== prevStaticSource) {\n          newDrawCalls.push(drawCall._staticSource);\n          prevStaticSource = drawCall._staticSource;\n        }\n      } else {\n        newDrawCalls.push(drawCall);\n      }\n    }\n    meshInstances.length = newDrawCalls.length;\n    for (let i = 0; i < newDrawCalls.length; i++) {\n      meshInstances[i] = newDrawCalls[i];\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/renderer/static-meshes.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/scene.js":
/*!*********************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/scene.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Scene\": () => (/* binding */ Scene)\n/* harmony export */ });\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _core_math_color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/math/color.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n/* harmony import */ var _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/math/vec3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec3.js\");\n/* harmony import */ var _core_math_quat_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/math/quat.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/quat.js\");\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _core_math_mat3_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/math/mat3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat3.js\");\n/* harmony import */ var _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/math/mat4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js\");\n/* harmony import */ var _platform_graphics_graphics_device_access_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../platform/graphics/graphics-device-access.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/graphics-device-access.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _sky_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./sky.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/sky.js\");\n/* harmony import */ var _lighting_lighting_params_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lighting/lighting-params.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/lighting/lighting-params.js\");\n/* harmony import */ var _immediate_immediate_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./immediate/immediate.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/immediate/immediate.js\");\n/* harmony import */ var _graphics_env_lighting_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./graphics/env-lighting.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/graphics/env-lighting.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Scene extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor(graphicsDevice) {\n    super();\n    this.ambientBake = false;\n    this.ambientBakeOcclusionBrightness = 0;\n    this.ambientBakeOcclusionContrast = 0;\n    this.ambientLight = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_1__.Color(0, 0, 0);\n    this.ambientLuminance = 0;\n    this.exposure = 1;\n    this.fogColor = new _core_math_color_js__WEBPACK_IMPORTED_MODULE_1__.Color(0, 0, 0);\n    this.fogDensity = 0;\n    this.fogEnd = 1000;\n    this.fogStart = 1;\n    this.lightmapSizeMultiplier = 1;\n    this.lightmapMaxResolution = 2048;\n    this.lightmapMode = _constants_js__WEBPACK_IMPORTED_MODULE_2__.BAKE_COLORDIR;\n    this.lightmapFilterEnabled = false;\n    this.lightmapHDR = false;\n    this.root = null;\n    this.sky = null;\n    this.physicalUnits = false;\n    this.device = graphicsDevice || _platform_graphics_graphics_device_access_js__WEBPACK_IMPORTED_MODULE_3__.GraphicsDeviceAccess.get();\n    this._gravity = new _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_4__.Vec3(0, -9.8, 0);\n    this._layers = null;\n    this._fog = _constants_js__WEBPACK_IMPORTED_MODULE_2__.FOG_NONE;\n    this._gammaCorrection = _constants_js__WEBPACK_IMPORTED_MODULE_2__.GAMMA_SRGB;\n    this._toneMapping = 0;\n    this._skyboxCubeMap = null;\n    this._prefilteredCubemaps = [null, null, null, null, null, null];\n    this._envAtlas = null;\n    this._internalEnvAtlas = null;\n    this._skyboxIntensity = 1;\n    this._skyboxLuminance = 0;\n    this._skyboxMip = 0;\n    this._skyboxRotation = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_5__.Quat();\n    this._skyboxRotationMat3 = new _core_math_mat3_js__WEBPACK_IMPORTED_MODULE_6__.Mat3();\n    this._skyboxRotationMat4 = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_7__.Mat4();\n    this._ambientBakeNumSamples = 1;\n    this._ambientBakeSpherePart = 0.4;\n    this._lightmapFilterRange = 10;\n    this._lightmapFilterSmoothness = 0.2;\n    this._clusteredLightingEnabled = true;\n    this._lightingParams = new _lighting_lighting_params_js__WEBPACK_IMPORTED_MODULE_8__.LightingParams(this.device.supportsAreaLights, this.device.maxTextureSize, () => {\n      this._layers._dirtyLights = true;\n    });\n    this._stats = {\n      meshInstances: 0,\n      lights: 0,\n      dynamicLights: 0,\n      bakedLights: 0,\n      lastStaticPrepareFullTime: 0,\n      lastStaticPrepareSearchTime: 0,\n      lastStaticPrepareWriteTime: 0,\n      lastStaticPrepareTriAabbTime: 0,\n      lastStaticPrepareCombineTime: 0,\n      updateShadersTime: 0\n    };\n    this.updateShaders = true;\n    this._shaderVersion = 0;\n    this._statsUpdated = false;\n    this.immediate = new _immediate_immediate_js__WEBPACK_IMPORTED_MODULE_9__.Immediate(this.device);\n  }\n  get defaultDrawLayer() {\n    return this.layers.getLayerById(_constants_js__WEBPACK_IMPORTED_MODULE_2__.LAYERID_IMMEDIATE);\n  }\n  set ambientBakeNumSamples(value) {\n    this._ambientBakeNumSamples = _core_math_math_js__WEBPACK_IMPORTED_MODULE_10__.math.clamp(Math.floor(value), 1, 255);\n  }\n  get ambientBakeNumSamples() {\n    return this._ambientBakeNumSamples;\n  }\n  set ambientBakeSpherePart(value) {\n    this._ambientBakeSpherePart = _core_math_math_js__WEBPACK_IMPORTED_MODULE_10__.math.clamp(value, 0.001, 1);\n  }\n  get ambientBakeSpherePart() {\n    return this._ambientBakeSpherePart;\n  }\n  set clusteredLightingEnabled(value) {\n    if (!this._clusteredLightingEnabled && value) {\n      console.error('Turning on disabled clustered lighting is not currently supported');\n      return;\n    }\n    this._clusteredLightingEnabled = value;\n  }\n  get clusteredLightingEnabled() {\n    return this._clusteredLightingEnabled;\n  }\n  set drawCalls(value) {}\n  get drawCalls() {\n    let drawCalls = this.layers._meshInstances;\n    if (!drawCalls.length) {\n      this.layers._update(this.device, this.clusteredLightingEnabled);\n      drawCalls = this.layers._meshInstances;\n    }\n    return drawCalls;\n  }\n  set envAtlas(value) {\n    if (value !== this._envAtlas) {\n      this._envAtlas = value;\n      if (value) {\n        value.addressU = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.ADDRESS_REPEAT;\n        value.addressV = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.ADDRESS_CLAMP_TO_EDGE;\n        value.minFilter = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.FILTER_LINEAR;\n        value.magFilter = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.FILTER_LINEAR;\n        value.mipmaps = false;\n      }\n      this.updateShaders = true;\n    }\n  }\n  get envAtlas() {\n    return this._envAtlas;\n  }\n  set fog(type) {\n    if (type !== this._fog) {\n      this._fog = type;\n      this.updateShaders = true;\n    }\n  }\n  get fog() {\n    return this._fog;\n  }\n  set gammaCorrection(value) {\n    if (value !== this._gammaCorrection) {\n      this._gammaCorrection = value;\n      this.updateShaders = true;\n    }\n  }\n  get gammaCorrection() {\n    return this._gammaCorrection;\n  }\n  set layers(layers) {\n    const prev = this._layers;\n    this._layers = layers;\n    this.fire('set:layers', prev, layers);\n  }\n  get layers() {\n    return this._layers;\n  }\n  get lighting() {\n    return this._lightingParams;\n  }\n  set lightmapFilterRange(value) {\n    this._lightmapFilterRange = Math.max(value, 0.001);\n  }\n  get lightmapFilterRange() {\n    return this._lightmapFilterRange;\n  }\n  set lightmapFilterSmoothness(value) {\n    this._lightmapFilterSmoothness = Math.max(value, 0.001);\n  }\n  get lightmapFilterSmoothness() {\n    return this._lightmapFilterSmoothness;\n  }\n  set prefilteredCubemaps(value) {\n    const cubemaps = this._prefilteredCubemaps;\n    value = value || [];\n    let changed = false;\n    let complete = true;\n    for (let i = 0; i < 6; ++i) {\n      const v = value[i] || null;\n      if (cubemaps[i] !== v) {\n        cubemaps[i] = v;\n        changed = true;\n      }\n      complete = complete && !!cubemaps[i];\n    }\n    if (changed) {\n      this._resetSky();\n      if (complete) {\n        this._internalEnvAtlas = _graphics_env_lighting_js__WEBPACK_IMPORTED_MODULE_12__.EnvLighting.generatePrefilteredAtlas(cubemaps, {\n          target: this._internalEnvAtlas\n        });\n        if (!this._envAtlas) {\n          this.envAtlas = this._internalEnvAtlas;\n        }\n      } else if (this._internalEnvAtlas) {\n        if (this._envAtlas === this._internalEnvAtlas) {\n          this.envAtlas = null;\n        }\n        this._internalEnvAtlas.destroy();\n        this._internalEnvAtlas = null;\n      }\n    }\n  }\n  get prefilteredCubemaps() {\n    return this._prefilteredCubemaps;\n  }\n  set skybox(value) {\n    if (value !== this._skyboxCubeMap) {\n      this._skyboxCubeMap = value;\n      this._resetSky();\n    }\n  }\n  get skybox() {\n    return this._skyboxCubeMap;\n  }\n  set skyboxIntensity(value) {\n    if (value !== this._skyboxIntensity) {\n      this._skyboxIntensity = value;\n      this._resetSky();\n    }\n  }\n  get skyboxIntensity() {\n    return this._skyboxIntensity;\n  }\n  set skyboxLuminance(value) {\n    if (value !== this._skyboxLuminance) {\n      this._skyboxLuminance = value;\n      this._resetSky();\n    }\n  }\n  get skyboxLuminance() {\n    return this._skyboxLuminance;\n  }\n  set skyboxMip(value) {\n    if (value !== this._skyboxMip) {\n      this._skyboxMip = value;\n      this._resetSky();\n    }\n  }\n  get skyboxMip() {\n    return this._skyboxMip;\n  }\n  set skyboxRotation(value) {\n    if (!this._skyboxRotation.equals(value)) {\n      this._skyboxRotation.copy(value);\n      if (value.equals(_core_math_quat_js__WEBPACK_IMPORTED_MODULE_5__.Quat.IDENTITY)) {\n        this._skyboxRotationMat3.setIdentity();\n      } else {\n        this._skyboxRotationMat4.setTRS(_core_math_vec3_js__WEBPACK_IMPORTED_MODULE_4__.Vec3.ZERO, value, _core_math_vec3_js__WEBPACK_IMPORTED_MODULE_4__.Vec3.ONE);\n        this._skyboxRotationMat4.invertTo3x3(this._skyboxRotationMat3);\n      }\n      this._resetSky();\n    }\n  }\n  get skyboxRotation() {\n    return this._skyboxRotation;\n  }\n  set toneMapping(value) {\n    if (value !== this._toneMapping) {\n      this._toneMapping = value;\n      this.updateShaders = true;\n    }\n  }\n  get toneMapping() {\n    return this._toneMapping;\n  }\n  destroy() {\n    this._resetSky();\n    this.root = null;\n    this.off();\n  }\n  drawLine(start, end, color = _core_math_color_js__WEBPACK_IMPORTED_MODULE_1__.Color.WHITE, depthTest = true, layer = this.defaultDrawLayer) {\n    const batch = this.immediate.getBatch(layer, depthTest);\n    batch.addLines([start, end], [color, color]);\n  }\n  drawLines(positions, colors, depthTest = true, layer = this.defaultDrawLayer) {\n    const batch = this.immediate.getBatch(layer, depthTest);\n    batch.addLines(positions, colors);\n  }\n  drawLineArrays(positions, colors, depthTest = true, layer = this.defaultDrawLayer) {\n    const batch = this.immediate.getBatch(layer, depthTest);\n    batch.addLinesArrays(positions, colors);\n  }\n  applySettings(settings) {\n    const physics = settings.physics;\n    const render = settings.render;\n    this._gravity.set(physics.gravity[0], physics.gravity[1], physics.gravity[2]);\n    this.ambientLight.set(render.global_ambient[0], render.global_ambient[1], render.global_ambient[2]);\n    this.ambientLuminance = render.ambientLuminance;\n    this._fog = render.fog;\n    this.fogColor.set(render.fog_color[0], render.fog_color[1], render.fog_color[2]);\n    this.fogStart = render.fog_start;\n    this.fogEnd = render.fog_end;\n    this.fogDensity = render.fog_density;\n    this._gammaCorrection = render.gamma_correction;\n    this._toneMapping = render.tonemapping;\n    this.lightmapSizeMultiplier = render.lightmapSizeMultiplier;\n    this.lightmapMaxResolution = render.lightmapMaxResolution;\n    this.lightmapMode = render.lightmapMode;\n    this.exposure = render.exposure;\n    this._skyboxIntensity = render.skyboxIntensity === undefined ? 1 : render.skyboxIntensity;\n    this._skyboxLuminance = render.skyboxLuminance === undefined ? 20000 : render.skyboxLuminance;\n    this._skyboxMip = render.skyboxMip === undefined ? 0 : render.skyboxMip;\n    if (render.skyboxRotation) {\n      this.skyboxRotation = new _core_math_quat_js__WEBPACK_IMPORTED_MODULE_5__.Quat().setFromEulerAngles(render.skyboxRotation[0], render.skyboxRotation[1], render.skyboxRotation[2]);\n    }\n    this.clusteredLightingEnabled = render.clusteredLightingEnabled;\n    this.lighting.applySettings(render);\n    ['lightmapFilterEnabled', 'lightmapFilterRange', 'lightmapFilterSmoothness', 'ambientBake', 'ambientBakeNumSamples', 'ambientBakeSpherePart', 'ambientBakeOcclusionBrightness', 'ambientBakeOcclusionContrast'].forEach(setting => {\n      if (render.hasOwnProperty(setting)) {\n        this[setting] = render[setting];\n      }\n    });\n    this._resetSky();\n  }\n  _getSkyboxTex() {\n    const cubemaps = this._prefilteredCubemaps;\n    if (this._skyboxMip) {\n      const skyboxMapping = [0, 1, 3, 4, 5, 6];\n      return cubemaps[skyboxMapping[this._skyboxMip]] || this._envAtlas || cubemaps[0] || this._skyboxCubeMap;\n    }\n    return this._skyboxCubeMap || cubemaps[0] || this._envAtlas;\n  }\n  _updateSky(device) {\n    if (!this.sky) {\n      const texture = this._getSkyboxTex();\n      if (texture) {\n        this.sky = new _sky_js__WEBPACK_IMPORTED_MODULE_13__.Sky(device, this, texture);\n        this.fire('set:skybox', texture);\n      }\n    }\n  }\n  _resetSky() {\n    var _this$sky;\n    (_this$sky = this.sky) == null ? void 0 : _this$sky.destroy();\n    this.sky = null;\n    this.updateShaders = true;\n  }\n  setSkybox(cubemaps) {\n    if (!cubemaps) {\n      this.skybox = null;\n      this.prefilteredCubemaps = [null, null, null, null, null, null];\n    } else {\n      this.skybox = cubemaps[0] || null;\n      this.prefilteredCubemaps = cubemaps.slice(1);\n    }\n  }\n  get lightmapPixelFormat() {\n    return this.lightmapHDR && this.device.getHdrFormat(false, true, false, true) || _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_11__.PIXELFORMAT_RGBA8;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/scene.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunk-builder.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunk-builder.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ChunkBuilder\": () => (/* binding */ ChunkBuilder)\n/* harmony export */ });\nclass ChunkBuilder {\n  constructor() {\n    this.code = '';\n  }\n  append(...chunks) {\n    chunks.forEach(chunk => {\n      if (chunk.endsWith('\\n')) {\n        this.code += chunk;\n      } else {\n        this.code += chunk + '\\n';\n      }\n    });\n  }\n  prepend(...chunks) {\n    chunks.forEach(chunk => {\n      if (chunk.endsWith('\\n')) {\n        this.code = chunk + this.code;\n      } else {\n        this.code = chunk + '\\n' + this.code;\n      }\n    });\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunk-builder.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunk-utils.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunk-utils.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ChunkUtils\": () => (/* binding */ ChunkUtils)\n/* harmony export */ });\nconst decodeTable = {\n  'linear': 'decodeLinear',\n  'srgb': 'decodeGamma',\n  'rgbm': 'decodeRGBM',\n  'rgbe': 'decodeRGBE',\n  'rgbp': 'decodeRGBP'\n};\nconst encodeTable = {\n  'linear': 'encodeLinear',\n  'srgb': 'encodeGamma',\n  'rgbm': 'encodeRGBM',\n  'rgbe': 'encodeRGBE',\n  'rgbp': 'encodeRGBP'\n};\nclass ChunkUtils {\n  static decodeFunc(encoding) {\n    return decodeTable[encoding] || 'decodeGamma';\n  }\n  static encodeFunc(encoding) {\n    return encodeTable[encoding] || 'encodeGamma';\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunk-utils.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/chunks-lightmapper.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/chunks-lightmapper.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"shaderChunksLightmapper\": () => (/* binding */ shaderChunksLightmapper)\n/* harmony export */ });\n/* harmony import */ var _lightmapper_frag_bakeDirLmEnd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lightmapper/frag/bakeDirLmEnd.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lightmapper/frag/bakeDirLmEnd.js\");\n/* harmony import */ var _lightmapper_frag_bakeLmEnd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lightmapper/frag/bakeLmEnd.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lightmapper/frag/bakeLmEnd.js\");\n/* harmony import */ var _lightmapper_frag_dilate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lightmapper/frag/dilate.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lightmapper/frag/dilate.js\");\n/* harmony import */ var _lightmapper_frag_bilateralDeNoise_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lightmapper/frag/bilateralDeNoise.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lightmapper/frag/bilateralDeNoise.js\");\n\n\n\n\n\nconst shaderChunksLightmapper = {\n  bakeDirLmEndPS: _lightmapper_frag_bakeDirLmEnd_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n  bakeLmEndPS: _lightmapper_frag_bakeLmEnd_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  dilatePS: _lightmapper_frag_dilate_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n  bilateralDeNoisePS: _lightmapper_frag_bilateralDeNoise_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]\n};\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/chunks-lightmapper.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/chunks.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/chunks.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"shaderChunks\": () => (/* binding */ shaderChunks)\n/* harmony export */ });\n/* harmony import */ var _standard_frag_alphaTest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./standard/frag/alphaTest.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/alphaTest.js\");\n/* harmony import */ var _lit_frag_ambientConstant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lit/frag/ambientConstant.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/ambientConstant.js\");\n/* harmony import */ var _lit_frag_ambientEnv_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lit/frag/ambientEnv.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/ambientEnv.js\");\n/* harmony import */ var _lit_frag_ambientSH_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lit/frag/ambientSH.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/ambientSH.js\");\n/* harmony import */ var _standard_frag_ao_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./standard/frag/ao.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/ao.js\");\n/* harmony import */ var _lit_frag_aoDiffuseOcc_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lit/frag/aoDiffuseOcc.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/aoDiffuseOcc.js\");\n/* harmony import */ var _lit_frag_aoSpecOcc_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lit/frag/aoSpecOcc.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/aoSpecOcc.js\");\n/* harmony import */ var _lit_frag_aoSpecOccConst_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lit/frag/aoSpecOccConst.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/aoSpecOccConst.js\");\n/* harmony import */ var _lit_frag_aoSpecOccConstSimple_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lit/frag/aoSpecOccConstSimple.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/aoSpecOccConstSimple.js\");\n/* harmony import */ var _lit_frag_aoSpecOccSimple_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lit/frag/aoSpecOccSimple.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/aoSpecOccSimple.js\");\n/* harmony import */ var _lit_frag_base_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lit/frag/base.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/base.js\");\n/* harmony import */ var _lit_vert_base_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lit/vert/base.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/base.js\");\n/* harmony import */ var _lit_frag_baseNineSliced_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./lit/frag/baseNineSliced.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/baseNineSliced.js\");\n/* harmony import */ var _lit_vert_baseNineSliced_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./lit/vert/baseNineSliced.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/baseNineSliced.js\");\n/* harmony import */ var _lit_frag_baseNineSlicedTiled_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./lit/frag/baseNineSlicedTiled.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/baseNineSlicedTiled.js\");\n/* harmony import */ var _lit_frag_biasConst_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./lit/frag/biasConst.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/biasConst.js\");\n/* harmony import */ var _lit_frag_blurVSM_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./lit/frag/blurVSM.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/blurVSM.js\");\n/* harmony import */ var _standard_frag_clearCoat_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./standard/frag/clearCoat.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/clearCoat.js\");\n/* harmony import */ var _standard_frag_clearCoatGloss_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./standard/frag/clearCoatGloss.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/clearCoatGloss.js\");\n/* harmony import */ var _standard_frag_clearCoatNormal_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./standard/frag/clearCoatNormal.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/clearCoatNormal.js\");\n/* harmony import */ var _lit_frag_clusteredLightUtils_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./lit/frag/clusteredLightUtils.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/clusteredLightUtils.js\");\n/* harmony import */ var _lit_frag_clusteredLightCookies_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./lit/frag/clusteredLightCookies.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/clusteredLightCookies.js\");\n/* harmony import */ var _lit_frag_clusteredLightShadows_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./lit/frag/clusteredLightShadows.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/clusteredLightShadows.js\");\n/* harmony import */ var _lit_frag_clusteredLight_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./lit/frag/clusteredLight.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/clusteredLight.js\");\n/* harmony import */ var _lit_frag_combine_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./lit/frag/combine.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/combine.js\");\n/* harmony import */ var _lit_frag_cookie_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./lit/frag/cookie.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/cookie.js\");\n/* harmony import */ var _lit_frag_cubeMapProjectBox_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./lit/frag/cubeMapProjectBox.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/cubeMapProjectBox.js\");\n/* harmony import */ var _lit_frag_cubeMapProjectNone_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./lit/frag/cubeMapProjectNone.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/cubeMapProjectNone.js\");\n/* harmony import */ var _lit_frag_cubeMapRotate_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./lit/frag/cubeMapRotate.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/cubeMapRotate.js\");\n/* harmony import */ var _common_frag_decode_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./common/frag/decode.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/decode.js\");\n/* harmony import */ var _standard_frag_detailModes_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./standard/frag/detailModes.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/detailModes.js\");\n/* harmony import */ var _standard_frag_diffuse_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./standard/frag/diffuse.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/diffuse.js\");\n/* harmony import */ var _standard_frag_diffuseDetailMap_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./standard/frag/diffuseDetailMap.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/diffuseDetailMap.js\");\n/* harmony import */ var _standard_frag_emissive_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./standard/frag/emissive.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/emissive.js\");\n/* harmony import */ var _common_frag_encode_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./common/frag/encode.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/encode.js\");\n/* harmony import */ var _lit_frag_end_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./lit/frag/end.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/end.js\");\n/* harmony import */ var _lit_vert_end_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./lit/vert/end.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/end.js\");\n/* harmony import */ var _common_frag_envAtlas_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./common/frag/envAtlas.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/envAtlas.js\");\n/* harmony import */ var _common_frag_envConst_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./common/frag/envConst.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/envConst.js\");\n/* harmony import */ var _common_frag_envMultiply_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./common/frag/envMultiply.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/envMultiply.js\");\n/* harmony import */ var _lit_frag_extension_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./lit/frag/extension.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/extension.js\");\n/* harmony import */ var _lit_vert_extension_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./lit/vert/extension.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/extension.js\");\n/* harmony import */ var _lit_frag_falloffInvSquared_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./lit/frag/falloffInvSquared.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/falloffInvSquared.js\");\n/* harmony import */ var _lit_frag_falloffLinear_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./lit/frag/falloffLinear.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/falloffLinear.js\");\n/* harmony import */ var _common_frag_fixCubemapSeamsNone_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./common/frag/fixCubemapSeamsNone.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/fixCubemapSeamsNone.js\");\n/* harmony import */ var _common_frag_fixCubemapSeamsStretch_js__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./common/frag/fixCubemapSeamsStretch.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/fixCubemapSeamsStretch.js\");\n/* harmony import */ var _lit_frag_float_unpacking_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./lit/frag/float-unpacking.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/float-unpacking.js\");\n/* harmony import */ var _lit_frag_fogExp_js__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./lit/frag/fogExp.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/fogExp.js\");\n/* harmony import */ var _lit_frag_fogExp2_js__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./lit/frag/fogExp2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/fogExp2.js\");\n/* harmony import */ var _lit_frag_fogLinear_js__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./lit/frag/fogLinear.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/fogLinear.js\");\n/* harmony import */ var _lit_frag_fogNone_js__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./lit/frag/fogNone.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/fogNone.js\");\n/* harmony import */ var _lit_frag_fresnelSchlick_js__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./lit/frag/fresnelSchlick.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/fresnelSchlick.js\");\n/* harmony import */ var _common_frag_fullscreenQuad_js__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./common/frag/fullscreenQuad.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/fullscreenQuad.js\");\n/* harmony import */ var _common_vert_fullscreenQuad_js__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./common/vert/fullscreenQuad.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/fullscreenQuad.js\");\n/* harmony import */ var _common_frag_gamma1_0_js__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./common/frag/gamma1_0.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/gamma1_0.js\");\n/* harmony import */ var _common_frag_gamma2_2_js__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./common/frag/gamma2_2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/gamma2_2.js\");\n/* harmony import */ var _platform_graphics_shader_chunks_frag_gles2_js__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ../../../platform/graphics/shader-chunks/frag/gles2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-chunks/frag/gles2.js\");\n/* harmony import */ var _platform_graphics_shader_chunks_frag_gles3_js__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ../../../platform/graphics/shader-chunks/frag/gles3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-chunks/frag/gles3.js\");\n/* harmony import */ var _platform_graphics_shader_chunks_vert_gles3_js__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ../../../platform/graphics/shader-chunks/vert/gles3.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-chunks/vert/gles3.js\");\n/* harmony import */ var _standard_frag_gloss_js__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./standard/frag/gloss.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/gloss.js\");\n/* harmony import */ var _lit_frag_iridescenceDiffraction_js__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./lit/frag/iridescenceDiffraction.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/iridescenceDiffraction.js\");\n/* harmony import */ var _standard_frag_iridescence_js__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./standard/frag/iridescence.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/iridescence.js\");\n/* harmony import */ var _standard_frag_iridescenceThickness_js__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./standard/frag/iridescenceThickness.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/iridescenceThickness.js\");\n/* harmony import */ var _lit_vert_instancing_js__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./lit/vert/instancing.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/instancing.js\");\n/* harmony import */ var _lit_frag_lightDiffuseLambert_js__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./lit/frag/lightDiffuseLambert.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightDiffuseLambert.js\");\n/* harmony import */ var _lit_frag_lightDirPoint_js__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./lit/frag/lightDirPoint.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightDirPoint.js\");\n/* harmony import */ var _lit_frag_lightmapAdd_js__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./lit/frag/lightmapAdd.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightmapAdd.js\");\n/* harmony import */ var _lit_frag_lightmapDirAdd_js__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./lit/frag/lightmapDirAdd.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightmapDirAdd.js\");\n/* harmony import */ var _standard_frag_lightmapDir_js__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./standard/frag/lightmapDir.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/lightmapDir.js\");\n/* harmony import */ var _standard_frag_lightmapSingle_js__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./standard/frag/lightmapSingle.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/lightmapSingle.js\");\n/* harmony import */ var _lit_frag_lightSpecularAnisoGGX_js__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./lit/frag/lightSpecularAnisoGGX.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightSpecularAnisoGGX.js\");\n/* harmony import */ var _lit_frag_lightSpecularBlinn_js__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./lit/frag/lightSpecularBlinn.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightSpecularBlinn.js\");\n/* harmony import */ var _lit_frag_lightSpecularPhong_js__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./lit/frag/lightSpecularPhong.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightSpecularPhong.js\");\n/* harmony import */ var _lit_frag_lightSheen_js__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./lit/frag/lightSheen.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightSheen.js\");\n/* harmony import */ var _lit_frag_ltc_js__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./lit/frag/ltc.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/ltc.js\");\n/* harmony import */ var _standard_frag_metalness_js__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./standard/frag/metalness.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/metalness.js\");\n/* harmony import */ var _common_frag_msdf_js__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./common/frag/msdf.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/msdf.js\");\n/* harmony import */ var _lit_frag_metalnessModulate_js__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./lit/frag/metalnessModulate.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/metalnessModulate.js\");\n/* harmony import */ var _common_vert_msdf_js__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./common/vert/msdf.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/msdf.js\");\n/* harmony import */ var _lit_vert_normal_js__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ./lit/vert/normal.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/normal.js\");\n/* harmony import */ var _standard_frag_normalDetailMap_js__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./standard/frag/normalDetailMap.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/normalDetailMap.js\");\n/* harmony import */ var _lit_vert_normalInstanced_js__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./lit/vert/normalInstanced.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/normalInstanced.js\");\n/* harmony import */ var _standard_frag_normalMap_js__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ./standard/frag/normalMap.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/normalMap.js\");\n/* harmony import */ var _lit_vert_normalSkinned_js__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ./lit/vert/normalSkinned.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/normalSkinned.js\");\n/* harmony import */ var _standard_frag_normalXY_js__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ./standard/frag/normalXY.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/normalXY.js\");\n/* harmony import */ var _standard_frag_normalXYZ_js__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! ./standard/frag/normalXYZ.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/normalXYZ.js\");\n/* harmony import */ var _standard_frag_opacity_js__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! ./standard/frag/opacity.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/opacity.js\");\n/* harmony import */ var _lit_frag_outputAlpha_js__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(/*! ./lit/frag/outputAlpha.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/outputAlpha.js\");\n/* harmony import */ var _lit_frag_outputAlphaOpaque_js__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(/*! ./lit/frag/outputAlphaOpaque.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/outputAlphaOpaque.js\");\n/* harmony import */ var _lit_frag_outputAlphaPremul_js__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(/*! ./lit/frag/outputAlphaPremul.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/outputAlphaPremul.js\");\n/* harmony import */ var _common_frag_outputTex2D_js__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(/*! ./common/frag/outputTex2D.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/outputTex2D.js\");\n/* harmony import */ var _common_frag_packDepth_js__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(/*! ./common/frag/packDepth.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/packDepth.js\");\n/* harmony import */ var _standard_frag_sheen_js__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(/*! ./standard/frag/sheen.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/sheen.js\");\n/* harmony import */ var _standard_frag_sheenGloss_js__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(/*! ./standard/frag/sheenGloss.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/sheenGloss.js\");\n/* harmony import */ var _standard_frag_parallax_js__WEBPACK_IMPORTED_MODULE_94__ = __webpack_require__(/*! ./standard/frag/parallax.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/parallax.js\");\n/* harmony import */ var _particle_frag_particle_js__WEBPACK_IMPORTED_MODULE_95__ = __webpack_require__(/*! ./particle/frag/particle.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle.js\");\n/* harmony import */ var _particle_vert_particle_js__WEBPACK_IMPORTED_MODULE_96__ = __webpack_require__(/*! ./particle/vert/particle.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle.js\");\n/* harmony import */ var _particle_vert_particleAnimFrameClamp_js__WEBPACK_IMPORTED_MODULE_97__ = __webpack_require__(/*! ./particle/vert/particleAnimFrameClamp.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particleAnimFrameClamp.js\");\n/* harmony import */ var _particle_vert_particleAnimFrameLoop_js__WEBPACK_IMPORTED_MODULE_98__ = __webpack_require__(/*! ./particle/vert/particleAnimFrameLoop.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particleAnimFrameLoop.js\");\n/* harmony import */ var _particle_vert_particleAnimTex_js__WEBPACK_IMPORTED_MODULE_99__ = __webpack_require__(/*! ./particle/vert/particleAnimTex.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particleAnimTex.js\");\n/* harmony import */ var _particle_frag_particleInputFloat_js__WEBPACK_IMPORTED_MODULE_100__ = __webpack_require__(/*! ./particle/frag/particleInputFloat.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleInputFloat.js\");\n/* harmony import */ var _particle_frag_particleInputRgba8_js__WEBPACK_IMPORTED_MODULE_101__ = __webpack_require__(/*! ./particle/frag/particleInputRgba8.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleInputRgba8.js\");\n/* harmony import */ var _particle_frag_particleOutputFloat_js__WEBPACK_IMPORTED_MODULE_102__ = __webpack_require__(/*! ./particle/frag/particleOutputFloat.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleOutputFloat.js\");\n/* harmony import */ var _particle_frag_particleOutputRgba8_js__WEBPACK_IMPORTED_MODULE_103__ = __webpack_require__(/*! ./particle/frag/particleOutputRgba8.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleOutputRgba8.js\");\n/* harmony import */ var _particle_frag_particleUpdaterAABB_js__WEBPACK_IMPORTED_MODULE_104__ = __webpack_require__(/*! ./particle/frag/particleUpdaterAABB.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterAABB.js\");\n/* harmony import */ var _particle_frag_particleUpdaterEnd_js__WEBPACK_IMPORTED_MODULE_105__ = __webpack_require__(/*! ./particle/frag/particleUpdaterEnd.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterEnd.js\");\n/* harmony import */ var _particle_frag_particleUpdaterInit_js__WEBPACK_IMPORTED_MODULE_106__ = __webpack_require__(/*! ./particle/frag/particleUpdaterInit.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterInit.js\");\n/* harmony import */ var _particle_frag_particleUpdaterNoRespawn_js__WEBPACK_IMPORTED_MODULE_107__ = __webpack_require__(/*! ./particle/frag/particleUpdaterNoRespawn.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterNoRespawn.js\");\n/* harmony import */ var _particle_frag_particleUpdaterOnStop_js__WEBPACK_IMPORTED_MODULE_108__ = __webpack_require__(/*! ./particle/frag/particleUpdaterOnStop.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterOnStop.js\");\n/* harmony import */ var _particle_frag_particleUpdaterRespawn_js__WEBPACK_IMPORTED_MODULE_109__ = __webpack_require__(/*! ./particle/frag/particleUpdaterRespawn.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterRespawn.js\");\n/* harmony import */ var _particle_frag_particleUpdaterSphere_js__WEBPACK_IMPORTED_MODULE_110__ = __webpack_require__(/*! ./particle/frag/particleUpdaterSphere.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterSphere.js\");\n/* harmony import */ var _particle_frag_particleUpdaterStart_js__WEBPACK_IMPORTED_MODULE_111__ = __webpack_require__(/*! ./particle/frag/particleUpdaterStart.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterStart.js\");\n/* harmony import */ var _particle_vert_particle_billboard_js__WEBPACK_IMPORTED_MODULE_112__ = __webpack_require__(/*! ./particle/vert/particle_billboard.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_billboard.js\");\n/* harmony import */ var _particle_frag_particle_blendAdd_js__WEBPACK_IMPORTED_MODULE_113__ = __webpack_require__(/*! ./particle/frag/particle_blendAdd.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_blendAdd.js\");\n/* harmony import */ var _particle_frag_particle_blendMultiply_js__WEBPACK_IMPORTED_MODULE_114__ = __webpack_require__(/*! ./particle/frag/particle_blendMultiply.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_blendMultiply.js\");\n/* harmony import */ var _particle_frag_particle_blendNormal_js__WEBPACK_IMPORTED_MODULE_115__ = __webpack_require__(/*! ./particle/frag/particle_blendNormal.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_blendNormal.js\");\n/* harmony import */ var _particle_vert_particle_cpu_js__WEBPACK_IMPORTED_MODULE_116__ = __webpack_require__(/*! ./particle/vert/particle_cpu.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_cpu.js\");\n/* harmony import */ var _particle_vert_particle_cpu_end_js__WEBPACK_IMPORTED_MODULE_117__ = __webpack_require__(/*! ./particle/vert/particle_cpu_end.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_cpu_end.js\");\n/* harmony import */ var _particle_vert_particle_customFace_js__WEBPACK_IMPORTED_MODULE_118__ = __webpack_require__(/*! ./particle/vert/particle_customFace.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_customFace.js\");\n/* harmony import */ var _particle_frag_particle_end_js__WEBPACK_IMPORTED_MODULE_119__ = __webpack_require__(/*! ./particle/frag/particle_end.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_end.js\");\n/* harmony import */ var _particle_vert_particle_end_js__WEBPACK_IMPORTED_MODULE_120__ = __webpack_require__(/*! ./particle/vert/particle_end.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_end.js\");\n/* harmony import */ var _particle_frag_particle_halflambert_js__WEBPACK_IMPORTED_MODULE_121__ = __webpack_require__(/*! ./particle/frag/particle_halflambert.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_halflambert.js\");\n/* harmony import */ var _particle_vert_particle_init_js__WEBPACK_IMPORTED_MODULE_122__ = __webpack_require__(/*! ./particle/vert/particle_init.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_init.js\");\n/* harmony import */ var _particle_frag_particle_lambert_js__WEBPACK_IMPORTED_MODULE_123__ = __webpack_require__(/*! ./particle/frag/particle_lambert.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_lambert.js\");\n/* harmony import */ var _particle_frag_particle_lighting_js__WEBPACK_IMPORTED_MODULE_124__ = __webpack_require__(/*! ./particle/frag/particle_lighting.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_lighting.js\");\n/* harmony import */ var _particle_vert_particle_localShift_js__WEBPACK_IMPORTED_MODULE_125__ = __webpack_require__(/*! ./particle/vert/particle_localShift.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_localShift.js\");\n/* harmony import */ var _particle_vert_particle_mesh_js__WEBPACK_IMPORTED_MODULE_126__ = __webpack_require__(/*! ./particle/vert/particle_mesh.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_mesh.js\");\n/* harmony import */ var _particle_vert_particle_normal_js__WEBPACK_IMPORTED_MODULE_127__ = __webpack_require__(/*! ./particle/vert/particle_normal.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_normal.js\");\n/* harmony import */ var _particle_frag_particle_normalMap_js__WEBPACK_IMPORTED_MODULE_128__ = __webpack_require__(/*! ./particle/frag/particle_normalMap.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_normalMap.js\");\n/* harmony import */ var _particle_vert_particle_pointAlong_js__WEBPACK_IMPORTED_MODULE_129__ = __webpack_require__(/*! ./particle/vert/particle_pointAlong.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_pointAlong.js\");\n/* harmony import */ var _particle_frag_particle_soft_js__WEBPACK_IMPORTED_MODULE_130__ = __webpack_require__(/*! ./particle/frag/particle_soft.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_soft.js\");\n/* harmony import */ var _particle_vert_particle_soft_js__WEBPACK_IMPORTED_MODULE_131__ = __webpack_require__(/*! ./particle/vert/particle_soft.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_soft.js\");\n/* harmony import */ var _particle_vert_particle_stretch_js__WEBPACK_IMPORTED_MODULE_132__ = __webpack_require__(/*! ./particle/vert/particle_stretch.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_stretch.js\");\n/* harmony import */ var _particle_vert_particle_TBN_js__WEBPACK_IMPORTED_MODULE_133__ = __webpack_require__(/*! ./particle/vert/particle_TBN.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_TBN.js\");\n/* harmony import */ var _particle_vert_particle_wrap_js__WEBPACK_IMPORTED_MODULE_134__ = __webpack_require__(/*! ./particle/vert/particle_wrap.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_wrap.js\");\n/* harmony import */ var _lit_frag_reflDir_js__WEBPACK_IMPORTED_MODULE_135__ = __webpack_require__(/*! ./lit/frag/reflDir.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflDir.js\");\n/* harmony import */ var _lit_frag_reflDirAniso_js__WEBPACK_IMPORTED_MODULE_136__ = __webpack_require__(/*! ./lit/frag/reflDirAniso.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflDirAniso.js\");\n/* harmony import */ var _lit_frag_reflectionCC_js__WEBPACK_IMPORTED_MODULE_137__ = __webpack_require__(/*! ./lit/frag/reflectionCC.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflectionCC.js\");\n/* harmony import */ var _lit_frag_reflectionCube_js__WEBPACK_IMPORTED_MODULE_138__ = __webpack_require__(/*! ./lit/frag/reflectionCube.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflectionCube.js\");\n/* harmony import */ var _lit_frag_reflectionEnvHQ_js__WEBPACK_IMPORTED_MODULE_139__ = __webpack_require__(/*! ./lit/frag/reflectionEnvHQ.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflectionEnvHQ.js\");\n/* harmony import */ var _lit_frag_reflectionEnv_js__WEBPACK_IMPORTED_MODULE_140__ = __webpack_require__(/*! ./lit/frag/reflectionEnv.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflectionEnv.js\");\n/* harmony import */ var _lit_frag_reflectionSphere_js__WEBPACK_IMPORTED_MODULE_141__ = __webpack_require__(/*! ./lit/frag/reflectionSphere.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflectionSphere.js\");\n/* harmony import */ var _lit_frag_reflectionSphereLow_js__WEBPACK_IMPORTED_MODULE_142__ = __webpack_require__(/*! ./lit/frag/reflectionSphereLow.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflectionSphereLow.js\");\n/* harmony import */ var _lit_frag_reflectionSheen_js__WEBPACK_IMPORTED_MODULE_143__ = __webpack_require__(/*! ./lit/frag/reflectionSheen.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflectionSheen.js\");\n/* harmony import */ var _lit_frag_refractionCube_js__WEBPACK_IMPORTED_MODULE_144__ = __webpack_require__(/*! ./lit/frag/refractionCube.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/refractionCube.js\");\n/* harmony import */ var _lit_frag_refractionDynamic_js__WEBPACK_IMPORTED_MODULE_145__ = __webpack_require__(/*! ./lit/frag/refractionDynamic.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/refractionDynamic.js\");\n/* harmony import */ var _common_frag_reproject_js__WEBPACK_IMPORTED_MODULE_146__ = __webpack_require__(/*! ./common/frag/reproject.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/reproject.js\");\n/* harmony import */ var _common_frag_screenDepth_js__WEBPACK_IMPORTED_MODULE_147__ = __webpack_require__(/*! ./common/frag/screenDepth.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/screenDepth.js\");\n/* harmony import */ var _lit_frag_shadowCascades_js__WEBPACK_IMPORTED_MODULE_148__ = __webpack_require__(/*! ./lit/frag/shadowCascades.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowCascades.js\");\n/* harmony import */ var _lit_frag_shadowCommon_js__WEBPACK_IMPORTED_MODULE_149__ = __webpack_require__(/*! ./lit/frag/shadowCommon.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowCommon.js\");\n/* harmony import */ var _lit_frag_shadowCoord_js__WEBPACK_IMPORTED_MODULE_150__ = __webpack_require__(/*! ./lit/frag/shadowCoord.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowCoord.js\");\n/* harmony import */ var _lit_frag_shadowCoordPerspZbuffer_js__WEBPACK_IMPORTED_MODULE_151__ = __webpack_require__(/*! ./lit/frag/shadowCoordPerspZbuffer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowCoordPerspZbuffer.js\");\n/* harmony import */ var _lit_frag_shadowEVSM_js__WEBPACK_IMPORTED_MODULE_152__ = __webpack_require__(/*! ./lit/frag/shadowEVSM.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowEVSM.js\");\n/* harmony import */ var _lit_frag_shadowEVSMn_js__WEBPACK_IMPORTED_MODULE_153__ = __webpack_require__(/*! ./lit/frag/shadowEVSMn.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowEVSMn.js\");\n/* harmony import */ var _lit_frag_shadowStandard_js__WEBPACK_IMPORTED_MODULE_154__ = __webpack_require__(/*! ./lit/frag/shadowStandard.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowStandard.js\");\n/* harmony import */ var _lit_frag_shadowStandardGL2_js__WEBPACK_IMPORTED_MODULE_155__ = __webpack_require__(/*! ./lit/frag/shadowStandardGL2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowStandardGL2.js\");\n/* harmony import */ var _lit_frag_shadowVSM8_js__WEBPACK_IMPORTED_MODULE_156__ = __webpack_require__(/*! ./lit/frag/shadowVSM8.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowVSM8.js\");\n/* harmony import */ var _lit_frag_shadowVSM_common_js__WEBPACK_IMPORTED_MODULE_157__ = __webpack_require__(/*! ./lit/frag/shadowVSM_common.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowVSM_common.js\");\n/* harmony import */ var _common_vert_skinBatchConst_js__WEBPACK_IMPORTED_MODULE_158__ = __webpack_require__(/*! ./common/vert/skinBatchConst.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/skinBatchConst.js\");\n/* harmony import */ var _common_vert_skinBatchTex_js__WEBPACK_IMPORTED_MODULE_159__ = __webpack_require__(/*! ./common/vert/skinBatchTex.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/skinBatchTex.js\");\n/* harmony import */ var _common_vert_skinConst_js__WEBPACK_IMPORTED_MODULE_160__ = __webpack_require__(/*! ./common/vert/skinConst.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/skinConst.js\");\n/* harmony import */ var _common_vert_skinTex_js__WEBPACK_IMPORTED_MODULE_161__ = __webpack_require__(/*! ./common/vert/skinTex.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/skinTex.js\");\n/* harmony import */ var _skybox_frag_skyboxEnv_js__WEBPACK_IMPORTED_MODULE_162__ = __webpack_require__(/*! ./skybox/frag/skyboxEnv.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/skybox/frag/skyboxEnv.js\");\n/* harmony import */ var _skybox_frag_skyboxHDR_js__WEBPACK_IMPORTED_MODULE_163__ = __webpack_require__(/*! ./skybox/frag/skyboxHDR.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/skybox/frag/skyboxHDR.js\");\n/* harmony import */ var _skybox_vert_skybox_js__WEBPACK_IMPORTED_MODULE_164__ = __webpack_require__(/*! ./skybox/vert/skybox.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/skybox/vert/skybox.js\");\n/* harmony import */ var _standard_frag_specular_js__WEBPACK_IMPORTED_MODULE_165__ = __webpack_require__(/*! ./standard/frag/specular.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/specular.js\");\n/* harmony import */ var _common_frag_spherical_js__WEBPACK_IMPORTED_MODULE_166__ = __webpack_require__(/*! ./common/frag/spherical.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/spherical.js\");\n/* harmony import */ var _standard_frag_specularityFactor_js__WEBPACK_IMPORTED_MODULE_167__ = __webpack_require__(/*! ./standard/frag/specularityFactor.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/specularityFactor.js\");\n/* harmony import */ var _lit_frag_spot_js__WEBPACK_IMPORTED_MODULE_168__ = __webpack_require__(/*! ./lit/frag/spot.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/spot.js\");\n/* harmony import */ var _lit_frag_start_js__WEBPACK_IMPORTED_MODULE_169__ = __webpack_require__(/*! ./lit/frag/start.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/start.js\");\n/* harmony import */ var _lit_vert_start_js__WEBPACK_IMPORTED_MODULE_170__ = __webpack_require__(/*! ./lit/vert/start.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/start.js\");\n/* harmony import */ var _lit_frag_startNineSliced_js__WEBPACK_IMPORTED_MODULE_171__ = __webpack_require__(/*! ./lit/frag/startNineSliced.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/startNineSliced.js\");\n/* harmony import */ var _lit_frag_startNineSlicedTiled_js__WEBPACK_IMPORTED_MODULE_172__ = __webpack_require__(/*! ./lit/frag/startNineSlicedTiled.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/startNineSlicedTiled.js\");\n/* harmony import */ var _lit_frag_storeEVSM_js__WEBPACK_IMPORTED_MODULE_173__ = __webpack_require__(/*! ./lit/frag/storeEVSM.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/storeEVSM.js\");\n/* harmony import */ var _lit_vert_tangentBinormal_js__WEBPACK_IMPORTED_MODULE_174__ = __webpack_require__(/*! ./lit/vert/tangentBinormal.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/tangentBinormal.js\");\n/* harmony import */ var _lit_frag_TBN_js__WEBPACK_IMPORTED_MODULE_175__ = __webpack_require__(/*! ./lit/frag/TBN.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/TBN.js\");\n/* harmony import */ var _lit_frag_TBNderivative_js__WEBPACK_IMPORTED_MODULE_176__ = __webpack_require__(/*! ./lit/frag/TBNderivative.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/TBNderivative.js\");\n/* harmony import */ var _lit_frag_TBNfast_js__WEBPACK_IMPORTED_MODULE_177__ = __webpack_require__(/*! ./lit/frag/TBNfast.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/TBNfast.js\");\n/* harmony import */ var _lit_frag_TBNObjectSpace_js__WEBPACK_IMPORTED_MODULE_178__ = __webpack_require__(/*! ./lit/frag/TBNObjectSpace.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/TBNObjectSpace.js\");\n/* harmony import */ var _standard_frag_textureSample_js__WEBPACK_IMPORTED_MODULE_179__ = __webpack_require__(/*! ./standard/frag/textureSample.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/textureSample.js\");\n/* harmony import */ var _standard_frag_thickness_js__WEBPACK_IMPORTED_MODULE_180__ = __webpack_require__(/*! ./standard/frag/thickness.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/thickness.js\");\n/* harmony import */ var _common_frag_tonemappingAces_js__WEBPACK_IMPORTED_MODULE_181__ = __webpack_require__(/*! ./common/frag/tonemappingAces.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/tonemappingAces.js\");\n/* harmony import */ var _common_frag_tonemappingAces2_js__WEBPACK_IMPORTED_MODULE_182__ = __webpack_require__(/*! ./common/frag/tonemappingAces2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/tonemappingAces2.js\");\n/* harmony import */ var _common_frag_tonemappingFilmic_js__WEBPACK_IMPORTED_MODULE_183__ = __webpack_require__(/*! ./common/frag/tonemappingFilmic.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/tonemappingFilmic.js\");\n/* harmony import */ var _common_frag_tonemappingHejl_js__WEBPACK_IMPORTED_MODULE_184__ = __webpack_require__(/*! ./common/frag/tonemappingHejl.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/tonemappingHejl.js\");\n/* harmony import */ var _common_frag_tonemappingLinear_js__WEBPACK_IMPORTED_MODULE_185__ = __webpack_require__(/*! ./common/frag/tonemappingLinear.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/tonemappingLinear.js\");\n/* harmony import */ var _common_frag_tonemappingNone_js__WEBPACK_IMPORTED_MODULE_186__ = __webpack_require__(/*! ./common/frag/tonemappingNone.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/tonemappingNone.js\");\n/* harmony import */ var _common_vert_transform_js__WEBPACK_IMPORTED_MODULE_187__ = __webpack_require__(/*! ./common/vert/transform.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/transform.js\");\n/* harmony import */ var _common_vert_transformDecl_js__WEBPACK_IMPORTED_MODULE_188__ = __webpack_require__(/*! ./common/vert/transformDecl.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/transformDecl.js\");\n/* harmony import */ var _standard_frag_transmission_js__WEBPACK_IMPORTED_MODULE_189__ = __webpack_require__(/*! ./standard/frag/transmission.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/transmission.js\");\n/* harmony import */ var _lit_vert_uv0_js__WEBPACK_IMPORTED_MODULE_190__ = __webpack_require__(/*! ./lit/vert/uv0.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/uv0.js\");\n/* harmony import */ var _lit_vert_uv1_js__WEBPACK_IMPORTED_MODULE_191__ = __webpack_require__(/*! ./lit/vert/uv1.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/uv1.js\");\n/* harmony import */ var _lit_frag_viewDir_js__WEBPACK_IMPORTED_MODULE_192__ = __webpack_require__(/*! ./lit/frag/viewDir.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/viewDir.js\");\n/* harmony import */ var _lit_vert_viewNormal_js__WEBPACK_IMPORTED_MODULE_193__ = __webpack_require__(/*! ./lit/vert/viewNormal.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/viewNormal.js\");\n/* harmony import */ var _platform_graphics_shader_chunks_frag_webgpu_js__WEBPACK_IMPORTED_MODULE_194__ = __webpack_require__(/*! ../../../platform/graphics/shader-chunks/frag/webgpu.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-chunks/frag/webgpu.js\");\n/* harmony import */ var _platform_graphics_shader_chunks_vert_webgpu_js__WEBPACK_IMPORTED_MODULE_195__ = __webpack_require__(/*! ../../../platform/graphics/shader-chunks/vert/webgpu.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-chunks/vert/webgpu.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst shaderChunks = {\n  alphaTestPS: _standard_frag_alphaTest_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n  ambientConstantPS: _lit_frag_ambientConstant_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  ambientEnvPS: _lit_frag_ambientEnv_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n  ambientSHPS: _lit_frag_ambientSH_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n  aoPS: _standard_frag_ao_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n  aoDiffuseOccPS: _lit_frag_aoDiffuseOcc_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\n  aoSpecOccPS: _lit_frag_aoSpecOcc_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"],\n  aoSpecOccConstPS: _lit_frag_aoSpecOccConst_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"],\n  aoSpecOccConstSimplePS: _lit_frag_aoSpecOccConstSimple_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"],\n  aoSpecOccSimplePS: _lit_frag_aoSpecOccSimple_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"],\n  basePS: _lit_frag_base_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"],\n  baseVS: _lit_vert_base_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"],\n  baseNineSlicedPS: _lit_frag_baseNineSliced_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"],\n  baseNineSlicedVS: _lit_vert_baseNineSliced_js__WEBPACK_IMPORTED_MODULE_13__[\"default\"],\n  baseNineSlicedTiledPS: _lit_frag_baseNineSlicedTiled_js__WEBPACK_IMPORTED_MODULE_14__[\"default\"],\n  biasConstPS: _lit_frag_biasConst_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"],\n  blurVSMPS: _lit_frag_blurVSM_js__WEBPACK_IMPORTED_MODULE_16__[\"default\"],\n  clearCoatPS: _standard_frag_clearCoat_js__WEBPACK_IMPORTED_MODULE_17__[\"default\"],\n  clearCoatGlossPS: _standard_frag_clearCoatGloss_js__WEBPACK_IMPORTED_MODULE_18__[\"default\"],\n  clearCoatNormalPS: _standard_frag_clearCoatNormal_js__WEBPACK_IMPORTED_MODULE_19__[\"default\"],\n  clusteredLightCookiesPS: _lit_frag_clusteredLightCookies_js__WEBPACK_IMPORTED_MODULE_20__[\"default\"],\n  clusteredLightShadowsPS: _lit_frag_clusteredLightShadows_js__WEBPACK_IMPORTED_MODULE_21__[\"default\"],\n  clusteredLightUtilsPS: _lit_frag_clusteredLightUtils_js__WEBPACK_IMPORTED_MODULE_22__[\"default\"],\n  clusteredLightPS: _lit_frag_clusteredLight_js__WEBPACK_IMPORTED_MODULE_23__[\"default\"],\n  combinePS: _lit_frag_combine_js__WEBPACK_IMPORTED_MODULE_24__[\"default\"],\n  cookiePS: _lit_frag_cookie_js__WEBPACK_IMPORTED_MODULE_25__[\"default\"],\n  cubeMapProjectBoxPS: _lit_frag_cubeMapProjectBox_js__WEBPACK_IMPORTED_MODULE_26__[\"default\"],\n  cubeMapProjectNonePS: _lit_frag_cubeMapProjectNone_js__WEBPACK_IMPORTED_MODULE_27__[\"default\"],\n  cubeMapRotatePS: _lit_frag_cubeMapRotate_js__WEBPACK_IMPORTED_MODULE_28__[\"default\"],\n  detailModesPS: _standard_frag_detailModes_js__WEBPACK_IMPORTED_MODULE_29__[\"default\"],\n  diffusePS: _standard_frag_diffuse_js__WEBPACK_IMPORTED_MODULE_30__[\"default\"],\n  diffuseDetailMapPS: _standard_frag_diffuseDetailMap_js__WEBPACK_IMPORTED_MODULE_31__[\"default\"],\n  decodePS: _common_frag_decode_js__WEBPACK_IMPORTED_MODULE_32__[\"default\"],\n  emissivePS: _standard_frag_emissive_js__WEBPACK_IMPORTED_MODULE_33__[\"default\"],\n  encodePS: _common_frag_encode_js__WEBPACK_IMPORTED_MODULE_34__[\"default\"],\n  endPS: _lit_frag_end_js__WEBPACK_IMPORTED_MODULE_35__[\"default\"],\n  endVS: _lit_vert_end_js__WEBPACK_IMPORTED_MODULE_36__[\"default\"],\n  envAtlasPS: _common_frag_envAtlas_js__WEBPACK_IMPORTED_MODULE_37__[\"default\"],\n  envConstPS: _common_frag_envConst_js__WEBPACK_IMPORTED_MODULE_38__[\"default\"],\n  envMultiplyPS: _common_frag_envMultiply_js__WEBPACK_IMPORTED_MODULE_39__[\"default\"],\n  extensionPS: _lit_frag_extension_js__WEBPACK_IMPORTED_MODULE_40__[\"default\"],\n  extensionVS: _lit_vert_extension_js__WEBPACK_IMPORTED_MODULE_41__[\"default\"],\n  falloffInvSquaredPS: _lit_frag_falloffInvSquared_js__WEBPACK_IMPORTED_MODULE_42__[\"default\"],\n  falloffLinearPS: _lit_frag_falloffLinear_js__WEBPACK_IMPORTED_MODULE_43__[\"default\"],\n  fixCubemapSeamsNonePS: _common_frag_fixCubemapSeamsNone_js__WEBPACK_IMPORTED_MODULE_44__[\"default\"],\n  fixCubemapSeamsStretchPS: _common_frag_fixCubemapSeamsStretch_js__WEBPACK_IMPORTED_MODULE_45__[\"default\"],\n  floatUnpackingPS: _lit_frag_float_unpacking_js__WEBPACK_IMPORTED_MODULE_46__[\"default\"],\n  fogExpPS: _lit_frag_fogExp_js__WEBPACK_IMPORTED_MODULE_47__[\"default\"],\n  fogExp2PS: _lit_frag_fogExp2_js__WEBPACK_IMPORTED_MODULE_48__[\"default\"],\n  fogLinearPS: _lit_frag_fogLinear_js__WEBPACK_IMPORTED_MODULE_49__[\"default\"],\n  fogNonePS: _lit_frag_fogNone_js__WEBPACK_IMPORTED_MODULE_50__[\"default\"],\n  fresnelSchlickPS: _lit_frag_fresnelSchlick_js__WEBPACK_IMPORTED_MODULE_51__[\"default\"],\n  fullscreenQuadPS: _common_frag_fullscreenQuad_js__WEBPACK_IMPORTED_MODULE_52__[\"default\"],\n  fullscreenQuadVS: _common_vert_fullscreenQuad_js__WEBPACK_IMPORTED_MODULE_53__[\"default\"],\n  gamma1_0PS: _common_frag_gamma1_0_js__WEBPACK_IMPORTED_MODULE_54__[\"default\"],\n  gamma2_2PS: _common_frag_gamma2_2_js__WEBPACK_IMPORTED_MODULE_55__[\"default\"],\n  gles2PS: _platform_graphics_shader_chunks_frag_gles2_js__WEBPACK_IMPORTED_MODULE_56__[\"default\"],\n  gles3PS: _platform_graphics_shader_chunks_frag_gles3_js__WEBPACK_IMPORTED_MODULE_57__[\"default\"],\n  gles3VS: _platform_graphics_shader_chunks_vert_gles3_js__WEBPACK_IMPORTED_MODULE_58__[\"default\"],\n  glossPS: _standard_frag_gloss_js__WEBPACK_IMPORTED_MODULE_59__[\"default\"],\n  iridescenceDiffractionPS: _lit_frag_iridescenceDiffraction_js__WEBPACK_IMPORTED_MODULE_60__[\"default\"],\n  iridescencePS: _standard_frag_iridescence_js__WEBPACK_IMPORTED_MODULE_61__[\"default\"],\n  iridescenceThicknessPS: _standard_frag_iridescenceThickness_js__WEBPACK_IMPORTED_MODULE_62__[\"default\"],\n  instancingVS: _lit_vert_instancing_js__WEBPACK_IMPORTED_MODULE_63__[\"default\"],\n  lightDiffuseLambertPS: _lit_frag_lightDiffuseLambert_js__WEBPACK_IMPORTED_MODULE_64__[\"default\"],\n  lightDirPointPS: _lit_frag_lightDirPoint_js__WEBPACK_IMPORTED_MODULE_65__[\"default\"],\n  lightmapAddPS: _lit_frag_lightmapAdd_js__WEBPACK_IMPORTED_MODULE_66__[\"default\"],\n  lightmapDirAddPS: _lit_frag_lightmapDirAdd_js__WEBPACK_IMPORTED_MODULE_67__[\"default\"],\n  lightmapDirPS: _standard_frag_lightmapDir_js__WEBPACK_IMPORTED_MODULE_68__[\"default\"],\n  lightmapSinglePS: _standard_frag_lightmapSingle_js__WEBPACK_IMPORTED_MODULE_69__[\"default\"],\n  lightSpecularAnisoGGXPS: _lit_frag_lightSpecularAnisoGGX_js__WEBPACK_IMPORTED_MODULE_70__[\"default\"],\n  lightSpecularBlinnPS: _lit_frag_lightSpecularBlinn_js__WEBPACK_IMPORTED_MODULE_71__[\"default\"],\n  lightSpecularPhongPS: _lit_frag_lightSpecularPhong_js__WEBPACK_IMPORTED_MODULE_72__[\"default\"],\n  lightSheenPS: _lit_frag_lightSheen_js__WEBPACK_IMPORTED_MODULE_73__[\"default\"],\n  ltc: _lit_frag_ltc_js__WEBPACK_IMPORTED_MODULE_74__[\"default\"],\n  metalnessPS: _standard_frag_metalness_js__WEBPACK_IMPORTED_MODULE_75__[\"default\"],\n  metalnessModulatePS: _lit_frag_metalnessModulate_js__WEBPACK_IMPORTED_MODULE_76__[\"default\"],\n  msdfPS: _common_frag_msdf_js__WEBPACK_IMPORTED_MODULE_77__[\"default\"],\n  msdfVS: _common_vert_msdf_js__WEBPACK_IMPORTED_MODULE_78__[\"default\"],\n  normalVS: _lit_vert_normal_js__WEBPACK_IMPORTED_MODULE_79__[\"default\"],\n  normalDetailMapPS: _standard_frag_normalDetailMap_js__WEBPACK_IMPORTED_MODULE_80__[\"default\"],\n  normalInstancedVS: _lit_vert_normalInstanced_js__WEBPACK_IMPORTED_MODULE_81__[\"default\"],\n  normalMapPS: _standard_frag_normalMap_js__WEBPACK_IMPORTED_MODULE_82__[\"default\"],\n  normalSkinnedVS: _lit_vert_normalSkinned_js__WEBPACK_IMPORTED_MODULE_83__[\"default\"],\n  normalXYPS: _standard_frag_normalXY_js__WEBPACK_IMPORTED_MODULE_84__[\"default\"],\n  normalXYZPS: _standard_frag_normalXYZ_js__WEBPACK_IMPORTED_MODULE_85__[\"default\"],\n  opacityPS: _standard_frag_opacity_js__WEBPACK_IMPORTED_MODULE_86__[\"default\"],\n  outputAlphaPS: _lit_frag_outputAlpha_js__WEBPACK_IMPORTED_MODULE_87__[\"default\"],\n  outputAlphaOpaquePS: _lit_frag_outputAlphaOpaque_js__WEBPACK_IMPORTED_MODULE_88__[\"default\"],\n  outputAlphaPremulPS: _lit_frag_outputAlphaPremul_js__WEBPACK_IMPORTED_MODULE_89__[\"default\"],\n  outputTex2DPS: _common_frag_outputTex2D_js__WEBPACK_IMPORTED_MODULE_90__[\"default\"],\n  packDepthPS: _common_frag_packDepth_js__WEBPACK_IMPORTED_MODULE_91__[\"default\"],\n  sheenPS: _standard_frag_sheen_js__WEBPACK_IMPORTED_MODULE_92__[\"default\"],\n  sheenGlossPS: _standard_frag_sheenGloss_js__WEBPACK_IMPORTED_MODULE_93__[\"default\"],\n  parallaxPS: _standard_frag_parallax_js__WEBPACK_IMPORTED_MODULE_94__[\"default\"],\n  particlePS: _particle_frag_particle_js__WEBPACK_IMPORTED_MODULE_95__[\"default\"],\n  particleVS: _particle_vert_particle_js__WEBPACK_IMPORTED_MODULE_96__[\"default\"],\n  particleAnimFrameClampVS: _particle_vert_particleAnimFrameClamp_js__WEBPACK_IMPORTED_MODULE_97__[\"default\"],\n  particleAnimFrameLoopVS: _particle_vert_particleAnimFrameLoop_js__WEBPACK_IMPORTED_MODULE_98__[\"default\"],\n  particleAnimTexVS: _particle_vert_particleAnimTex_js__WEBPACK_IMPORTED_MODULE_99__[\"default\"],\n  particleInputFloatPS: _particle_frag_particleInputFloat_js__WEBPACK_IMPORTED_MODULE_100__[\"default\"],\n  particleInputRgba8PS: _particle_frag_particleInputRgba8_js__WEBPACK_IMPORTED_MODULE_101__[\"default\"],\n  particleOutputFloatPS: _particle_frag_particleOutputFloat_js__WEBPACK_IMPORTED_MODULE_102__[\"default\"],\n  particleOutputRgba8PS: _particle_frag_particleOutputRgba8_js__WEBPACK_IMPORTED_MODULE_103__[\"default\"],\n  particleUpdaterAABBPS: _particle_frag_particleUpdaterAABB_js__WEBPACK_IMPORTED_MODULE_104__[\"default\"],\n  particleUpdaterEndPS: _particle_frag_particleUpdaterEnd_js__WEBPACK_IMPORTED_MODULE_105__[\"default\"],\n  particleUpdaterInitPS: _particle_frag_particleUpdaterInit_js__WEBPACK_IMPORTED_MODULE_106__[\"default\"],\n  particleUpdaterNoRespawnPS: _particle_frag_particleUpdaterNoRespawn_js__WEBPACK_IMPORTED_MODULE_107__[\"default\"],\n  particleUpdaterOnStopPS: _particle_frag_particleUpdaterOnStop_js__WEBPACK_IMPORTED_MODULE_108__[\"default\"],\n  particleUpdaterRespawnPS: _particle_frag_particleUpdaterRespawn_js__WEBPACK_IMPORTED_MODULE_109__[\"default\"],\n  particleUpdaterSpherePS: _particle_frag_particleUpdaterSphere_js__WEBPACK_IMPORTED_MODULE_110__[\"default\"],\n  particleUpdaterStartPS: _particle_frag_particleUpdaterStart_js__WEBPACK_IMPORTED_MODULE_111__[\"default\"],\n  particle_billboardVS: _particle_vert_particle_billboard_js__WEBPACK_IMPORTED_MODULE_112__[\"default\"],\n  particle_blendAddPS: _particle_frag_particle_blendAdd_js__WEBPACK_IMPORTED_MODULE_113__[\"default\"],\n  particle_blendMultiplyPS: _particle_frag_particle_blendMultiply_js__WEBPACK_IMPORTED_MODULE_114__[\"default\"],\n  particle_blendNormalPS: _particle_frag_particle_blendNormal_js__WEBPACK_IMPORTED_MODULE_115__[\"default\"],\n  particle_cpuVS: _particle_vert_particle_cpu_js__WEBPACK_IMPORTED_MODULE_116__[\"default\"],\n  particle_cpu_endVS: _particle_vert_particle_cpu_end_js__WEBPACK_IMPORTED_MODULE_117__[\"default\"],\n  particle_customFaceVS: _particle_vert_particle_customFace_js__WEBPACK_IMPORTED_MODULE_118__[\"default\"],\n  particle_endPS: _particle_frag_particle_end_js__WEBPACK_IMPORTED_MODULE_119__[\"default\"],\n  particle_endVS: _particle_vert_particle_end_js__WEBPACK_IMPORTED_MODULE_120__[\"default\"],\n  particle_halflambertPS: _particle_frag_particle_halflambert_js__WEBPACK_IMPORTED_MODULE_121__[\"default\"],\n  particle_initVS: _particle_vert_particle_init_js__WEBPACK_IMPORTED_MODULE_122__[\"default\"],\n  particle_lambertPS: _particle_frag_particle_lambert_js__WEBPACK_IMPORTED_MODULE_123__[\"default\"],\n  particle_lightingPS: _particle_frag_particle_lighting_js__WEBPACK_IMPORTED_MODULE_124__[\"default\"],\n  particle_localShiftVS: _particle_vert_particle_localShift_js__WEBPACK_IMPORTED_MODULE_125__[\"default\"],\n  particle_meshVS: _particle_vert_particle_mesh_js__WEBPACK_IMPORTED_MODULE_126__[\"default\"],\n  particle_normalVS: _particle_vert_particle_normal_js__WEBPACK_IMPORTED_MODULE_127__[\"default\"],\n  particle_normalMapPS: _particle_frag_particle_normalMap_js__WEBPACK_IMPORTED_MODULE_128__[\"default\"],\n  particle_pointAlongVS: _particle_vert_particle_pointAlong_js__WEBPACK_IMPORTED_MODULE_129__[\"default\"],\n  particle_softPS: _particle_frag_particle_soft_js__WEBPACK_IMPORTED_MODULE_130__[\"default\"],\n  particle_softVS: _particle_vert_particle_soft_js__WEBPACK_IMPORTED_MODULE_131__[\"default\"],\n  particle_stretchVS: _particle_vert_particle_stretch_js__WEBPACK_IMPORTED_MODULE_132__[\"default\"],\n  particle_TBNVS: _particle_vert_particle_TBN_js__WEBPACK_IMPORTED_MODULE_133__[\"default\"],\n  particle_wrapVS: _particle_vert_particle_wrap_js__WEBPACK_IMPORTED_MODULE_134__[\"default\"],\n  reflDirPS: _lit_frag_reflDir_js__WEBPACK_IMPORTED_MODULE_135__[\"default\"],\n  reflDirAnisoPS: _lit_frag_reflDirAniso_js__WEBPACK_IMPORTED_MODULE_136__[\"default\"],\n  reflectionCCPS: _lit_frag_reflectionCC_js__WEBPACK_IMPORTED_MODULE_137__[\"default\"],\n  reflectionCubePS: _lit_frag_reflectionCube_js__WEBPACK_IMPORTED_MODULE_138__[\"default\"],\n  reflectionEnvHQPS: _lit_frag_reflectionEnvHQ_js__WEBPACK_IMPORTED_MODULE_139__[\"default\"],\n  reflectionEnvPS: _lit_frag_reflectionEnv_js__WEBPACK_IMPORTED_MODULE_140__[\"default\"],\n  reflectionSpherePS: _lit_frag_reflectionSphere_js__WEBPACK_IMPORTED_MODULE_141__[\"default\"],\n  reflectionSphereLowPS: _lit_frag_reflectionSphereLow_js__WEBPACK_IMPORTED_MODULE_142__[\"default\"],\n  reflectionSheenPS: _lit_frag_reflectionSheen_js__WEBPACK_IMPORTED_MODULE_143__[\"default\"],\n  refractionCubePS: _lit_frag_refractionCube_js__WEBPACK_IMPORTED_MODULE_144__[\"default\"],\n  refractionDynamicPS: _lit_frag_refractionDynamic_js__WEBPACK_IMPORTED_MODULE_145__[\"default\"],\n  reprojectPS: _common_frag_reproject_js__WEBPACK_IMPORTED_MODULE_146__[\"default\"],\n  screenDepthPS: _common_frag_screenDepth_js__WEBPACK_IMPORTED_MODULE_147__[\"default\"],\n  shadowCascadesPS: _lit_frag_shadowCascades_js__WEBPACK_IMPORTED_MODULE_148__[\"default\"],\n  shadowCommonPS: _lit_frag_shadowCommon_js__WEBPACK_IMPORTED_MODULE_149__[\"default\"],\n  shadowCoordPS: _lit_frag_shadowCoord_js__WEBPACK_IMPORTED_MODULE_150__[\"default\"],\n  shadowCoordPerspZbufferPS: _lit_frag_shadowCoordPerspZbuffer_js__WEBPACK_IMPORTED_MODULE_151__[\"default\"],\n  shadowEVSMPS: _lit_frag_shadowEVSM_js__WEBPACK_IMPORTED_MODULE_152__[\"default\"],\n  shadowEVSMnPS: _lit_frag_shadowEVSMn_js__WEBPACK_IMPORTED_MODULE_153__[\"default\"],\n  shadowStandardPS: _lit_frag_shadowStandard_js__WEBPACK_IMPORTED_MODULE_154__[\"default\"],\n  shadowStandardGL2PS: _lit_frag_shadowStandardGL2_js__WEBPACK_IMPORTED_MODULE_155__[\"default\"],\n  shadowVSM8PS: _lit_frag_shadowVSM8_js__WEBPACK_IMPORTED_MODULE_156__[\"default\"],\n  shadowVSM_commonPS: _lit_frag_shadowVSM_common_js__WEBPACK_IMPORTED_MODULE_157__[\"default\"],\n  skinBatchConstVS: _common_vert_skinBatchConst_js__WEBPACK_IMPORTED_MODULE_158__[\"default\"],\n  skinBatchTexVS: _common_vert_skinBatchTex_js__WEBPACK_IMPORTED_MODULE_159__[\"default\"],\n  skinConstVS: _common_vert_skinConst_js__WEBPACK_IMPORTED_MODULE_160__[\"default\"],\n  skinTexVS: _common_vert_skinTex_js__WEBPACK_IMPORTED_MODULE_161__[\"default\"],\n  skyboxEnvPS: _skybox_frag_skyboxEnv_js__WEBPACK_IMPORTED_MODULE_162__[\"default\"],\n  skyboxHDRPS: _skybox_frag_skyboxHDR_js__WEBPACK_IMPORTED_MODULE_163__[\"default\"],\n  skyboxVS: _skybox_vert_skybox_js__WEBPACK_IMPORTED_MODULE_164__[\"default\"],\n  specularPS: _standard_frag_specular_js__WEBPACK_IMPORTED_MODULE_165__[\"default\"],\n  sphericalPS: _common_frag_spherical_js__WEBPACK_IMPORTED_MODULE_166__[\"default\"],\n  specularityFactorPS: _standard_frag_specularityFactor_js__WEBPACK_IMPORTED_MODULE_167__[\"default\"],\n  spotPS: _lit_frag_spot_js__WEBPACK_IMPORTED_MODULE_168__[\"default\"],\n  startPS: _lit_frag_start_js__WEBPACK_IMPORTED_MODULE_169__[\"default\"],\n  startVS: _lit_vert_start_js__WEBPACK_IMPORTED_MODULE_170__[\"default\"],\n  startNineSlicedPS: _lit_frag_startNineSliced_js__WEBPACK_IMPORTED_MODULE_171__[\"default\"],\n  startNineSlicedTiledPS: _lit_frag_startNineSlicedTiled_js__WEBPACK_IMPORTED_MODULE_172__[\"default\"],\n  storeEVSMPS: _lit_frag_storeEVSM_js__WEBPACK_IMPORTED_MODULE_173__[\"default\"],\n  tangentBinormalVS: _lit_vert_tangentBinormal_js__WEBPACK_IMPORTED_MODULE_174__[\"default\"],\n  TBNPS: _lit_frag_TBN_js__WEBPACK_IMPORTED_MODULE_175__[\"default\"],\n  TBNderivativePS: _lit_frag_TBNderivative_js__WEBPACK_IMPORTED_MODULE_176__[\"default\"],\n  TBNfastPS: _lit_frag_TBNfast_js__WEBPACK_IMPORTED_MODULE_177__[\"default\"],\n  TBNObjectSpacePS: _lit_frag_TBNObjectSpace_js__WEBPACK_IMPORTED_MODULE_178__[\"default\"],\n  textureSamplePS: _standard_frag_textureSample_js__WEBPACK_IMPORTED_MODULE_179__[\"default\"],\n  thicknessPS: _standard_frag_thickness_js__WEBPACK_IMPORTED_MODULE_180__[\"default\"],\n  tonemappingAcesPS: _common_frag_tonemappingAces_js__WEBPACK_IMPORTED_MODULE_181__[\"default\"],\n  tonemappingAces2PS: _common_frag_tonemappingAces2_js__WEBPACK_IMPORTED_MODULE_182__[\"default\"],\n  tonemappingFilmicPS: _common_frag_tonemappingFilmic_js__WEBPACK_IMPORTED_MODULE_183__[\"default\"],\n  tonemappingHejlPS: _common_frag_tonemappingHejl_js__WEBPACK_IMPORTED_MODULE_184__[\"default\"],\n  tonemappingLinearPS: _common_frag_tonemappingLinear_js__WEBPACK_IMPORTED_MODULE_185__[\"default\"],\n  tonemappingNonePS: _common_frag_tonemappingNone_js__WEBPACK_IMPORTED_MODULE_186__[\"default\"],\n  transformVS: _common_vert_transform_js__WEBPACK_IMPORTED_MODULE_187__[\"default\"],\n  transformDeclVS: _common_vert_transformDecl_js__WEBPACK_IMPORTED_MODULE_188__[\"default\"],\n  transmissionPS: _standard_frag_transmission_js__WEBPACK_IMPORTED_MODULE_189__[\"default\"],\n  uv0VS: _lit_vert_uv0_js__WEBPACK_IMPORTED_MODULE_190__[\"default\"],\n  uv1VS: _lit_vert_uv1_js__WEBPACK_IMPORTED_MODULE_191__[\"default\"],\n  viewDirPS: _lit_frag_viewDir_js__WEBPACK_IMPORTED_MODULE_192__[\"default\"],\n  viewNormalVS: _lit_vert_viewNormal_js__WEBPACK_IMPORTED_MODULE_193__[\"default\"],\n  webgpuPS: _platform_graphics_shader_chunks_frag_webgpu_js__WEBPACK_IMPORTED_MODULE_194__[\"default\"],\n  webgpuVS: _platform_graphics_shader_chunks_vert_webgpu_js__WEBPACK_IMPORTED_MODULE_195__[\"default\"]\n};\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/chunks.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/decode.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/decode.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ decodePS)\n/* harmony export */ });\nvar decodePS = `\nvec3 decodeLinear(vec4 raw) {\n    return raw.rgb;\n}\n\nfloat decodeGamma(float raw) {\n    return pow(raw, 2.2);\n}\n\nvec3 decodeGamma(vec3 raw) {\n    return pow(raw, vec3(2.2));\n}\n\nvec3 decodeGamma(vec4 raw) {\n    return pow(raw.xyz, vec3(2.2));\n}\n\nvec3 decodeRGBM(vec4 raw) {\n    vec3 color = (8.0 * raw.a) * raw.rgb;\n    return color * color;\n}\n\nvec3 decodeRGBP(vec4 raw) {\n    vec3 color = raw.rgb * (-raw.a * 7.0 + 8.0);\n    return color * color;\n}\n\nvec3 decodeRGBE(vec4 raw) {\n    if (raw.a == 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    } else {\n        return raw.xyz * pow(2.0, raw.w * 255.0 - 128.0);\n    }\n}\n\nvec4 passThrough(vec4 raw) {\n    return raw;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/decode.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/encode.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/encode.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ encodePS)\n/* harmony export */ });\nvar encodePS = `\nvec4 encodeLinear(vec3 source) {\n    return vec4(source, 1.0);\n}\n\nvec4 encodeGamma(vec3 source) {\n    return vec4(pow(source + 0.0000001, vec3(1.0 / 2.2)), 1.0);\n}\n\nvec4 encodeRGBM(vec3 source) { // modified RGBM\n    vec4 result;\n    result.rgb = pow(source.rgb, vec3(0.5));\n    result.rgb *= 1.0 / 8.0;\n\n    result.a = saturate( max( max( result.r, result.g ), max( result.b, 1.0 / 255.0 ) ) );\n    result.a = ceil(result.a * 255.0) / 255.0;\n\n    result.rgb /= result.a;\n    return result;\n}\n\nvec4 encodeRGBP(vec3 source) {\n    // convert incoming linear to gamma(ish)\n    vec3 gamma = pow(source, vec3(0.5));\n\n    // calculate the maximum component clamped to 1..8\n    float maxVal = min(8.0, max(1.0, max(gamma.x, max(gamma.y, gamma.z))));\n\n    // calculate storage factor\n    float v = 1.0 - ((maxVal - 1.0) / 7.0);\n\n    // round the value for storage in 8bit channel\n    v = ceil(v * 255.0) / 255.0;\n\n    return vec4(gamma / (-v * 7.0 + 8.0), v);    \n}\n\nvec4 encodeRGBE(vec3 source) {\n    float maxVal = max(source.x, max(source.y, source.z));\n    if (maxVal < 1e-32) {\n        return vec4(0, 0, 0, 0);\n    } else {\n        float e = ceil(log2(maxVal));\n        return vec4(source / pow(2.0, e), (e + 128.0) / 255.0);\n    }\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/encode.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/envAtlas.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/envAtlas.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ envAtlasPS)\n/* harmony export */ });\nvar envAtlasPS = `\n// the envAtlas is fixed at 512 pixels. every equirect is generated with 1 pixel boundary.\nconst float atlasSize = 512.0;\nconst float seamSize = 1.0 / atlasSize;\n\n// map a normalized equirect UV to the given rectangle (taking 1 pixel seam into account).\nvec2 mapUv(vec2 uv, vec4 rect) {\n    return vec2(mix(rect.x + seamSize, rect.x + rect.z - seamSize, uv.x),\n                mix(rect.y + seamSize, rect.y + rect.w - seamSize, uv.y));\n}\n\n// map a normalized equirect UV and roughness level to the correct atlas rect.\nvec2 mapRoughnessUv(vec2 uv, float level) {\n    float t = 1.0 / exp2(level);\n    return mapUv(uv, vec4(0, 1.0 - t, t, t * 0.5));\n}\n\n// map shiny level UV\nvec2 mapShinyUv(vec2 uv, float level) {\n    float t = 1.0 / exp2(level);\n    return mapUv(uv, vec4(1.0 - t, 1.0 - t, t, t * 0.5));\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/envAtlas.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/envConst.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/envConst.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ envConstPS)\n/* harmony export */ });\nvar envConstPS = `\nvec3 processEnvironment(vec3 color) {\n    return color;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/envConst.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/envMultiply.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/envMultiply.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ envMultiplyPS)\n/* harmony export */ });\nvar envMultiplyPS = `\nuniform float skyboxIntensity;\n\nvec3 processEnvironment(vec3 color) {\n    return color * skyboxIntensity;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/envMultiply.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/fixCubemapSeamsNone.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/fixCubemapSeamsNone.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fixCubemapSeamsNonePS)\n/* harmony export */ });\nvar fixCubemapSeamsNonePS = `\nvec3 fixSeams(vec3 vec, float mipmapIndex) {\n    return vec;\n}\n\nvec3 fixSeams(vec3 vec) {\n    return vec;\n}\n\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\n    return vec;\n}\n\nvec3 calcSeam(vec3 vec) {\n    return vec3(0);\n}\n\nvec3 applySeam(vec3 vec, vec3 seam, float scale) {\n    return vec;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/fixCubemapSeamsNone.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/fixCubemapSeamsStretch.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/fixCubemapSeamsStretch.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fixCubemapSeamsStretchPS)\n/* harmony export */ });\nvar fixCubemapSeamsStretchPS = `\nvec3 fixSeams(vec3 vec, float mipmapIndex) {\n    vec3 avec = abs(vec);\n    float scale = 1.0 - exp2(mipmapIndex) / 128.0;\n    float M = max(max(avec.x, avec.y), avec.z);\n    if (avec.x != M) vec.x *= scale;\n    if (avec.y != M) vec.y *= scale;\n    if (avec.z != M) vec.z *= scale;\n    return vec;\n}\n\nvec3 fixSeams(vec3 vec) {\n    vec3 avec = abs(vec);\n    float scale = 1.0 - 1.0 / 128.0;\n    float M = max(max(avec.x, avec.y), avec.z);\n    if (avec.x != M) vec.x *= scale;\n    if (avec.y != M) vec.y *= scale;\n    if (avec.z != M) vec.z *= scale;\n    return vec;\n}\n\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\n    vec3 avec = abs(vec);\n    float scale = invRecMipSize;\n    float M = max(max(avec.x, avec.y), avec.z);\n    if (avec.x != M) vec.x *= scale;\n    if (avec.y != M) vec.y *= scale;\n    if (avec.z != M) vec.z *= scale;\n    return vec;\n}\n\nvec3 calcSeam(vec3 vec) {\n    vec3 avec = abs(vec);\n    float M = max(avec.x, max(avec.y, avec.z));\n    return vec3(avec.x != M ? 1.0 : 0.0,\n                avec.y != M ? 1.0 : 0.0,\n                avec.z != M ? 1.0 : 0.0);\n}\n\nvec3 applySeam(vec3 vec, vec3 seam, float scale) {\n    return vec * (seam * -scale + vec3(1.0));\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/fixCubemapSeamsStretch.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/fullscreenQuad.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/fullscreenQuad.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fullscreenQuadPS)\n/* harmony export */ });\nvar fullscreenQuadPS = `\nvarying vec2 vUv0;\n\nuniform sampler2D source;\n\nvoid main(void) {\n    gl_FragColor = texture2D(source, vUv0);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/fullscreenQuad.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/gamma1_0.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/gamma1_0.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ gamma1_0PS)\n/* harmony export */ });\nvar gamma1_0PS = `\nfloat gammaCorrectInput(float color) {\n    return color;\n}\n\nvec3 gammaCorrectInput(vec3 color) {\n    return color;\n}\n\nvec4 gammaCorrectInput(vec4 color) {\n    return color;\n}\n\nvec3 gammaCorrectOutput(vec3 color) {\n    return color;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/gamma1_0.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/gamma2_2.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/gamma2_2.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ gamma2_2PS)\n/* harmony export */ });\nvar gamma2_2PS = `\nfloat gammaCorrectInput(float color) {\n    return decodeGamma(color);\n}\n\nvec3 gammaCorrectInput(vec3 color) {\n    return decodeGamma(color);\n}\n\nvec4 gammaCorrectInput(vec4 color) {\n    return vec4(decodeGamma(color.xyz), color.w);\n}\n\nvec3 gammaCorrectOutput(vec3 color) {\n#ifdef HDR\n    return color;\n#else\n    return pow(color + 0.0000001, vec3(1.0 / 2.2));\n#endif\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/gamma2_2.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/msdf.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/msdf.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ msdfPS)\n/* harmony export */ });\nvar msdfPS = `\nuniform sampler2D texture_msdfMap;\n\n#ifdef GL_OES_standard_derivatives\n#define USE_FWIDTH\n#endif\n\n#ifdef GL2\n#define USE_FWIDTH\n#endif\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat map (float min, float max, float v) {\n    return (v - min) / (max - min);\n}\n\nuniform float font_sdfIntensity; // intensity is used to boost the value read from the SDF, 0 is no boost, 1.0 is max boost\nuniform float font_pxrange;      // the number of pixels between inside and outside the font in SDF\nuniform float font_textureWidth; // the width of the texture atlas\n\n#ifdef UNIFORM_TEXT_PARAMETERS\nuniform vec4 outline_color;\nuniform float outline_thickness;\nuniform vec4 shadow_color;\nuniform vec2 shadow_offset;\n#else\nvarying vec4 outline_color;\nvarying float outline_thickness;\nvarying vec4 shadow_color;\nvarying vec2 shadow_offset;\n#endif\n\nvec4 applyMsdf(vec4 color) {\n    // sample the field\n    vec3 tsample = texture2D(texture_msdfMap, vUv0).rgb;\n    vec2 uvShdw = vUv0 - shadow_offset;\n    vec3 ssample = texture2D(texture_msdfMap, uvShdw).rgb;\n    // get the signed distance value\n    float sigDist = median(tsample.r, tsample.g, tsample.b);\n    float sigDistShdw = median(ssample.r, ssample.g, ssample.b);\n\n    // smoothing limit - smaller value makes for sharper but more aliased text, especially on angles\n    // too large value (0.5) creates a dark glow around the letters\n    float smoothingMax = 0.2;\n\n    #ifdef USE_FWIDTH\n    // smoothing depends on size of texture on screen\n    vec2 w = fwidth(vUv0);\n    float smoothing = clamp(w.x * font_textureWidth / font_pxrange, 0.0, smoothingMax);\n    #else\n    float font_size = 16.0; // TODO fix this\n    // smoothing gets smaller as the font size gets bigger\n    // don't have fwidth we can approximate from font size, this doesn't account for scaling\n    // so a big font scaled down will be wrong...\n    float smoothing = clamp(font_pxrange / font_size, 0.0, smoothingMax);\n    #endif\n\n    float mapMin = 0.05;\n    float mapMax = clamp(1.0 - font_sdfIntensity, mapMin, 1.0);\n\n    // remap to a smaller range (used on smaller font sizes)\n    float sigDistInner = map(mapMin, mapMax, sigDist);\n    float sigDistOutline = map(mapMin, mapMax, sigDist + outline_thickness);\n    sigDistShdw = map(mapMin, mapMax, sigDistShdw + outline_thickness);\n\n    float center = 0.5;\n    // calculate smoothing and use to generate opacity\n    float inside = smoothstep(center-smoothing, center+smoothing, sigDistInner);\n    float outline = smoothstep(center-smoothing, center+smoothing, sigDistOutline);\n    float shadow = smoothstep(center-smoothing, center+smoothing, sigDistShdw);\n\n    vec4 tcolor = (outline > inside) ? outline * vec4(outline_color.a * outline_color.rgb, outline_color.a) : vec4(0.0);\n    tcolor = mix(tcolor, color, inside);\n\n    vec4 scolor = (shadow > outline) ? shadow * vec4(shadow_color.a * shadow_color.rgb, shadow_color.a) : tcolor;\n    tcolor = mix(scolor, tcolor, outline);\n    \n    return tcolor;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/msdf.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/outputTex2D.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/outputTex2D.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ outputTex2DPS)\n/* harmony export */ });\nvar outputTex2DPS = `\nvarying vec2 vUv0;\n\nuniform sampler2D source;\n\nvoid main(void) {\n    gl_FragColor = texture2D(source, vUv0);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/outputTex2D.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/packDepth.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/packDepth.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ packDepthPS)\n/* harmony export */ });\nvar packDepthPS = `\n// Packing a float in GLSL with multiplication and mod\n// http://blog.gradientstudios.com/2012/08/23/shadow-map-improvement\nvec4 packFloat(float depth) {\n    const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n    const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\n    // combination of mod and multiplication and division works better\n    vec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n    res -= res.xxyz * bit_mask;\n    return res;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/packDepth.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/reproject.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/reproject.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ reprojectPS)\n/* harmony export */ });\n/* harmony import */ var _decode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decode.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/decode.js\");\n/* harmony import */ var _encode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./encode.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/encode.js\");\n\n\n\nvar reprojectPS = `\n// This shader requires the following #DEFINEs:\n//\n// PROCESS_FUNC - must be one of reproject, prefilter\n// DECODE_FUNC - must be one of decodeRGBM, decodeRGBE, decodeGamma or decodeLinear\n// ENCODE_FUNC - must be one of encodeRGBM, encodeRGBE, encideGamma or encodeLinear\n// SOURCE_FUNC - must be one of sampleCubemap, sampleEquirect, sampleOctahedral\n// TARGET_FUNC - must be one of getDirectionCubemap, getDirectionEquirect, getDirectionOctahedral\n//\n// When filtering:\n// NUM_SAMPLES - number of samples\n// NUM_SAMPLES_SQRT - sqrt of number of samples\n//\n// SUPPORTS_TEXLOD - whether supports texlod is supported\n\nvarying vec2 vUv0;\n\n// source\nuniform sampler2D sourceTex;\nuniform samplerCube sourceCube;\n\n// samples\nuniform sampler2D samplesTex;\nuniform vec2 samplesTexInverseSize;\n\n// params:\n// x - target cubemap face 0..6\n// y - specular power (when prefiltering)\n// z - source cubemap seam scale (0 to disable)\n// w - target cubemap size for seam calc (0 to disable)\nuniform vec4 params;\n\n// params2:\n// x - target image total pixels\n// y - source cubemap size\nuniform vec2 params2;\n\nfloat targetFace() { return params.x; }\nfloat specularPower() { return params.y; }\nfloat sourceCubeSeamScale() { return params.z; }\nfloat targetCubeSeamScale() { return params.w; }\n\nfloat targetTotalPixels() { return params2.x; }\nfloat sourceTotalPixels() { return params2.y; }\n\nfloat PI = 3.141592653589793;\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\n${_decode_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]}\n${_encode_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]}\n\n//-- supported projections\n\nvec3 modifySeams(vec3 dir, float scale) {\n    vec3 adir = abs(dir);\n    float M = max(max(adir.x, adir.y), adir.z);\n    return dir / M * vec3(\n        adir.x == M ? 1.0 : scale,\n        adir.y == M ? 1.0 : scale,\n        adir.z == M ? 1.0 : scale\n    );\n}\n\nvec2 toSpherical(vec3 dir) {\n    return vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));\n}\n\nvec3 fromSpherical(vec2 uv) {\n    return vec3(cos(uv.y) * sin(uv.x),\n                sin(uv.y),\n                cos(uv.y) * cos(uv.x));\n}\n\nvec3 getDirectionEquirect() {\n    return fromSpherical((vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0) * vec2(PI, PI * 0.5));\n}\n\nvec4 sampleEquirect(vec2 sph) {\n    vec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;\n    return texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n}\n\nvec4 sampleEquirect(vec3 dir) {\n    return sampleEquirect(toSpherical(dir));\n}\n\nvec4 sampleCubemap(vec3 dir) {\n    return textureCube(sourceCube, modifySeams(dir, 1.0 - sourceCubeSeamScale()));\n}\n\nvec4 sampleCubemap(vec2 sph) {\n    return sampleCubemap(fromSpherical(sph));\n}\n\nvec4 sampleEquirect(vec2 sph, float mipLevel) {\n    vec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;\n#ifdef SUPPORTS_TEXLOD\n    return texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);\n#else\n    return texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n#endif\n}\n\nvec4 sampleEquirect(vec3 dir, float mipLevel) {\n    return sampleEquirect(toSpherical(dir), mipLevel);\n}\n\nvec4 sampleCubemap(vec3 dir, float mipLevel) {\n#ifdef SUPPORTS_TEXLOD\n    return textureCubeLodEXT(sourceCube, modifySeams(dir, 1.0 - exp2(mipLevel) * sourceCubeSeamScale()), mipLevel);\n#else\n    return textureCube(sourceCube, modifySeams(dir, 1.0 - exp2(mipLevel) * sourceCubeSeamScale()));\n#endif\n}\n\nvec4 sampleCubemap(vec2 sph, float mipLevel) {\n    return sampleCubemap(fromSpherical(sph), mipLevel);\n}\n\n// octahedral code, based on http://jcgt.org/published/0003/02/01\n// \"Survey of Efficient Representations for Independent Unit Vectors\" by Cigolle, Donow, Evangelakos, Mara, McGuire, Meyer\n\nfloat signNotZero(float k){\n    return(k >= 0.0) ? 1.0 : -1.0;\n}\n\nvec2 signNotZero(vec2 v) {\n    return vec2(signNotZero(v.x), signNotZero(v.y));\n}\n\n// Returns a unit vector. Argument o is an octahedral vector packed via octEncode, on the [-1, +1] square\nvec3 octDecode(vec2 o) {\n    vec3 v = vec3(o.x, 1.0 - abs(o.x) - abs(o.y), o.y);\n    if (v.y < 0.0) {\n        v.xz = (1.0 - abs(v.zx)) * signNotZero(v.xz);\n    }\n    return normalize(v);\n}\n\nvec3 getDirectionOctahedral() {\n    return octDecode(vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0);\n}\n\n// Assumes that v is a unit vector. The result is an octahedral vector on the [-1, +1] square\nvec2 octEncode(in vec3 v) {\n    float l1norm = abs(v.x) + abs(v.y) + abs(v.z);\n    vec2 result = v.xz * (1.0 / l1norm);\n    if (v.y < 0.0) {\n        result = (1.0 - abs(result.yx)) * signNotZero(result.xy);\n    }\n    return result;\n}\n\nvec4 sampleOctahedral(vec3 dir) {\n    vec2 uv = octEncode(dir) * 0.5 + 0.5;\n    return texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n}\n\nvec4 sampleOctahedral(vec2 sph) {\n    return sampleOctahedral(fromSpherical(sph));\n}\n\nvec4 sampleOctahedral(vec3 dir, float mipLevel) {\n    vec2 uv = octEncode(dir) * 0.5 + 0.5;\n#ifdef SUPPORTS_TEXLOD\n    return texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);\n#else\n    return texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n#endif\n}\n\nvec4 sampleOctahedral(vec2 sph, float mipLevel) {\n    return sampleOctahedral(fromSpherical(sph), mipLevel);\n}\n\n/////////////////////////////////////////////////////////////////////\n\nvec3 getDirectionCubemap() {\n    vec2 st = vUv0 * 2.0 - 1.0;\n    float face = targetFace();\n\n    vec3 vec;\n    if (face == 0.0) {\n        vec = vec3(1, -st.y, -st.x);\n    } else if (face == 1.0) {\n        vec = vec3(-1, -st.y, st.x);\n    } else if (face == 2.0) {\n        vec = vec3(st.x, 1, st.y);\n    } else if (face == 3.0) {\n        vec = vec3(st.x, -1, -st.y);\n    } else if (face == 4.0) {\n        vec = vec3(st.x, -st.y, 1);\n    } else {\n        vec = vec3(-st.x, -st.y, -1);\n    }\n\n    return normalize(modifySeams(vec, 1.0 / (1.0 - targetCubeSeamScale())));\n}\n\nmat3 matrixFromVector(vec3 n) { // frisvad\n    float a = 1.0 / (1.0 + n.z);\n    float b = -n.x * n.y * a;\n    vec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n    vec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n    return mat3(b1, b2, n);\n}\n\nmat3 matrixFromVectorSlow(vec3 n) {\n    vec3 up = (1.0 - abs(n.y) <= 0.0000001) ? vec3(0.0, 0.0, n.y > 0.0 ? 1.0 : -1.0) : vec3(0.0, 1.0, 0.0);\n    vec3 x = normalize(cross(up, n));\n    vec3 y = cross(n, x);\n    return mat3(x, y, n);\n}\n\nvec4 reproject() {\n    if (NUM_SAMPLES <= 1) {\n        // single sample\n        return ENCODE_FUNC(DECODE_FUNC(SOURCE_FUNC(TARGET_FUNC())));\n    } else {\n        // multi sample\n        vec3 t = TARGET_FUNC();\n        vec3 tu = dFdx(t);\n        vec3 tv = dFdy(t);\n\n        vec3 result = vec3(0.0);\n        for (float u = 0.0; u < NUM_SAMPLES_SQRT; ++u) {\n            for (float v = 0.0; v < NUM_SAMPLES_SQRT; ++v) {\n                result += DECODE_FUNC(SOURCE_FUNC(normalize(t +\n                                                            tu * (u / NUM_SAMPLES_SQRT - 0.5) +\n                                                            tv * (v / NUM_SAMPLES_SQRT - 0.5))));\n            }\n        }\n        return ENCODE_FUNC(result / (NUM_SAMPLES_SQRT * NUM_SAMPLES_SQRT));\n    }\n}\n\nvec4 unpackFloat = vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0);\n\nvoid unpackSample(int i, out vec3 L, out float mipLevel) {\n    float u = (float(i * 4) + 0.5) * samplesTexInverseSize.x;\n    float v = (floor(u) + 0.5) * samplesTexInverseSize.y;\n\n    vec4 raw;\n    raw.x = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n    raw.y = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n    raw.z = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n    raw.w = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat);\n\n    L.xyz = raw.xyz * 2.0 - 1.0;\n    mipLevel = raw.w * 8.0;\n}\n\n// convolve an environment given pre-generated samples\nvec4 prefilterSamples() {\n    // construct vector space given target direction\n    mat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());\n\n    vec3 L;\n    float mipLevel;\n\n    vec3 result = vec3(0.0);\n    float totalWeight = 0.0;\n    for (int i = 0; i < NUM_SAMPLES; ++i) {\n        unpackSample(i, L, mipLevel);\n        result += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel)) * L.z;\n        totalWeight += L.z;\n    }\n\n    return ENCODE_FUNC(result / totalWeight);\n}\n\n// unweighted version of prefilterSamples\nvec4 prefilterSamplesUnweighted() {\n    // construct vector space given target direction\n    mat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());\n\n    vec3 L;\n    float mipLevel;\n\n    vec3 result = vec3(0.0);\n    float totalWeight = 0.0;\n    for (int i = 0; i < NUM_SAMPLES; ++i) {\n        unpackSample(i, L, mipLevel);\n        result += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel));\n    }\n\n    return ENCODE_FUNC(result / float(NUM_SAMPLES));\n}\n\nvoid main(void) {\n    gl_FragColor = PROCESS_FUNC();\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/reproject.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/screenDepth.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/screenDepth.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ screenDepthPS)\n/* harmony export */ });\nvar screenDepthPS = `\nuniform highp sampler2D uSceneDepthMap;\n\n#ifndef SCREENSIZE\n#define SCREENSIZE\nuniform vec4 uScreenSize;\n#endif\n\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n\n\n\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params; // 1 / camera_far,      camera_far,     camera_near,        is_ortho\n#endif\n\n#ifdef GL2\nfloat linearizeDepth(float z) {\n    if (camera_params.w == 0.0)\n        return (camera_params.z * camera_params.y) / (camera_params.y + z * (camera_params.z - camera_params.y));\n    else\n        return camera_params.z + z * (camera_params.y - camera_params.z);\n}\n#else\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n    const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n    return dot(rgbaDepth, bitShift);\n}\n#endif\n#endif\n\n// Retrieves rendered linear camera depth by UV\nfloat getLinearScreenDepth(vec2 uv) {\n    #ifdef GL2\n        return linearizeDepth(texture2D(uSceneDepthMap, uv).r);\n    #else\n        return unpackFloat(texture2D(uSceneDepthMap, uv)) * camera_params.y;\n    #endif\n}\n\n#ifndef VERTEXSHADER\n// Retrieves rendered linear camera depth under the current pixel\nfloat getLinearScreenDepth() {\n    vec2 uv = gl_FragCoord.xy * uScreenSize.zw;\n    return getLinearScreenDepth(uv);\n}\n#endif\n\n// Generates linear camera depth for the given world position\nfloat getLinearDepth(vec3 pos) {\n    return -(matrix_view * vec4(pos, 1.0)).z;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/screenDepth.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/spherical.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/spherical.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ sphericalPS)\n/* harmony export */ });\nvar sphericalPS = `\n// equirectangular helper functions\nconst float PI = 3.141592653589793;\n\nvec2 toSpherical(vec3 dir) {\n    return vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));\n}\n\nvec2 toSphericalUv(vec3 dir) {\n    vec2 uv = toSpherical(dir) / vec2(PI * 2.0, PI) + 0.5;\n    return vec2(uv.x, 1.0 - uv.y);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/spherical.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/tonemappingAces.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/tonemappingAces.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ tonemappingAcesPS)\n/* harmony export */ });\nvar tonemappingAcesPS = `\nuniform float exposure;\n\nvec3 toneMap(vec3 color) {\n    float tA = 2.51;\n    float tB = 0.03;\n    float tC = 2.43;\n    float tD = 0.59;\n    float tE = 0.14;\n    vec3 x = color * exposure;\n    return (x*(tA*x+tB))/(x*(tC*x+tD)+tE);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/tonemappingAces.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/tonemappingAces2.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/tonemappingAces2.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ tonemappingAces2PS)\n/* harmony export */ });\nvar tonemappingAces2PS = `\nuniform float exposure;\n\n// ACES approximation by Stephen Hill\n\n// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v) {\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 toneMap(vec3 color) {\n    color *= exposure;\n    color = color * ACESInputMat;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n    color = color * ACESOutputMat;\n\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/tonemappingAces2.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/tonemappingFilmic.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/tonemappingFilmic.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ tonemappingFilmicPS)\n/* harmony export */ });\nvar tonemappingFilmicPS = `\nconst float A =  0.15;\nconst float B =  0.50;\nconst float C =  0.10;\nconst float D =  0.20;\nconst float E =  0.02;\nconst float F =  0.30;\nconst float W =  11.2;\n\nuniform float exposure;\n\nvec3 uncharted2Tonemap(vec3 x) {\n   return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\nvec3 toneMap(vec3 color) {\n    color = uncharted2Tonemap(color * exposure);\n    vec3 whiteScale = 1.0 / uncharted2Tonemap(vec3(W,W,W));\n    color = color * whiteScale;\n\n    return color;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/tonemappingFilmic.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/tonemappingHejl.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/tonemappingHejl.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ tonemappingHejlPS)\n/* harmony export */ });\nvar tonemappingHejlPS = `\nuniform float exposure;\n\nvec3 toneMap(vec3 color) {\n    color *= exposure;\n    const float  A = 0.22, B = 0.3, C = .1, D = 0.2, E = .01, F = 0.3;\n    const float Scl = 1.25;\n\n    vec3 h = max( vec3(0.0), color - vec3(0.004) );\n    return (h*((Scl*A)*h+Scl*vec3(C*B,C*B,C*B))+Scl*vec3(D*E,D*E,D*E)) / (h*(A*h+vec3(B,B,B))+vec3(D*F,D*F,D*F)) - Scl*vec3(E/F,E/F,E/F);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/tonemappingHejl.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/tonemappingLinear.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/tonemappingLinear.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ tonemappingLinearPS)\n/* harmony export */ });\nvar tonemappingLinearPS = `\nuniform float exposure;\n\nvec3 toneMap(vec3 color) {\n    return color * exposure;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/tonemappingLinear.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/tonemappingNone.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/tonemappingNone.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ tonemappingNonePS)\n/* harmony export */ });\nvar tonemappingNonePS = `\nvec3 toneMap(vec3 color) {\n    return color;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/frag/tonemappingNone.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/fullscreenQuad.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/fullscreenQuad.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fullscreenQuadVS)\n/* harmony export */ });\nvar fullscreenQuadVS = `\nattribute vec2 vertex_position;\n\nvarying vec2 vUv0;\n\nvoid main(void)\n{\n    gl_Position = vec4(vertex_position, 0.5, 1.0);\n    vUv0 = vertex_position.xy*0.5+0.5;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/fullscreenQuad.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/msdf.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/msdf.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ msdfVS)\n/* harmony export */ });\nvar msdfVS = `\nattribute vec3 vertex_outlineParameters;\nattribute vec3 vertex_shadowParameters;\n\nvarying vec4 outline_color;\nvarying float outline_thickness;\nvarying vec4 shadow_color;\nvarying vec2 shadow_offset;\n\nvoid unpackMsdfParams() {\n    vec3 little = mod(vertex_outlineParameters, 256.);\n    vec3 big = (vertex_outlineParameters - little) / 256.;\n\n    outline_color.rb = little.xy / 255.;\n    outline_color.ga = big.xy / 255.;\n\n    // _outlineThicknessScale === 0.2\n    outline_thickness = little.z / 255. * 0.2;\n\n    little = mod(vertex_shadowParameters, 256.);\n    big = (vertex_shadowParameters - little) / 256.;\n\n    shadow_color.rb = little.xy / 255.;\n    shadow_color.ga = big.xy / 255.;\n\n    // vec2(little.z, big.z) / 127. - 1. remaps shadow offset from [0, 254] to [-1, 1]\n    // _shadowOffsetScale === 0.005\n    shadow_offset = (vec2(little.z, big.z) / 127. - 1.) * 0.005;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/msdf.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/skinBatchConst.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/skinBatchConst.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ skinBatchConstVS)\n/* harmony export */ });\nvar skinBatchConstVS = `\nattribute float vertex_boneIndices;\n\nuniform vec4 matrix_pose[BONE_LIMIT * 3];\n\nmat4 getBoneMatrix(const in float i) {\n    // read 4x3 matrix\n    vec4 v1 = matrix_pose[int(3.0 * i)];\n    vec4 v2 = matrix_pose[int(3.0 * i + 1.0)];\n    vec4 v3 = matrix_pose[int(3.0 * i + 2.0)];\n\n    // transpose to 4x4 matrix\n    return mat4(\n        v1.x, v2.x, v3.x, 0,\n        v1.y, v2.y, v3.y, 0,\n        v1.z, v2.z, v3.z, 0,\n        v1.w, v2.w, v3.w, 1\n    );\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/skinBatchConst.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/skinBatchTex.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/skinBatchTex.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ skinBatchTexVS)\n/* harmony export */ });\nvar skinBatchTexVS = `\nattribute float vertex_boneIndices;\n\nuniform highp sampler2D texture_poseMap;\nuniform vec4 texture_poseMapSize;\n\nmat4 getBoneMatrix(const in float i) {\n    float j = i * 3.0;\n    float dx = texture_poseMapSize.z;\n    float dy = texture_poseMapSize.w;\n\n    float y = floor(j * dx);\n    float x = j - (y * texture_poseMapSize.x);\n    y = dy * (y + 0.5);\n\n    // read elements of 4x3 matrix\n    vec4 v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n    vec4 v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n    vec4 v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n\n    // transpose to 4x4 matrix\n    return mat4(\n        v1.x, v2.x, v3.x, 0,\n        v1.y, v2.y, v3.y, 0,\n        v1.z, v2.z, v3.z, 0,\n        v1.w, v2.w, v3.w, 1\n    );\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/skinBatchTex.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/skinConst.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/skinConst.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ skinConstVS)\n/* harmony export */ });\nvar skinConstVS = `\nattribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\n\nuniform vec4 matrix_pose[BONE_LIMIT * 3];\n\nvoid getBoneMatrix(const in float i, out vec4 v1, out vec4 v2, out vec4 v3) {\n    // read 4x3 matrix\n    v1 = matrix_pose[int(3.0 * i)];\n    v2 = matrix_pose[int(3.0 * i + 1.0)];\n    v3 = matrix_pose[int(3.0 * i + 2.0)];\n}\n\nmat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {\n    // get 4 bone matrices\n    vec4 a1, a2, a3;\n    getBoneMatrix(indices.x, a1, a2, a3);\n\n    vec4 b1, b2, b3;\n    getBoneMatrix(indices.y, b1, b2, b3);\n\n    vec4 c1, c2, c3;\n    getBoneMatrix(indices.z, c1, c2, c3);\n\n    vec4 d1, d2, d3;\n    getBoneMatrix(indices.w, d1, d2, d3);\n\n    // multiply them by weights and add up to get final 4x3 matrix\n    vec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;\n    vec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;\n    vec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;\n\n    // add up weights\n    float one = dot(weights, vec4(1.0));\n\n    // transpose to 4x4 matrix\n    return mat4(\n        v1.x, v2.x, v3.x, 0,\n        v1.y, v2.y, v3.y, 0,\n        v1.z, v2.z, v3.z, 0,\n        v1.w, v2.w, v3.w, one\n    );\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/skinConst.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/skinTex.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/skinTex.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ skinTexVS)\n/* harmony export */ });\nvar skinTexVS = `\n\nattribute vec4 vertex_boneWeights;\n\n#ifdef WEBGPU\n    attribute uvec4 vertex_boneIndices;\n    #define BoneIndexFormat uint\n    #define BoneIndexFormat4 uvec4\n#else\n    attribute vec4 vertex_boneIndices;\n    #define BoneIndexFormat float\n    #define BoneIndexFormat4 vec4\n#endif\n\nuniform highp sampler2D texture_poseMap;\nuniform vec4 texture_poseMapSize;\n\nvoid getBoneMatrix(const in BoneIndexFormat index, out vec4 v1, out vec4 v2, out vec4 v3) {\n\n    float i = float(index);\n    float j = i * 3.0;\n    float dx = texture_poseMapSize.z;\n    float dy = texture_poseMapSize.w;\n    \n    float y = floor(j * dx);\n    float x = j - (y * texture_poseMapSize.x);\n    y = dy * (y + 0.5);\n\n    // read elements of 4x3 matrix\n    v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n    v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n    v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n}\n\nmat4 getSkinMatrix(const in BoneIndexFormat4 indices, const in vec4 weights) {\n    // get 4 bone matrices\n    vec4 a1, a2, a3;\n    getBoneMatrix(indices.x, a1, a2, a3);\n\n    vec4 b1, b2, b3;\n    getBoneMatrix(indices.y, b1, b2, b3);\n\n    vec4 c1, c2, c3;\n    getBoneMatrix(indices.z, c1, c2, c3);\n\n    vec4 d1, d2, d3;\n    getBoneMatrix(indices.w, d1, d2, d3);\n\n    // multiply them by weights and add up to get final 4x3 matrix\n    vec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;\n    vec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;\n    vec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;\n\n    // add up weights\n    float one = dot(weights, vec4(1.0));\n\n    // transpose to 4x4 matrix\n    return mat4(\n        v1.x, v2.x, v3.x, 0,\n        v1.y, v2.y, v3.y, 0,\n        v1.z, v2.z, v3.z, 0,\n        v1.w, v2.w, v3.w, one\n    );\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/skinTex.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/transform.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/transform.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ transformVS)\n/* harmony export */ });\nvar transformVS = `\n#ifdef PIXELSNAP\nuniform vec4 uScreenSize;\n#endif\n\n#ifdef SCREENSPACE\nuniform float projectionFlipY;\n#endif\n\n#ifdef MORPHING\nuniform vec4 morph_weights_a;\nuniform vec4 morph_weights_b;\n#endif\n\n#ifdef MORPHING_TEXTURE_BASED\nuniform vec4 morph_tex_params;\n\nvec2 getTextureMorphCoords() {\n    float vertexId = morph_vertex_id;\n    vec2 textureSize = morph_tex_params.xy;\n    vec2 invTextureSize = morph_tex_params.zw;\n\n    // turn vertexId into int grid coordinates\n    float morphGridV = floor(vertexId * invTextureSize.x);\n    float morphGridU = vertexId - (morphGridV * textureSize.x);\n\n    // convert grid coordinates to uv coordinates with half pixel offset\n    return (vec2(morphGridU, morphGridV) * invTextureSize) + (0.5 * invTextureSize);\n}\n#endif\n\n#ifdef MORPHING_TEXTURE_BASED_POSITION\nuniform highp sampler2D morphPositionTex;\n#endif\n\nmat4 getModelMatrix() {\n    #ifdef DYNAMICBATCH\n    return getBoneMatrix(vertex_boneIndices);\n    #elif defined(SKIN)\n    return matrix_model * getSkinMatrix(vertex_boneIndices, vertex_boneWeights);\n    #elif defined(INSTANCING)\n    return mat4(instance_line1, instance_line2, instance_line3, instance_line4);\n    #else\n    return matrix_model;\n    #endif\n}\n\nvec4 getPosition() {\n    dModelMatrix = getModelMatrix();\n    vec3 localPos = vertex_position;\n\n    #ifdef NINESLICED\n    // outer and inner vertices are at the same position, scale both\n    localPos.xz *= outerScale;\n\n    // offset inner vertices inside\n    // (original vertices must be in [-1;1] range)\n    vec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n    vec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n    localPos.xz += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n\n    vTiledUv = (localPos.xz - outerScale + innerOffset.xy) * -0.5 + 1.0; // uv = local pos - inner corner\n\n    localPos.xz *= -0.5; // move from -1;1 to -0.5;0.5\n    localPos = localPos.xzy;\n    #endif\n\n    #ifdef MORPHING\n    #ifdef MORPHING_POS03\n    localPos.xyz += morph_weights_a[0] * morph_pos0;\n    localPos.xyz += morph_weights_a[1] * morph_pos1;\n    localPos.xyz += morph_weights_a[2] * morph_pos2;\n    localPos.xyz += morph_weights_a[3] * morph_pos3;\n    #endif // MORPHING_POS03\n    #ifdef MORPHING_POS47\n    localPos.xyz += morph_weights_b[0] * morph_pos4;\n    localPos.xyz += morph_weights_b[1] * morph_pos5;\n    localPos.xyz += morph_weights_b[2] * morph_pos6;\n    localPos.xyz += morph_weights_b[3] * morph_pos7;\n    #endif // MORPHING_POS47\n    #endif // MORPHING\n\n    #ifdef MORPHING_TEXTURE_BASED_POSITION\n    // apply morph offset from texture\n    vec2 morphUV = getTextureMorphCoords();\n    vec3 morphPos = texture2D(morphPositionTex, morphUV).xyz;\n    localPos += morphPos;\n    #endif\n\n    vec4 posW = dModelMatrix * vec4(localPos, 1.0);\n    #ifdef SCREENSPACE\n    posW.zw = vec2(0.0, 1.0);\n    #endif\n    dPositionW = posW.xyz;\n\n    vec4 screenPos;\n    #ifdef UV1LAYOUT\n    screenPos = vec4(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1);\n    #else\n    #ifdef SCREENSPACE\n    screenPos = posW;\n    screenPos.y *= projectionFlipY;\n    #else\n    screenPos = matrix_viewProjection * posW;\n    #endif\n\n    #ifdef PIXELSNAP\n    // snap vertex to a pixel boundary\n    screenPos.xy = (screenPos.xy * 0.5) + 0.5;\n    screenPos.xy *= uScreenSize.xy;\n    screenPos.xy = floor(screenPos.xy);\n    screenPos.xy *= uScreenSize.zw;\n    screenPos.xy = (screenPos.xy * 2.0) - 1.0;\n    #endif\n    #endif\n\n    return screenPos;\n}\n\nvec3 getWorldPosition() {\n    return dPositionW;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/transform.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/transformDecl.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/transformDecl.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ transformDeclVS)\n/* harmony export */ });\nvar transformDeclVS = `\nattribute vec3 vertex_position;\n\nuniform mat4 matrix_model;\nuniform mat4 matrix_viewProjection;\n\nvec3 dPositionW;\nmat4 dModelMatrix;\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/common/vert/transformDecl.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lightmapper/frag/bakeDirLmEnd.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lightmapper/frag/bakeDirLmEnd.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ bakeDirLmEndPS)\n/* harmony export */ });\nvar bakeDirLmEndPS = `\n    vec4 dirLm = texture2D(texture_dirLightMap, vUv1);\n\n    if (bakeDir > 0.5) {\n        if (dAtten > 0.00001) {\n            dirLm.xyz = dirLm.xyz * 2.0 - vec3(1.0);\n            dAtten = saturate(dAtten);\n            gl_FragColor.rgb = normalize(dLightDirNormW.xyz*dAtten + dirLm.xyz*dirLm.w) * 0.5 + vec3(0.5);\n            gl_FragColor.a = dirLm.w + dAtten;\n            gl_FragColor.a = max(gl_FragColor.a, 1.0 / 255.0);\n        } else {\n            gl_FragColor = dirLm;\n        }\n    } else {\n        gl_FragColor.rgb = dirLm.xyz;\n        gl_FragColor.a = max(dirLm.w, dAtten > 0.00001? (1.0/255.0) : 0.0);\n    }\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lightmapper/frag/bakeDirLmEnd.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lightmapper/frag/bakeLmEnd.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lightmapper/frag/bakeLmEnd.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ bakeLmEndPS)\n/* harmony export */ });\nvar bakeLmEndPS = `\n#ifdef LIGHTMAP_RGBM\n    gl_FragColor.rgb = dDiffuseLight;\n    gl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(0.5));\n    gl_FragColor.rgb /= 8.0;\n    gl_FragColor.a = clamp( max( max( gl_FragColor.r, gl_FragColor.g ), max( gl_FragColor.b, 1.0 / 255.0 ) ), 0.0,1.0 );\n    gl_FragColor.a = ceil(gl_FragColor.a * 255.0) / 255.0;\n    gl_FragColor.rgb /= gl_FragColor.a;\n#else\n    gl_FragColor = vec4(dDiffuseLight, 1.0);\n#endif\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lightmapper/frag/bakeLmEnd.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lightmapper/frag/bilateralDeNoise.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lightmapper/frag/bilateralDeNoise.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ bilateralDeNoisePS)\n/* harmony export */ });\nvar bilateralDeNoisePS = `\n// bilateral filter, based on https://www.shadertoy.com/view/4dfGDH# and\n// http://people.csail.mit.edu/sparis/bf_course/course_notes.pdf\n\n// A bilateral filter is a non-linear, edge-preserving, and noise-reducing smoothing filter for images.\n// It replaces the intensity of each pixel with a weighted average of intensity values from nearby pixels.\n// This weight can be based on a Gaussian distribution. Crucially, the weights depend not only on\n// Euclidean distance of pixels, but also on the radiometric differences (e.g., range differences, such\n// as color intensity, depth distance, etc.). This preserves sharp edges.\n\nfloat normpdf3(in vec3 v, in float sigma) {\n    return 0.39894 * exp(-0.5 * dot(v, v) / (sigma * sigma)) / sigma;\n}\n\nvec3 decodeRGBM(vec4 rgbm) {\n    vec3 color = (8.0 * rgbm.a) * rgbm.rgb;\n    return color * color;\n}\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec4 encodeRGBM(vec3 color) { // modified RGBM\n    vec4 encoded;\n    encoded.rgb = pow(color.rgb, vec3(0.5));\n    encoded.rgb *= 1.0 / 8.0;\n\n    encoded.a = saturate( max( max( encoded.r, encoded.g ), max( encoded.b, 1.0 / 255.0 ) ) );\n    encoded.a = ceil(encoded.a * 255.0) / 255.0;\n\n    encoded.rgb /= encoded.a;\n    return encoded;\n}\n\n// filter size\n#define MSIZE 15\n\nvarying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\nuniform vec2 sigmas;\nuniform float bZnorm;\nuniform float kernel[MSIZE];\n\nvoid main(void) {\n    \n    vec4 pixelRgbm = texture2D(source, vUv0);\n\n    // lightmap specific optimization - skip pixels that were not baked\n    // this also allows dilate filter that work on the output of this to work correctly, as it depends on .a being zero\n    // to dilate, which the following blur filter would otherwise modify\n    if (pixelRgbm.a <= 0.0) {\n        gl_FragColor = pixelRgbm;\n        return ;\n    }\n\n    // range sigma - controls blurriness based on a pixel distance\n    float sigma = sigmas.x;\n\n    // domain sigma - controls blurriness based on a pixel similarity (to preserve edges)\n    float bSigma = sigmas.y;\n\n    vec3 pixelHdr = decodeRGBM(pixelRgbm);\n    vec3 accumulatedHdr = vec3(0.0);\n    float accumulatedFactor = 0.0;\n\n    // read out the texels\n    const int kSize = (MSIZE-1)/2;\n    for (int i = -kSize; i <= kSize; ++i) {\n        for (int j = -kSize; j <= kSize; ++j) {\n            \n            // sample the pixel with offset\n            vec2 coord = vUv0 + vec2(float(i), float(j)) * pixelOffset;\n            vec4 rgbm = texture2D(source, coord);\n\n            // lightmap - only use baked pixels\n            if (rgbm.a > 0.0) {\n                vec3 hdr = decodeRGBM(rgbm);\n\n                // bilateral factors\n                float factor = kernel[kSize + j] * kernel[kSize + i];\n                factor *= normpdf3(hdr - pixelHdr, bSigma) * bZnorm;\n\n                // accumulate\n                accumulatedHdr += factor * hdr;\n                accumulatedFactor += factor;\n            }\n        }\n    }\n\n    gl_FragColor = encodeRGBM(accumulatedHdr / accumulatedFactor);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lightmapper/frag/bilateralDeNoise.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lightmapper/frag/dilate.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lightmapper/frag/dilate.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ dilatePS)\n/* harmony export */ });\nvar dilatePS = `\n\nvarying vec2 vUv0;\n\nuniform sampler2D source;\nuniform vec2 pixelOffset;\n\nvoid main(void) {\n    vec4 c = texture2D(source, vUv0);\n    c = c.a>0.0? c : texture2D(source, vUv0 - pixelOffset);\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, -pixelOffset.y));\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, -pixelOffset.y));\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, 0));\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, 0));\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, pixelOffset.y));\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, pixelOffset.y));\n    c = c.a>0.0? c : texture2D(source, vUv0 + pixelOffset);\n    gl_FragColor = c;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lightmapper/frag/dilate.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/TBN.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/TBN.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TBNPS)\n/* harmony export */ });\nvar TBNPS = `\nvoid getTBN() {\n    dTBN = mat3(normalize(dTangentW), normalize(dBinormalW), normalize(dVertexNormalW));\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/TBN.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/TBNObjectSpace.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/TBNObjectSpace.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TBNObjectSpacePS)\n/* harmony export */ });\nvar TBNObjectSpacePS = `\nvoid getTBN() {\n\n    vec3 B = cross(dVertexNormalW, vObjectSpaceUpW);\n    vec3 T = cross(dVertexNormalW, B);\n\n    if (dot(B,B)==0.0) // deal with case when vObjectSpaceUpW dVertexNormalW are parallel\n    {\n        float major=max(max(dVertexNormalW.x, dVertexNormalW.y),dVertexNormalW.z);\n\n        if (dVertexNormalW.x==major)\n        {\n            B=cross(dVertexNormalW, vec3(0,1,0));\n            T=cross(dVertexNormalW, B);\n        }\n        else if (dVertexNormalW.y==major)\n        {\n            B=cross(dVertexNormalW, vec3(0,0,1));\n            T=cross(dVertexNormalW, B);\n        }\n        else if (dVertexNormalW.z==major)\n        {\n            B=cross(dVertexNormalW, vec3(1,0,0));\n            T=cross(dVertexNormalW, B);\n        }\n    }\n\n    dTBN = mat3(normalize(T), normalize(B), normalize(dVertexNormalW));\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/TBNObjectSpace.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/TBNderivative.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/TBNderivative.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TBNderivativePS)\n/* harmony export */ });\nvar TBNderivativePS = `\nuniform float tbnBasis;\n\n// http://www.thetenthplanet.de/archives/1180\nvoid getTBN() {\n    vec2 uv = $UV;\n\n    // get edge vectors of the pixel triangle\n    vec3 dp1 = dFdx( vPositionW );\n    vec3 dp2 = dFdy( vPositionW );\n    vec2 duv1 = dFdx( uv );\n    vec2 duv2 = dFdy( uv );\n\n    // solve the linear system\n    vec3 dp2perp = cross( dp2, dVertexNormalW );\n    vec3 dp1perp = cross( dVertexNormalW, dp1 );\n    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n\n    // construct a scale-invariant frame\n    float denom = max( dot(T,T), dot(B,B) );\n    float invmax = (denom == 0.0) ? 0.0 : tbnBasis / sqrt( denom );\n    dTBN = mat3(T * invmax, -B * invmax, dVertexNormalW );\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/TBNderivative.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/TBNfast.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/TBNfast.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TBNfastPS)\n/* harmony export */ });\nvar TBNfastPS = `\nvoid getTBN() {\n    dTBN = mat3(dTangentW, dBinormalW, dVertexNormalW);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/TBNfast.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/ambientConstant.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/ambientConstant.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ambientConstantPS)\n/* harmony export */ });\nvar ambientConstantPS = `\nvoid addAmbient() {\n    dDiffuseLight += light_globalAmbient;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/ambientConstant.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/ambientEnv.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/ambientEnv.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ambientEnvPS)\n/* harmony export */ });\nvar ambientEnvPS = `\n#ifndef ENV_ATLAS\n#define ENV_ATLAS\nuniform sampler2D texture_envAtlas;\n#endif\n\nvoid addAmbient() {\n    vec3 dir = normalize(cubeMapRotate(dNormalW) * vec3(-1.0, 1.0, 1.0));\n    vec2 uv = mapUv(toSphericalUv(dir), vec4(128.0, 256.0 + 128.0, 64.0, 32.0) / atlasSize);\n\n    vec4 raw = texture2D(texture_envAtlas, uv);\n    vec3 linear = $DECODE(raw);\n    dDiffuseLight += processEnvironment(linear);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/ambientEnv.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/ambientSH.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/ambientSH.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ambientSHPS)\n/* harmony export */ });\nvar ambientSHPS = `\nuniform vec3 ambientSH[9];\n\nvoid addAmbient() {\n    vec3 n = cubeMapRotate(dNormalW);\n\n    vec3 color =\n        ambientSH[0] +\n        ambientSH[1] * n.x +\n        ambientSH[2] * n.y +\n        ambientSH[3] * n.z +\n        ambientSH[4] * n.x * n.z +\n        ambientSH[5] * n.z * n.y +\n        ambientSH[6] * n.y * n.x +\n        ambientSH[7] * (3.0 * n.z * n.z - 1.0) +\n        ambientSH[8] * (n.x * n.x - n.y * n.y);\n\n    dDiffuseLight += processEnvironment(max(color, vec3(0.0)));\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/ambientSH.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/aoDiffuseOcc.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/aoDiffuseOcc.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ aoDiffuseOccPS)\n/* harmony export */ });\nvar aoDiffuseOccPS = `\nvoid occludeDiffuse() {\n    dDiffuseLight *= dAo;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/aoDiffuseOcc.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/aoSpecOcc.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/aoSpecOcc.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ aoSpecOccPS)\n/* harmony export */ });\nvar aoSpecOccPS = `\nuniform float material_occludeSpecularIntensity;\n\nvoid occludeSpecular() {\n    // approximated specular occlusion from AO\n    float specPow = exp2(dGlossiness * 11.0);\n    // http://research.tri-ace.com/Data/cedec2011_RealtimePBR_Implementation_e.pptx\n    float specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);\n    specOcc = mix(1.0, specOcc, material_occludeSpecularIntensity);\n\n    dSpecularLight *= specOcc;\n    dReflection *= specOcc;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/aoSpecOcc.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/aoSpecOccConst.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/aoSpecOccConst.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ aoSpecOccConstPS)\n/* harmony export */ });\nvar aoSpecOccConstPS = `\nvoid occludeSpecular() {\n    // approximated specular occlusion from AO\n    float specPow = exp2(dGlossiness * 11.0);\n    // http://research.tri-ace.com/Data/cedec2011_RealtimePBR_Implementation_e.pptx\n    float specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);\n\n    dSpecularLight *= specOcc;\n    dReflection *= specOcc;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/aoSpecOccConst.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/aoSpecOccConstSimple.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/aoSpecOccConstSimple.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ aoSpecOccConstSimplePS)\n/* harmony export */ });\nvar aoSpecOccConstSimplePS = `\nvoid occludeSpecular() {\n    dSpecularLight *= dAo;\n    dReflection *= dAo;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/aoSpecOccConstSimple.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/aoSpecOccSimple.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/aoSpecOccSimple.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ aoSpecOccSimplePS)\n/* harmony export */ });\nvar aoSpecOccSimplePS = `\nuniform float material_occludeSpecularIntensity;\n\nvoid occludeSpecular() {\n    float specOcc = mix(1.0, dAo, material_occludeSpecularIntensity);\n    dSpecularLight *= specOcc;\n    dReflection *= specOcc;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/aoSpecOccSimple.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/base.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/base.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ basePS)\n/* harmony export */ });\nvar basePS = `\nuniform vec3 view_position;\n\nuniform vec3 light_globalAmbient;\n\nfloat square(float x) {\n    return x*x;\n}\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 saturate(vec3 x) {\n    return clamp(x, vec3(0.0), vec3(1.0));\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/base.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/baseNineSliced.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/baseNineSliced.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ baseNineSlicedPS)\n/* harmony export */ });\nvar baseNineSlicedPS = `\n#define NINESLICED\n\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\n\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\n\nvec2 nineSlicedUv;\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/baseNineSliced.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/baseNineSlicedTiled.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/baseNineSlicedTiled.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ baseNineSlicedTiledPS)\n/* harmony export */ });\nvar baseNineSlicedTiledPS = `\n#define NINESLICED\n#define NINESLICETILED\n\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\n\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\n\nvec2 nineSlicedUv;\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/baseNineSlicedTiled.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/biasConst.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/biasConst.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ biasConstPS)\n/* harmony export */ });\nvar biasConstPS = `\n#define SHADOWBIAS\n\nfloat getShadowBias(float resolution, float maxBias) {\n    return maxBias;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/biasConst.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/blurVSM.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/blurVSM.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ blurVSMPS)\n/* harmony export */ });\nvar blurVSMPS = `\nvarying vec2 vUv0;\n\nuniform sampler2D source;\nuniform vec2 pixelOffset;\n\n#ifdef GAUSS\nuniform float weight[SAMPLES];\n#endif\n\n#ifdef PACKED\nfloat decodeFloatRG(vec2 rg) {\n    return rg.y*(1.0/255.0) + rg.x;\n}\n\nvec2 encodeFloatRG( float v ) {\n    vec2 enc = vec2(1.0, 255.0) * v;\n    enc = fract(enc);\n    enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n    return enc;\n}\n#endif\n\nvoid main(void) {\n    vec3 moments = vec3(0.0);\n    vec2 uv = vUv0 - pixelOffset * (float(SAMPLES) * 0.5);\n    for (int i=0; i<SAMPLES; i++) {\n        vec4 c = texture2D(source, uv + pixelOffset * float(i));\n\n        #ifdef PACKED\n        c.xy = vec2(decodeFloatRG(c.xy), decodeFloatRG(c.zw));\n        #endif\n\n        #ifdef GAUSS\n        moments += c.xyz * weight[i];\n        #else\n        moments += c.xyz;\n        #endif\n    }\n\n    #ifndef GAUSS\n    moments /= float(SAMPLES);\n    #endif\n\n    #ifdef PACKED\n    gl_FragColor = vec4(encodeFloatRG(moments.x), encodeFloatRG(moments.y));\n    #else\n    gl_FragColor = vec4(moments.x, moments.y, moments.z, 1.0);\n    #endif\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/blurVSM.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/clusteredLight.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/clusteredLight.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ clusteredLightPS)\n/* harmony export */ });\nvar clusteredLightPS = `\nuniform sampler2D clusterWorldTexture;\nuniform sampler2D lightsTexture8;\nuniform highp sampler2D lightsTextureFloat;\n\n// complex ifdef expression are not supported, handle it here\n// defined(CLUSTER_COOKIES) || defined(CLUSTER_SHADOWS)\n#if defined(CLUSTER_COOKIES)\n    #define CLUSTER_COOKIES_OR_SHADOWS\n#endif\n#if defined(CLUSTER_SHADOWS)\n    #define CLUSTER_COOKIES_OR_SHADOWS\n#endif\n\n#ifdef CLUSTER_SHADOWS\n    #ifdef GL2\n        // TODO: when VSM shadow is supported, it needs to use sampler2D in webgl2\n        uniform sampler2DShadow shadowAtlasTexture;\n    #else\n        uniform sampler2D shadowAtlasTexture;\n    #endif\n#endif\n\n#ifdef CLUSTER_COOKIES\n    uniform sampler2D cookieAtlasTexture;\n#endif\n\n#ifdef GL2\n    uniform int clusterMaxCells;\n#else\n    uniform vec4 lightsTextureInvSize;\n#endif\n\nuniform float clusterPixelsPerCell;\nuniform vec3 clusterCellsCountByBoundsSize;\nuniform vec3 clusterTextureSize;\nuniform vec3 clusterBoundsMin;\nuniform vec3 clusterBoundsDelta;\nuniform vec3 clusterCellsDot;\nuniform vec3 clusterCellsMax;\nuniform vec2 clusterCompressionLimit0;\nuniform vec2 shadowAtlasParams;\n\n// structure storing light properties of a clustered light\nstruct ClusterLightData {\n\n    #ifdef GL2\n        // light index\n        int lightIndex;\n    #else\n        // v coordinate to look up the light textures - this is the same as lightIndex but in 0..1 range\n        float lightV;\n    #endif\n\n    // type of the light (spot or omni)\n    float type;\n\n    // area light shape\n    float shape;\n\n    // area light sizes / orientation\n    vec3 halfWidth;\n    vec3 halfHeight;\n\n    // light follow mode\n    float falloffMode;\n\n    // 0.0 if the light doesn't cast shadows\n    float shadowIntensity;\n\n    // shadow bias values\n    float shadowBias;\n    float shadowNormalBias;\n\n    // world space position\n    vec3 position;\n\n    // world space direction (spot light only)\n    vec3 direction;\n\n    // range of the light\n    float range;\n\n    // spot light inner and outer angle cosine\n    float innerConeAngleCos;\n    float outerConeAngleCos;\n\n    // color\n    vec3 color;\n\n    // atlas viewport for omni light shadow and cookie (.xy is offset to the viewport slot, .z is size of the face in the atlas)\n    vec3 omniAtlasViewport;\n\n    // 1.0 if the light has a cookie texture\n    float cookie;\n\n    // 1.0 if cookie texture is rgb, otherwise it is using a single channel selectable by cookieChannelMask\n    float cookieRgb;\n\n    // intensity of the cookie\n    float cookieIntensity;\n\n    // channel mask - one of the channels has 1, the others are 0\n    vec4 cookieChannelMask;\n\n    // light mask\n    float mask;\n};\n\n// Note: on some devices (tested on Pixel 3A XL), this matrix when stored inside the light struct has lower precision compared to\n// when stored outside, so we store it outside to avoid spot shadow flickering. This might need to be done to other / all members\n// of the structure if further similar issues are observed.\n\n// shadow (spot light only) / cookie projection matrix\nmat4 lightProjectionMatrix;\n\n// macros for light properties\n#define isClusteredLightCastShadow(light) ( light.shadowIntensity > 0.0 )\n#define isClusteredLightCookie(light) (light.cookie > 0.5 )\n#define isClusteredLightCookieRgb(light) (light.cookieRgb > 0.5 )\n#define isClusteredLightSpot(light) ( light.type > 0.5 )\n#define isClusteredLightFalloffLinear(light) ( light.falloffMode < 0.5 )\n\n// macros to test light shape\n// Note: Following functions need to be called serially in listed order as they do not test both '>' and '<'\n#define isClusteredLightArea(light) ( light.shape > 0.1 )\n#define isClusteredLightRect(light) ( light.shape < 0.3 )\n#define isClusteredLightDisk(light) ( light.shape < 0.6 )\n\n// macro to test light mask (mesh accepts dynamic vs lightmapped lights)\n#ifdef CLUSTER_MESH_DYNAMIC_LIGHTS\n    // accept lights marked as dynamic or both dynamic and lightmapped\n    #define acceptLightMask(light) ( light.mask < 0.75)\n#else\n    // accept lights marked as lightmapped or both dynamic and lightmapped\n    #define acceptLightMask(light) ( light.mask > 0.25)\n#endif\n\nvec4 decodeClusterLowRange4Vec4(vec4 d0, vec4 d1, vec4 d2, vec4 d3) {\n    return vec4(\n        bytes2floatRange4(d0, -2.0, 2.0),\n        bytes2floatRange4(d1, -2.0, 2.0),\n        bytes2floatRange4(d2, -2.0, 2.0),\n        bytes2floatRange4(d3, -2.0, 2.0)\n    );\n}\n\n#ifdef GL2\n\n    vec4 sampleLightsTexture8(const ClusterLightData clusterLightData, int index) {\n        return texelFetch(lightsTexture8, ivec2(index, clusterLightData.lightIndex), 0);\n    }\n\n    vec4 sampleLightTextureF(const ClusterLightData clusterLightData, int index) {\n        return texelFetch(lightsTextureFloat, ivec2(index, clusterLightData.lightIndex), 0);\n    }\n\n#else\n\n    vec4 sampleLightsTexture8(const ClusterLightData clusterLightData, float index) {\n        return texture2DLodEXT(lightsTexture8, vec2(index * lightsTextureInvSize.z, clusterLightData.lightV), 0.0);\n    }\n\n    vec4 sampleLightTextureF(const ClusterLightData clusterLightData, float index) {\n        return texture2DLodEXT(lightsTextureFloat, vec2(index * lightsTextureInvSize.x, clusterLightData.lightV), 0.0);\n    }\n\n#endif\n\nvoid decodeClusterLightCore(inout ClusterLightData clusterLightData, float lightIndex) {\n\n    // light index\n    #ifdef GL2\n        clusterLightData.lightIndex = int(lightIndex);\n    #else\n        clusterLightData.lightV = (lightIndex + 0.5) * lightsTextureInvSize.w;\n    #endif\n\n    // shared data from 8bit texture\n    vec4 lightInfo = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_FLAGS);\n    clusterLightData.type = lightInfo.x;\n    clusterLightData.shape = lightInfo.y;\n    clusterLightData.falloffMode = lightInfo.z;\n    clusterLightData.shadowIntensity = lightInfo.w;\n\n    // color\n    vec4 colorA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_A);\n    vec4 colorB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_B);\n    clusterLightData.color = vec3(bytes2float2(colorA.xy), bytes2float2(colorA.zw), bytes2float2(colorB.xy)) * clusterCompressionLimit0.y;\n\n    // cookie\n    clusterLightData.cookie = colorB.z;\n\n    // light mask\n    clusterLightData.mask = colorB.w;\n\n    #ifdef CLUSTER_TEXTURE_FLOAT\n\n        vec4 lightPosRange = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_POSITION_RANGE);\n        clusterLightData.position = lightPosRange.xyz;\n        clusterLightData.range = lightPosRange.w;\n\n        // spot light direction\n        vec4 lightDir_Unused = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_SPOT_DIRECTION);\n        clusterLightData.direction = lightDir_Unused.xyz;\n\n    #else   // 8bit\n\n        vec4 encPosX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_X);\n        vec4 encPosY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Y);\n        vec4 encPosZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Z);\n        clusterLightData.position = vec3(bytes2float4(encPosX), bytes2float4(encPosY), bytes2float4(encPosZ)) * clusterBoundsDelta + clusterBoundsMin;\n\n        vec4 encRange = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_RANGE);\n        clusterLightData.range = bytes2float4(encRange) * clusterCompressionLimit0.x;\n\n        // spot light direction\n        vec4 encDirX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_X);\n        vec4 encDirY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Y);\n        vec4 encDirZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Z);\n        clusterLightData.direction = vec3(bytes2float4(encDirX), bytes2float4(encDirY), bytes2float4(encDirZ)) * 2.0 - 1.0;\n\n    #endif\n}\n\nvoid decodeClusterLightSpot(inout ClusterLightData clusterLightData) {\n\n    // spot light cos angles\n    vec4 coneAngle = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_ANGLES);\n    clusterLightData.innerConeAngleCos = bytes2float2(coneAngle.xy) * 2.0 - 1.0;\n    clusterLightData.outerConeAngleCos = bytes2float2(coneAngle.zw) * 2.0 - 1.0;\n}\n\nvoid decodeClusterLightOmniAtlasViewport(inout ClusterLightData clusterLightData) {\n    #ifdef CLUSTER_TEXTURE_FLOAT\n        clusterLightData.omniAtlasViewport = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0).xyz;\n    #else\n        vec4 viewportA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_A);\n        vec4 viewportB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_B);\n        clusterLightData.omniAtlasViewport = vec3(bytes2float2(viewportA.xy), bytes2float2(viewportA.zw), bytes2float2(viewportB.xy));\n    #endif\n}\n\nvoid decodeClusterLightAreaData(inout ClusterLightData clusterLightData) {\n    #ifdef CLUSTER_TEXTURE_FLOAT\n        clusterLightData.halfWidth = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_WIDTH).xyz;\n        clusterLightData.halfHeight = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_HEIGHT).xyz;\n    #else\n        vec4 areaWidthX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_X);\n        vec4 areaWidthY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Y);\n        vec4 areaWidthZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Z);\n        clusterLightData.halfWidth = vec3(mantissaExponent2Float(areaWidthX), mantissaExponent2Float(areaWidthY), mantissaExponent2Float(areaWidthZ));\n\n        vec4 areaHeightX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_X);\n        vec4 areaHeightY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Y);\n        vec4 areaHeightZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Z);\n        clusterLightData.halfHeight = vec3(mantissaExponent2Float(areaHeightX), mantissaExponent2Float(areaHeightY), mantissaExponent2Float(areaHeightZ));\n    #endif\n}\n\nvoid decodeClusterLightProjectionMatrixData(inout ClusterLightData clusterLightData) {\n    \n    // shadow matrix\n    #ifdef CLUSTER_TEXTURE_FLOAT\n        vec4 m0 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0);\n        vec4 m1 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_1);\n        vec4 m2 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_2);\n        vec4 m3 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_3);\n    #else\n        vec4 m00 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_00);\n        vec4 m01 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_01);\n        vec4 m02 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_02);\n        vec4 m03 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_03);\n        vec4 m0 = decodeClusterLowRange4Vec4(m00, m01, m02, m03);\n\n        vec4 m10 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_10);\n        vec4 m11 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_11);\n        vec4 m12 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_12);\n        vec4 m13 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_13);\n        vec4 m1 = decodeClusterLowRange4Vec4(m10, m11, m12, m13);\n\n        vec4 m20 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_20);\n        vec4 m21 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_21);\n        vec4 m22 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_22);\n        vec4 m23 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_23);\n        vec4 m2 = decodeClusterLowRange4Vec4(m20, m21, m22, m23);\n\n        vec4 m30 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_30);\n        vec4 m31 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_31);\n        vec4 m32 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_32);\n        vec4 m33 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_33);\n        vec4 m3 = vec4(mantissaExponent2Float(m30), mantissaExponent2Float(m31), mantissaExponent2Float(m32), mantissaExponent2Float(m33));\n    #endif\n    \n    lightProjectionMatrix = mat4(m0, m1, m2, m3);\n}\n\nvoid decodeClusterLightShadowData(inout ClusterLightData clusterLightData) {\n    \n    // shadow biases\n    vec4 biases = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SHADOW_BIAS);\n    clusterLightData.shadowBias = bytes2floatRange2(biases.xy, -1.0, 20.0),\n    clusterLightData.shadowNormalBias = bytes2float2(biases.zw);\n}\n\nvoid decodeClusterLightCookieData(inout ClusterLightData clusterLightData) {\n\n    vec4 cookieA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_A);\n    clusterLightData.cookieIntensity = cookieA.x;\n    clusterLightData.cookieRgb = cookieA.y;\n\n    clusterLightData.cookieChannelMask = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_B);\n}\n\nvoid evaluateLight(ClusterLightData light) {\n\n    dAtten3 = vec3(1.0);\n\n    // evaluate omni part of the light\n    getLightDirPoint(light.position);\n\n    #ifdef CLUSTER_AREALIGHTS\n\n    // distance attenuation\n    if (isClusteredLightArea(light)) { // area light\n\n        // area lights\n        decodeClusterLightAreaData(light);\n\n        // handle light shape\n        if (isClusteredLightRect(light)) {\n            calcRectLightValues(light.position, light.halfWidth, light.halfHeight);\n        } else if (isClusteredLightDisk(light)) {\n            calcDiskLightValues(light.position, light.halfWidth, light.halfHeight);\n        } else { // sphere\n            calcSphereLightValues(light.position, light.halfWidth, light.halfHeight);\n        }\n\n        dAtten = getFalloffWindow(light.range);\n\n    } else\n\n    #endif\n\n    {   // punctual light\n\n        if (isClusteredLightFalloffLinear(light))\n            dAtten = getFalloffLinear(light.range);\n        else\n            dAtten = getFalloffInvSquared(light.range);\n    }\n\n    if (dAtten > 0.00001) {\n\n        #ifdef CLUSTER_AREALIGHTS\n\n        if (isClusteredLightArea(light)) { // area light\n\n            // handle light shape\n            if (isClusteredLightRect(light)) {\n                dAttenD = getRectLightDiffuse() * 16.0;\n            } else if (isClusteredLightDisk(light)) {\n                dAttenD = getDiskLightDiffuse() * 16.0;\n            } else { // sphere\n                dAttenD = getSphereLightDiffuse() * 16.0;\n            }\n\n        } else\n\n        #endif\n\n        {\n            dAtten *= getLightDiffuse();\n        }\n\n        // spot light falloff\n        if (isClusteredLightSpot(light)) {\n            decodeClusterLightSpot(light);\n            dAtten *= getSpotEffect(light.direction, light.innerConeAngleCos, light.outerConeAngleCos);\n        }\n\n        #if defined(CLUSTER_COOKIES_OR_SHADOWS)\n\n        if (dAtten > 0.00001) {\n\n            // shadow / cookie\n            if (isClusteredLightCastShadow(light) || isClusteredLightCookie(light)) {\n\n                // shared shadow / cookie data depends on light type\n                if (isClusteredLightSpot(light)) {\n                    decodeClusterLightProjectionMatrixData(light);\n                } else {\n                    decodeClusterLightOmniAtlasViewport(light);\n                }\n\n                float shadowTextureResolution = shadowAtlasParams.x;\n                float shadowEdgePixels = shadowAtlasParams.y;\n\n                #ifdef CLUSTER_COOKIES\n\n                // cookie\n                if (isClusteredLightCookie(light)) {\n                    decodeClusterLightCookieData(light);\n\n                    if (isClusteredLightSpot(light)) {\n                        dAtten3 = getCookie2DClustered(cookieAtlasTexture, lightProjectionMatrix, vPositionW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask);\n                    } else {\n                        dAtten3 = getCookieCubeClustered(cookieAtlasTexture, dLightDirW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask, shadowTextureResolution, shadowEdgePixels, light.omniAtlasViewport);\n                    }\n                }\n\n                #endif\n\n                #ifdef CLUSTER_SHADOWS\n\n                // shadow\n                if (isClusteredLightCastShadow(light)) {\n                    decodeClusterLightShadowData(light);\n\n                    vec4 shadowParams = vec4(shadowTextureResolution, light.shadowNormalBias, light.shadowBias, 1.0 / light.range);\n\n                    if (isClusteredLightSpot(light)) {\n\n                        // spot shadow\n                        getShadowCoordPerspZbufferNormalOffset(lightProjectionMatrix, shadowParams);\n                        \n                        #if defined(CLUSTER_SHADOW_TYPE_PCF1)\n                            float shadow = getShadowSpotClusteredPCF1(shadowAtlasTexture, shadowParams);\n                        #elif defined(CLUSTER_SHADOW_TYPE_PCF3)\n                            float shadow = getShadowSpotClusteredPCF3(shadowAtlasTexture, shadowParams);\n                        #elif defined(CLUSTER_SHADOW_TYPE_PCF5)\n                            float shadow = getShadowSpotClusteredPCF5(shadowAtlasTexture, shadowParams);\n                        #endif\n                        dAtten *= mix(1.0, shadow, light.shadowIntensity);\n\n                    } else {\n\n                        // omni shadow\n                        normalOffsetPointShadow(shadowParams);  // normalBias adjusted for distance\n\n                        #if defined(CLUSTER_SHADOW_TYPE_PCF1)\n                            float shadow = getShadowOmniClusteredPCF1(shadowAtlasTexture, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dLightDirW);\n                        #elif defined(CLUSTER_SHADOW_TYPE_PCF3)\n                            float shadow = getShadowOmniClusteredPCF3(shadowAtlasTexture, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dLightDirW);\n                        #elif defined(CLUSTER_SHADOW_TYPE_PCF5)\n                            float shadow = getShadowOmniClusteredPCF5(shadowAtlasTexture, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dLightDirW);\n                        #endif\n                        dAtten *= mix(1.0, shadow, light.shadowIntensity);\n                    }\n                }\n\n                #endif\n            }\n        }\n\n        #endif\n\n        // diffuse / specular / clearcoat\n        #ifdef CLUSTER_AREALIGHTS\n\n        if (isClusteredLightArea(light)) { // area light\n\n            // area light diffuse\n            {\n                vec3 areaDiffuse = (dAttenD * dAtten) * light.color * dAtten3;\n\n                #if defined(LIT_SPECULAR)\n                    #if defined(LIT_CONSERVE_ENERGY)\n                        areaDiffuse = mix(areaDiffuse, vec3(0), dLTCSpecFres);\n                    #endif\n                #endif\n\n                // area light diffuse - it does not mix diffuse lighting into specular attenuation\n                dDiffuseLight += areaDiffuse;\n            }\n\n            // specular and clear coat are material settings and get included by a define based on the material\n            #ifdef LIT_SPECULAR\n\n                // area light specular\n                float areaLightSpecular;\n\n                if (isClusteredLightRect(light)) {\n                    areaLightSpecular = getRectLightSpecular();\n                } else if (isClusteredLightDisk(light)) {\n                    areaLightSpecular = getDiskLightSpecular();\n                } else { // sphere\n                    areaLightSpecular = getSphereLightSpecular();\n                }\n\n                dSpecularLight += dLTCSpecFres * areaLightSpecular * dAtten * light.color * dAtten3;\n\n                #ifdef LIT_CLEARCOAT\n\n                    // area light specular clear coat\n                    float areaLightSpecularCC;\n\n                    if (isClusteredLightRect(light)) {\n                        areaLightSpecularCC = getRectLightSpecularCC();\n                    } else if (isClusteredLightDisk(light)) {\n                        areaLightSpecularCC = getDiskLightSpecularCC();\n                    } else { // sphere\n                        areaLightSpecularCC = getSphereLightSpecularCC();\n                    }\n\n                    ccSpecularLight += ccLTCSpecFres * areaLightSpecularCC * dAtten * light.color  * dAtten3;\n\n                #endif\n\n            #endif\n\n        } else\n\n        #endif\n\n        {    // punctual light\n\n            // punctual light diffuse\n            {\n                vec3 punctualDiffuse = dAtten * light.color * dAtten3;\n\n                #if defined(CLUSTER_AREALIGHTS)\n                #if defined(LIT_SPECULAR)\n                #if defined(LIT_CONSERVE_ENERGY)\n                    punctualDiffuse = mix(punctualDiffuse, vec3(0), dSpecularity);\n                #endif\n                #endif\n                #endif\n\n                dDiffuseLight += punctualDiffuse;\n            }\n   \n            // specular and clear coat are material settings and get included by a define based on the material\n            #ifdef LIT_SPECULAR\n\n                vec3 halfDir = normalize(-dLightDirNormW + dViewDirW);\n                \n                // specular\n                #ifdef LIT_SPECULAR_FRESNEL\n                    dSpecularLight += getLightSpecular(halfDir) * dAtten * light.color * dAtten3 * getFresnel(dot(dViewDirW, halfDir), dSpecularity);\n                #else\n                    dSpecularLight += getLightSpecular(halfDir) * dAtten * light.color * dAtten3 * dSpecularity;\n                #endif\n\n                #ifdef LIT_CLEARCOAT\n                    #ifdef LIT_SPECULAR_FRESNEL\n                        ccSpecularLight += getLightSpecularCC(halfDir) * dAtten * light.color * dAtten3 * getFresnelCC(dot(dViewDirW, halfDir));\n                    #else\n                        ccSpecularLight += getLightSpecularCC(halfDir) * dAtten * light.color * dAtten3;\n                    #endif\n                #endif\n\n                #ifdef LIT_SHEEN\n                    sSpecularLight += getLightSpecularSheen(halfDir) * dAtten * light.color * dAtten3;\n                #endif\n\n            #endif\n        }\n    }\n}\n\nvoid evaluateClusterLight(float lightIndex) {\n\n    // decode core light data from textures\n    ClusterLightData clusterLightData;\n    decodeClusterLightCore(clusterLightData, lightIndex);\n\n    // evaluate light if it uses accepted light mask\n    if (acceptLightMask(clusterLightData))\n        evaluateLight(clusterLightData);\n}\n\nvoid addClusteredLights() {\n    // world space position to 3d integer cell cordinates in the cluster structure\n    vec3 cellCoords = floor((vPositionW - clusterBoundsMin) * clusterCellsCountByBoundsSize);\n\n    // no lighting when cell coordinate is out of range\n    if (!(any(lessThan(cellCoords, vec3(0.0))) || any(greaterThanEqual(cellCoords, clusterCellsMax)))) {\n\n        // cell index (mapping from 3d cell coordinates to linear memory)\n        float cellIndex = dot(clusterCellsDot, cellCoords);\n\n        // convert cell index to uv coordinates\n        float clusterV = floor(cellIndex * clusterTextureSize.y);\n        float clusterU = cellIndex - (clusterV * clusterTextureSize.x);\n\n        #ifdef GL2\n\n            // loop over maximum number of light cells\n            for (int lightCellIndex = 0; lightCellIndex < clusterMaxCells; lightCellIndex++) {\n\n                vec4 lightIndices = texelFetch(clusterWorldTexture, ivec2(int(clusterU) + lightCellIndex, clusterV), 0);\n\n                // evaluate up to 4 lights. This is written using a loop instead of manually unrolling to keep shader compile time smaller\n                vec4 indices = lightIndices * 255.0;\n                for (int i = 0; i < 4; i++) {\n                    \n                    if (indices.x <= 0.0)\n                        return;\n\n                    evaluateClusterLight(indices.x); \n                    indices = indices.yzwx;\n                }\n            }\n\n        #else\n\n            clusterV = (clusterV + 0.5) * clusterTextureSize.z;\n\n            // loop over maximum possible number of supported light cells\n            const float maxLightCells = 256.0 / 4.0;  // 8 bit index, each stores 4 lights\n            for (float lightCellIndex = 0.5; lightCellIndex < maxLightCells; lightCellIndex++) {\n\n                vec4 lightIndices = texture2DLodEXT(clusterWorldTexture, vec2(clusterTextureSize.y * (clusterU + lightCellIndex), clusterV), 0.0);\n                vec4 indices = lightIndices * 255.0;\n\n                // evaluate up to 4 lights. This is written using a loop instead of manually unrolling to keep shader compile time smaller\n                for (int i = 0; i < 4; i++) {\n                    \n                    if (indices.x <= 0.0)\n                        return;\n\n                    evaluateClusterLight(indices.x); \n                    indices = indices.yzwx;\n                }\n\n                // end of the cell array\n                if (lightCellIndex > clusterPixelsPerCell) {\n                    break;\n                }\n            }\n\n        #endif\n    }\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/clusteredLight.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/clusteredLightCookies.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/clusteredLightCookies.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ clusteredLightCookiesPS)\n/* harmony export */ });\nvar clusteredLightCookiesPS = `\nvec3 _getCookieClustered(sampler2D tex, vec2 uv, float intensity, bool isRgb, vec4 cookieChannel) {\n    vec4 pixel = mix(vec4(1.0), texture2D(tex, uv), intensity);\n    return isRgb == true ? pixel.rgb : vec3(dot(pixel, cookieChannel));\n}\n\n// getCookie2D for clustered lighting including channel selector\nvec3 getCookie2DClustered(sampler2D tex, mat4 transform, vec3 worldPosition, float intensity, bool isRgb, vec4 cookieChannel) {\n    vec4 projPos = transform * vec4(worldPosition, 1.0);\n    return _getCookieClustered(tex, projPos.xy / projPos.w, intensity, isRgb, cookieChannel);\n}\n\n// getCookie for clustered omni light with the cookie texture being stored in the cookie atlas\nvec3 getCookieCubeClustered(sampler2D tex, vec3 dir, float intensity, bool isRgb, vec4 cookieChannel, float shadowTextureResolution, float shadowEdgePixels, vec3 omniAtlasViewport) {\n    vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n    return _getCookieClustered(tex, uv, intensity, isRgb, cookieChannel);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/clusteredLightCookies.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/clusteredLightShadows.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/clusteredLightShadows.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ clusteredLightShadowsPS)\n/* harmony export */ });\nvar clusteredLightShadowsPS = `\n// Clustered Omni Sampling using atlas\n\n#ifdef GL2\n\n    #if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\n    float getShadowOmniClusteredPCF1(sampler2DShadow shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\n        float shadowTextureResolution = shadowParams.x;\n        vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\n        float shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n        return textureShadow(shadowMap, vec3(uv, shadowZ));\n    }\n\n    #endif\n\n    #if defined(CLUSTER_SHADOW_TYPE_PCF3)\n\n    float getShadowOmniClusteredPCF3(sampler2DShadow shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\n        float shadowTextureResolution = shadowParams.x;\n        vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\n        float shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n        dShadowCoord = vec3(uv, shadowZ);\n        return getShadowPCF3x3(shadowMap, shadowParams.xyz);\n    }\n\n    #endif\n\n    #if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\n    float getShadowOmniClusteredPCF5(sampler2DShadow shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\n        float shadowTextureResolution = shadowParams.x;\n        vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\n        float shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n        dShadowCoord = vec3(uv, shadowZ);\n        return getShadowPCF5x5(shadowMap, shadowParams.xyz);\n    }\n\n    #endif\n\n#else\n\n    #if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\n    float getShadowOmniClusteredPCF1(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\n        float shadowTextureResolution = shadowParams.x;\n        vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\n        // no filter shadow sampling\n        float depth = unpackFloat(textureShadow(shadowMap, uv));\n        float shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n        return depth > shadowZ ? 1.0 : 0.0;\n    }\n\n    #endif\n\n    #if defined(CLUSTER_SHADOW_TYPE_PCF3)\n\n    float getShadowOmniClusteredPCF3(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\n        float shadowTextureResolution = shadowParams.x;\n        vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\n        // pcf3\n        float shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n        dShadowCoord = vec3(uv, shadowZ);\n        return getShadowPCF3x3(shadowMap, shadowParams.xyz);\n    }\n\n    #endif\n\n    #if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\n    // we don't have PCF5 implementation for webgl1, use PCF3\n    float getShadowOmniClusteredPCF5(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\n        float shadowTextureResolution = shadowParams.x;\n        vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\n        // pcf3\n        float shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n        dShadowCoord = vec3(uv, shadowZ);\n        return getShadowPCF3x3(shadowMap, shadowParams.xyz);\n    }\n\n    #endif\n\n#endif\n\n\n// Clustered Spot Sampling using atlas\n\n#ifdef GL2\n\n    #if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\n    float getShadowSpotClusteredPCF1(sampler2DShadow shadowMap, vec4 shadowParams) {\n        return textureShadow(shadowMap, dShadowCoord);\n    }\n\n    #endif\n\n    #if defined(CLUSTER_SHADOW_TYPE_PCF3)\n\n    float getShadowSpotClusteredPCF3(sampler2DShadow shadowMap, vec4 shadowParams) {\n        return getShadowSpotPCF3x3(shadowMap, shadowParams);\n    }\n\n    #endif\n\n    #if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\n    float getShadowSpotClusteredPCF5(sampler2DShadow shadowMap, vec4 shadowParams) {\n        return getShadowPCF5x5(shadowMap, shadowParams.xyz);\n    }\n    #endif\n\n#else\n\n    #if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\n    float getShadowSpotClusteredPCF1(sampler2D shadowMap, vec4 shadowParams) {\n\n        float depth = unpackFloat(textureShadow(shadowMap, dShadowCoord.xy));\n\n        return depth > dShadowCoord.z ? 1.0 : 0.0;\n\n    }\n\n    #endif\n\n    #if defined(CLUSTER_SHADOW_TYPE_PCF3)\n\n    float getShadowSpotClusteredPCF3(sampler2D shadowMap, vec4 shadowParams) {\n        return getShadowSpotPCF3x3(shadowMap, shadowParams);\n    }\n\n    #endif\n\n    #if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\n    // we don't have PCF5 implementation for webgl1, use PCF3\n    float getShadowSpotClusteredPCF5(sampler2D shadowMap, vec4 shadowParams) {\n        return getShadowSpotPCF3x3(shadowMap, shadowParams);\n    }\n\n    #endif\n\n#endif\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/clusteredLightShadows.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/clusteredLightUtils.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/clusteredLightUtils.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ clusteredLightUtilsPS)\n/* harmony export */ });\nvar clusteredLightUtilsPS = `\n// Converts unnormalized direction vector to a cubemap face index [0..5] and uv coordinates within the face in [0..1] range.\n// Additionally offset to a tile in atlas within 3x3 subdivision is provided\nvec2 getCubemapFaceCoordinates(const vec3 dir, out float faceIndex, out vec2 tileOffset)\n{\n    vec3 vAbs = abs(dir);\n    float ma;\n    vec2 uv;\n    if (vAbs.z >= vAbs.x && vAbs.z >= vAbs.y) {   // front / back\n\n        faceIndex = dir.z < 0.0 ? 5.0 : 4.0;\n        ma = 0.5 / vAbs.z;\n        uv = vec2(dir.z < 0.0 ? -dir.x : dir.x, -dir.y);\n\n        tileOffset.x = 2.0;\n        tileOffset.y = dir.z < 0.0 ? 1.0 : 0.0;\n\n    } else if(vAbs.y >= vAbs.x) {  // top index 2, bottom index 3\n\n        faceIndex = dir.y < 0.0 ? 3.0 : 2.0;\n        ma = 0.5 / vAbs.y;\n        uv = vec2(dir.x, dir.y < 0.0 ? -dir.z : dir.z);\n\n        tileOffset.x = 1.0;\n        tileOffset.y = dir.y < 0.0 ? 1.0 : 0.0;\n\n    } else {    // left / right\n\n        faceIndex = dir.x < 0.0 ? 1.0 : 0.0;\n        ma = 0.5 / vAbs.x;\n        uv = vec2(dir.x < 0.0 ? dir.z : -dir.z, -dir.y);\n\n        tileOffset.x = 0.0;\n        tileOffset.y = dir.x < 0.0 ? 1.0 : 0.0;\n\n    }\n    return uv * ma + 0.5;\n}\n\n// converts unnormalized direction vector to a texture coordinate for a cubemap face stored within texture atlas described by the viewport\nvec2 getCubemapAtlasCoordinates(const vec3 omniAtlasViewport, float shadowEdgePixels, float shadowTextureResolution, const vec3 dir) {\n\n    float faceIndex;\n    vec2 tileOffset;\n    vec2 uv = getCubemapFaceCoordinates(dir, faceIndex, tileOffset);\n\n    // move uv coordinates inwards inside to compensate for larger fov when rendering shadow into atlas\n    float atlasFaceSize = omniAtlasViewport.z;\n    float tileSize = shadowTextureResolution * atlasFaceSize;\n    float offset = shadowEdgePixels / tileSize;\n    uv = uv * vec2(1.0 - offset * 2.0) + vec2(offset * 1.0);\n\n    // scale uv coordinates to cube face area within the viewport\n    uv *= atlasFaceSize;\n\n    // offset into face of the atlas (3x3 grid)\n    uv += tileOffset * atlasFaceSize;\n\n    // offset into the atlas viewport\n    uv += omniAtlasViewport.xy;\n\n    return uv;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/clusteredLightUtils.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/combine.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/combine.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ combinePS)\n/* harmony export */ });\nvar combinePS = `\nvec3 combineColor() {\n    vec3 ret = vec3(0);\n#ifdef LIT_OLD_AMBIENT\n    ret += (dDiffuseLight - light_globalAmbient) * dAlbedo + material_ambient * light_globalAmbient;\n#else\n    ret += dAlbedo * dDiffuseLight;\n#endif\n#ifdef LIT_SPECULAR\n    ret += dSpecularLight;\n#endif\n#ifdef LIT_REFLECTIONS\n    ret += dReflection.rgb * dReflection.a;\n#endif\n\n#ifdef LIT_SHEEN\n    float sheenScaling = 1.0 - max(max(sSpecularity.r, sSpecularity.g), sSpecularity.b) * 0.157;\n    ret = ret * sheenScaling + (sSpecularLight + sReflection.rgb) * sSpecularity;\n#endif\n#ifdef LIT_CLEARCOAT\n    float clearCoatScaling = 1.0 - ccFresnel * ccSpecularity;\n    ret = ret * clearCoatScaling + (ccSpecularLight + ccReflection.rgb) * ccSpecularity;\n#endif\n\n    return ret;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/combine.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/cookie.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/cookie.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ cookiePS)\n/* harmony export */ });\nvar cookiePS = `\n// light cookie functionality for non-clustered lights\nvec4 getCookie2D(sampler2D tex, mat4 transform, float intensity) {\n    vec4 projPos = transform * vec4(vPositionW, 1.0);\n    projPos.xy /= projPos.w;\n    return mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\n\nvec4 getCookie2DClip(sampler2D tex, mat4 transform, float intensity) {\n    vec4 projPos = transform * vec4(vPositionW, 1.0);\n    projPos.xy /= projPos.w;\n    if (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n    return mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\n\nvec4 getCookie2DXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n    vec4 projPos = transform * vec4(vPositionW, 1.0);\n    projPos.xy /= projPos.w;\n    projPos.xy += cookieOffset;\n    vec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n    return mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\n\nvec4 getCookie2DClipXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n    vec4 projPos = transform * vec4(vPositionW, 1.0);\n    projPos.xy /= projPos.w;\n    projPos.xy += cookieOffset;\n    if (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n    vec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n    return mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\n\nvec4 getCookieCube(samplerCube tex, mat4 transform, float intensity) {\n    return mix(vec4(1.0), textureCube(tex, dLightDirNormW * mat3(transform)), intensity);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/cookie.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/cubeMapProjectBox.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/cubeMapProjectBox.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ cubeMapProjectBoxPS)\n/* harmony export */ });\nvar cubeMapProjectBoxPS = `\nuniform vec3 envBoxMin, envBoxMax;\n\nvec3 cubeMapProject(vec3 nrdir) {\n    nrdir = cubeMapRotate(nrdir);\n\n    vec3 rbmax = (envBoxMax - vPositionW) / nrdir;\n    vec3 rbmin = (envBoxMin - vPositionW) / nrdir;\n\n    vec3 rbminmax;\n    rbminmax.x = nrdir.x>0.0? rbmax.x : rbmin.x;\n    rbminmax.y = nrdir.y>0.0? rbmax.y : rbmin.y;\n    rbminmax.z = nrdir.z>0.0? rbmax.z : rbmin.z;\n\n    float fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);\n\n    vec3 posonbox = vPositionW + nrdir * fa;\n    vec3 envBoxPos = (envBoxMin + envBoxMax) * 0.5;\n    return normalize(posonbox - envBoxPos);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/cubeMapProjectBox.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/cubeMapProjectNone.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/cubeMapProjectNone.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ cubeMapProjectNonePS)\n/* harmony export */ });\nvar cubeMapProjectNonePS = `\nvec3 cubeMapProject(vec3 dir) {\n    return cubeMapRotate(dir);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/cubeMapProjectNone.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/cubeMapRotate.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/cubeMapRotate.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ cubeMapRotatePS)\n/* harmony export */ });\nvar cubeMapRotatePS = `\n#ifdef CUBEMAP_ROTATION\nuniform mat3 cubeMapRotationMatrix;\n#endif\n\nvec3 cubeMapRotate(vec3 refDir) {\n#ifdef CUBEMAP_ROTATION\n    return refDir * cubeMapRotationMatrix;\n#else\n    return refDir;\n#endif\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/cubeMapRotate.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/end.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/end.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ endPS)\n/* harmony export */ });\nvar endPS = `\n    gl_FragColor.rgb = combineColor();\n\n    gl_FragColor.rgb += dEmission;\n    gl_FragColor.rgb = addFog(gl_FragColor.rgb);\n\n    #ifndef HDR\n    gl_FragColor.rgb = toneMap(gl_FragColor.rgb);\n    gl_FragColor.rgb = gammaCorrectOutput(gl_FragColor.rgb);\n    #endif\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/end.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/extension.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/extension.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ extensionPS)\n/* harmony export */ });\nvar extensionPS = `\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/extension.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/falloffInvSquared.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/falloffInvSquared.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ falloffInvSquaredPS)\n/* harmony export */ });\nvar falloffInvSquaredPS = `\nfloat getFalloffWindow(float lightRadius) {\n    float sqrDist = dot(dLightDirW, dLightDirW);\n    float invRadius = 1.0 / lightRadius;\n    return square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\n}\n\nfloat getFalloffInvSquared(float lightRadius) {\n    float sqrDist = dot(dLightDirW, dLightDirW);\n    float falloff = 1.0 / (sqrDist + 1.0);\n    float invRadius = 1.0 / lightRadius;\n\n    falloff *= 16.0;\n    falloff *= square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\n\n    return falloff;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/falloffInvSquared.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/falloffLinear.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/falloffLinear.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ falloffLinearPS)\n/* harmony export */ });\nvar falloffLinearPS = `\nfloat getFalloffLinear(float lightRadius) {\n    float d = length(dLightDirW);\n    return max(((lightRadius - d) / lightRadius), 0.0);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/falloffLinear.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/float-unpacking.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/float-unpacking.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ floatUnpackingPS)\n/* harmony export */ });\nvar floatUnpackingPS = `\n// float unpacking functionality, complimentary to float-packing.js\nfloat bytes2float2(vec2 data) {\n    return dot(data, vec2(1.0, 1.0 / 255.0));\n}\n\nfloat bytes2float3(vec3 data) {\n    return dot(data, vec3(1.0, 1.0 / 255.0, 1.0 / 65025.0));\n}\n\nfloat bytes2float4(vec4 data) {\n    return dot(data, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n}\n\nfloat bytes2floatRange2(vec2 data, float min, float max) {\n    return mix(min, max, bytes2float2(data));\n}\n\nfloat bytes2floatRange3(vec3 data, float min, float max) {\n    return mix(min, max, bytes2float3(data));\n}\n\nfloat bytes2floatRange4(vec4 data, float min, float max) {\n    return mix(min, max, bytes2float4(data));\n}\n\nfloat mantissaExponent2Float(vec4 pack)\n{\n    float value = bytes2floatRange3(pack.xyz, -1.0, 1.0);\n    float exponent = floor(pack.w * 255.0 - 127.0);\n    return value * exp2(exponent);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/float-unpacking.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/fogExp.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/fogExp.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fogExpPS)\n/* harmony export */ });\nvar fogExpPS = `\nuniform vec3 fog_color;\nuniform float fog_density;\nfloat dBlendModeFogFactor = 1.0;\n\nvec3 addFog(vec3 color) {\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    float fogFactor = exp(-depth * fog_density);\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n    return mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/fogExp.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/fogExp2.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/fogExp2.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fogExp2PS)\n/* harmony export */ });\nvar fogExp2PS = `\nuniform vec3 fog_color;\nuniform float fog_density;\nfloat dBlendModeFogFactor = 1.0;\n\nvec3 addFog(vec3 color) {\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    float fogFactor = exp(-depth * depth * fog_density * fog_density);\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n    return mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/fogExp2.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/fogLinear.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/fogLinear.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fogLinearPS)\n/* harmony export */ });\nvar fogLinearPS = `\nuniform vec3 fog_color;\nuniform float fog_start;\nuniform float fog_end;\nfloat dBlendModeFogFactor = 1.0;\n\nvec3 addFog(vec3 color) {\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    float fogFactor = (fog_end - depth) / (fog_end - fog_start);\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n    return mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/fogLinear.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/fogNone.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/fogNone.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fogNonePS)\n/* harmony export */ });\nvar fogNonePS = `\nfloat dBlendModeFogFactor = 1.0;\n\nvec3 addFog(vec3 color) {\n    return color;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/fogNone.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/fresnelSchlick.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/fresnelSchlick.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fresnelSchlickPS)\n/* harmony export */ });\nvar fresnelSchlickPS = `\n// Schlick's approximation\nvec3 getFresnel(float cosTheta, vec3 f0) {\n    float fresnel = pow(1.0 - max(cosTheta, 0.0), 5.0);\n    float glossSq = dGlossiness * dGlossiness;\n    vec3 ret = f0 + (max(vec3(glossSq), f0) - f0) * fresnel;\n    #ifdef LIT_IRIDESCENCE\n        return mix(ret, dIridescenceFresnel, vec3(dIridescence));\n    #else\n        return ret;\n    #endif    \n}\n\nfloat getFresnelCC(float cosTheta) {\n    float fresnel = pow(1.0 - max(cosTheta, 0.0), 5.0);\n    return 0.04 + (1.0 - 0.04) * fresnel;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/fresnelSchlick.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/iridescenceDiffraction.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/iridescenceDiffraction.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ iridescenceDiffractionPS)\n/* harmony export */ });\nvar iridescenceDiffractionPS = `\nuniform float material_iridescenceRefractionIndex;\n\n#ifndef PI\n#define PI 3.14159265\n#endif\n\nfloat iridescence_iorToFresnel(float transmittedIor, float incidentIor) {\n    return pow((transmittedIor - incidentIor) / (transmittedIor + incidentIor), 2.0);\n}\n\nvec3 iridescence_iorToFresnel(vec3 transmittedIor, float incidentIor) {\n    return pow((transmittedIor - vec3(incidentIor)) / (transmittedIor + vec3(incidentIor)), vec3(2.0));\n}\n\nvec3 iridescence_fresnelToIor(vec3 f0) {\n    vec3 sqrtF0 = sqrt(f0);\n    return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);\n}\n\nvec3 iridescence_sensitivity(float opd, vec3 shift) {\n    float phase = 2.0 * PI * opd * 1.0e-9;\n    const vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);\n    const vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);\n    const vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);\n\n    vec3 xyz = val * sqrt(2.0 * PI * var) * cos(pos * phase + shift) * exp(-pow(phase, 2.0) * var);\n    xyz.x += 9.7470e-14 * sqrt(2.0 * PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * pow(phase, 2.0));\n    xyz /= vec3(1.0685e-07);\n\n    const mat3 XYZ_TO_REC709 = mat3(\n        3.2404542, -0.9692660,  0.0556434,\n       -1.5371385,  1.8760108, -0.2040259,\n       -0.4985314,  0.0415560,  1.0572252\n    );\n\n    return XYZ_TO_REC709 * xyz;\n}\n\nfloat iridescence_fresnel(float cosTheta, float f0) {\n    float x = clamp(1.0 - cosTheta, 0.0, 1.0);\n    float x2 = x * x;\n    float x5 = x * x2 * x2;\n    return f0 + (1.0 - f0) * x5;\n} \n\nvec3 iridescence_fresnel(float cosTheta, vec3 f0) {\n    float x = clamp(1.0 - cosTheta, 0.0, 1.0);\n    float x2 = x * x;\n    float x5 = x * x2 * x2; \n    return f0 + (vec3(1.0) - f0) * x5;\n}\n\nvec3 calcIridescence(float outsideIor, float cosTheta, vec3 base_f0) {\n\n    float iridescenceIor = mix(outsideIor, material_iridescenceRefractionIndex, smoothstep(0.0, 0.03, dIridescenceThickness));\n    float sinTheta2Sq = pow(outsideIor / iridescenceIor, 2.0) * (1.0 - pow(cosTheta, 2.0));\n    float cosTheta2Sq = 1.0 - sinTheta2Sq;\n\n    if (cosTheta2Sq < 0.0) {\n        return vec3(1.0);\n    }\n\n    float cosTheta2 = sqrt(cosTheta2Sq);\n\n    float r0 = iridescence_iorToFresnel(iridescenceIor, outsideIor);\n    float r12 = iridescence_fresnel(cosTheta, r0);\n    float r21 = r12;\n    float t121 = 1.0 - r12;\n\n    float phi12 = iridescenceIor < outsideIor ? PI : 0.0;\n    float phi21 = PI - phi12;\n\n    vec3 baseIor = iridescence_fresnelToIor(base_f0 + vec3(0.0001));\n    vec3 r1 = iridescence_iorToFresnel(baseIor, iridescenceIor);\n    vec3 r23 = iridescence_fresnel(cosTheta2, r1);\n\n    vec3 phi23 = vec3(0.0);\n    if (baseIor[0] < iridescenceIor) phi23[0] = PI;\n    if (baseIor[1] < iridescenceIor) phi23[1] = PI;\n    if (baseIor[2] < iridescenceIor) phi23[2] = PI;\n    float opd = 2.0 * iridescenceIor * dIridescenceThickness * cosTheta2;\n    vec3 phi = vec3(phi21) + phi23; \n\n    vec3 r123Sq = clamp(r12 * r23, 1e-5, 0.9999);\n    vec3 r123 = sqrt(r123Sq);\n    vec3 rs = pow(t121, 2.0) * r23 / (1.0 - r123Sq);\n\n    vec3 c0 = r12 + rs;\n    vec3 i = c0;\n\n    vec3 cm = rs - t121;\n    for (int m = 1; m <= 2; m++) {\n        cm *= r123;\n        vec3 sm = 2.0 * iridescence_sensitivity(float(m) * opd, float(m) * phi);\n        i += cm * sm;\n    }\n    return max(i, vec3(0.0));\n}\n\nvoid getIridescence(float cosTheta) {\n    dIridescenceFresnel = calcIridescence(1.0, cosTheta, dSpecularity);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/iridescenceDiffraction.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightDiffuseLambert.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightDiffuseLambert.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ lightDiffuseLambertPS)\n/* harmony export */ });\nvar lightDiffuseLambertPS = `\nfloat getLightDiffuse() {\n    return max(dot(dNormalW, -dLightDirNormW), 0.0);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightDiffuseLambert.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightDirPoint.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightDirPoint.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ lightDirPointPS)\n/* harmony export */ });\nvar lightDirPointPS = `\nvoid getLightDirPoint(vec3 lightPosW) {\n    dLightDirW = vPositionW - lightPosW;\n    dLightDirNormW = normalize(dLightDirW);\n    dLightPosW = lightPosW;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightDirPoint.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightSheen.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightSheen.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ lightSheenPS)\n/* harmony export */ });\nvar lightSheenPS = `\n\nfloat sheenD(vec3 normal, vec3 h, float roughness) {\n    float invR = 1.0 / (roughness * roughness);\n    float cos2h = max(dot(normal, h), 0.0);\n    cos2h *= cos2h;\n    float sin2h = max(1.0 - cos2h, 0.0078125);\n    return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);\n}\n\nfloat sheenV(vec3 normal, vec3 view, vec3 light) {\n    float NoV = max(dot(normal, view), 0.000001);\n    float NoL = max(dot(normal, light), 0.000001);\n    return 1.0 / (4.0 * (NoL + NoV - NoL * NoV));\n}\n\nfloat getLightSpecularSheen(vec3 h) {\n    float D = sheenD(dNormalW, h, sGlossiness);\n    float V = sheenV(dNormalW, dViewDirW, -dLightDirNormW);\n    return D * V;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightSheen.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightSpecularAnisoGGX.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightSpecularAnisoGGX.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ lightSpecularAnisoGGXPS)\n/* harmony export */ });\nvar lightSpecularAnisoGGXPS = `\n// Anisotropic GGX\nfloat calcLightSpecular(float tGlossiness, vec3 tNormalW, vec3 h) {\n    float PI = 3.141592653589793;\n    float roughness = max((1.0 - tGlossiness) * (1.0 - tGlossiness), 0.001);\n    float anisotropy = material_anisotropy * roughness;\n \n    float at = max((roughness + anisotropy), roughness / 4.0);\n    float ab = max((roughness - anisotropy), roughness / 4.0);\n\n    float NoH = dot(tNormalW, h);\n    float ToH = dot(dTBN[0], h);\n    float BoH = dot(dTBN[1], h);\n\n    float a2 = at * ab;\n    vec3 v = vec3(ab * ToH, at * BoH, a2 * NoH);\n    float v2 = dot(v, v);\n    float w2 = a2 / v2;\n    float D = a2 * w2 * w2 * (1.0 / PI);\n\n    float ToV = dot(dTBN[0], dViewDirW);\n    float BoV = dot(dTBN[1], dViewDirW);\n    float ToL = dot(dTBN[0], -dLightDirNormW);\n    float BoL = dot(dTBN[1], -dLightDirNormW);\n    float NoV = dot(tNormalW, dViewDirW);\n    float NoL = dot(tNormalW, -dLightDirNormW);\n\n    float lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));\n    float lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));\n    float G = 0.5 / (lambdaV + lambdaL);\n\n    return D * G;\n}\n\nfloat getLightSpecular(vec3 h) {\n    return calcLightSpecular(dGlossiness, dNormalW, h);\n}\n\n#ifdef LIT_CLEARCOAT\nfloat getLightSpecularCC(vec3 h) {\n    return calcLightSpecular(ccGlossiness, ccNormalW, h);\n}\n#endif\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightSpecularAnisoGGX.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightSpecularBlinn.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightSpecularBlinn.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ lightSpecularBlinnPS)\n/* harmony export */ });\nvar lightSpecularBlinnPS = `\n// Energy-conserving (hopefully) Blinn-Phong\nfloat calcLightSpecular(float tGlossiness, vec3 tNormalW, vec3 h) {\n    float nh = max( dot( h, tNormalW ), 0.0 );\n\n    float specPow = exp2(tGlossiness * 11.0); // glossiness is linear, power is not; 0 - 2048\n\n    // Hack: On Mac OS X, calling pow with zero for the exponent generates hideous artifacts so bias up a little\n    specPow = max(specPow, 0.0001);\n\n    return pow(nh, specPow) * (specPow + 2.0) / 8.0;\n}\n\nfloat getLightSpecular(vec3 h) {\n    return calcLightSpecular(dGlossiness, dNormalW, h);\n}\n\n#ifdef LIT_CLEARCOAT\nfloat getLightSpecularCC(vec3 h) {\n    return calcLightSpecular(ccGlossiness, ccNormalW, h);\n}\n#endif\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightSpecularBlinn.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightSpecularPhong.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightSpecularPhong.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ lightSpecularPhongPS)\n/* harmony export */ });\nvar lightSpecularPhongPS = `\nfloat calcLightSpecular(float tGlossiness, vec3 tReflDirW, vec3 h) {\n    float specPow = tGlossiness;\n\n    // Hack: On Mac OS X, calling pow with zero for the exponent generates hideous artifacts so bias up a little\n    return pow(max(dot(tReflDirW, -dLightDirNormW), 0.0), specPow + 0.0001);\n}\n\nfloat getLightSpecular(vec3 h) {\n    return calcLightSpecular(dGlossiness, dReflDirW, h);\n}\n\n#ifdef LIT_CLEARCOAT\nfloat getLightSpecularCC(vec3 h) {\n    return calcLightSpecular(ccGlossiness, ccReflDirW,h );\n}\n#endif\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightSpecularPhong.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightmapAdd.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightmapAdd.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ lightmapAddPS)\n/* harmony export */ });\nvar lightmapAddPS = `\nvoid addLightMap() {\n    dDiffuseLight += dLightmap;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightmapAdd.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightmapDirAdd.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightmapDirAdd.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ lightmapDirAddPS)\n/* harmony export */ });\nvar lightmapDirAddPS = `\nvoid addLightMap() {\n    if (dot(dLightmapDir, dLightmapDir) < 0.0001) {\n        dDiffuseLight += dLightmap;\n    } else {\n        dLightDirNormW = dLightmapDir;\n\n        float vlight = saturate(dot(dLightDirNormW, -dVertexNormalW));\n        float flight = saturate(dot(dLightDirNormW, -dNormalW));\n        float nlight = (flight / max(vlight, 0.01)) * 0.5;\n\n        dDiffuseLight += dLightmap * nlight * 2.0;\n\n        vec3 halfDirW = normalize(-dLightmapDir + dViewDirW);\n        vec3 specularLight = dLightmap * getLightSpecular(halfDirW);\n\n        #ifdef LIT_SPECULAR_FRESNEL\n        specularLight *= getFresnel(dot(dViewDirW, halfDirW), dSpecularity);\n        #endif\n\n        dSpecularLight += specularLight;\n    }\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/lightmapDirAdd.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/ltc.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/ltc.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ltc)\n/* harmony export */ });\nvar ltc = `\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nmat3 transposeMat3( const in mat3 m ) {\n    mat3 tmp;\n    tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n    tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n    tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n    return tmp;\n}\n\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n    const float LUT_SIZE = 64.0;\n    const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n    const float LUT_BIAS = 0.5 / LUT_SIZE;\n    float dotNV = saturate( dot( N, V ) );\n    // texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n    vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n    uv = uv * LUT_SCALE + LUT_BIAS;\n    return uv;\n}\n\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n    // Real-Time Area Lighting: a Journey from Research to Production (p.102)\n    // An approximation of the form factor of a horizon-clipped rectangle.\n    float l = length( f );\n    return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\n\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n    float x = dot( v1, v2 );\n    float y = abs( x );\n    // rational polynomial approximation to theta / sin( theta ) / 2PI\n    float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n    float b = 3.4175940 + ( 4.1616724 + y ) * y;\n    float v = a / b;\n    float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n    return cross( v1, v2 ) * theta_sintheta;\n}\n\nstruct Coords {\n    vec3 coord0;\n    vec3 coord1;\n    vec3 coord2;\n    vec3 coord3;\n};\n\nfloat LTC_EvaluateRect( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in Coords rectCoords) {\n    // bail if point is on back side of plane of light\n    // assumes ccw winding order of light vertices\n    vec3 v1 = rectCoords.coord1 - rectCoords.coord0;\n    vec3 v2 = rectCoords.coord3 - rectCoords.coord0;\n    \n    vec3 lightNormal = cross( v1, v2 );\n    // if( dot( lightNormal, P - rectCoords.coord0 ) < 0.0 ) return 0.0;\n    float factor = sign(-dot( lightNormal, P - rectCoords.coord0 ));\n\n    // construct orthonormal basis around N\n    vec3 T1, T2;\n    T1 = normalize( V - N * dot( V, N ) );\n    T2 =  factor * cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system\n    // compute transform\n    mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n    // transform rect\n    vec3 coords[ 4 ];\n    coords[ 0 ] = mat * ( rectCoords.coord0 - P );\n    coords[ 1 ] = mat * ( rectCoords.coord1 - P );\n    coords[ 2 ] = mat * ( rectCoords.coord2 - P );\n    coords[ 3 ] = mat * ( rectCoords.coord3 - P );\n    // project rect onto sphere\n    coords[ 0 ] = normalize( coords[ 0 ] );\n    coords[ 1 ] = normalize( coords[ 1 ] );\n    coords[ 2 ] = normalize( coords[ 2 ] );\n    coords[ 3 ] = normalize( coords[ 3 ] );\n    // calculate vector form factor\n    vec3 vectorFormFactor = vec3( 0.0 );\n    vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n    vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n    vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n    vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n    // adjust for horizon clipping\n    float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\n    return result;\n}\n\nCoords dLTCCoords;\nCoords getLTCLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){\n    Coords coords;\n    coords.coord0 = lightPos + halfWidth - halfHeight;\n    coords.coord1 = lightPos - halfWidth - halfHeight;\n    coords.coord2 = lightPos - halfWidth + halfHeight;\n    coords.coord3 = lightPos + halfWidth + halfHeight;\n    return coords;\n}\n\nfloat dSphereRadius;\nCoords getSphereLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){\n    // used for simple sphere light falloff\n    // also, the code only handles a spherical light, it cannot be non-uniformly scaled in world space, and so we enforce it here\n    dSphereRadius = max(length(halfWidth), length(halfHeight));\n\n    // Billboard the 2d light quad to reflection vector, as it's used for specular. This allows us to use disk math for the sphere.\n    vec3 f = reflect(normalize(lightPos - view_position), vNormalW);\n    vec3 w = normalize(cross(f, halfHeight));\n    vec3 h = normalize(cross(f, w));\n\n    return getLTCLightCoords(lightPos, w * dSphereRadius, h * dSphereRadius);\n}\n\n// used for LTC LUT texture lookup\nvec2 dLTCUV;\n#ifdef LIT_CLEARCOAT\nvec2 ccLTCUV;\n#endif\nvec2 getLTCLightUV(float tGlossiness, vec3 tNormalW)\n{\n    float roughness = max((1.0 - tGlossiness) * (1.0 - tGlossiness), 0.001);\n    return LTC_Uv( tNormalW, dViewDirW, roughness );\n}\n\n//used for energy conservation and to modulate specular\nvec3 dLTCSpecFres;\n#ifdef LIT_CLEARCOAT\nvec3 ccLTCSpecFres;\n#endif\nvec3 getLTCLightSpecFres(vec2 uv, vec3 tSpecularity)\n{\n    vec4 t2 = texture2DLodEXT(areaLightsLutTex2, uv, 0.0);\n\n    #ifdef AREA_R8_G8_B8_A8_LUTS\n    t2 *= vec4(0.693103,1,1,1);\n    t2 += vec4(0.306897,0,0,0);\n    #endif\n\n    return tSpecularity * t2.x + ( vec3( 1.0 ) - tSpecularity) * t2.y;\n}\n\nvoid calcLTCLightValues()\n{\n    dLTCUV = getLTCLightUV(dGlossiness, dNormalW);\n    dLTCSpecFres = getLTCLightSpecFres(dLTCUV, dSpecularity); \n\n#ifdef LIT_CLEARCOAT\n    ccLTCUV = getLTCLightUV(ccGlossiness, ccNormalW);\n    ccLTCSpecFres = getLTCLightSpecFres(ccLTCUV, vec3(ccSpecularity));\n#endif\n}\n\nvoid calcRectLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n    dLTCCoords = getLTCLightCoords(lightPos, halfWidth, halfHeight);\n}\nvoid calcDiskLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n    calcRectLightValues(lightPos, halfWidth, halfHeight);\n}\nvoid calcSphereLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n    dLTCCoords = getSphereLightCoords(lightPos, halfWidth, halfHeight);\n}\n\n// An extended version of the implementation from\n// \"How to solve a cubic equation, revisited\"\n// http://momentsingraphics.de/?p=105\nvec3 SolveCubic(vec4 Coefficient)\n{\n    float pi = 3.14159;\n    // Normalize the polynomial\n    Coefficient.xyz /= Coefficient.w;\n    // Divide middle coefficients by three\n    Coefficient.yz /= 3.0;\n\n    float A = Coefficient.w;\n    float B = Coefficient.z;\n    float C = Coefficient.y;\n    float D = Coefficient.x;\n\n    // Compute the Hessian and the discriminant\n    vec3 Delta = vec3(\n        -Coefficient.z * Coefficient.z + Coefficient.y,\n        -Coefficient.y * Coefficient.z + Coefficient.x,\n        dot(vec2(Coefficient.z, -Coefficient.y), Coefficient.xy)\n    );\n\n    float Discriminant = dot(vec2(4.0 * Delta.x, -Delta.y), Delta.zy);\n\n    vec3 RootsA, RootsD;\n\n    vec2 xlc, xsc;\n\n    // Algorithm A\n    {\n        float A_a = 1.0;\n        float C_a = Delta.x;\n        float D_a = -2.0 * B * Delta.x + Delta.y;\n\n        // Take the cubic root of a normalized complex number\n        float Theta = atan(sqrt(Discriminant), -D_a) / 3.0;\n\n        float x_1a = 2.0 * sqrt(-C_a) * cos(Theta);\n        float x_3a = 2.0 * sqrt(-C_a) * cos(Theta + (2.0 / 3.0) * pi);\n\n        float xl;\n        if ((x_1a + x_3a) > 2.0 * B)\n            xl = x_1a;\n        else\n            xl = x_3a;\n\n        xlc = vec2(xl - B, A);\n    }\n\n    // Algorithm D\n    {\n        float A_d = D;\n        float C_d = Delta.z;\n        float D_d = -D * Delta.y + 2.0 * C * Delta.z;\n\n        // Take the cubic root of a normalized complex number\n        float Theta = atan(D * sqrt(Discriminant), -D_d) / 3.0;\n\n        float x_1d = 2.0 * sqrt(-C_d) * cos(Theta);\n        float x_3d = 2.0 * sqrt(-C_d) * cos(Theta + (2.0 / 3.0) * pi);\n\n        float xs;\n        if (x_1d + x_3d < 2.0 * C)\n            xs = x_1d;\n        else\n            xs = x_3d;\n\n        xsc = vec2(-D, xs + C);\n    }\n\n    float E =  xlc.y * xsc.y;\n    float F = -xlc.x * xsc.y - xlc.y * xsc.x;\n    float G =  xlc.x * xsc.x;\n\n    vec2 xmc = vec2(C * F - B * G, -B * F + C * E);\n\n    vec3 Root = vec3(xsc.x / xsc.y, xmc.x / xmc.y, xlc.x / xlc.y);\n\n    if (Root.x < Root.y && Root.x < Root.z)\n        Root.xyz = Root.yxz;\n    else if (Root.z < Root.x && Root.z < Root.y)\n        Root.xyz = Root.xzy;\n\n    return Root;\n}\n\nfloat LTC_EvaluateDisk(vec3 N, vec3 V, vec3 P, mat3 Minv, Coords points)\n{\n    // construct orthonormal basis around N\n    vec3 T1, T2;\n    T1 = normalize(V - N * dot(V, N));\n    T2 = cross(N, T1);\n\n    // rotate area light in (T1, T2, N) basis\n    //mat3 R = transpose(mat3(T1, T2, N));\n    mat3 R = transposeMat3( mat3( T1, T2, N ) );\n    // polygon (allocate 5 vertices for clipping)\n    vec3 L_[ 3 ];\n    L_[ 0 ] = R * ( points.coord0 - P );\n    L_[ 1 ] = R * ( points.coord1 - P );\n    L_[ 2 ] = R * ( points.coord2 - P );\n\n    vec3 Lo_i = vec3(0);\n\n    // init ellipse\n    vec3 C  = 0.5 * (L_[0] + L_[2]);\n    vec3 V1 = 0.5 * (L_[1] - L_[2]);\n    vec3 V2 = 0.5 * (L_[1] - L_[0]);\n\n    C  = Minv * C;\n    V1 = Minv * V1;\n    V2 = Minv * V2;\n\n    //if(dot(cross(V1, V2), C) > 0.0)\n    //    return 0.0;\n\n    // compute eigenvectors of ellipse\n    float a, b;\n    float d11 = dot(V1, V1);\n    float d22 = dot(V2, V2);\n    float d12 = dot(V1, V2);\n    if (abs(d12) / sqrt(d11 * d22) > 0.0001)\n    {\n        float tr = d11 + d22;\n        float det = -d12 * d12 + d11 * d22;\n\n        // use sqrt matrix to solve for eigenvalues\n        det = sqrt(det);\n        float u = 0.5 * sqrt(tr - 2.0 * det);\n        float v = 0.5 * sqrt(tr + 2.0 * det);\n        float e_max = (u + v) * (u + v);\n        float e_min = (u - v) * (u - v);\n\n        vec3 V1_, V2_;\n\n        if (d11 > d22)\n        {\n            V1_ = d12 * V1 + (e_max - d11) * V2;\n            V2_ = d12 * V1 + (e_min - d11) * V2;\n        }\n        else\n        {\n            V1_ = d12*V2 + (e_max - d22)*V1;\n            V2_ = d12*V2 + (e_min - d22)*V1;\n        }\n\n        a = 1.0 / e_max;\n        b = 1.0 / e_min;\n        V1 = normalize(V1_);\n        V2 = normalize(V2_);\n    }\n    else\n    {\n        a = 1.0 / dot(V1, V1);\n        b = 1.0 / dot(V2, V2);\n        V1 *= sqrt(a);\n        V2 *= sqrt(b);\n    }\n\n    vec3 V3 = cross(V1, V2);\n    if (dot(C, V3) < 0.0)\n        V3 *= -1.0;\n\n    float L  = dot(V3, C);\n    float x0 = dot(V1, C) / L;\n    float y0 = dot(V2, C) / L;\n\n    float E1 = inversesqrt(a);\n    float E2 = inversesqrt(b);\n\n    a *= L * L;\n    b *= L * L;\n\n    float c0 = a * b;\n    float c1 = a * b * (1.0 + x0 * x0 + y0 * y0) - a - b;\n    float c2 = 1.0 - a * (1.0 + x0 * x0) - b * (1.0 + y0 * y0);\n    float c3 = 1.0;\n\n    vec3 roots = SolveCubic(vec4(c0, c1, c2, c3));\n    float e1 = roots.x;\n    float e2 = roots.y;\n    float e3 = roots.z;\n\n    vec3 avgDir = vec3(a * x0 / (a - e2), b * y0 / (b - e2), 1.0);\n\n    mat3 rotate = mat3(V1, V2, V3);\n\n    avgDir = rotate * avgDir;\n    avgDir = normalize(avgDir);\n\n    float L1 = sqrt(-e2 / e3);\n    float L2 = sqrt(-e2 / e1);\n\n    float formFactor = L1 * L2 * inversesqrt((1.0 + L1 * L1) * (1.0 + L2 * L2));\n    \n    const float LUT_SIZE = 64.0;\n    const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n    const float LUT_BIAS = 0.5 / LUT_SIZE;\n\n    // use tabulated horizon-clipped sphere\n    vec2 uv = vec2(avgDir.z * 0.5 + 0.5, formFactor);\n    uv = uv*LUT_SCALE + LUT_BIAS;\n\n    float scale = texture2DLodEXT(areaLightsLutTex2, uv, 0.0).w;\n\n    return formFactor*scale;\n}\n\nfloat getRectLightDiffuse() {\n    return LTC_EvaluateRect( dNormalW, dViewDirW, vPositionW, mat3( 1.0 ), dLTCCoords );\n}\n\nfloat getDiskLightDiffuse() {\n    return LTC_EvaluateDisk( dNormalW, dViewDirW, vPositionW, mat3( 1.0 ), dLTCCoords );\n}\n\nfloat getSphereLightDiffuse() {\n    // NB: this could be improved further with distance based wrap lighting\n    float falloff = dSphereRadius / (dot(dLightDirW, dLightDirW) + dSphereRadius);\n    return getLightDiffuse()*falloff;\n}\n\nmat3 getLTCLightInvMat(vec2 uv)\n{\n    vec4 t1 = texture2DLodEXT(areaLightsLutTex1, uv, 0.0);\n\n    #ifdef AREA_R8_G8_B8_A8_LUTS\n    t1 *= vec4(1.001, 0.3239, 0.60437568, 1.0);\n    t1 += vec4(0.0, -0.2976, -0.01381, 0.0);\n    #endif\n\n    return mat3(\n        vec3( t1.x, 0, t1.y ),\n        vec3(    0, 1,    0 ),\n        vec3( t1.z, 0, t1.w )\n    );\n}\n\nfloat calcRectLightSpecular(vec3 tNormalW, vec2 uv) {\n    mat3 mInv = getLTCLightInvMat(uv);\n    return LTC_EvaluateRect( tNormalW, dViewDirW, vPositionW, mInv, dLTCCoords );\n}\n\nfloat getRectLightSpecular() {\n    return calcRectLightSpecular(dNormalW, dLTCUV);\n}\n\n#ifdef LIT_CLEARCOAT\nfloat getRectLightSpecularCC() {\n    return calcRectLightSpecular(ccNormalW, ccLTCUV);\n}\n#endif\n\nfloat calcDiskLightSpecular(vec3 tNormalW, vec2 uv) {\n    mat3 mInv = getLTCLightInvMat(uv);\n    return LTC_EvaluateDisk( tNormalW, dViewDirW, vPositionW, mInv, dLTCCoords );\n}\n\nfloat getDiskLightSpecular() {\n    return calcDiskLightSpecular(dNormalW, dLTCUV);\n}\n\n#ifdef LIT_CLEARCOAT\nfloat getDiskLightSpecularCC() {\n    return calcDiskLightSpecular(ccNormalW, ccLTCUV);\n}\n#endif\n\nfloat getSphereLightSpecular() {\n    return calcDiskLightSpecular(dNormalW, dLTCUV);\n}\n\n#ifdef LIT_CLEARCOAT\nfloat getSphereLightSpecularCC() {\n    return calcDiskLightSpecular(ccNormalW, ccLTCUV);\n}\n#endif\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/ltc.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/metalnessModulate.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/metalnessModulate.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ metalnessModulatePS)\n/* harmony export */ });\nvar metalnessModulatePS = `\n\nuniform float material_f0;\n\nvoid getMetalnessModulate() {\n    vec3 dielectricF0 = material_f0 * dSpecularity;\n    dSpecularity = mix(dielectricF0, dAlbedo, dMetalness);\n    dAlbedo *= 1.0 - dMetalness;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/metalnessModulate.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/outputAlpha.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/outputAlpha.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ outputAlphaPS)\n/* harmony export */ });\nvar outputAlphaPS = `\ngl_FragColor.a = dAlpha;\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/outputAlpha.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/outputAlphaOpaque.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/outputAlphaOpaque.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ outputAlphaOpaquePS)\n/* harmony export */ });\nvar outputAlphaOpaquePS = `\n    gl_FragColor.a = 1.0;\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/outputAlphaOpaque.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/outputAlphaPremul.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/outputAlphaPremul.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ outputAlphaPremulPS)\n/* harmony export */ });\nvar outputAlphaPremulPS = `\ngl_FragColor.rgb *= dAlpha;\ngl_FragColor.a = dAlpha;\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/outputAlphaPremul.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflDir.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflDir.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ reflDirPS)\n/* harmony export */ });\nvar reflDirPS = `\nvoid getReflDir() {\n    dReflDirW = normalize(-reflect(dViewDirW, dNormalW));\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflDir.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflDirAniso.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflDirAniso.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ reflDirAnisoPS)\n/* harmony export */ });\nvar reflDirAnisoPS = `\nvoid getReflDir() {\n    float roughness = sqrt(1.0 - min(dGlossiness, 1.0));\n    float anisotropy = material_anisotropy * roughness;\n    vec3 anisotropicDirection = anisotropy >= 0.0 ? dTBN[1] : dTBN[0];\n    vec3 anisotropicTangent = cross(anisotropicDirection, dViewDirW);\n    vec3 anisotropicNormal = cross(anisotropicTangent, anisotropicDirection);\n    vec3 bentNormal = normalize(mix(normalize(dNormalW), normalize(anisotropicNormal), anisotropy));\n    dReflDirW = reflect(-dViewDirW, bentNormal);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflDirAniso.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflectionCC.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflectionCC.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ reflectionCCPS)\n/* harmony export */ });\nvar reflectionCCPS = `\n#ifdef LIT_CLEARCOAT\nvoid addReflectionCC() {\n    ccReflection += calcReflection(ccReflDirW, ccGlossiness);\n}\n#endif\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflectionCC.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflectionCube.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflectionCube.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ reflectionCubePS)\n/* harmony export */ });\nvar reflectionCubePS = `\nuniform samplerCube texture_cubeMap;\nuniform float material_reflectivity;\n\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n    vec3 lookupVec = fixSeams(cubeMapProject(tReflDirW));\n    lookupVec.x *= -1.0;\n    return $DECODE(textureCube(texture_cubeMap, lookupVec));\n}\n\nvoid addReflection() {   \n    dReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflectionCube.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflectionEnv.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflectionEnv.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ reflectionEnvPS)\n/* harmony export */ });\nvar reflectionEnvPS = `\n#ifndef ENV_ATLAS\n#define ENV_ATLAS\nuniform sampler2D texture_envAtlas;\n#endif\nuniform float material_reflectivity;\n\n// calculate mip level for shiny reflection given equirect coords uv.\nfloat shinyMipLevel(vec2 uv) {\n    vec2 dx = dFdx(uv);\n    vec2 dy = dFdy(uv);\n\n    // calculate second dF at 180 degrees\n    vec2 uv2 = vec2(fract(uv.x + 0.5), uv.y);\n    vec2 dx2 = dFdx(uv2);\n    vec2 dy2 = dFdy(uv2);\n\n    // calculate min of both sets of dF to handle discontinuity at the azim edge\n    float maxd = min(max(dot(dx, dx), dot(dy, dy)), max(dot(dx2, dx2), dot(dy2, dy2)));\n\n    return clamp(0.5 * log2(maxd) - 1.0 + textureBias, 0.0, 5.0);\n}\n\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n    vec3 dir = cubeMapProject(tReflDirW) * vec3(-1.0, 1.0, 1.0);\n    vec2 uv = toSphericalUv(dir);\n\n    // calculate roughness level\n    float level = saturate(1.0 - tGlossiness) * 5.0;\n    float ilevel = floor(level);\n\n    // accessing the shiny (top level) reflection - perform manual mipmap lookup\n    float level2 = shinyMipLevel(uv * atlasSize);\n    float ilevel2 = floor(level2);\n\n    vec2 uv0, uv1;\n    float weight;\n    if (ilevel == 0.0) {\n        uv0 = mapShinyUv(uv, ilevel2);\n        uv1 = mapShinyUv(uv, ilevel2 + 1.0);\n        weight = level2 - ilevel2;\n    } else {\n        // accessing rough reflection - just sample the same part twice\n        uv0 = uv1 = mapRoughnessUv(uv, ilevel);\n        weight = 0.0;\n    }\n\n    vec3 linearA = $DECODE(texture2D(texture_envAtlas, uv0));\n    vec3 linearB = $DECODE(texture2D(texture_envAtlas, uv1));\n    vec3 linear0 = mix(linearA, linearB, weight);\n    vec3 linear1 = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));\n\n    return processEnvironment(mix(linear0, linear1, level - ilevel));\n}\n\nvoid addReflection() {   \n    dReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflectionEnv.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflectionEnvHQ.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflectionEnvHQ.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ reflectionEnvHQPS)\n/* harmony export */ });\nvar reflectionEnvHQPS = `\n#ifndef ENV_ATLAS\n#define ENV_ATLAS\nuniform sampler2D texture_envAtlas;\n#endif\nuniform samplerCube texture_cubeMap;\nuniform float material_reflectivity;\n\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n    vec3 dir = cubeMapProject(tReflDirW) * vec3(-1.0, 1.0, 1.0);\n    vec2 uv = toSphericalUv(dir);\n\n    // calculate roughness level\n    float level = saturate(1.0 - tGlossiness) * 5.0;\n    float ilevel = floor(level);\n    float flevel = level - ilevel;\n\n    vec3 sharp = $DECODE(textureCube(texture_cubeMap, fixSeams(dir)));\n    vec3 roughA = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel)));\n    vec3 roughB = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));\n\n    return processEnvironment(mix(sharp, mix(roughA, roughB, flevel), min(level, 1.0)));\n}\n\nvoid addReflection() {   \n    dReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflectionEnvHQ.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflectionSheen.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflectionSheen.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ reflectionSheenPS)\n/* harmony export */ });\nvar reflectionSheenPS = `\n\nvoid addReflectionSheen() {\n    float NoV = dot(dNormalW, dViewDirW);\n    float alphaG = sGlossiness * sGlossiness;\n\n    // Avoid using a LUT and approximate the values analytically\n    float a = sGlossiness < 0.25 ? -339.2 * alphaG + 161.4 * sGlossiness - 25.9 : -8.48 * alphaG + 14.3 * sGlossiness - 9.95;\n    float b = sGlossiness < 0.25 ? 44.0 * alphaG - 23.7 * sGlossiness + 3.26 : 1.97 * alphaG - 3.27 * sGlossiness + 0.72;\n    float DG = exp( a * NoV + b ) + ( sGlossiness < 0.25 ? 0.0 : 0.1 * ( sGlossiness - 0.25 ) );\n    sReflection += calcReflection(dNormalW, 0.0) * saturate(DG);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflectionSheen.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflectionSphere.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflectionSphere.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ reflectionSpherePS)\n/* harmony export */ });\nvar reflectionSpherePS = `\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\n\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n    vec3 reflDirV = (mat3(matrix_view) * tReflDirW).xyz;\n\n    float m = 2.0 * sqrt( dot(reflDirV.xy, reflDirV.xy) + (reflDirV.z+1.0)*(reflDirV.z+1.0) );\n    vec2 sphereMapUv = reflDirV.xy / m + 0.5;\n\n    return $DECODE(texture2D(texture_sphereMap, sphereMapUv));\n}\n\nvoid addReflection() {   \n    dReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflectionSphere.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflectionSphereLow.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflectionSphereLow.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ reflectionSphereLowPS)\n/* harmony export */ });\nvar reflectionSphereLowPS = `\nuniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\n\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n    vec3 reflDirV = vNormalV;\n\n    vec2 sphereMapUv = reflDirV.xy * 0.5 + 0.5;\n    return $DECODE(texture2D(texture_sphereMap, sphereMapUv));\n}\n\nvoid addReflection() {   \n    dReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/reflectionSphereLow.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/refractionCube.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/refractionCube.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ refractionCubePS)\n/* harmony export */ });\nvar refractionCubePS = `\nuniform float material_refractionIndex;\n\nvec3 refract2(vec3 viewVec, vec3 Normal, float IOR) {\n    float vn = dot(viewVec, Normal);\n    float k = 1.0 - IOR * IOR * (1.0 - vn * vn);\n    vec3 refrVec = IOR * viewVec - (IOR * vn + sqrt(k)) * Normal;\n    return refrVec;\n}\n\nvoid addRefraction() {\n    // use same reflection code with refraction vector\n    vec3 tmpDir = dReflDirW;\n    vec4 tmpRefl = dReflection;\n    dReflDirW = refract2(-dViewDirW, dNormalW, material_refractionIndex);\n    dReflection = vec4(0);\n    addReflection();\n    dDiffuseLight = mix(dDiffuseLight, dReflection.rgb * dAlbedo, dTransmission);\n    dReflection = tmpRefl;\n    dReflDirW = tmpDir;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/refractionCube.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/refractionDynamic.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/refractionDynamic.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ refractionDynamicPS)\n/* harmony export */ });\nvar refractionDynamicPS = `\nuniform float material_refractionIndex;\nuniform float material_invAttenuationDistance;\nuniform vec3 material_attenuation;\n\nvec3 refract2(vec3 viewVec, vec3 Normal, float IOR) {\n    float vn = dot(viewVec, Normal);\n    float k = 1.0 - IOR * IOR * (1.0 - vn * vn);\n    vec3 refrVec = IOR * viewVec - (IOR * vn + sqrt(k)) * Normal;\n    return refrVec;\n}\n\nvoid addRefraction() {\n\n    // Extract scale from the model transform\n    vec3 modelScale;\n    modelScale.x = length(vec3(matrix_model[0].xyz));\n    modelScale.y = length(vec3(matrix_model[1].xyz));\n    modelScale.z = length(vec3(matrix_model[2].xyz));\n\n    // Calculate the refraction vector, scaled by the thickness and scale of the object\n    vec3 refractionVector = normalize(refract(-dViewDirW, dNormalW, material_refractionIndex)) * dThickness * modelScale;\n\n    // The refraction point is the entry point + vector to exit point\n    vec4 pointOfRefraction = vec4(vPositionW + refractionVector, 1.0);\n\n    // Project to texture space so we can sample it\n    vec4 projectionPoint = matrix_viewProjection * pointOfRefraction;\n\n    // use built-in getGrabScreenPos function to convert screen position to grab texture uv coords\n    vec2 uv = getGrabScreenPos(projectionPoint);\n\n    #ifdef SUPPORTS_TEXLOD\n        // Use IOR and roughness to select mip\n        float iorToRoughness = (1.0 - dGlossiness) * clamp((1.0 / material_refractionIndex) * 2.0 - 2.0, 0.0, 1.0);\n        float refractionLod = log2(uScreenSize.x) * iorToRoughness;\n        vec3 refraction = texture2DLodEXT(uSceneColorMap, uv, refractionLod).rgb;\n    #else\n        vec3 refraction = texture2D(uSceneColorMap, uv).rgb;\n    #endif\n\n    // Transmittance is our final refraction color\n    vec3 transmittance;\n    if (material_invAttenuationDistance != 0.0)\n    {\n        vec3 attenuation = -log(material_attenuation) * material_invAttenuationDistance;\n        transmittance = exp(-attenuation * length(refractionVector));\n    }\n    else\n    {\n        transmittance = refraction;\n    }\n\n    // Apply fresnel effect on refraction\n    vec3 fresnel = vec3(1.0) - getFresnel(dot(dViewDirW, dNormalW), dSpecularity);\n    dDiffuseLight = mix(dDiffuseLight, refraction * transmittance * fresnel, dTransmission);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/refractionDynamic.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowCascades.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowCascades.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ shadowCascadesPS)\n/* harmony export */ });\nvar shadowCascadesPS = `\nconst float maxCascades = 4.0;\n\n// shadow matrix for selected cascade\nmat4 cascadeShadowMat;\n\n// function which selects a shadow projection matrix based on cascade distances \nvoid getShadowCascadeMatrix(mat4 shadowMatrixPalette[4], float shadowCascadeDistances[4], float shadowCascadeCount) {\n\n    // depth in 0 .. far plane range\n    float depth = 1.0 / gl_FragCoord.w;\n\n    // find cascade index based on the depth (loop as there is no per component vec compare operator in webgl)\n    float cascadeIndex = 0.0;\n    for (float i = 0.0; i < maxCascades; i++) {\n        if (depth < shadowCascadeDistances[int(i)]) {\n            cascadeIndex = i;\n            break;\n        }\n    }\n\n    // limit to actual number of used cascades\n    cascadeIndex = min(cascadeIndex, shadowCascadeCount - 1.0);\n\n    // pick shadow matrix\n    #ifdef GL2\n        cascadeShadowMat = shadowMatrixPalette[int(cascadeIndex)];\n    #else\n        // webgl 1 does not allow non-cost index array lookup\n        if (cascadeIndex == 0.0) {\n            cascadeShadowMat = shadowMatrixPalette[0];\n        }\n        else if (cascadeIndex == 1.0) {\n            cascadeShadowMat = shadowMatrixPalette[1];\n        }\n        else if (cascadeIndex == 2.0) {\n            cascadeShadowMat = shadowMatrixPalette[2];\n        }\n        else {\n            cascadeShadowMat = shadowMatrixPalette[3];\n        }\n    #endif\n}\n\nvoid fadeShadow(float shadowCascadeDistances[4]) {                  \n\n    // if the pixel is past the shadow distance, remove shadow\n    // this enforces straight line instead of corner of shadow which moves when camera rotates  \n    float depth = 1.0 / gl_FragCoord.w;\n    if (depth > shadowCascadeDistances[int(maxCascades - 1.0)]) {\n        dShadowCoord.z = -9999999.0;\n    }\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowCascades.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowCommon.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowCommon.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ shadowCommonPS)\n/* harmony export */ });\nvar shadowCommonPS = `\nvoid normalOffsetPointShadow(vec4 shadowParams) {\n    float distScale = length(dLightDirW);\n    vec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale; //0.02\n    vec3 dir = wPos - dLightPosW;\n    dLightDirW = dir;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowCommon.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowCoord.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowCoord.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ shadowCoordPS)\n/* harmony export */ });\nvar shadowCoordPS = `\nvoid _getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams, vec3 wPos) {\n    dShadowCoord = (shadowMatrix * vec4(wPos, 1.0)).xyz;\n    dShadowCoord.z = saturate(dShadowCoord.z) - 0.0001;\n\n    #ifdef SHADOWBIAS\n    dShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n    #endif\n}\n\nvoid _getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\n    vec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n    projPos.xy /= projPos.w;\n    dShadowCoord.xy = projPos.xy;\n    dShadowCoord.z = length(dLightDirW) * shadowParams.w;\n\n    #ifdef SHADOWBIAS\n    dShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n    #endif\n}\n\nvoid getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams) {\n    _getShadowCoordOrtho(shadowMatrix, shadowParams, vPositionW);\n}\n\nvoid getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams) {\n    _getShadowCoordPersp(shadowMatrix, shadowParams, vPositionW);\n}\n\nvoid getShadowCoordPerspNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {\n    float distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW)); // fov?\n    vec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n\n    _getShadowCoordPersp(shadowMatrix, shadowParams, wPos);\n}\n\nvoid getShadowCoordOrthoNormalOffset(mat4 shadowMatrix, vec3 shadowParams) {\n    vec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0); //0.08\n\n    _getShadowCoordOrtho(shadowMatrix, shadowParams, wPos);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowCoord.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowCoordPerspZbuffer.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowCoordPerspZbuffer.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ shadowCoordPerspZbufferPS)\n/* harmony export */ });\nvar shadowCoordPerspZbufferPS = `\nvoid _getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\n    vec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n    projPos.xyz /= projPos.w;\n    dShadowCoord = projPos.xyz;\n    // depth bias is already applied on render\n}\n\nvoid getShadowCoordPerspZbufferNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {\n    vec3 wPos = vPositionW + dVertexNormalW * shadowParams.y;\n    _getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, wPos);\n}\n\nvoid getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams) {\n    _getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, vPositionW);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowCoordPerspZbuffer.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowEVSM.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowEVSM.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ shadowEVSMPS)\n/* harmony export */ });\nvar shadowEVSMPS = `\nfloat VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n    vec3 moments = texture2D(tex, texCoords).xyz;\n    return calculateEVSM(moments, Z, vsmBias, exponent);\n}\n\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n    return VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\n\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n    return VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowEVSM.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowEVSMn.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowEVSMn.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ shadowEVSMnPS)\n/* harmony export */ });\nvar shadowEVSMnPS = `\nfloat VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n    float pixelSize = 1.0 / resolution;\n    texCoords -= vec2(pixelSize);\n    vec3 s00 = texture2D(tex, texCoords).xyz;\n    vec3 s10 = texture2D(tex, texCoords + vec2(pixelSize, 0)).xyz;\n    vec3 s01 = texture2D(tex, texCoords + vec2(0, pixelSize)).xyz;\n    vec3 s11 = texture2D(tex, texCoords + vec2(pixelSize)).xyz;\n    vec2 fr = fract(texCoords * resolution);\n    vec3 h0 = mix(s00, s10, fr.x);\n    vec3 h1 = mix(s01, s11, fr.x);\n    vec3 moments = mix(h0, h1, fr.y);\n    return calculateEVSM(moments, Z, vsmBias, exponent);\n}\n\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n    return VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\n\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n    return VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowEVSMn.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowStandard.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowStandard.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ shadowStandardPS)\n/* harmony export */ });\nvar shadowStandardPS = `\nvec3 lessThan2(vec3 a, vec3 b) {\n    return clamp((b - a)*1000.0, 0.0, 1.0); // softer version\n}\n\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n    const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n    return dot(rgbaDepth, bitShift);\n}\n#endif\n\n// ----- Direct/Spot Sampling -----\n\n#ifdef GL2\n\nfloat _getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowParams) {\n    float z = dShadowCoord.z;\n    vec2 uv = dShadowCoord.xy * shadowParams.x; // 1 unit - 1 texel\n    float shadowMapSizeInv = 1.0 / shadowParams.x;\n    vec2 base_uv = floor(uv + 0.5);\n    float s = (uv.x + 0.5 - base_uv.x);\n    float t = (uv.y + 0.5 - base_uv.y);\n    base_uv -= vec2(0.5);\n    base_uv *= shadowMapSizeInv;\n\n    float sum = 0.0;\n\n    float uw0 = (3.0 - 2.0 * s);\n    float uw1 = (1.0 + 2.0 * s);\n\n    float u0 = (2.0 - s) / uw0 - 1.0;\n    float u1 = s / uw1 + 1.0;\n\n    float vw0 = (3.0 - 2.0 * t);\n    float vw1 = (1.0 + 2.0 * t);\n\n    float v0 = (2.0 - t) / vw0 - 1.0;\n    float v1 = t / vw1 + 1.0;\n\n    u0 = u0 * shadowMapSizeInv + base_uv.x;\n    v0 = v0 * shadowMapSizeInv + base_uv.y;\n\n    u1 = u1 * shadowMapSizeInv + base_uv.x;\n    v1 = v1 * shadowMapSizeInv + base_uv.y;\n\n    sum += uw0 * vw0 * textureShadow(shadowMap, vec3(u0, v0, z));\n    sum += uw1 * vw0 * textureShadow(shadowMap, vec3(u1, v0, z));\n    sum += uw0 * vw1 * textureShadow(shadowMap, vec3(u0, v1, z));\n    sum += uw1 * vw1 * textureShadow(shadowMap, vec3(u1, v1, z));\n\n    sum *= 1.0f / 16.0;\n    return sum;\n}\n\nfloat getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowParams) {\n    return _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowParams);\n}\n\nfloat getShadowSpotPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams) {\n    return _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowParams.xyz);\n}\n\n#else // GL1\n\nfloat _xgetShadowPCF3x3(mat3 depthKernel, sampler2D shadowMap, vec3 shadowParams) {\n    mat3 shadowKernel;\n    vec3 shadowCoord = dShadowCoord;\n    vec3 shadowZ = vec3(shadowCoord.z);\n    shadowKernel[0] = vec3(greaterThan(depthKernel[0], shadowZ));\n    shadowKernel[1] = vec3(greaterThan(depthKernel[1], shadowZ));\n    shadowKernel[2] = vec3(greaterThan(depthKernel[2], shadowZ));\n\n    vec2 fractionalCoord = fract( shadowCoord.xy * shadowParams.x );\n\n    shadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\n    shadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\n\n    vec4 shadowValues;\n    shadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\n    shadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\n    shadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\n    shadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\n\n    return dot( shadowValues, vec4( 1.0 ) ) * 0.25;\n}\n\nfloat _getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {\n    vec3 shadowCoord = dShadowCoord;\n\n    float xoffset = 1.0 / shadowParams.x; // 1/shadow map width\n    float dx0 = -xoffset;\n    float dx1 = xoffset;\n\n    mat3 depthKernel;\n    depthKernel[0][0] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx0, dx0)));\n    depthKernel[0][1] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx0, 0.0)));\n    depthKernel[0][2] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx0, dx1)));\n    depthKernel[1][0] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(0.0, dx0)));\n    depthKernel[1][1] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy));\n    depthKernel[1][2] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(0.0, dx1)));\n    depthKernel[2][0] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx1, dx0)));\n    depthKernel[2][1] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx1, 0.0)));\n    depthKernel[2][2] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx1, dx1)));\n\n    return _xgetShadowPCF3x3(depthKernel, shadowMap, shadowParams);\n}\n\nfloat getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {\n    return _getShadowPCF3x3(shadowMap, shadowParams);\n}\n\nfloat getShadowSpotPCF3x3(sampler2D shadowMap, vec4 shadowParams) {\n    return _getShadowPCF3x3(shadowMap, shadowParams.xyz);\n}\n#endif\n\n\n// ----- Omni Sampling -----\n\n#ifndef WEBGPU\n\nfloat _getShadowPoint(samplerCube shadowMap, vec4 shadowParams, vec3 dir) {\n\n    vec3 tc = normalize(dir);\n    vec3 tcAbs = abs(tc);\n\n    vec4 dirX = vec4(1,0,0, tc.x);\n    vec4 dirY = vec4(0,1,0, tc.y);\n    float majorAxisLength = tc.z;\n    if ((tcAbs.x > tcAbs.y) && (tcAbs.x > tcAbs.z)) {\n        dirX = vec4(0,0,1, tc.z);\n        dirY = vec4(0,1,0, tc.y);\n        majorAxisLength = tc.x;\n    } else if ((tcAbs.y > tcAbs.x) && (tcAbs.y > tcAbs.z)) {\n        dirX = vec4(1,0,0, tc.x);\n        dirY = vec4(0,0,1, tc.z);\n        majorAxisLength = tc.y;\n    }\n\n    float shadowParamsInFaceSpace = ((1.0/shadowParams.x) * 2.0) * abs(majorAxisLength);\n\n    vec3 xoffset = (dirX.xyz * shadowParamsInFaceSpace);\n    vec3 yoffset = (dirY.xyz * shadowParamsInFaceSpace);\n    vec3 dx0 = -xoffset;\n    vec3 dy0 = -yoffset;\n    vec3 dx1 = xoffset;\n    vec3 dy1 = yoffset;\n\n    mat3 shadowKernel;\n    mat3 depthKernel;\n\n    depthKernel[0][0] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy0));\n    depthKernel[0][1] = unpackFloat(textureCube(shadowMap, tc + dx0));\n    depthKernel[0][2] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy1));\n    depthKernel[1][0] = unpackFloat(textureCube(shadowMap, tc + dy0));\n    depthKernel[1][1] = unpackFloat(textureCube(shadowMap, tc));\n    depthKernel[1][2] = unpackFloat(textureCube(shadowMap, tc + dy1));\n    depthKernel[2][0] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy0));\n    depthKernel[2][1] = unpackFloat(textureCube(shadowMap, tc + dx1));\n    depthKernel[2][2] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy1));\n\n    vec3 shadowZ = vec3(length(dir) * shadowParams.w + shadowParams.z);\n\n    shadowKernel[0] = vec3(lessThan2(depthKernel[0], shadowZ));\n    shadowKernel[1] = vec3(lessThan2(depthKernel[1], shadowZ));\n    shadowKernel[2] = vec3(lessThan2(depthKernel[2], shadowZ));\n\n    vec2 uv = (vec2(dirX.w, dirY.w) / abs(majorAxisLength)) * 0.5;\n\n    vec2 fractionalCoord = fract( uv * shadowParams.x );\n\n    shadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\n    shadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\n\n    vec4 shadowValues;\n    shadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\n    shadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\n    shadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\n    shadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\n\n    return 1.0 - dot( shadowValues, vec4( 1.0 ) ) * 0.25;\n}\n\nfloat getShadowPointPCF3x3(samplerCube shadowMap, vec4 shadowParams) {\n    return _getShadowPoint(shadowMap, shadowParams, dLightDirW);\n}\n\n#endif\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowStandard.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowStandardGL2.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowStandardGL2.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ shadowStandardGL2PS)\n/* harmony export */ });\nvar shadowStandardGL2PS = `\nfloat _getShadowPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowParams) {\n    // http://the-witness.net/news/2013/09/shadow-mapping-summary-part-1/\n\n    float z = dShadowCoord.z;\n    vec2 uv = dShadowCoord.xy * shadowParams.x; // 1 unit - 1 texel\n    float shadowMapSizeInv = 1.0 / shadowParams.x;\n    vec2 base_uv = floor(uv + 0.5);\n    float s = (uv.x + 0.5 - base_uv.x);\n    float t = (uv.y + 0.5 - base_uv.y);\n    base_uv -= vec2(0.5);\n    base_uv *= shadowMapSizeInv;\n\n\n    float uw0 = (4.0 - 3.0 * s);\n    float uw1 = 7.0;\n    float uw2 = (1.0 + 3.0 * s);\n\n    float u0 = (3.0 - 2.0 * s) / uw0 - 2.0;\n    float u1 = (3.0 + s) / uw1;\n    float u2 = s / uw2 + 2.0;\n\n    float vw0 = (4.0 - 3.0 * t);\n    float vw1 = 7.0;\n    float vw2 = (1.0 + 3.0 * t);\n\n    float v0 = (3.0 - 2.0 * t) / vw0 - 2.0;\n    float v1 = (3.0 + t) / vw1;\n    float v2 = t / vw2 + 2.0;\n\n    float sum = 0.0;\n\n    u0 = u0 * shadowMapSizeInv + base_uv.x;\n    v0 = v0 * shadowMapSizeInv + base_uv.y;\n\n    u1 = u1 * shadowMapSizeInv + base_uv.x;\n    v1 = v1 * shadowMapSizeInv + base_uv.y;\n\n    u2 = u2 * shadowMapSizeInv + base_uv.x;\n    v2 = v2 * shadowMapSizeInv + base_uv.y;\n\n    sum += uw0 * vw0 * textureShadow(shadowMap, vec3(u0, v0, z));\n    sum += uw1 * vw0 * textureShadow(shadowMap, vec3(u1, v0, z));\n    sum += uw2 * vw0 * textureShadow(shadowMap, vec3(u2, v0, z));\n\n    sum += uw0 * vw1 * textureShadow(shadowMap, vec3(u0, v1, z));\n    sum += uw1 * vw1 * textureShadow(shadowMap, vec3(u1, v1, z));\n    sum += uw2 * vw1 * textureShadow(shadowMap, vec3(u2, v1, z));\n\n    sum += uw0 * vw2 * textureShadow(shadowMap, vec3(u0, v2, z));\n    sum += uw1 * vw2 * textureShadow(shadowMap, vec3(u1, v2, z));\n    sum += uw2 * vw2 * textureShadow(shadowMap, vec3(u2, v2, z));\n\n    sum *= 1.0f / 144.0;\n\n    sum = saturate(sum);\n\n    return sum;\n}\n\nfloat getShadowPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowParams) {\n    return _getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowParams);\n}\n\nfloat getShadowSpotPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams) {\n    return _getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowParams.xyz);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowStandardGL2.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowVSM8.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowVSM8.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ shadowVSM8PS)\n/* harmony export */ });\nvar shadowVSM8PS = `\nfloat calculateVSM8(vec3 moments, float Z, float vsmBias) {\n    float VSMBias = vsmBias;//0.01 * 0.25;\n    float depthScale = VSMBias * Z;\n    float minVariance1 = depthScale * depthScale;\n    return chebyshevUpperBound(moments.xy, Z, minVariance1, 0.1);\n}\n\nfloat decodeFloatRG(vec2 rg) {\n    return rg.y*(1.0/255.0) + rg.x;\n}\n\nfloat VSM8(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n    vec4 c = texture2D(tex, texCoords);\n    vec3 moments = vec3(decodeFloatRG(c.xy), decodeFloatRG(c.zw), 0.0);\n    return calculateVSM8(moments, Z, vsmBias);\n}\n\nfloat getShadowVSM8(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n    return VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, 0.0);\n}\n\nfloat getShadowSpotVSM8(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n    return VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, 0.0);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowVSM8.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowVSM_common.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowVSM_common.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ shadowVSM_commonPS)\n/* harmony export */ });\nvar shadowVSM_commonPS = `\nfloat linstep(float a, float b, float v) {\n    return saturate((v - a) / (b - a));\n}\n\nfloat reduceLightBleeding(float pMax, float amount) {\n   // Remove the [0, amount] tail and linearly rescale (amount, 1].\n   return linstep(amount, 1.0, pMax);\n}\n\nfloat chebyshevUpperBound(vec2 moments, float mean, float minVariance, float lightBleedingReduction) {\n    // Compute variance\n    float variance = moments.y - (moments.x * moments.x);\n    variance = max(variance, minVariance);\n\n    // Compute probabilistic upper bound\n    float d = mean - moments.x;\n    float pMax = variance / (variance + (d * d));\n\n    pMax = reduceLightBleeding(pMax, lightBleedingReduction);\n\n    // One-tailed Chebyshev\n    return (mean <= moments.x ? 1.0 : pMax);\n}\n\nfloat calculateEVSM(vec3 moments, float Z, float vsmBias, float exponent) {\n    Z = 2.0 * Z - 1.0;\n    float warpedDepth = exp(exponent * Z);\n\n    moments.xy += vec2(warpedDepth, warpedDepth*warpedDepth) * (1.0 - moments.z);\n\n    float VSMBias = vsmBias;//0.01 * 0.25;\n    float depthScale = VSMBias * exponent * warpedDepth;\n    float minVariance1 = depthScale * depthScale;\n    return chebyshevUpperBound(moments.xy, warpedDepth, minVariance1, 0.1);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/shadowVSM_common.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/spot.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/spot.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ spotPS)\n/* harmony export */ });\nvar spotPS = `\nfloat getSpotEffect(vec3 lightSpotDirW, float lightInnerConeAngle, float lightOuterConeAngle) {\n    float cosAngle = dot(dLightDirNormW, lightSpotDirW);\n    return smoothstep(lightOuterConeAngle, lightInnerConeAngle, cosAngle);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/spot.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/start.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/start.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ startPS)\n/* harmony export */ });\nvar startPS = `\nvoid main(void) {\n    dReflection = vec4(0);\n\n    #ifdef LIT_CLEARCOAT\n    ccSpecularLight = vec3(0);\n    ccReflection = vec3(0);\n    #endif\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/start.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/startNineSliced.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/startNineSliced.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ startNineSlicedPS)\n/* harmony export */ });\nvar startNineSlicedPS = `\n    nineSlicedUv = vUv0;\n    nineSlicedUv.y = 1.0 - nineSlicedUv.y;\n\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/startNineSliced.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/startNineSlicedTiled.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/startNineSlicedTiled.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ startNineSlicedTiledPS)\n/* harmony export */ });\nvar startNineSlicedTiledPS = `\n    vec2 tileMask = step(vMask, vec2(0.99999));\n    vec2 tileSize = 0.5 * (innerOffset.xy + innerOffset.zw);\n    vec2 tileScale = vec2(1.0) / (vec2(1.0) - tileSize);\n    vec2 clampedUv = mix(innerOffset.xy * 0.5, vec2(1.0) - innerOffset.zw * 0.5, fract((vTiledUv - tileSize) * tileScale));\n    clampedUv = clampedUv * atlasRect.zw + atlasRect.xy;\n    nineSlicedUv = vUv0 * tileMask + clampedUv * (vec2(1.0) - tileMask);\n    nineSlicedUv.y = 1.0 - nineSlicedUv.y;\n    \n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/startNineSlicedTiled.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/storeEVSM.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/storeEVSM.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ storeEVSMPS)\n/* harmony export */ });\nvar storeEVSMPS = `\nfloat exponent = VSM_EXPONENT;\n\ndepth = 2.0 * depth - 1.0;\ndepth =  exp(exponent * depth);\ngl_FragColor = vec4(depth, depth*depth, 1.0, 1.0);\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/storeEVSM.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/viewDir.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/viewDir.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ viewDirPS)\n/* harmony export */ });\nvar viewDirPS = `\nvoid getViewDir() {\n    dViewDirW = normalize(view_position - vPositionW);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/frag/viewDir.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/base.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/base.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ baseVS)\n/* harmony export */ });\nvar baseVS = `\nattribute vec3 vertex_position;\nattribute vec3 vertex_normal;\nattribute vec4 vertex_tangent;\nattribute vec2 vertex_texCoord0;\nattribute vec2 vertex_texCoord1;\nattribute vec4 vertex_color;\n\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\n\nvec3 dPositionW;\nmat4 dModelMatrix;\nmat3 dNormalMatrix;\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/base.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/baseNineSliced.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/baseNineSliced.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ baseNineSlicedVS)\n/* harmony export */ });\nvar baseNineSlicedVS = `\n#define NINESLICED\n\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\n\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/baseNineSliced.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/end.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/end.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ endVS)\n/* harmony export */ });\nvar endVS = `\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/end.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/extension.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/extension.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ extensionVS)\n/* harmony export */ });\nvar extensionVS = `\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/extension.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/instancing.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/instancing.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ instancingVS)\n/* harmony export */ });\nvar instancingVS = `\nattribute vec4 instance_line1;\nattribute vec4 instance_line2;\nattribute vec4 instance_line3;\nattribute vec4 instance_line4;\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/instancing.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/normal.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/normal.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ normalVS)\n/* harmony export */ });\nvar normalVS = `\n#ifdef MORPHING_TEXTURE_BASED_NORMAL\nuniform highp sampler2D morphNormalTex;\n#endif\n\nvec3 getNormal() {\n    #ifdef SKIN\n    dNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\n    #elif defined(INSTANCING)\n    dNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\n    #else\n    dNormalMatrix = matrix_normal;\n    #endif\n\n    vec3 tempNormal = vertex_normal;\n\n    #ifdef MORPHING\n    #ifdef MORPHING_NRM03\n    tempNormal += morph_weights_a[0] * morph_nrm0;\n    tempNormal += morph_weights_a[1] * morph_nrm1;\n    tempNormal += morph_weights_a[2] * morph_nrm2;\n    tempNormal += morph_weights_a[3] * morph_nrm3;\n    #endif\n    #ifdef MORPHING_NRM47\n    tempNormal += morph_weights_b[0] * morph_nrm4;\n    tempNormal += morph_weights_b[1] * morph_nrm5;\n    tempNormal += morph_weights_b[2] * morph_nrm6;\n    tempNormal += morph_weights_b[3] * morph_nrm7;\n    #endif\n    #endif\n\n    #ifdef MORPHING_TEXTURE_BASED_NORMAL\n    // apply morph offset from texture\n    vec2 morphUV = getTextureMorphCoords();\n    vec3 morphNormal = texture2D(morphNormalTex, morphUV).xyz;\n    tempNormal += morphNormal;\n    #endif\n\n    return normalize(dNormalMatrix * tempNormal);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/normal.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/normalInstanced.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/normalInstanced.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ normalInstancedVS)\n/* harmony export */ });\nvar normalInstancedVS = `\nvec3 getNormal() {\n    dNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\n    return normalize(dNormalMatrix * vertex_normal);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/normalInstanced.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/normalSkinned.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/normalSkinned.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ normalSkinnedVS)\n/* harmony export */ });\nvar normalSkinnedVS = `\nvec3 getNormal() {\n    dNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\n    return normalize(dNormalMatrix * vertex_normal);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/normalSkinned.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/start.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/start.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ startVS)\n/* harmony export */ });\nvar startVS = `\nvoid main(void) {\n    gl_Position = getPosition();\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/start.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/tangentBinormal.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/tangentBinormal.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ tangentBinormalVS)\n/* harmony export */ });\nvar tangentBinormalVS = `\nvec3 getTangent() {\n    return normalize(dNormalMatrix * vertex_tangent.xyz);\n}\n\nvec3 getBinormal() {\n    return cross(vNormalW, vTangentW) * vertex_tangent.w;\n}\n\nvec3 getObjectSpaceUp() {\n    return normalize(dNormalMatrix * vec3(0, 1, 0));\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/tangentBinormal.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/uv0.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/uv0.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ uv0VS)\n/* harmony export */ });\nvar uv0VS = `\n#ifdef NINESLICED\nvec2 getUv0() {\n    vec2 uv = vertex_position.xz;\n\n    // offset inner vertices inside\n    // (original vertices must be in [-1;1] range)\n    vec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n    vec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n    uv += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n\n    uv = uv * -0.5 + 0.5;\n    uv = uv * atlasRect.zw + atlasRect.xy;\n\n    vMask = vertex_texCoord0.xy;\n\n    return uv;\n}\n#else\nvec2 getUv0() {\n    return vertex_texCoord0;\n}\n#endif\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/uv0.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/uv1.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/uv1.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ uv1VS)\n/* harmony export */ });\nvar uv1VS = `\nvec2 getUv1() {\n    return vertex_texCoord1;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/uv1.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/viewNormal.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/viewNormal.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ viewNormalVS)\n/* harmony export */ });\nvar viewNormalVS = `\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n\nvec3 getViewNormal() {\n    return mat3(matrix_view) * vNormalW;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/lit/vert/viewNormal.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particlePS)\n/* harmony export */ });\nvar particlePS = `\nvarying vec4 texCoordsAlphaLife;\n\nuniform sampler2D colorMap;\nuniform sampler2D colorParam;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\n\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\n\nuniform float softening;\nuniform float colorMult;\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n    const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n    float depth = dot(rgbaDepth, bitShift);\n    return depth;\n}\n#endif\n\nvoid main(void) {\n    vec4 tex  = gammaCorrectInput(texture2D(colorMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)));\n    vec4 ramp = gammaCorrectInput(texture2D(colorParam, vec2(texCoordsAlphaLife.w, 0.0)));\n    ramp.rgb *= colorMult;\n\n    ramp.a += texCoordsAlphaLife.z;\n\n    vec3 rgb = tex.rgb * ramp.rgb;\n    float a  = tex.a * ramp.a;\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleInputFloat.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleInputFloat.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particleInputFloatPS)\n/* harmony export */ });\nvar particleInputFloatPS = `\nvoid readInput(float uv) {\n    vec4 tex = texture2D(particleTexIN, vec2(uv, 0.25));\n    vec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.75));\n\n    inPos = tex.xyz;\n    inVel = tex2.xyz;\n    inAngle = (tex.w < 0.0? -tex.w : tex.w) - 1000.0;\n    inShow = tex.w >= 0.0;\n    inLife = tex2.w;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleInputFloat.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleInputRgba8.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleInputRgba8.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particleInputRgba8PS)\n/* harmony export */ });\nvar particleInputRgba8PS = `\n//RG=X, BA=Y\n//RG=Z, BA=A\n//RGB=V, A=visMode\n//RGBA=life\n\n#define PI2 6.283185307179586\n\nuniform vec3 inBoundsSize;\nuniform vec3 inBoundsCenter;\n\nuniform float maxVel;\n\nfloat decodeFloatRG(vec2 rg) {\n    return rg.y*(1.0/255.0) + rg.x;\n}\n\nfloat decodeFloatRGBA( vec4 rgba ) {\n  return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\n}\n\nvoid readInput(float uv) {\n    vec4 tex0 = texture2D(particleTexIN, vec2(uv, 0.125));\n    vec4 tex1 = texture2D(particleTexIN, vec2(uv, 0.375));\n    vec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.625));\n    vec4 tex3 = texture2D(particleTexIN, vec2(uv, 0.875));\n\n    inPos = vec3(decodeFloatRG(tex0.rg), decodeFloatRG(tex0.ba), decodeFloatRG(tex1.rg));\n    inPos = (inPos - vec3(0.5)) * inBoundsSize + inBoundsCenter;\n\n    inVel = tex2.xyz;\n    inVel = (inVel - vec3(0.5)) * maxVel;\n\n    inAngle = decodeFloatRG(tex1.ba) * PI2;\n    inShow = tex2.a > 0.5;\n\n    inLife = decodeFloatRGBA(tex3);\n    float maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n    float maxPosLife = lifetime+1.0;\n    inLife = inLife * (maxNegLife + maxPosLife) - maxNegLife;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleInputRgba8.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleOutputFloat.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleOutputFloat.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particleOutputFloatPS)\n/* harmony export */ });\nvar particleOutputFloatPS = `\nvoid writeOutput() {\n    if (gl_FragCoord.y<1.0) {\n        gl_FragColor = vec4(outPos, (outAngle + 1000.0) * visMode);\n    } else {\n        gl_FragColor = vec4(outVel, outLife);\n    }\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleOutputFloat.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleOutputRgba8.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleOutputRgba8.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particleOutputRgba8PS)\n/* harmony export */ });\nvar particleOutputRgba8PS = `\nuniform vec3 outBoundsMul;\nuniform vec3 outBoundsAdd;\n\nvec2 encodeFloatRG( float v ) {\n    vec2 enc = vec2(1.0, 255.0) * v;\n    enc = fract(enc);\n    enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n    return enc;\n}\n\nvec4 encodeFloatRGBA( float v ) {\n    vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;\n    enc = fract(enc);\n    enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n    return enc;\n}\n\nvoid writeOutput() {\n    outPos = outPos * outBoundsMul + outBoundsAdd;\n    outAngle = fract(outAngle / PI2);\n\n    outVel = (outVel / maxVel) + vec3(0.5); // TODO: mul\n\n    float maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n    float maxPosLife = lifetime+1.0;\n    outLife = (outLife + maxNegLife) / (maxNegLife + maxPosLife);\n\n    if (gl_FragCoord.y < 1.0) {\n        gl_FragColor = vec4(encodeFloatRG(outPos.x), encodeFloatRG(outPos.y));\n    } else if (gl_FragCoord.y < 2.0) {\n        gl_FragColor = vec4(encodeFloatRG(outPos.z), encodeFloatRG(outAngle));\n    } else if (gl_FragCoord.y < 3.0) {\n        gl_FragColor = vec4(outVel, visMode*0.5+0.5);\n    } else {\n        gl_FragColor = encodeFloatRGBA(outLife);\n    }\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleOutputRgba8.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterAABB.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterAABB.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particleUpdaterAABBPS)\n/* harmony export */ });\nvar particleUpdaterAABBPS = `\nuniform mat3 spawnBounds;\nuniform vec3 spawnPosInnerRatio;\n\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n    vec3 pos = inBounds - vec3(0.5);\n\n    vec3 posAbs = abs(pos);\n    vec3 maxPos = vec3(max(posAbs.x, max(posAbs.y, posAbs.z)));\n\n    vec3 edge = maxPos + (vec3(0.5) - maxPos) * spawnPosInnerRatio;\n\n    pos.x = edge.x * (maxPos.x == posAbs.x ? sign(pos.x) : 2.0 * pos.x);\n    pos.y = edge.y * (maxPos.y == posAbs.y ? sign(pos.y) : 2.0 * pos.y);\n    pos.z = edge.z * (maxPos.z == posAbs.z ? sign(pos.z) : 2.0 * pos.z);\n\n#ifndef LOCAL_SPACE\n    return emitterPos + spawnBounds * pos;\n#else\n    return spawnBounds * pos;\n#endif\n}\n\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n    localVelocity -= vec3(0, 0, initialVelocity);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterAABB.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterEnd.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterEnd.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particleUpdaterEndPS)\n/* harmony export */ });\nvar particleUpdaterEndPS = `\n    writeOutput();\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterEnd.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterInit.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterInit.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particleUpdaterInitPS)\n/* harmony export */ });\nvar particleUpdaterInitPS = `\nvarying vec2 vUv0;\n\nuniform highp sampler2D particleTexIN;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\nuniform highp sampler2D internalTex3;\n\nuniform mat3 emitterMatrix, emitterMatrixInv;\nuniform vec3 emitterScale;\n\nuniform vec3 emitterPos, frameRandom, localVelocityDivMult, velocityDivMult;\nuniform float delta, rate, rateDiv, lifetime, numParticles, rotSpeedDivMult, radialSpeedDivMult, seed;\nuniform float startAngle, startAngle2;\nuniform float initialVelocity;\n\nuniform float graphSampleSize;\nuniform float graphNumSamples;\n\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\nfloat visMode;\n\nvec3 outPos;\nvec3 outVel;\nfloat outAngle;\nbool outShow;\nfloat outLife;\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterInit.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterNoRespawn.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterNoRespawn.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particleUpdaterNoRespawnPS)\n/* harmony export */ });\nvar particleUpdaterNoRespawnPS = `\n    if (outLife >= lifetime) {\n        outLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n        visMode = -1.0;\n    }\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterNoRespawn.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterOnStop.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterOnStop.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particleUpdaterOnStopPS)\n/* harmony export */ });\nvar particleUpdaterOnStopPS = `\n    visMode = outLife < 0.0? -1.0: visMode;\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterOnStop.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterRespawn.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterRespawn.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particleUpdaterRespawnPS)\n/* harmony export */ });\nvar particleUpdaterRespawnPS = `\n    if (outLife >= lifetime) {\n        outLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n        visMode = 1.0;\n    }\n    visMode = outLife < 0.0? 1.0: visMode;\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterRespawn.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterSphere.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterSphere.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particleUpdaterSpherePS)\n/* harmony export */ });\nvar particleUpdaterSpherePS = `\nuniform float spawnBoundsSphere;\nuniform float spawnBoundsSphereInnerRatio;\n\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n    float rnd4 = fract(rndFactor * 1000.0);\n    vec3 norm = normalize(inBounds.xyz - vec3(0.5));\n    float r = rnd4 * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;\n#ifndef LOCAL_SPACE\n    return emitterPos + norm * r * spawnBoundsSphere;\n#else\n    return norm * r * spawnBoundsSphere;\n#endif\n}\n\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n    localVelocity += normalize(inBounds - vec3(0.5)) * initialVelocity;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterSphere.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterStart.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterStart.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particleUpdaterStartPS)\n/* harmony export */ });\nvar particleUpdaterStartPS = `\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 unpack3NFloats(float src) {\n    float r = fract(src);\n    float g = fract(src * 256.0);\n    float b = fract(src * 65536.0);\n    return vec3(r, g, b);\n}\n\nvec3 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {\n    vec4 a = texture2D(tex, tc);\n    vec4 b = texture2D(tex, tc + graphSampleSize);\n    float c = fract(tc.x * graphNumSamples);\n\n    vec3 unpackedA = unpack3NFloats(a.w);\n    vec3 unpackedB = unpack3NFloats(b.w);\n    w = mix(unpackedA, unpackedB, c);\n\n    return mix(a.xyz, b.xyz, c);\n}\n\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\nvec4 hash41(float p) {\n    vec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\n\nvoid main(void) {\n    if (gl_FragCoord.x > numParticles) discard;\n\n    readInput(vUv0.x);\n    visMode = inShow? 1.0 : -1.0;\n\n    vec4 rndFactor = hash41(gl_FragCoord.x + seed);\n\n    float particleRate = rate + rateDiv * rndFactor.x;\n\n    outLife = inLife + delta;\n    float nlife = clamp(outLife / lifetime, 0.0, 1.0);\n\n    vec3 localVelocityDiv;\n    vec3 velocityDiv;\n    vec3 paramDiv;\n    vec3 localVelocity = tex1Dlod_lerp(internalTex0, vec2(nlife, 0), localVelocityDiv);\n    vec3 velocity =      tex1Dlod_lerp(internalTex1, vec2(nlife, 0), velocityDiv);\n    vec3 params =        tex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\n    float rotSpeed = params.x;\n    float rotSpeedDiv = paramDiv.y;\n\n    vec3 radialParams = tex1Dlod_lerp(internalTex3, vec2(nlife, 0), paramDiv);\n    float radialSpeed = radialParams.x;\n    float radialSpeedDiv = radialParams.y;\n\n    bool respawn = inLife <= 0.0 || outLife >= lifetime;\n    inPos = respawn ? calcSpawnPosition(rndFactor.xyz, rndFactor.x) : inPos;\n    inAngle = respawn ? mix(startAngle, startAngle2, rndFactor.x) : inAngle;\n\n#ifndef LOCAL_SPACE\n    vec3 radialVel = inPos - emitterPos;\n#else\n    vec3 radialVel = inPos;\n#endif\n    radialVel = (dot(radialVel, radialVel) > 1.0E-8) ? radialSpeed * normalize(radialVel) : vec3(0.0);\n    radialVel += (radialSpeedDiv * vec3(2.0) - vec3(1.0)) * radialSpeedDivMult * rndFactor.xyz;\n\n    localVelocity +=    (localVelocityDiv * vec3(2.0) - vec3(1.0)) * localVelocityDivMult * rndFactor.xyz;\n    velocity +=         (velocityDiv * vec3(2.0) - vec3(1.0)) * velocityDivMult * rndFactor.xyz;\n    rotSpeed +=         (rotSpeedDiv * 2.0 - 1.0) * rotSpeedDivMult * rndFactor.y;\n\n    addInitialVelocity(localVelocity, rndFactor.xyz);\n\n#ifndef LOCAL_SPACE\n    outVel = emitterMatrix * localVelocity + (radialVel + velocity) * emitterScale;\n#else\n    outVel = (localVelocity + radialVel) / emitterScale + emitterMatrixInv * velocity;\n#endif\n\n    outPos = inPos + outVel * delta;\n    outAngle = inAngle + rotSpeed * delta;\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particleUpdaterStart.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_blendAdd.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_blendAdd.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particle_blendAddPS)\n/* harmony export */ });\nvar particle_blendAddPS = `\n    dBlendModeFogFactor = 0.0;\n    rgb *= saturate(gammaCorrectInput(max(a, 0.0)));\n    if ((rgb.r + rgb.g + rgb.b) < 0.000001) discard;\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_blendAdd.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_blendMultiply.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_blendMultiply.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particle_blendMultiplyPS)\n/* harmony export */ });\nvar particle_blendMultiplyPS = `\n    rgb = mix(vec3(1.0), rgb, vec3(a));\n    if (rgb.r + rgb.g + rgb.b > 2.99) discard;\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_blendMultiply.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_blendNormal.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_blendNormal.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particle_blendNormalPS)\n/* harmony export */ });\nvar particle_blendNormalPS = `\n    if (a < 0.01) discard;\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_blendNormal.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_end.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_end.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particle_endPS)\n/* harmony export */ });\nvar particle_endPS = `\n    rgb = addFog(rgb);\n    rgb = toneMap(rgb);\n    rgb = gammaCorrectOutput(rgb);\n    gl_FragColor = vec4(rgb, a);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_end.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_halflambert.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_halflambert.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particle_halflambertPS)\n/* harmony export */ });\nvar particle_halflambertPS = `\n    vec3 negNormal = normal*0.5+0.5;\n    vec3 posNormal = -normal*0.5+0.5;\n    negNormal *= negNormal;\n    posNormal *= posNormal;\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_halflambert.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_lambert.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_lambert.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particle_lambertPS)\n/* harmony export */ });\nvar particle_lambertPS = `\n    vec3 negNormal = max(normal, vec3(0.0));\n    vec3 posNormal = max(-normal, vec3(0.0));\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_lambert.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_lighting.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_lighting.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particle_lightingPS)\n/* harmony export */ });\nvar particle_lightingPS = `\n    vec3 light = negNormal.x*lightCube[0] + posNormal.x*lightCube[1] +\n                        negNormal.y*lightCube[2] + posNormal.y*lightCube[3] +\n                        negNormal.z*lightCube[4] + posNormal.z*lightCube[5];\n\n    rgb *= light;\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_lighting.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_normalMap.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_normalMap.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particle_normalMapPS)\n/* harmony export */ });\nvar particle_normalMapPS = `\n    vec3 normalMap = normalize(texture2D(normalMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)).xyz * 2.0 - 1.0);\n    vec3 normal = ParticleMat * normalMap;\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_normalMap.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_soft.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_soft.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particle_softPS)\n/* harmony export */ });\nvar particle_softPS = `\n    float depth = getLinearScreenDepth();\n    float particleDepth = vDepth;\n    float depthDiff = saturate(abs(particleDepth - depth) * softening);\n    a *= depthDiff;\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/frag/particle_soft.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particleVS)\n/* harmony export */ });\nvar particleVS = `\nvec3 unpack3NFloats(float src) {\n    float r = fract(src);\n    float g = fract(src * 256.0);\n    float b = fract(src * 65536.0);\n    return vec3(r, g, b);\n}\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc) {\n    return mix( texture2D(tex,tc), texture2D(tex,tc + graphSampleSize), fract(tc.x*graphNumSamples) );\n}\n\nvec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {\n    vec4 a = texture2D(tex,tc);\n    vec4 b = texture2D(tex,tc + graphSampleSize);\n    float c = fract(tc.x*graphNumSamples);\n\n    vec3 unpackedA = unpack3NFloats(a.w);\n    vec3 unpackedB = unpack3NFloats(b.w);\n    w = mix(unpackedA, unpackedB, c);\n\n    return mix(a, b, c);\n}\n\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix) {\n    float c = cos(pRotation);\n    float s = sin(pRotation);\n\n    mat2 m = mat2(c, -s, s, c);\n    rotMatrix = m;\n\n    return m * quadXY;\n}\n\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY) {\n    #ifdef SCREEN_SPACE\n        vec3 pos = vec3(-1, 0, 0) * quadXY.x + vec3(0, -1, 0) * quadXY.y;\n    #else\n        vec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n    #endif\n\n    return pos;\n}\n\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY) {\n    vec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n    return pos;\n}\n\nvec2 safeNormalize(vec2 v) {\n    float l = length(v);\n    return (l > 1e-06) ? v / l : v;\n}\n\nvoid main(void) {\n    vec3 meshLocalPos = particle_vertexData.xyz;\n    float id = floor(particle_vertexData.w);\n\n    float rndFactor = fract(sin(id + 1.0 + seed));\n    vec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n\n    float uv = id / numParticlesPot;\n    readInput(uv);\n\n#ifdef LOCAL_SPACE\n    inVel = mat3(matrix_model) * inVel;\n#endif\n    vec2 velocityV = safeNormalize((mat3(matrix_view) * inVel).xy); // should be removed by compiler if align/stretch is not used\n\n    float particleLifetime = lifetime;\n\n    if (inLife <= 0.0 || inLife > particleLifetime || !inShow) meshLocalPos = vec3(0.0);\n    vec2 quadXY = meshLocalPos.xy;\n    float nlife = clamp(inLife / particleLifetime, 0.0, 1.0);\n\n    vec3 paramDiv;\n    vec4 params = tex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\n    float scale = params.y;\n    float scaleDiv = paramDiv.x;\n    float alphaDiv = paramDiv.z;\n\n    scale += (scaleDiv * 2.0 - 1.0) * scaleDivMult * fract(rndFactor*10000.0);\n\n#ifndef USE_MESH\n    texCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#else\n    texCoordsAlphaLife = vec4(particle_uv, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#endif\n\n    vec3 particlePos = inPos;\n    vec3 particlePosMoved = vec3(0.0);\n\n    mat2 rotMatrix;\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particleAnimFrameClamp.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particleAnimFrameClamp.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particleAnimFrameClampVS)\n/* harmony export */ });\nvar particleAnimFrameClampVS = `\n    float animFrame = min(floor(texCoordsAlphaLife.w * animTexParams.y) + animTexParams.x, animTexParams.z);\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particleAnimFrameClamp.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particleAnimFrameLoop.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particleAnimFrameLoop.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particleAnimFrameLoopVS)\n/* harmony export */ });\nvar particleAnimFrameLoopVS = `\n    float animFrame = floor(mod(texCoordsAlphaLife.w * animTexParams.y + animTexParams.x, animTexParams.z + 1.0));\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particleAnimFrameLoop.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particleAnimTex.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particleAnimTex.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particleAnimTexVS)\n/* harmony export */ });\nvar particleAnimTexVS = `\n    float animationIndex;\n\n    if (animTexIndexParams.y == 1.0) {\n        animationIndex = floor((animTexParams.w + 1.0) * rndFactor3.z) * (animTexParams.z + 1.0);\n    } else {\n        animationIndex = animTexIndexParams.x * (animTexParams.z + 1.0);\n    }\n\n    float atlasX = (animationIndex + animFrame) * animTexTilesParams.x;\n    float atlasY = 1.0 - floor(atlasX + 1.0) * animTexTilesParams.y;\n    atlasX = fract(atlasX);\n\n    texCoordsAlphaLife.xy *= animTexTilesParams.xy;\n    texCoordsAlphaLife.xy += vec2(atlasX, atlasY);\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particleAnimTex.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_TBN.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_TBN.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particle_TBNVS)\n/* harmony export */ });\nvar particle_TBNVS = `\n    mat3 rot3 = mat3(rotMatrix[0][0], rotMatrix[0][1], 0.0, rotMatrix[1][0], rotMatrix[1][1], 0.0, 0.0, 0.0, 1.0);\n    ParticleMat = mat3(-matrix_viewInverse[0].xyz, -matrix_viewInverse[1].xyz, matrix_viewInverse[2].xyz) * rot3;\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_TBN.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_billboard.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_billboard.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particle_billboardVS)\n/* harmony export */ });\nvar particle_billboardVS = `\n    quadXY = rotate(quadXY, inAngle, rotMatrix);\n    vec3 localPos = billboard(particlePos, quadXY);\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_billboard.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_cpu.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_cpu.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particle_cpuVS)\n/* harmony export */ });\nvar particle_cpuVS = `\nattribute vec4 particle_vertexData;   // XYZ = world pos, W = life\nattribute vec4 particle_vertexData2;  // X = angle, Y = scale, Z = alpha, W = velocity.x\nattribute vec4 particle_vertexData3;  // XYZ = particle local pos, W = velocity.y\nattribute float particle_vertexData4; // particle id\n#ifndef USE_MESH\n#define VDATA5TYPE vec2\n#else\n#define VDATA5TYPE vec4\n#endif\nattribute VDATA5TYPE particle_vertexData5; // VDATA4TYPE depends on useMesh property. Start with X = velocity.z, Y = particle ID and for mesh particles proceeds with Z = mesh UV.x, W = mesh UV.y\n\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\n\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\n\nuniform float numParticles;\nuniform float lifetime;\nuniform float stretch;\nuniform float seed;\nuniform vec3 wrapBounds, emitterScale, faceTangent, faceBinorm;\nuniform sampler2D texLifeAndSourcePosOUT;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\nuniform vec3 emitterPos;\n\nvarying vec4 texCoordsAlphaLife;\n\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix)\n{\n    float c = cos(pRotation);\n    float s = sin(pRotation);\n    //vec4 rotationMatrix = vec4(c, -s, s, c);\n\n    mat2 m = mat2(c, -s, s, c);\n    rotMatrix = m;\n\n    return m * quadXY;\n}\n\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY)\n{\n    vec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n    return pos;\n}\n\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY)\n{\n    vec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n    return pos;\n}\n\nvoid main(void)\n{\n    vec3 particlePos = particle_vertexData.xyz;\n    vec3 inPos = particlePos;\n    vec3 vertPos = particle_vertexData3.xyz;\n    vec3 inVel = vec3(particle_vertexData2.w, particle_vertexData3.w, particle_vertexData5.x);\n\n    float id = floor(particle_vertexData4);\n    float rndFactor = fract(sin(id + 1.0 + seed));\n    vec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n\n#ifdef LOCAL_SPACE\n    inVel = mat3(matrix_model) * inVel;\n#endif\n    vec2 velocityV = normalize((mat3(matrix_view) * inVel).xy); // should be removed by compiler if align/stretch is not used\n\n    vec2 quadXY = vertPos.xy;\n\n#ifdef USE_MESH\n    texCoordsAlphaLife = vec4(particle_vertexData5.zw, particle_vertexData2.z, particle_vertexData.w);\n#else\n    texCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, particle_vertexData2.z, particle_vertexData.w);\n#endif\n    mat2 rotMatrix;\n\n    float inAngle = particle_vertexData2.x;\n    vec3 particlePosMoved = vec3(0.0);\n    vec3 meshLocalPos = particle_vertexData3.xyz;\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_cpu.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_cpu_end.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_cpu_end.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particle_cpu_endVS)\n/* harmony export */ });\nvar particle_cpu_endVS = `\n    localPos *= particle_vertexData2.y * emitterScale;\n    localPos += particlePos;\n\n    gl_Position = matrix_viewProjection * vec4(localPos, 1.0);\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_cpu_end.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_customFace.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_customFace.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particle_customFaceVS)\n/* harmony export */ });\nvar particle_customFaceVS = `\n    quadXY = rotate(quadXY, inAngle, rotMatrix);\n    vec3 localPos = customFace(particlePos, quadXY);\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_customFace.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_end.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_end.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particle_endVS)\n/* harmony export */ });\nvar particle_endVS = `\n    localPos *= scale * emitterScale;\n    localPos += particlePos;\n\n    #ifdef SCREEN_SPACE\n    gl_Position = vec4(localPos.x, localPos.y, 0.0, 1.0);\n    #else\n    gl_Position = matrix_viewProjection * vec4(localPos.xyz, 1.0);\n    #endif\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_end.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_init.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_init.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particle_initVS)\n/* harmony export */ });\nvar particle_initVS = `\nattribute vec4 particle_vertexData; // XYZ = particle position, W = particle ID + random factor\n#ifdef USE_MESH\nattribute vec2 particle_uv;         // mesh UV\n#endif\n\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\n\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n\nuniform float numParticles, numParticlesPot;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nuniform float stretch;\nuniform vec3 wrapBounds;\nuniform vec3 emitterScale, emitterPos, faceTangent, faceBinorm;\nuniform float rate, rateDiv, lifetime, deltaRandomnessStatic, scaleDivMult, alphaDivMult, seed, delta;\nuniform sampler2D particleTexOUT, particleTexIN;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\n\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\n\nvarying vec4 texCoordsAlphaLife;\n\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_init.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_localShift.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_localShift.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particle_localShiftVS)\n/* harmony export */ });\nvar particle_localShiftVS = `\n    particlePos = (matrix_model * vec4(particlePos, 1.0)).xyz;\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_localShift.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_mesh.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_mesh.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particle_meshVS)\n/* harmony export */ });\nvar particle_meshVS = `\n    vec3 localPos = meshLocalPos;\n    localPos.xy = rotate(localPos.xy, inAngle, rotMatrix);\n    localPos.yz = rotate(localPos.yz, inAngle, rotMatrix);\n\n    billboard(particlePos, quadXY);\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_mesh.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_normal.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_normal.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particle_normalVS)\n/* harmony export */ });\nvar particle_normalVS = `\n    Normal = normalize(localPos + matrix_viewInverse[2].xyz);\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_normal.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_pointAlong.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_pointAlong.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particle_pointAlongVS)\n/* harmony export */ });\nvar particle_pointAlongVS = `\n    inAngle = atan(velocityV.x, velocityV.y); // not the fastest way, but easier to plug in; TODO: create rot matrix right from vectors\n\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_pointAlong.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_soft.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_soft.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particle_softVS)\n/* harmony export */ });\nvar particle_softVS = `\n    vDepth = getLinearDepth(localPos);\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_soft.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_stretch.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_stretch.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particle_stretchVS)\n/* harmony export */ });\nvar particle_stretchVS = `\n    vec3 moveDir = inVel * stretch;\n    vec3 posPrev = particlePos - moveDir;\n    posPrev += particlePosMoved;\n\n    vec2 centerToVertexV = normalize((mat3(matrix_view) * localPos).xy);\n\n    float interpolation = dot(-velocityV, centerToVertexV) * 0.5 + 0.5;\n\n    particlePos = mix(particlePos, posPrev, interpolation);\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_stretch.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_wrap.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_wrap.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ particle_wrapVS)\n/* harmony export */ });\nvar particle_wrapVS = `\n    vec3 origParticlePos = particlePos;\n    particlePos -= matrix_model[3].xyz;\n    particlePos = mod(particlePos, wrapBounds) - wrapBounds * 0.5;\n    particlePos += matrix_model[3].xyz;\n    particlePosMoved = particlePos - origParticlePos;\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/particle/vert/particle_wrap.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/skybox/frag/skyboxEnv.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/skybox/frag/skyboxEnv.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ skyboxEnvPS)\n/* harmony export */ });\nvar skyboxEnvPS = `\nvarying vec3 vViewDir;\n\nuniform sampler2D texture_envAtlas;\nuniform float mipLevel;\n\nvoid main(void) {\n    vec3 dir = vViewDir * vec3(-1.0, 1.0, 1.0);\n    vec2 uv = toSphericalUv(normalize(dir));\n\n    vec3 linear = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, mipLevel)));\n\n    gl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/skybox/frag/skyboxEnv.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/skybox/frag/skyboxHDR.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/skybox/frag/skyboxHDR.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ skyboxHDRPS)\n/* harmony export */ });\nvar skyboxHDRPS = `\nvarying vec3 vViewDir;\n\nuniform samplerCube texture_cubeMap;\n\nvoid main(void) {\n    vec3 dir=vViewDir;\n    dir.x *= -1.0;\n\n    vec3 linear = $DECODE(textureCube(texture_cubeMap, fixSeamsStatic(dir, $FIXCONST)));\n\n    gl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/skybox/frag/skyboxHDR.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/skybox/vert/skybox.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/skybox/vert/skybox.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ skyboxVS)\n/* harmony export */ });\nvar skyboxVS = `\nattribute vec3 aPosition;\n\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n\nuniform mat4 matrix_projectionSkybox;\nuniform mat3 cubeMapRotationMatrix;\n\nvarying vec3 vViewDir;\n\nvoid main(void) {\n    mat4 view = matrix_view;\n    view[3][0] = view[3][1] = view[3][2] = 0.0;\n    gl_Position = matrix_projectionSkybox * view * vec4(aPosition, 1.0);\n\n    // Force skybox to far Z, regardless of the clip planes on the camera\n    // Subtract a tiny fudge factor to ensure floating point errors don't\n    // still push pixels beyond far Z. See:\n    // http://www.opengl.org/discussion_boards/showthread.php/171867-skybox-problem\n\n    gl_Position.z = gl_Position.w - 0.00001;\n    vViewDir = aPosition * cubeMapRotationMatrix;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/skybox/vert/skybox.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/alphaTest.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/alphaTest.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ alphaTestPS)\n/* harmony export */ });\nvar alphaTestPS = `\nuniform float alpha_ref;\n\nvoid alphaTest(float a) {\n    if (a < alpha_ref) discard;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/alphaTest.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/ao.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/ao.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ aoPS)\n/* harmony export */ });\nvar aoPS = `\n\nvoid getAO() {\n    dAo = 1.0;\n\n    #ifdef MAPTEXTURE\n    dAo *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n    dAo *= saturate(vVertexColor.$VC);\n    #endif\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/ao.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/clearCoat.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/clearCoat.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ clearCoatPS)\n/* harmony export */ });\nvar clearCoatPS = `\n#ifdef MAPFLOAT\nuniform float material_clearCoat;\n#endif\n\nvoid getClearCoat() {\n    ccSpecularity = 1.0;\n\n    #ifdef MAPFLOAT\n    ccSpecularity *= material_clearCoat;\n    #endif\n\n    #ifdef MAPTEXTURE\n    ccSpecularity *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n    ccSpecularity *= saturate(vVertexColor.$VC);\n    #endif\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/clearCoat.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/clearCoatGloss.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/clearCoatGloss.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ clearCoatGlossPS)\n/* harmony export */ });\nvar clearCoatGlossPS = `\n#ifdef MAPFLOAT\nuniform float material_clearCoatGloss;\n#endif\n\nvoid getClearCoatGlossiness() {\n    ccGlossiness = 1.0;\n\n    #ifdef MAPFLOAT\n    ccGlossiness *= material_clearCoatGloss;\n    #endif\n\n    #ifdef MAPTEXTURE\n    ccGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n    ccGlossiness *= saturate(vVertexColor.$VC);\n    #endif\n\n    #ifdef MAPINVERT\n    ccGlossiness = 1.0 - ccGlossiness;\n    #endif\n\n    ccGlossiness += 0.0000001;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/clearCoatGloss.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/clearCoatNormal.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/clearCoatNormal.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ clearCoatNormalPS)\n/* harmony export */ });\nvar clearCoatNormalPS = `\n#ifdef MAPTEXTURE\nuniform float material_clearCoatBumpiness;\n#endif\n\nvoid getClearCoatNormal() {\n#ifdef MAPTEXTURE\n    vec3 normalMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));\n    normalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_clearCoatBumpiness);\n    ccNormalW = normalize(dTBN * normalMap);\n#else\n    ccNormalW = dVertexNormalW;\n#endif\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/clearCoatNormal.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/detailModes.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/detailModes.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ detailModesPS)\n/* harmony export */ });\nvar detailModesPS = `\nvec3 detailMode_mul(vec3 c1, vec3 c2) {\n    return c1 * c2;\n}\n\nvec3 detailMode_add(vec3 c1, vec3 c2) {\n    return c1 + c2;\n}\n\n// https://en.wikipedia.org/wiki/Blend_modes#Screen\nvec3 detailMode_screen(vec3 c1, vec3 c2) {\n    return 1.0 - (1.0 - c1)*(1.0 - c2);\n}\n\n// https://en.wikipedia.org/wiki/Blend_modes#Overlay\nvec3 detailMode_overlay(vec3 c1, vec3 c2) {\n    return mix(1.0 - 2.0*(1.0 - c1)*(1.0 - c2), 2.0*c1*c2, step(c1, vec3(0.5)));\n}\n\nvec3 detailMode_min(vec3 c1, vec3 c2) {\n    return min(c1, c2);\n}\n\nvec3 detailMode_max(vec3 c1, vec3 c2) {\n    return max(c1, c2);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/detailModes.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/diffuse.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/diffuse.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ diffusePS)\n/* harmony export */ });\nvar diffusePS = `\n#ifdef MAPCOLOR\nuniform vec3 material_diffuse;\n#endif\n\nvoid getAlbedo() {\n    dAlbedo = vec3(1.0);\n\n#ifdef MAPCOLOR\n    dAlbedo *= material_diffuse.rgb;\n#endif\n\n#ifdef MAPTEXTURE\n    vec3 albedoBase = $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n    dAlbedo *= addAlbedoDetail(albedoBase);\n#endif\n\n#ifdef MAPVERTEX\n    dAlbedo *= gammaCorrectInput(saturate(vVertexColor.$VC));\n#endif\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/diffuse.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/diffuseDetailMap.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/diffuseDetailMap.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ diffuseDetailMapPS)\n/* harmony export */ });\nvar diffuseDetailMapPS = `\nvec3 addAlbedoDetail(vec3 albedo) {\n#ifdef MAPTEXTURE\n    vec3 albedoDetail = $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n    return detailMode_$DETAILMODE(albedo, albedoDetail);\n#else\n    return albedo;\n#endif\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/diffuseDetailMap.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/emissive.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/emissive.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ emissivePS)\n/* harmony export */ });\nvar emissivePS = `\n#ifdef MAPCOLOR\nuniform vec3 material_emissive;\n#endif\n\n#ifdef MAPFLOAT\nuniform float material_emissiveIntensity;\n#endif\n\nvoid getEmission() {\n    dEmission = vec3(1.0);\n\n    #ifdef MAPFLOAT\n    dEmission *= material_emissiveIntensity;\n    #endif\n\n    #ifdef MAPCOLOR\n    dEmission *= material_emissive;\n    #endif\n\n    #ifdef MAPTEXTURE\n    dEmission *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n    dEmission *= gammaCorrectInput(saturate(vVertexColor.$VC));\n    #endif\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/emissive.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/gloss.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/gloss.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ glossPS)\n/* harmony export */ });\nvar glossPS = `\n#ifdef MAPFLOAT\nuniform float material_gloss;\n#endif\n\nvoid getGlossiness() {\n    dGlossiness = 1.0;\n\n    #ifdef MAPFLOAT\n    dGlossiness *= material_gloss;\n    #endif\n\n    #ifdef MAPTEXTURE\n    dGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n    dGlossiness *= saturate(vVertexColor.$VC);\n    #endif\n\n    #ifdef MAPINVERT\n    dGlossiness = 1.0 - dGlossiness;\n    #endif\n\n    dGlossiness += 0.0000001;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/gloss.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/iridescence.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/iridescence.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ iridescencePS)\n/* harmony export */ });\nvar iridescencePS = `\n#ifdef MAPFLOAT\nuniform float material_iridescence;\n#endif\n\nvoid getIridescence() {\n    float iridescence = 1.0;\n\n    #ifdef MAPFLOAT\n    iridescence *= material_iridescence;\n    #endif\n\n    #ifdef MAPTEXTURE\n    iridescence *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n    #endif\n\n    dIridescence = iridescence; \n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/iridescence.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/iridescenceThickness.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/iridescenceThickness.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ iridescenceThicknessPS)\n/* harmony export */ });\nvar iridescenceThicknessPS = `\nuniform float material_iridescenceThicknessMax;\n\n#ifdef MAPTEXTURE\nuniform float material_iridescenceThicknessMin;\n#endif\n\nvoid getIridescenceThickness() {\n\n    #ifdef MAPTEXTURE\n    float blend = texture2DBias($SAMPLER, $UV, textureBias).$CH;\n    float iridescenceThickness = mix(material_iridescenceThicknessMin, material_iridescenceThicknessMax, blend);\n    #else\n    float iridescenceThickness = material_iridescenceThicknessMax;\n    #endif\n\n    dIridescenceThickness = iridescenceThickness; \n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/iridescenceThickness.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/lightmapDir.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/lightmapDir.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ lightmapDirPS)\n/* harmony export */ });\nvar lightmapDirPS = `\nuniform sampler2D texture_lightMap;\nuniform sampler2D texture_dirLightMap;\n\nvoid getLightMap() {\n    dLightmap = $DECODE(texture2DBias(texture_lightMap, $UV, textureBias)).$CH;\n\n    vec3 dir = texture2DBias(texture_dirLightMap, $UV, textureBias).xyz * 2.0 - 1.0;\n    float dirDot = dot(dir, dir);\n    dLightmapDir = (dirDot > 0.001) ? dir / sqrt(dirDot) : vec3(0.0);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/lightmapDir.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/lightmapSingle.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/lightmapSingle.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ lightmapSinglePS)\n/* harmony export */ });\nvar lightmapSinglePS = `\nvoid getLightMap() {\n    dLightmap = vec3(1.0);\n\n    #ifdef MAPTEXTURE\n    dLightmap *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n    dLightmap *= saturate(vVertexColor.$VC);\n    #endif\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/lightmapSingle.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/metalness.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/metalness.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ metalnessPS)\n/* harmony export */ });\nvar metalnessPS = `\n#ifdef MAPFLOAT\nuniform float material_metalness;\n#endif\n\nvoid getMetalness() {\n    float metalness = 1.0;\n\n    #ifdef MAPFLOAT\n    metalness *= material_metalness;\n    #endif\n\n    #ifdef MAPTEXTURE\n    metalness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n    metalness *= saturate(vVertexColor.$VC);\n    #endif\n\n    dMetalness = metalness;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/metalness.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/normalDetailMap.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/normalDetailMap.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ normalDetailMapPS)\n/* harmony export */ });\nvar normalDetailMapPS = `\n#ifdef MAPTEXTURE\nuniform float material_normalDetailMapBumpiness;\n\nvec3 blendNormals(vec3 n1, vec3 n2) {\n    // https://blog.selfshadow.com/publications/blending-in-detail/#detail-oriented\n    n1 += vec3(0, 0, 1);\n    n2 *= vec3(-1, -1, 1);\n    return n1 * dot(n1, n2) / n1.z - n2;\n}\n#endif\n\nvec3 addNormalDetail(vec3 normalMap) {\n#ifdef MAPTEXTURE\n    vec3 normalDetailMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));\n    normalDetailMap = mix(vec3(0.0, 0.0, 1.0), normalDetailMap, material_normalDetailMapBumpiness);\n    return blendNormals(normalMap, normalDetailMap);\n#else\n    return normalMap;\n#endif\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/normalDetailMap.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/normalMap.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/normalMap.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ normalMapPS)\n/* harmony export */ });\nvar normalMapPS = `\n#ifdef MAPTEXTURE\nuniform float material_bumpiness;\n#endif\n\nvoid getNormal() {\n#ifdef MAPTEXTURE\n    vec3 normalMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));\n    normalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_bumpiness);\n    dNormalW = normalize(dTBN * addNormalDetail(normalMap));\n#else\n    dNormalW = dVertexNormalW;\n#endif\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/normalMap.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/normalXY.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/normalXY.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ normalXYPS)\n/* harmony export */ });\nvar normalXYPS = `\nvec3 unpackNormal(vec4 nmap) {\n    vec3 normal;\n    normal.xy = nmap.wy * 2.0 - 1.0;\n    normal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));\n    return normal;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/normalXY.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/normalXYZ.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/normalXYZ.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ normalXYZPS)\n/* harmony export */ });\nvar normalXYZPS = `\nvec3 unpackNormal(vec4 nmap) {\n    return nmap.xyz * 2.0 - 1.0;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/normalXYZ.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/opacity.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/opacity.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ opacityPS)\n/* harmony export */ });\nvar opacityPS = `\n#ifdef MAPFLOAT\nuniform float material_opacity;\n#endif\n\nvoid getOpacity() {\n    dAlpha = 1.0;\n\n    #ifdef MAPFLOAT\n    dAlpha *= material_opacity;\n    #endif\n\n    #ifdef MAPTEXTURE\n    dAlpha *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n    dAlpha *= clamp(vVertexColor.$VC, 0.0, 1.0);\n    #endif\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/opacity.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/parallax.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/parallax.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ parallaxPS)\n/* harmony export */ });\nvar parallaxPS = `\nuniform float material_heightMapFactor;\n\nvoid getParallax() {\n    float parallaxScale = material_heightMapFactor;\n\n    float height = texture2DBias($SAMPLER, $UV, textureBias).$CH;\n    height = height * parallaxScale - parallaxScale*0.5;\n    vec3 viewDirT = dViewDirW * dTBN;\n\n    viewDirT.z += 0.42;\n    dUvOffset = height * (viewDirT.xy / viewDirT.z);\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/parallax.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/sheen.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/sheen.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ sheenPS)\n/* harmony export */ });\nvar sheenPS = `\n\n#ifdef MAPCOLOR\nuniform vec3 material_sheen;\n#endif\n\nvoid getSheen() {\n    vec3 sheenColor = vec3(1, 1, 1);\n\n    #ifdef MAPCOLOR\n    sheenColor *= material_sheen;\n    #endif\n\n    #ifdef MAPTEXTURE\n    sheenColor *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n    sheenColor *= saturate(vVertexColor.$VC);\n    #endif\n\n    sSpecularity = sheenColor;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/sheen.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/sheenGloss.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/sheenGloss.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ sheenGlossPS)\n/* harmony export */ });\nvar sheenGlossPS = `\n#ifdef MAPFLOAT\nuniform float material_sheenGloss;\n#endif\n\nvoid getSheenGlossiness() {\n    float sheenGlossiness = 1.0;\n\n    #ifdef MAPFLOAT\n    sheenGlossiness *= material_sheenGloss;\n    #endif\n\n    #ifdef MAPTEXTURE\n    sheenGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n    sheenGlossiness *= saturate(vVertexColor.$VC);\n    #endif\n\n    #ifdef MAPINVERT\n    sheenGlossiness = 1.0 - sheenGlossiness;\n    #endif\n\n    sheenGlossiness += 0.0000001;\n    sGlossiness = sheenGlossiness;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/sheenGloss.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/specular.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/specular.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ specularPS)\n/* harmony export */ });\nvar specularPS = `\n\n#ifdef MAPCOLOR\nuniform vec3 material_specular;\n#endif\n\nvoid getSpecularity() {\n    vec3 specularColor = vec3(1,1,1);\n\n    #ifdef MAPCOLOR\n    specularColor *= material_specular;\n    #endif\n\n    #ifdef MAPTEXTURE\n    specularColor *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n    specularColor *= saturate(vVertexColor.$VC);\n    #endif\n\n    dSpecularity = specularColor;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/specular.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/specularityFactor.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/specularityFactor.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ specularityFactorPS)\n/* harmony export */ });\nvar specularityFactorPS = `\n\n#ifdef MAPFLOAT\nuniform float material_specularityFactor;\n#endif\n\nvoid getSpecularityFactor() {\n    float specularityFactor = 1.0;\n\n    #ifdef MAPFLOAT\n    specularityFactor *= material_specularityFactor;\n    #endif\n\n    #ifdef MAPTEXTURE\n    specularityFactor *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n    specularityFactor *= saturate(vVertexColor.$VC);\n    #endif\n\n    dSpecularityFactor = specularityFactor;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/specularityFactor.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/textureSample.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/textureSample.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ textureSamplePS)\n/* harmony export */ });\nvar textureSamplePS = `\nvec4 texture2DSRGB(sampler2D tex, vec2 uv) {\n    return gammaCorrectInput(texture2D(tex, uv));\n}\n\nvec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {\n    return gammaCorrectInput(texture2D(tex, uv, bias));\n}\n\nvec3 texture2DRGBM(sampler2D tex, vec2 uv) {\n    return decodeRGBM(texture2D(tex, uv));\n}\n\nvec3 texture2DRGBM(sampler2D tex, vec2 uv, float bias) {\n    return decodeRGBM(texture2D(tex, uv, bias));\n}\n\nvec3 texture2DRGBE(sampler2D tex, vec2 uv) {\n    return decodeRGBM(texture2D(tex, uv));\n}\n\nvec3 texture2DRGBE(sampler2D tex, vec2 uv, float bias) {\n    return decodeRGBM(texture2D(tex, uv, bias));\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/textureSample.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/thickness.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/thickness.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ thicknessPS)\n/* harmony export */ });\nvar thicknessPS = `\n#ifdef MAPFLOAT\nuniform float material_thickness;\n#endif\n\nvoid getThickness() {\n    dThickness = 1.0;\n\n    #ifdef MAPFLOAT\n    dThickness *= material_thickness;\n    #endif\n\n    #ifdef MAPTEXTURE\n    dThickness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n    dThickness *= saturate(vVertexColor.$VC);\n    #endif\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/thickness.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/transmission.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/transmission.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ transmissionPS)\n/* harmony export */ });\nvar transmissionPS = `\n\n#ifdef MAPFLOAT\nuniform float material_refraction;\n#endif\n\nvoid getRefraction() {\n    float refraction = 1.0;\n\n    #ifdef MAPFLOAT\n    refraction = material_refraction;\n    #endif\n\n    #ifdef MAPTEXTURE\n    refraction *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n    refraction *= saturate(vVertexColor.$VC);\n    #endif\n\n    dTransmission = refraction;\n}\n`;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/standard/frag/transmission.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/get-program-library.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/get-program-library.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getProgramLibrary\": () => (/* binding */ getProgramLibrary),\n/* harmony export */   \"setProgramLibrary\": () => (/* binding */ setProgramLibrary)\n/* harmony export */ });\n/* harmony import */ var _platform_graphics_device_cache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/graphics/device-cache.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/device-cache.js\");\n\n\n\nconst programLibraryDeviceCache = new _platform_graphics_device_cache_js__WEBPACK_IMPORTED_MODULE_0__.DeviceCache();\nfunction getProgramLibrary(device) {\n  const library = programLibraryDeviceCache.get(device);\n  return library;\n}\nfunction setProgramLibrary(device, library) {\n  programLibraryDeviceCache.get(device, () => {\n    return library;\n  });\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/get-program-library.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/program-library.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/program-library.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ProgramLibrary\": () => (/* binding */ ProgramLibrary)\n/* harmony export */ });\n/* harmony import */ var _core_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/core.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/core.js\");\n/* harmony import */ var _platform_graphics_shader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../platform/graphics/shader.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _shader_pass_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shader-pass.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-pass.js\");\n/* harmony import */ var _materials_standard_material_options_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../materials/standard-material-options.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material-options.js\");\n\n\n\n\n\n\n\nclass ProgramLibrary {\n  constructor(device, standardMaterial) {\n    this.processedCache = new Map();\n    this.definitionsCache = new Map();\n    this._device = device;\n    this._generators = {};\n    this._isClearingCache = false;\n    this._precached = false;\n    this._programsCollection = [];\n    this._defaultStdMatOption = new _materials_standard_material_options_js__WEBPACK_IMPORTED_MODULE_0__.StandardMaterialOptions();\n    this._defaultStdMatOptionMin = new _materials_standard_material_options_js__WEBPACK_IMPORTED_MODULE_0__.StandardMaterialOptions();\n    standardMaterial.shaderOptBuilder.updateRef(this._defaultStdMatOption, {}, standardMaterial, null, [], _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHADER_FORWARD, null);\n    standardMaterial.shaderOptBuilder.updateMinRef(this._defaultStdMatOptionMin, {}, standardMaterial, null, [], _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHADER_SHADOW, null);\n    device.on('destroy:shader', shader => {\n      this.removeFromCache(shader);\n    });\n  }\n  destroy() {\n    this.clearCache();\n  }\n  register(name, generator) {\n    if (!this.isRegistered(name)) {\n      this._generators[name] = generator;\n    }\n  }\n  unregister(name) {\n    if (this.isRegistered(name)) {\n      delete this._generators[name];\n    }\n  }\n  isRegistered(name) {\n    const generator = this._generators[name];\n    return generator !== undefined;\n  }\n  generateShaderDefinition(generator, name, key, options) {\n    let def = this.definitionsCache.get(key);\n    if (!def) {\n      var _options$litOptions, _options$litOptions2;\n      let lights;\n      if ((_options$litOptions = options.litOptions) != null && _options$litOptions.lights) {\n        lights = options.litOptions.lights;\n        options.litOptions.lights = lights.map(function (l) {\n          const lcopy = l.clone ? l.clone() : l;\n          lcopy.key = l.key;\n          return lcopy;\n        });\n      }\n      this.storeNewProgram(name, options);\n      if ((_options$litOptions2 = options.litOptions) != null && _options$litOptions2.lights) options.litOptions.lights = lights;\n      if (this._precached) ;\n      const device = this._device;\n      def = generator.createShaderDefinition(device, options);\n      def.name = `${name}-pass:${options.pass}`;\n      this.definitionsCache.set(key, def);\n    }\n    return def;\n  }\n  getCachedShader(key) {\n    return this.processedCache.get(key);\n  }\n  setCachedShader(key, shader) {\n    this.processedCache.set(key, shader);\n  }\n  getProgram(name, options, processingOptions) {\n    const generator = this._generators[name];\n    if (!generator) {\n      return null;\n    }\n    const generationKey = generator.generateKey(options);\n    const processingKey = JSON.stringify(processingOptions);\n    const totalKey = `${generationKey}#${processingKey}`;\n    let processedShader = this.getCachedShader(totalKey);\n    if (!processedShader) {\n      const generatedShaderDef = this.generateShaderDefinition(generator, name, generationKey, options);\n      const shaderDefinition = {\n        name: name,\n        attributes: generatedShaderDef.attributes,\n        vshader: generatedShaderDef.vshader,\n        fshader: generatedShaderDef.fshader,\n        processingOptions: processingOptions\n      };\n      processedShader = new _platform_graphics_shader_js__WEBPACK_IMPORTED_MODULE_2__.Shader(this._device, shaderDefinition);\n      this.setCachedShader(totalKey, processedShader);\n    }\n    return processedShader;\n  }\n  storeNewProgram(name, options) {\n    let opt = {};\n    if (name === \"standard\") {\n      const defaultMat = this._getDefaultStdMatOptions(options.pass);\n      for (const p in options) {\n        if (options.hasOwnProperty(p) && defaultMat[p] !== options[p] || p === \"pass\") opt[p] = options[p];\n      }\n      for (const p in options.litOptions) {\n        opt[p] = options.litOptions[p];\n      }\n    } else {\n      opt = options;\n    }\n    this._programsCollection.push(JSON.stringify({\n      name: name,\n      options: opt\n    }));\n  }\n  dumpPrograms() {\n    let text = 'let device = pc.app ? pc.app.graphicsDevice : pc.Application.getApplication().graphicsDevice;\\n';\n    text += 'let shaders = [';\n    if (this._programsCollection[0]) text += '\\n\\t' + this._programsCollection[0];\n    for (let i = 1; i < this._programsCollection.length; ++i) {\n      text += ',\\n\\t' + this._programsCollection[i];\n    }\n    text += '\\n];\\n';\n    text += 'device.getProgramLibrary().precompile(shaders);\\n';\n    text += 'if (pc.version != \\\"' + _core_core_js__WEBPACK_IMPORTED_MODULE_3__.version + '\\\" || pc.revision != \\\"' + _core_core_js__WEBPACK_IMPORTED_MODULE_3__.revision + '\\\")\\n';\n    text += '\\tconsole.warn(\\\"precompile-shaders.js: engine version mismatch, rebuild shaders lib with current engine\\\");';\n    const element = document.createElement('a');\n    element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));\n    element.setAttribute('download', 'precompile-shaders.js');\n    element.style.display = 'none';\n    document.body.appendChild(element);\n    element.click();\n    document.body.removeChild(element);\n  }\n  clearCache() {\n    this._isClearingCache = true;\n    this.processedCache.forEach(shader => {\n      shader.destroy();\n    });\n    this.processedCache.clear();\n    this._isClearingCache = false;\n  }\n  removeFromCache(shader) {\n    if (this._isClearingCache) return;\n    this.processedCache.forEach((cachedShader, key) => {\n      if (shader === cachedShader) {\n        this.processedCache.delete(key);\n      }\n    });\n  }\n  _getDefaultStdMatOptions(pass) {\n    return pass === _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHADER_DEPTH || pass === _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHADER_PICK || _shader_pass_js__WEBPACK_IMPORTED_MODULE_4__.ShaderPass.isShadow(pass) ? this._defaultStdMatOptionMin : this._defaultStdMatOption;\n  }\n  precompile(cache) {\n    if (cache) {\n      const shaders = new Array(cache.length);\n      for (let i = 0; i < cache.length; i++) {\n        if (cache[i].name === \"standard\") {\n          const opt = cache[i].options;\n          const defaultMat = this._getDefaultStdMatOptions(opt.pass);\n          for (const p in defaultMat) {\n            if (defaultMat.hasOwnProperty(p) && opt[p] === undefined) opt[p] = defaultMat[p];\n          }\n        }\n        shaders[i] = this.getProgram(cache[i].name, cache[i].options);\n      }\n    }\n    this._precached = true;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/program-library.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/programs/basic.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/programs/basic.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"basic\": () => (/* binding */ basic)\n/* harmony export */ });\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_shader_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../platform/graphics/shader-utils.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-utils.js\");\n/* harmony import */ var _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../chunks/chunks.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/chunks.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _shader_pass_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shader-pass.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-pass.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/programs/common.js\");\n\n\n\n\n\n\n\nconst basic = {\n  generateKey: function (options) {\n    let key = 'basic';\n    if (options.fog) key += '_fog';\n    if (options.alphaTest) key += '_atst';\n    if (options.vertexColors) key += '_vcol';\n    if (options.diffuseMap) key += '_diff';\n    if (options.skin) key += '_skin';\n    if (options.screenSpace) key += '_ss';\n    if (options.useInstancing) key += '_inst';\n    if (options.useMorphPosition) key += '_morphp';\n    if (options.useMorphNormal) key += '_morphn';\n    if (options.useMorphTextureBased) key += '_morpht';\n    key += '_' + options.pass;\n    return key;\n  },\n  createShaderDefinition: function (device, options) {\n    const attributes = {\n      vertex_position: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_POSITION\n    };\n    if (options.skin) {\n      attributes.vertex_boneWeights = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_BLENDWEIGHT;\n      attributes.vertex_boneIndices = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_BLENDINDICES;\n    }\n    if (options.vertexColors) {\n      attributes.vertex_color = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_COLOR;\n    }\n    if (options.diffuseMap) {\n      attributes.vertex_texCoord0 = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD0;\n    }\n    const shaderPassDefine = _shader_pass_js__WEBPACK_IMPORTED_MODULE_1__.ShaderPass.getPassShaderDefine(options.pass);\n    let vshader = shaderPassDefine;\n    vshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_2__.shaderChunks.transformDeclVS;\n    if (options.skin) {\n      vshader += (0,_common_js__WEBPACK_IMPORTED_MODULE_3__.skinCode)(device);\n      vshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_2__.shaderChunks.transformSkinnedVS;\n    } else {\n      vshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_2__.shaderChunks.transformVS;\n    }\n    if (options.vertexColors) {\n      vshader += 'attribute vec4 vertex_color;\\n';\n      vshader += 'varying vec4 vColor;\\n';\n    }\n    if (options.diffuseMap) {\n      vshader += 'attribute vec2 vertex_texCoord0;\\n';\n      vshader += 'varying vec2 vUv0;\\n';\n    }\n    if (options.pass === _constants_js__WEBPACK_IMPORTED_MODULE_4__.SHADER_DEPTH) {\n      vshader += 'varying float vDepth;\\n';\n      vshader += '#ifndef VIEWMATRIX\\n';\n      vshader += '#define VIEWMATRIX\\n';\n      vshader += 'uniform mat4 matrix_view;\\n';\n      vshader += '#endif\\n';\n      vshader += '#ifndef CAMERAPLANES\\n';\n      vshader += '#define CAMERAPLANES\\n';\n      vshader += 'uniform vec4 camera_params;\\n\\n';\n      vshader += '#endif\\n';\n    }\n    vshader += (0,_common_js__WEBPACK_IMPORTED_MODULE_3__.begin)();\n    vshader += \"   gl_Position = getPosition();\\n\";\n    if (options.pass === _constants_js__WEBPACK_IMPORTED_MODULE_4__.SHADER_DEPTH) {\n      vshader += \"    vDepth = -(matrix_view * vec4(getWorldPosition(),1.0)).z * camera_params.x;\\n\";\n    }\n    if (options.vertexColors) {\n      vshader += '    vColor = vertex_color;\\n';\n    }\n    if (options.diffuseMap) {\n      vshader += '    vUv0 = vertex_texCoord0;\\n';\n    }\n    vshader += (0,_common_js__WEBPACK_IMPORTED_MODULE_3__.end)();\n    let fshader = shaderPassDefine;\n    if (options.vertexColors) {\n      fshader += 'varying vec4 vColor;\\n';\n    } else {\n      fshader += 'uniform vec4 uColor;\\n';\n    }\n    if (options.diffuseMap) {\n      fshader += 'varying vec2 vUv0;\\n';\n      fshader += 'uniform sampler2D texture_diffuseMap;\\n';\n    }\n    if (options.fog) {\n      fshader += (0,_common_js__WEBPACK_IMPORTED_MODULE_3__.fogCode)(options.fog);\n    }\n    if (options.alphaTest) {\n      fshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_2__.shaderChunks.alphaTestPS;\n    }\n    if (options.pass === _constants_js__WEBPACK_IMPORTED_MODULE_4__.SHADER_DEPTH) {\n      fshader += 'varying float vDepth;\\n';\n      fshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_2__.shaderChunks.packDepthPS;\n    }\n    fshader += (0,_common_js__WEBPACK_IMPORTED_MODULE_3__.begin)();\n    if (options.vertexColors) {\n      fshader += '    gl_FragColor = vColor;\\n';\n    } else {\n      fshader += '    gl_FragColor = uColor;\\n';\n    }\n    if (options.diffuseMap) {\n      fshader += '    gl_FragColor *= texture2D(texture_diffuseMap, vUv0);\\n';\n    }\n    if (options.alphaTest) {\n      fshader += \"   alphaTest(gl_FragColor.a);\\n\";\n    }\n    if (options.pass !== _constants_js__WEBPACK_IMPORTED_MODULE_4__.SHADER_PICK) {\n      if (options.pass === _constants_js__WEBPACK_IMPORTED_MODULE_4__.SHADER_DEPTH) {\n        fshader += \"    gl_FragColor = packFloat(vDepth);\\n\";\n      } else {\n        if (options.fog) {\n          fshader += \"   glFragColor.rgb = addFog(gl_FragColor.rgb);\\n\";\n        }\n      }\n    }\n    fshader += (0,_common_js__WEBPACK_IMPORTED_MODULE_3__.end)();\n    return _platform_graphics_shader_utils_js__WEBPACK_IMPORTED_MODULE_5__.ShaderUtils.createDefinition(device, {\n      name: 'BasicShader',\n      attributes: attributes,\n      vertexCode: vshader,\n      fragmentCode: fshader\n    });\n  }\n};\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/programs/basic.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/programs/common.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/programs/common.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"begin\": () => (/* binding */ begin),\n/* harmony export */   \"end\": () => (/* binding */ end),\n/* harmony export */   \"fogCode\": () => (/* binding */ fogCode),\n/* harmony export */   \"gammaCode\": () => (/* binding */ gammaCode),\n/* harmony export */   \"skinCode\": () => (/* binding */ skinCode),\n/* harmony export */   \"tonemapCode\": () => (/* binding */ tonemapCode)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../chunks/chunks.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/chunks.js\");\n\n\n\nfunction gammaCode(value, chunks) {\n  if (!chunks) chunks = _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks;\n  if (value === _constants_js__WEBPACK_IMPORTED_MODULE_1__.GAMMA_SRGB || value === _constants_js__WEBPACK_IMPORTED_MODULE_1__.GAMMA_SRGBFAST) {\n    return chunks.gamma2_2PS ? chunks.gamma2_2PS : _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.gamma2_2PS;\n  } else if (value === _constants_js__WEBPACK_IMPORTED_MODULE_1__.GAMMA_SRGBHDR) {\n    return \"#define HDR\\n\" + (chunks.gamma2_2PS ? chunks.gamma2_2PS : _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.gamma2_2PS);\n  }\n  return chunks.gamma1_0PS ? chunks.gamma1_0PS : _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.gamma1_0PS;\n}\nfunction tonemapCode(value, chunks) {\n  if (!chunks) chunks = _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks;\n  if (value === _constants_js__WEBPACK_IMPORTED_MODULE_1__.TONEMAP_FILMIC) {\n    return chunks.tonemappingFilmicPS ? chunks.tonemappingFilmicPS : _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.tonemappingFilmicPS;\n  } else if (value === _constants_js__WEBPACK_IMPORTED_MODULE_1__.TONEMAP_LINEAR) {\n    return chunks.tonemappingLinearPS ? chunks.tonemappingLinearPS : _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.tonemappingLinearPS;\n  } else if (value === _constants_js__WEBPACK_IMPORTED_MODULE_1__.TONEMAP_HEJL) {\n    return chunks.tonemappingHejlPS ? chunks.tonemappingHejlPS : _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.tonemappingHejlPS;\n  } else if (value === _constants_js__WEBPACK_IMPORTED_MODULE_1__.TONEMAP_ACES) {\n    return chunks.tonemappingAcesPS ? chunks.tonemappingAcesPS : _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.tonemappingAcesPS;\n  } else if (value === _constants_js__WEBPACK_IMPORTED_MODULE_1__.TONEMAP_ACES2) {\n    return chunks.tonemappingAces2PS ? chunks.tonemappingAces2PS : _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.tonemappingAces2PS;\n  }\n  return chunks.tonemapingNonePS ? chunks.tonemapingNonePS : _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.tonemappingNonePS;\n}\nfunction fogCode(value, chunks) {\n  if (!chunks) chunks = _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks;\n  if (value === 'linear') {\n    return chunks.fogLinearPS ? chunks.fogLinearPS : _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.fogLinearPS;\n  } else if (value === 'exp') {\n    return chunks.fogExpPS ? chunks.fogExpPS : _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.fogExpPS;\n  } else if (value === 'exp2') {\n    return chunks.fogExp2PS ? chunks.fogExp2PS : _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.fogExp2PS;\n  }\n  return chunks.fogNonePS ? chunks.fogNonePS : _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.fogNonePS;\n}\nfunction skinCode(device, chunks) {\n  if (!chunks) chunks = _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks;\n  if (device.supportsBoneTextures) {\n    return chunks.skinTexVS;\n  }\n  return \"#define BONE_LIMIT \" + device.getBoneLimit() + \"\\n\" + chunks.skinConstVS;\n}\nfunction begin() {\n  return 'void main(void)\\n{\\n';\n}\nfunction end() {\n  return '}\\n';\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/programs/common.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/programs/lit-shader.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/programs/lit-shader.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LitShader\": () => (/* binding */ LitShader)\n/* harmony export */ });\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../chunks/chunks.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/chunks.js\");\n/* harmony import */ var _chunk_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../chunk-utils.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunk-utils.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _lighting_lights_buffer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../lighting/lights-buffer.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/lighting/lights-buffer.js\");\n/* harmony import */ var _shader_pass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shader-pass.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-pass.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./common.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/programs/common.js\");\n/* harmony import */ var _platform_graphics_shader_utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../platform/graphics/shader-utils.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-utils.js\");\n\n\n\n\n\n\n\n\n\n\nconst builtinAttributes = {\n  vertex_normal: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_NORMAL,\n  vertex_tangent: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TANGENT,\n  vertex_texCoord0: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD0,\n  vertex_texCoord1: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TEXCOORD1,\n  vertex_color: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_COLOR,\n  vertex_boneWeights: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_BLENDWEIGHT,\n  vertex_boneIndices: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_BLENDINDICES\n};\nconst builtinVaryings = {\n  vVertexColor: \"vec4\",\n  vPositionW: \"vec3\",\n  vNormalV: \"vec3\",\n  vNormalW: \"vec3\",\n  vTangentW: \"vec3\",\n  vBinormalW: \"vec3\",\n  vObjectSpaceUpW: \"vec3\",\n  vUv0: \"vec2\",\n  vUv1: \"vec2\"\n};\nclass LitShader {\n  constructor(device, options) {\n    this.device = device;\n    this.options = options;\n    this.attributes = {\n      vertex_position: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_POSITION\n    };\n    if (options.chunks) {\n      this.chunks = {};\n      const userChunks = options.chunks;\n      for (const chunkName in _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_1__.shaderChunks) {\n        if (userChunks.hasOwnProperty(chunkName)) {\n          const chunk = userChunks[chunkName];\n          for (const a in builtinAttributes) {\n            if (builtinAttributes.hasOwnProperty(a) && chunk.indexOf(a) >= 0) {\n              this.attributes[a] = builtinAttributes[a];\n            }\n          }\n          this.chunks[chunkName] = chunk;\n        } else {\n          this.chunks[chunkName] = _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_1__.shaderChunks[chunkName];\n        }\n      }\n    } else {\n      this.chunks = _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_1__.shaderChunks;\n    }\n    this.lighting = options.lights.length > 0 || options.dirLightMapEnabled || options.clusteredLightingEnabled;\n    this.reflections = !!options.reflectionSource;\n    this.shadowPass = _shader_pass_js__WEBPACK_IMPORTED_MODULE_2__.ShaderPass.isShadow(options.pass);\n    this.needsNormal = this.lighting || this.reflections || options.useSpecular || options.ambientSH || options.heightMapEnabled || options.enableGGXSpecular || options.clusteredLightingEnabled && !this.shadowPass || options.clearCoatNormalMapEnabled;\n    this.needsSceneColor = options.useDynamicRefraction;\n    this.needsScreenSize = options.useDynamicRefraction;\n    this.needsTransforms = options.useDynamicRefraction;\n    this.varyings = \"\";\n    this.vshader = null;\n    this.frontendDecl = null;\n    this.frontendCode = null;\n    this.frontendFunc = null;\n    this.lightingUv = null;\n    this.defines = [];\n    this.fshader = null;\n  }\n  _vsAddBaseCode(code, chunks, options) {\n    code += chunks.baseVS;\n    if (options.nineSlicedMode === _constants_js__WEBPACK_IMPORTED_MODULE_3__.SPRITE_RENDERMODE_SLICED || options.nineSlicedMode === _constants_js__WEBPACK_IMPORTED_MODULE_3__.SPRITE_RENDERMODE_TILED) {\n      code += chunks.baseNineSlicedVS;\n    }\n    return code;\n  }\n  _vsAddTransformCode(code, device, chunks, options) {\n    code += this.chunks.transformVS;\n    return code;\n  }\n  _setMapTransform(codes, name, id, uv) {\n    const checkId = id + uv * 100;\n    if (!codes[3][checkId]) {\n      const varName = `texture_${name}MapTransform`;\n      codes[0] += `uniform vec3 ${varName}0;\\n`;\n      codes[0] += `uniform vec3 ${varName}1;\\n`;\n      codes[1] += `varying vec2 vUV${uv}_${id};\\n`;\n      codes[2] += `   vUV${uv}_${id} = vec2(dot(vec3(uv${uv}, 1), ${varName}0), dot(vec3(uv${uv}, 1), ${varName}1));\\n`;\n      codes[3][checkId] = true;\n    }\n    return codes;\n  }\n  _fsGetBaseCode() {\n    const options = this.options;\n    const chunks = this.chunks;\n    let result = this.chunks.basePS;\n    if (options.nineSlicedMode === _constants_js__WEBPACK_IMPORTED_MODULE_3__.SPRITE_RENDERMODE_SLICED) {\n      result += chunks.baseNineSlicedPS;\n    } else if (options.nineSlicedMode === _constants_js__WEBPACK_IMPORTED_MODULE_3__.SPRITE_RENDERMODE_TILED) {\n      result += chunks.baseNineSlicedTiledPS;\n    }\n    return result;\n  }\n  _fsGetStartCode(code, device, chunks, options) {\n    let result = chunks.startPS;\n    if (options.nineSlicedMode === _constants_js__WEBPACK_IMPORTED_MODULE_3__.SPRITE_RENDERMODE_SLICED) {\n      result += chunks.startNineSlicedPS;\n    } else if (options.nineSlicedMode === _constants_js__WEBPACK_IMPORTED_MODULE_3__.SPRITE_RENDERMODE_TILED) {\n      result += chunks.startNineSlicedTiledPS;\n    }\n    return result;\n  }\n  _directionalShadowMapProjection(light, shadowCoordArgs, shadowParamArg, lightIndex, coordsFunctionName) {\n    let code = \"\";\n    if (light.numCascades > 1) {\n      code += `getShadowCascadeMatrix(light${lightIndex}_shadowMatrixPalette, light${lightIndex}_shadowCascadeDistances, light${lightIndex}_shadowCascadeCount);\\n`;\n      shadowCoordArgs = `(cascadeShadowMat, ${shadowParamArg});\\n`;\n    }\n    code += coordsFunctionName + shadowCoordArgs;\n    if (this.device.deviceType !== _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.DEVICETYPE_WEBGPU) {\n      code += `fadeShadow(light${lightIndex}_shadowCascadeDistances);\\n`;\n    }\n    return code;\n  }\n  _nonPointShadowMapProjection(device, light, shadowMatArg, shadowParamArg, lightIndex) {\n    const shadowCoordArgs = `(${shadowMatArg}, ${shadowParamArg});\\n`;\n    if (!light._normalOffsetBias || light._isVsm) {\n      if (light._type === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_SPOT) {\n        if (light._isPcf && (device.webgl2 || device.extStandardDerivatives || device.deviceType === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.DEVICETYPE_WEBGPU)) {\n          return \"       getShadowCoordPerspZbuffer\" + shadowCoordArgs;\n        }\n        return \"       getShadowCoordPersp\" + shadowCoordArgs;\n      }\n      return this._directionalShadowMapProjection(light, shadowCoordArgs, shadowParamArg, lightIndex, \"getShadowCoordOrtho\");\n    }\n    if (light._type === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_SPOT) {\n      if (light._isPcf && (device.webgl2 || device.extStandardDerivatives || device.deviceType === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.DEVICETYPE_WEBGPU)) {\n        return \"       getShadowCoordPerspZbufferNormalOffset\" + shadowCoordArgs;\n      }\n      return \"       getShadowCoordPerspNormalOffset\" + shadowCoordArgs;\n    }\n    return this._directionalShadowMapProjection(light, shadowCoordArgs, shadowParamArg, lightIndex, \"getShadowCoordOrthoNormalOffset\");\n  }\n  _getLightSourceShapeString(shape) {\n    switch (shape) {\n      case _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTSHAPE_RECT:\n        return 'Rect';\n      case _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTSHAPE_DISK:\n        return 'Disk';\n      case _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTSHAPE_SPHERE:\n        return 'Sphere';\n      default:\n        return '';\n    }\n  }\n  generateVertexShader(useUv, useUnmodifiedUv, mapTransforms) {\n    const device = this.device;\n    const options = this.options;\n    const chunks = this.chunks;\n    let code = '';\n    let codeBody = '';\n    code = this._vsAddBaseCode(code, chunks, options);\n    codeBody += \"   vPositionW    = getWorldPosition();\\n\";\n    if (this.options.pass === _constants_js__WEBPACK_IMPORTED_MODULE_3__.SHADER_DEPTH) {\n      code += 'varying float vDepth;\\n';\n      code += '#ifndef VIEWMATRIX\\n';\n      code += '#define VIEWMATRIX\\n';\n      code += 'uniform mat4 matrix_view;\\n';\n      code += '#endif\\n';\n      code += '#ifndef CAMERAPLANES\\n';\n      code += '#define CAMERAPLANES\\n';\n      code += 'uniform vec4 camera_params;\\n\\n';\n      code += '#endif\\n';\n      codeBody += \"    vDepth = -(matrix_view * vec4(vPositionW,1.0)).z * camera_params.x;\\n\";\n    }\n    if (this.options.useInstancing) {\n      this.attributes.instance_line1 = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR12;\n      this.attributes.instance_line2 = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR13;\n      this.attributes.instance_line3 = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR14;\n      this.attributes.instance_line4 = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR15;\n      code += chunks.instancingVS;\n    }\n    if (this.needsNormal) {\n      this.attributes.vertex_normal = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_NORMAL;\n      codeBody += \"   vNormalW = getNormal();\\n\";\n      if (options.reflectionSource === 'sphereMap' && device.fragmentUniformsCount <= 16) {\n        code += chunks.viewNormalVS;\n        codeBody += \"   vNormalV    = getViewNormal();\\n\";\n      }\n      if (options.hasTangents && (options.heightMapEnabled || options.normalMapEnabled || options.enableGGXSpecular)) {\n        this.attributes.vertex_tangent = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_TANGENT;\n        code += chunks.tangentBinormalVS;\n        codeBody += \"   vTangentW   = getTangent();\\n\";\n        codeBody += \"   vBinormalW  = getBinormal();\\n\";\n      } else if (options.enableGGXSpecular || !device.extStandardDerivatives) {\n        code += chunks.tangentBinormalVS;\n        codeBody += \"   vObjectSpaceUpW  = getObjectSpaceUp();\\n\";\n      }\n    }\n    const maxUvSets = 2;\n    for (let i = 0; i < maxUvSets; i++) {\n      if (useUv[i]) {\n        this.attributes[\"vertex_texCoord\" + i] = \"TEXCOORD\" + i;\n        code += chunks[\"uv\" + i + \"VS\"];\n        codeBody += \"   vec2 uv\" + i + \" = getUv\" + i + \"();\\n\";\n      }\n      if (useUnmodifiedUv[i]) {\n        codeBody += \"   vUv\" + i + \" = uv\" + i + \";\\n\";\n      }\n    }\n    const codes = [code, this.varyings, codeBody, []];\n    mapTransforms.forEach(mapTransform => {\n      this._setMapTransform(codes, mapTransform.name, mapTransform.id, mapTransform.uv);\n    });\n    code = codes[0];\n    this.varyings = codes[1];\n    codeBody = codes[2];\n    if (options.vertexColors) {\n      this.attributes.vertex_color = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_COLOR;\n      codeBody += \"   vVertexColor = vertex_color;\\n\";\n    }\n    if (options.useMsdf && options.msdfTextAttribute) {\n      this.attributes.vertex_outlineParameters = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR8;\n      this.attributes.vertex_shadowParameters = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR9;\n      codeBody += \"    unpackMsdfParams();\\n\";\n      code += chunks.msdfVS;\n    }\n    if (options.useMorphPosition || options.useMorphNormal) {\n      if (options.useMorphTextureBased) {\n        code += \"#define MORPHING_TEXTURE_BASED\\n\";\n        if (options.useMorphPosition) {\n          code += \"#define MORPHING_TEXTURE_BASED_POSITION\\n\";\n        }\n        if (options.useMorphNormal) {\n          code += \"#define MORPHING_TEXTURE_BASED_NORMAL\\n\";\n        }\n        this.attributes.morph_vertex_id = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR15;\n        code += \"attribute float morph_vertex_id;\\n\";\n      } else {\n        code += \"#define MORPHING\\n\";\n        if (options.useMorphPosition) {\n          this.attributes.morph_pos0 = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR8;\n          this.attributes.morph_pos1 = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR9;\n          this.attributes.morph_pos2 = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR10;\n          this.attributes.morph_pos3 = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR11;\n          code += \"#define MORPHING_POS03\\n\";\n          code += \"attribute vec3 morph_pos0;\\n\";\n          code += \"attribute vec3 morph_pos1;\\n\";\n          code += \"attribute vec3 morph_pos2;\\n\";\n          code += \"attribute vec3 morph_pos3;\\n\";\n        } else if (options.useMorphNormal) {\n          this.attributes.morph_nrm0 = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR8;\n          this.attributes.morph_nrm1 = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR9;\n          this.attributes.morph_nrm2 = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR10;\n          this.attributes.morph_nrm3 = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR11;\n          code += \"#define MORPHING_NRM03\\n\";\n          code += \"attribute vec3 morph_nrm0;\\n\";\n          code += \"attribute vec3 morph_nrm1;\\n\";\n          code += \"attribute vec3 morph_nrm2;\\n\";\n          code += \"attribute vec3 morph_nrm3;\\n\";\n        }\n        if (!options.useMorphNormal) {\n          this.attributes.morph_pos4 = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR12;\n          this.attributes.morph_pos5 = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR13;\n          this.attributes.morph_pos6 = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR14;\n          this.attributes.morph_pos7 = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR15;\n          code += \"#define MORPHING_POS47\\n\";\n          code += \"attribute vec3 morph_pos4;\\n\";\n          code += \"attribute vec3 morph_pos5;\\n\";\n          code += \"attribute vec3 morph_pos6;\\n\";\n          code += \"attribute vec3 morph_pos7;\\n\";\n        } else {\n          this.attributes.morph_nrm4 = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR12;\n          this.attributes.morph_nrm5 = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR13;\n          this.attributes.morph_nrm6 = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR14;\n          this.attributes.morph_nrm7 = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTR15;\n          code += \"#define MORPHING_NRM47\\n\";\n          code += \"attribute vec3 morph_nrm4;\\n\";\n          code += \"attribute vec3 morph_nrm5;\\n\";\n          code += \"attribute vec3 morph_nrm6;\\n\";\n          code += \"attribute vec3 morph_nrm7;\\n\";\n        }\n      }\n    }\n    if (options.skin) {\n      this.attributes.vertex_boneWeights = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_BLENDWEIGHT;\n      this.attributes.vertex_boneIndices = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_BLENDINDICES;\n      code += (0,_common_js__WEBPACK_IMPORTED_MODULE_4__.skinCode)(device, chunks);\n      code += \"#define SKIN\\n\";\n    } else if (options.useInstancing) {\n      code += \"#define INSTANCING\\n\";\n    }\n    if (options.screenSpace) {\n      code += \"#define SCREENSPACE\\n\";\n    }\n    if (options.pixelSnap) {\n      code += \"#define PIXELSNAP\\n\";\n    }\n    code = this._vsAddTransformCode(code, device, chunks, options);\n    if (this.needsNormal) {\n      code += chunks.normalVS;\n    }\n    code += \"\\n\";\n    code += chunks.startVS;\n    code += codeBody;\n    code += chunks.endVS;\n    code += \"}\";\n    Object.keys(builtinVaryings).forEach(v => {\n      if (code.indexOf(v) >= 0) {\n        this.varyings += `varying ${builtinVaryings[v]} ${v};\\n`;\n      }\n    });\n    const shaderPassDefine = _shader_pass_js__WEBPACK_IMPORTED_MODULE_2__.ShaderPass.getPassShaderDefine(this.options.pass);\n    this.vshader = shaderPassDefine + this.varyings + code;\n  }\n  _fsGetBeginCode() {\n    let code = _shader_pass_js__WEBPACK_IMPORTED_MODULE_2__.ShaderPass.getPassShaderDefine(this.options.pass);\n    for (let i = 0; i < this.defines.length; i++) {\n      code += `#define ${this.defines[i]}\\n`;\n    }\n    return code;\n  }\n  _fsGetPickPassCode() {\n    let code = this._fsGetBeginCode();\n    code += \"uniform vec4 uColor;\\n\";\n    code += this.varyings;\n    code += this.frontendDecl;\n    code += this.frontendCode;\n    code += (0,_common_js__WEBPACK_IMPORTED_MODULE_4__.begin)();\n    code += this.frontendFunc;\n    code += \"    gl_FragColor = uColor;\\n\";\n    code += (0,_common_js__WEBPACK_IMPORTED_MODULE_4__.end)();\n    return code;\n  }\n  _fsGetDepthPassCode() {\n    const chunks = this.chunks;\n    let code = this._fsGetBeginCode();\n    code += 'varying float vDepth;\\n';\n    code += this.varyings;\n    code += chunks.packDepthPS;\n    code += this.frontendDecl;\n    code += this.frontendCode;\n    code += (0,_common_js__WEBPACK_IMPORTED_MODULE_4__.begin)();\n    code += this.frontendFunc;\n    code += \"    gl_FragColor = packFloat(vDepth);\\n\";\n    code += (0,_common_js__WEBPACK_IMPORTED_MODULE_4__.end)();\n    return code;\n  }\n  _fsGetShadowPassCode() {\n    const device = this.device;\n    const options = this.options;\n    const chunks = this.chunks;\n    const varyings = this.varyings;\n    const lightType = _shader_pass_js__WEBPACK_IMPORTED_MODULE_2__.ShaderPass.toLightType(options.pass);\n    const shadowType = _shader_pass_js__WEBPACK_IMPORTED_MODULE_2__.ShaderPass.toShadowType(options.pass);\n    let code = this._fsGetBeginCode();\n    if (device.extStandardDerivatives && !device.webgl2 && device.deviceType !== _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.DEVICETYPE_WEBGPU) {\n      code += 'uniform vec2 polygonOffset;\\n';\n    }\n    if (shadowType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.SHADOW_VSM32) {\n      if (device.textureFloatHighPrecision) {\n        code += '#define VSM_EXPONENT 15.0\\n\\n';\n      } else {\n        code += '#define VSM_EXPONENT 5.54\\n\\n';\n      }\n    } else if (shadowType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.SHADOW_VSM16) {\n      code += '#define VSM_EXPONENT 5.54\\n\\n';\n    }\n    if (lightType !== _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_DIRECTIONAL) {\n      code += 'uniform vec3 view_position;\\n';\n      code += 'uniform float light_radius;\\n';\n    }\n    code += varyings;\n    code += this.frontendDecl;\n    code += this.frontendCode;\n    if (shadowType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.SHADOW_PCF3 && (!device.webgl2 || device.deviceType !== _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.DEVICETYPE_WEBGPU || lightType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_OMNI)) {\n      code += chunks.packDepthPS;\n    } else if (shadowType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.SHADOW_VSM8) {\n      code += \"vec2 encodeFloatRG( float v ) {\\n\";\n      code += \"    vec2 enc = vec2(1.0, 255.0) * v;\\n\";\n      code += \"    enc = fract(enc);\\n\";\n      code += \"    enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\\n\";\n      code += \"    return enc;\\n\";\n      code += \"}\\n\\n\";\n    }\n    code += (0,_common_js__WEBPACK_IMPORTED_MODULE_4__.begin)();\n    code += this.frontendFunc;\n    const isVsm = shadowType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.SHADOW_VSM8 || shadowType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.SHADOW_VSM16 || shadowType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.SHADOW_VSM32;\n    const applySlopeScaleBias = !device.webgl2 && device.extStandardDerivatives && device.deviceType !== _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.DEVICETYPE_WEBGPU;\n    if (lightType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_OMNI || isVsm && lightType !== _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_DIRECTIONAL) {\n      code += \"    float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);\\n\";\n    } else {\n      code += \"    float depth = gl_FragCoord.z;\\n\";\n    }\n    if (applySlopeScaleBias) {\n      code += \"    float minValue = 2.3374370500153186e-10; //(1.0 / 255.0) / (256.0 * 256.0 * 256.0);\\n\";\n      code += \"    depth += polygonOffset.x * max(abs(dFdx(depth)), abs(dFdy(depth))) + minValue * polygonOffset.y;\\n\";\n    }\n    if (shadowType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.SHADOW_PCF3 && (!device.webgl2 || lightType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_OMNI && !options.clusteredLightingEnabled)) {\n      code += \"    gl_FragColor = packFloat(depth);\\n\";\n    } else if (shadowType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.SHADOW_PCF3 || shadowType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.SHADOW_PCF5) {\n      code += \"    gl_FragColor = vec4(1.0);\\n\";\n      if (options.clusteredLightingEnabled && lightType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_OMNI && device.webgl2) {\n        code += \"    gl_FragDepth = depth;\\n\";\n      }\n    } else if (shadowType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.SHADOW_VSM8) {\n      code += \"    gl_FragColor = vec4(encodeFloatRG(depth), encodeFloatRG(depth*depth));\\n\";\n    } else {\n      code += chunks.storeEVSMPS;\n    }\n    code += (0,_common_js__WEBPACK_IMPORTED_MODULE_4__.end)();\n    return code;\n  }\n  _fsGetLitPassCode() {\n    const device = this.device;\n    const options = this.options;\n    const chunks = this.chunks;\n    let code = \"\";\n    if (options.opacityFadesSpecular === false) {\n      code += 'uniform float material_alphaFade;\\n';\n    }\n    if (options.useSpecular) {\n      this.defines.push(\"LIT_SPECULAR\");\n      if (this.reflections) {\n        this.defines.push(\"LIT_REFLECTIONS\");\n      }\n      if (options.useClearCoat) {\n        this.defines.push(\"LIT_CLEARCOAT\");\n      }\n      if (options.fresnelModel > 0) {\n        this.defines.push(\"LIT_SPECULAR_FRESNEL\");\n      }\n      if (options.conserveEnergy) {\n        this.defines.push(\"LIT_CONSERVE_ENERGY\");\n      }\n      if (options.useSheen) {\n        this.defines.push(\"LIT_SHEEN\");\n      }\n      if (options.useIridescence) {\n        this.defines.push(\"LIT_IRIDESCENCE\");\n      }\n    }\n    const shadowTypeUsed = [];\n    let numShadowLights = 0;\n    let shadowedDirectionalLightUsed = false;\n    let useVsm = false;\n    let usePerspZbufferShadow = false;\n    let hasAreaLights = options.lights.some(function (light) {\n      return light._shape && light._shape !== _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTSHAPE_PUNCTUAL;\n    });\n    if (options.clusteredLightingEnabled && options.clusteredLightingAreaLightsEnabled) {\n      hasAreaLights = true;\n    }\n    let areaLutsPrecision = 'highp';\n    if (device.areaLightLutFormat === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.PIXELFORMAT_RGBA8) {\n      code += \"#define AREA_R8_G8_B8_A8_LUTS\\n\";\n      areaLutsPrecision = 'lowp';\n    }\n    if (hasAreaLights || options.clusteredLightingEnabled) {\n      code += \"#define AREA_LIGHTS\\n\";\n      code += `uniform ${areaLutsPrecision} sampler2D areaLightsLutTex1;\\n`;\n      code += `uniform ${areaLutsPrecision} sampler2D areaLightsLutTex2;\\n`;\n    }\n    for (let i = 0; i < options.lights.length; i++) {\n      const light = options.lights[i];\n      const lightType = light._type;\n      if (options.clusteredLightingEnabled && lightType !== _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_DIRECTIONAL) continue;\n      const lightShape = hasAreaLights && light._shape ? light._shape : _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTSHAPE_PUNCTUAL;\n      code += \"uniform vec3 light\" + i + \"_color;\\n\";\n      if (lightType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_DIRECTIONAL) {\n        code += \"uniform vec3 light\" + i + \"_direction;\\n\";\n      } else {\n        code += \"uniform vec3 light\" + i + \"_position;\\n\";\n        code += \"uniform float light\" + i + \"_radius;\\n\";\n        if (lightType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_SPOT) {\n          code += \"uniform vec3 light\" + i + \"_direction;\\n\";\n          code += \"uniform float light\" + i + \"_innerConeAngle;\\n\";\n          code += \"uniform float light\" + i + \"_outerConeAngle;\\n\";\n        }\n      }\n      if (lightShape !== _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTSHAPE_PUNCTUAL) {\n        if (lightType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_DIRECTIONAL) {\n          code += \"uniform vec3 light\" + i + \"_position;\\n\";\n        }\n        code += \"uniform vec3 light\" + i + \"_halfWidth;\\n\";\n        code += \"uniform vec3 light\" + i + \"_halfHeight;\\n\";\n      }\n      if (light.castShadows && !options.noShadow) {\n        code += \"uniform mat4 light\" + i + \"_shadowMatrix;\\n\";\n        code += \"uniform float light\" + i + \"_shadowIntensity;\\n\";\n        if (lightType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_DIRECTIONAL) {\n          if (device.deviceType !== _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.DEVICETYPE_WEBGPU) {\n            code += \"uniform mat4 light\" + i + \"_shadowMatrixPalette[4];\\n\";\n            code += \"uniform float light\" + i + \"_shadowCascadeDistances[4];\\n\";\n          }\n          code += \"uniform float light\" + i + \"_shadowCascadeCount;\\n\";\n        }\n        if (lightType !== _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_DIRECTIONAL) {\n          code += \"uniform vec4 light\" + i + \"_shadowParams;\\n\";\n        } else {\n          shadowedDirectionalLightUsed = true;\n          code += \"uniform vec3 light\" + i + \"_shadowParams;\\n\";\n        }\n        if (lightType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_OMNI) {\n          code += \"uniform samplerCube light\" + i + \"_shadowMap;\\n\";\n        } else {\n          if (light._isPcf && device.supportsDepthShadow) {\n            code += \"uniform sampler2DShadow light\" + i + \"_shadowMap;\\n\";\n          } else {\n            code += \"uniform sampler2D light\" + i + \"_shadowMap;\\n\";\n          }\n        }\n        numShadowLights++;\n        shadowTypeUsed[light._shadowType] = true;\n        if (light._isVsm) useVsm = true;\n        if (light._isPcf && (device.supportsDepthShadow || device.extStandardDerivatives) && lightType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_SPOT) usePerspZbufferShadow = true;\n      }\n      if (light._cookie) {\n        if (light._cookie._cubemap) {\n          if (lightType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_OMNI) {\n            code += \"uniform samplerCube light\" + i + \"_cookie;\\n\";\n            code += \"uniform float light\" + i + \"_cookieIntensity;\\n\";\n            if (!light.castShadows || options.noShadow) code += \"uniform mat4 light\" + i + \"_shadowMatrix;\\n\";\n          }\n        } else {\n          if (lightType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_SPOT) {\n            code += \"uniform sampler2D light\" + i + \"_cookie;\\n\";\n            code += \"uniform float light\" + i + \"_cookieIntensity;\\n\";\n            if (!light.castShadows || options.noShadow) code += \"uniform mat4 light\" + i + \"_shadowMatrix;\\n\";\n            if (light._cookieTransform) {\n              code += \"uniform vec4 light\" + i + \"_cookieMatrix;\\n\";\n              code += \"uniform vec2 light\" + i + \"_cookieOffset;\\n\";\n            }\n          }\n        }\n      }\n    }\n    code += \"\\n\";\n    const hasTBN = this.needsNormal && (options.normalMapEnabled || options.clearCoatNormalMapEnabled || options.enableGGXSpecular && !options.heightMapEnabled);\n    if (hasTBN) {\n      if (options.hasTangents) {\n        code += options.fastTbn ? chunks.TBNfastPS : chunks.TBNPS;\n      } else {\n        if (device.extStandardDerivatives && (options.normalMapEnabled || options.clearCoatNormalMapEnabled)) {\n          code += chunks.TBNderivativePS.replace(/\\$UV/g, this.lightingUv);\n        } else {\n          code += chunks.TBNObjectSpacePS;\n        }\n      }\n    }\n    code += chunks.sphericalPS;\n    code += chunks.decodePS;\n    code += (0,_common_js__WEBPACK_IMPORTED_MODULE_4__.gammaCode)(options.gamma, chunks);\n    code += (0,_common_js__WEBPACK_IMPORTED_MODULE_4__.tonemapCode)(options.toneMap, chunks);\n    code += (0,_common_js__WEBPACK_IMPORTED_MODULE_4__.fogCode)(options.fog, chunks);\n    code += this.frontendCode;\n    if (options.useCubeMapRotation) {\n      code += \"#define CUBEMAP_ROTATION\\n\";\n    }\n    if (this.needsNormal) {\n      code += chunks.cubeMapRotatePS;\n      code += options.cubeMapProjection > 0 ? chunks.cubeMapProjectBoxPS : chunks.cubeMapProjectNonePS;\n      code += options.skyboxIntensity ? chunks.envMultiplyPS : chunks.envConstPS;\n    }\n    if (this.lighting && options.useSpecular || this.reflections) {\n      if (options.useMetalness) {\n        code += chunks.metalnessModulatePS;\n      }\n      if (options.fresnelModel === _constants_js__WEBPACK_IMPORTED_MODULE_3__.FRESNEL_SCHLICK) {\n        code += chunks.fresnelSchlickPS;\n      }\n      if (options.useIridescence) {\n        code += chunks.iridescenceDiffractionPS;\n      }\n    }\n    const useAo = options.aoMapEnabled || options.useAoVertexColors;\n    if (useAo) {\n      code += chunks.aoDiffuseOccPS;\n      switch (options.occludeSpecular) {\n        case _constants_js__WEBPACK_IMPORTED_MODULE_3__.SPECOCC_AO:\n          code += options.occludeSpecularFloat ? chunks.aoSpecOccSimplePS : chunks.aoSpecOccConstSimplePS;\n          break;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_3__.SPECOCC_GLOSSDEPENDENT:\n          code += options.occludeSpecularFloat ? chunks.aoSpecOccPS : chunks.aoSpecOccConstPS;\n          break;\n      }\n    }\n    if (options.reflectionSource === 'envAtlasHQ') {\n      code += options.fixSeams ? chunks.fixCubemapSeamsStretchPS : chunks.fixCubemapSeamsNonePS;\n      code += chunks.envAtlasPS;\n      code += chunks.reflectionEnvHQPS.replace(/\\$DECODE/g, _chunk_utils_js__WEBPACK_IMPORTED_MODULE_5__.ChunkUtils.decodeFunc(options.reflectionEncoding));\n    } else if (options.reflectionSource === 'envAtlas') {\n      code += chunks.envAtlasPS;\n      code += chunks.reflectionEnvPS.replace(/\\$DECODE/g, _chunk_utils_js__WEBPACK_IMPORTED_MODULE_5__.ChunkUtils.decodeFunc(options.reflectionEncoding));\n    } else if (options.reflectionSource === 'cubeMap') {\n      code += options.fixSeams ? chunks.fixCubemapSeamsStretchPS : chunks.fixCubemapSeamsNonePS;\n      code += chunks.reflectionCubePS.replace(/\\$DECODE/g, _chunk_utils_js__WEBPACK_IMPORTED_MODULE_5__.ChunkUtils.decodeFunc(options.reflectionEncoding));\n    } else if (options.reflectionSource === 'sphereMap') {\n      const scode = device.fragmentUniformsCount > 16 ? chunks.reflectionSpherePS : chunks.reflectionSphereLowPS;\n      code += scode.replace(/\\$DECODE/g, _chunk_utils_js__WEBPACK_IMPORTED_MODULE_5__.ChunkUtils.decodeFunc(options.reflectionEncoding));\n    }\n    if (this.reflections) {\n      if (options.useClearCoat) {\n        code += chunks.reflectionCCPS;\n      }\n      if (options.useSheen) {\n        code += chunks.reflectionSheenPS;\n      }\n    }\n    if (options.useRefraction) {\n      if (options.useDynamicRefraction) {\n        code += chunks.refractionDynamicPS;\n      } else if (this.reflections) {\n        code += chunks.refractionCubePS;\n      }\n    }\n    if (options.useSheen) {\n      code += chunks.lightSheenPS;\n    }\n    if (options.clusteredLightingEnabled) {\n      code += chunks.clusteredLightUtilsPS;\n      if (options.clusteredLightingCookiesEnabled) code += chunks.clusteredLightCookiesPS;\n      if (options.clusteredLightingShadowsEnabled && !options.noShadow) {\n        shadowTypeUsed[_constants_js__WEBPACK_IMPORTED_MODULE_3__.SHADOW_PCF3] = true;\n        shadowTypeUsed[_constants_js__WEBPACK_IMPORTED_MODULE_3__.SHADOW_PCF5] = true;\n      }\n      usePerspZbufferShadow = true;\n    }\n    if (numShadowLights > 0 || options.clusteredLightingEnabled) {\n      if (shadowedDirectionalLightUsed) {\n        code += chunks.shadowCascadesPS;\n      }\n      if (shadowTypeUsed[_constants_js__WEBPACK_IMPORTED_MODULE_3__.SHADOW_PCF3]) {\n        code += chunks.shadowStandardPS;\n      }\n      if (shadowTypeUsed[_constants_js__WEBPACK_IMPORTED_MODULE_3__.SHADOW_PCF5] && (device.webgl2 || device.deviceType === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.DEVICETYPE_WEBGPU)) {\n        code += chunks.shadowStandardGL2PS;\n      }\n      if (useVsm) {\n        code += chunks.shadowVSM_commonPS;\n        if (shadowTypeUsed[_constants_js__WEBPACK_IMPORTED_MODULE_3__.SHADOW_VSM8]) {\n          code += chunks.shadowVSM8PS;\n        }\n        if (shadowTypeUsed[_constants_js__WEBPACK_IMPORTED_MODULE_3__.SHADOW_VSM16]) {\n          code += device.extTextureHalfFloatLinear ? chunks.shadowEVSMPS.replace(/\\$/g, \"16\") : chunks.shadowEVSMnPS.replace(/\\$/g, \"16\");\n        }\n        if (shadowTypeUsed[_constants_js__WEBPACK_IMPORTED_MODULE_3__.SHADOW_VSM32]) {\n          code += device.extTextureFloatLinear ? chunks.shadowEVSMPS.replace(/\\$/g, \"32\") : chunks.shadowEVSMnPS.replace(/\\$/g, \"32\");\n        }\n      }\n      if (!(device.webgl2 || device.extStandardDerivatives || device.deviceType === _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.DEVICETYPE_WEBGPU)) {\n        code += chunks.biasConstPS;\n      }\n      code += chunks.shadowCoordPS + chunks.shadowCommonPS;\n      if (usePerspZbufferShadow) code += chunks.shadowCoordPerspZbufferPS;\n    }\n    if (options.enableGGXSpecular) code += \"uniform float material_anisotropy;\\n\";\n    if (this.lighting) {\n      code += chunks.lightDiffuseLambertPS;\n      if (hasAreaLights || options.clusteredLightingEnabled) code += chunks.ltc;\n    }\n    code += '\\n';\n    let useOldAmbient = false;\n    if (options.useSpecular) {\n      if (this.lighting) {\n        code += options.shadingModel === _constants_js__WEBPACK_IMPORTED_MODULE_3__.SPECULAR_PHONG ? chunks.lightSpecularPhongPS : options.enableGGXSpecular ? chunks.lightSpecularAnisoGGXPS : chunks.lightSpecularBlinnPS;\n      }\n      if (!options.fresnelModel && !this.reflections && !options.diffuseMapEnabled) {\n        code += \"    uniform vec3 material_ambient;\\n\";\n        code += \"#define LIT_OLD_AMBIENT\";\n        useOldAmbient = true;\n      }\n    }\n    code += chunks.combinePS;\n    if (options.lightMapEnabled || options.useLightMapVertexColors) {\n      code += options.useSpecular && options.dirLightMapEnabled ? chunks.lightmapDirAddPS : chunks.lightmapAddPS;\n    }\n    const addAmbient = !options.lightMapEnabled && !options.useLightMapVertexColors || options.lightMapWithoutAmbient;\n    if (addAmbient) {\n      if (options.ambientSource === 'ambientSH') {\n        code += chunks.ambientSHPS;\n      } else if (options.ambientSource === 'envAtlas') {\n        if (options.reflectionSource !== 'envAtlas' && options.reflectionSource !== 'envAtlasHQ') {\n          code += chunks.envAtlasPS;\n        }\n        code += chunks.ambientEnvPS.replace(/\\$DECODE/g, _chunk_utils_js__WEBPACK_IMPORTED_MODULE_5__.ChunkUtils.decodeFunc(options.ambientEncoding));\n      } else {\n        code += chunks.ambientConstantPS;\n      }\n    }\n    if (options.useAmbientTint && !useOldAmbient) {\n      code += \"uniform vec3 material_ambient;\\n\";\n    }\n    if (options.useMsdf) {\n      if (!options.msdfTextAttribute) {\n        code += \"\\n#define UNIFORM_TEXT_PARAMETERS\";\n      }\n      code += chunks.msdfPS;\n    }\n    if (this.needsNormal) {\n      code += chunks.viewDirPS;\n      if (options.useSpecular) {\n        code += options.enableGGXSpecular ? chunks.reflDirAnisoPS : chunks.reflDirPS;\n      }\n    }\n    let hasPointLights = false;\n    let usesLinearFalloff = false;\n    let usesInvSquaredFalloff = false;\n    let usesSpot = false;\n    let usesCookie = false;\n    let usesCookieNow;\n    if (options.clusteredLightingEnabled && this.lighting) {\n      usesSpot = true;\n      hasPointLights = true;\n      usesLinearFalloff = true;\n      usesCookie = true;\n      code += chunks.floatUnpackingPS;\n      if (options.lightMaskDynamic) code += \"\\n#define CLUSTER_MESH_DYNAMIC_LIGHTS\";\n      if (options.clusteredLightingCookiesEnabled) code += \"\\n#define CLUSTER_COOKIES\";\n      if (options.clusteredLightingShadowsEnabled && !options.noShadow) {\n        code += \"\\n#define CLUSTER_SHADOWS\";\n        code += \"\\n#define CLUSTER_SHADOW_TYPE_\" + _constants_js__WEBPACK_IMPORTED_MODULE_3__.shadowTypeToString[options.clusteredLightingShadowType];\n      }\n      if (options.clusteredLightingAreaLightsEnabled) code += \"\\n#define CLUSTER_AREALIGHTS\";\n      code += _lighting_lights_buffer_js__WEBPACK_IMPORTED_MODULE_6__.LightsBuffer.shaderDefines;\n      if (options.clusteredLightingShadowsEnabled && !options.noShadow) {\n        code += chunks.clusteredLightShadowsPS;\n      }\n      code += chunks.clusteredLightPS;\n    }\n    if (options.twoSidedLighting) code += \"uniform float twoSidedLightingNegScaleFactor;\\n\";\n    code += this._fsGetStartCode(code, device, chunks, options);\n    if (this.needsNormal) {\n      if (options.twoSidedLighting) {\n        code += \"    dVertexNormalW = normalize(gl_FrontFacing ? vNormalW * twoSidedLightingNegScaleFactor : -vNormalW * twoSidedLightingNegScaleFactor);\\n\";\n      } else {\n        code += \"    dVertexNormalW = normalize(vNormalW);\\n\";\n      }\n      if ((options.heightMapEnabled || options.normalMapEnabled) && options.hasTangents) {\n        if (options.twoSidedLighting) {\n          code += \"    dTangentW = gl_FrontFacing ? vTangentW * twoSidedLightingNegScaleFactor : -vTangentW * twoSidedLightingNegScaleFactor;\\n\";\n          code += \"    dBinormalW = gl_FrontFacing ? vBinormalW * twoSidedLightingNegScaleFactor : -vBinormalW * twoSidedLightingNegScaleFactor;\\n\";\n        } else {\n          code += \"    dTangentW = vTangentW;\\n\";\n          code += \"    dBinormalW = vBinormalW;\\n\";\n        }\n      }\n      code += \"    getViewDir();\\n\";\n      if (hasTBN) {\n        code += \"    getTBN();\\n\";\n      }\n    }\n    code += this.frontendFunc;\n    if (this.needsNormal) {\n      if (options.useSpecular) {\n        code += \"    getReflDir();\\n\";\n      }\n      if (options.useClearCoat) {\n        code += \"    ccReflDirW = normalize(-reflect(dViewDirW, ccNormalW));\\n\";\n      }\n    }\n    if (this.lighting && options.useSpecular || this.reflections) {\n      if (options.useMetalness) {\n        code += \"    getMetalnessModulate();\\n\";\n      }\n      if (options.useIridescence) {\n        code += \"    getIridescence(saturate(dot(dViewDirW, dNormalW)));\\n\";\n      }\n    }\n    if (addAmbient) {\n      code += \"    addAmbient();\\n\";\n      if (options.conserveEnergy && options.useSpecular) {\n        code += `   dDiffuseLight = dDiffuseLight * (1.0 - dSpecularity);`;\n      }\n      if (options.separateAmbient) {\n        code += `\n                    vec3 dAmbientLight = dDiffuseLight;\n                    dDiffuseLight = vec3(0);\n                `;\n      }\n    }\n    if (options.useAmbientTint && !useOldAmbient) {\n      code += \"    dDiffuseLight *= material_ambient;\\n\";\n    }\n    if (useAo && !options.occludeDirect) {\n      code += \"    occludeDiffuse();\\n\";\n    }\n    if (options.lightMapEnabled || options.useLightMapVertexColors) {\n      code += \"    addLightMap();\\n\";\n    }\n    if (this.lighting || this.reflections) {\n      if (this.reflections) {\n        if (options.useClearCoat) {\n          code += \"    addReflectionCC();\\n\";\n          if (options.fresnelModel > 0) {\n            code += \"    ccFresnel = getFresnelCC(dot(dViewDirW, ccNormalW));\\n\";\n            code += \"    ccReflection.rgb *= ccFresnel;\\n\";\n          } else {\n            code += \"    ccFresnel = 0.0;\\n\";\n          }\n        }\n        if (options.useSpecularityFactor) {\n          code += \"    ccReflection.rgb *= dSpecularityFactor;\\n\";\n        }\n        if (options.useSheen) {\n          code += \"    addReflectionSheen();\\n\";\n        }\n        code += \"    addReflection();\\n\";\n        if (options.fresnelModel > 0) {\n          code += \"    dReflection.rgb *= getFresnel(dot(dViewDirW, dNormalW), dSpecularity);\\n\";\n        } else {\n          code += \"    dReflection.rgb *= dSpecularity;\\n\";\n        }\n        if (options.useSpecularityFactor) {\n          code += \"    dReflection.rgb *= dSpecularityFactor;\\n\";\n        }\n      }\n      if (hasAreaLights) {\n        code += \"    dSpecularLight *= dSpecularity;\\n\";\n        if (options.useSpecular) {\n          code += \"    calcLTCLightValues();\\n\";\n        }\n      }\n      for (let i = 0; i < options.lights.length; i++) {\n        const light = options.lights[i];\n        const lightType = light._type;\n        if (options.clusteredLightingEnabled && lightType !== _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_DIRECTIONAL) {\n          continue;\n        }\n        usesCookieNow = false;\n        const lightShape = hasAreaLights && light._shape ? light.shape : _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTSHAPE_PUNCTUAL;\n        const shapeString = hasAreaLights && light._shape ? this._getLightSourceShapeString(lightShape) : '';\n        if (lightShape !== _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTSHAPE_PUNCTUAL) {\n          code += \"    calc\" + shapeString + \"LightValues(light\" + i + \"_position, light\" + i + \"_halfWidth, light\" + i + \"_halfHeight);\\n\";\n        }\n        if (lightType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_DIRECTIONAL) {\n          code += \"    dLightDirNormW = light\" + i + \"_direction;\\n\";\n          code += \"    dAtten = 1.0;\\n\";\n        } else {\n          if (light._cookie) {\n            if (lightType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_SPOT && !light._cookie._cubemap) {\n              usesCookie = true;\n              usesCookieNow = true;\n            } else if (lightType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_OMNI && light._cookie._cubemap) {\n              usesCookie = true;\n              usesCookieNow = true;\n            }\n          }\n          code += \"    getLightDirPoint(light\" + i + \"_position);\\n\";\n          hasPointLights = true;\n          if (usesCookieNow) {\n            if (lightType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_SPOT) {\n              code += \"    dAtten3 = getCookie2D\" + (light._cookieFalloff ? \"\" : \"Clip\") + (light._cookieTransform ? \"Xform\" : \"\") + \"(light\" + i + \"_cookie, light\" + i + \"_shadowMatrix, light\" + i + \"_cookieIntensity\" + (light._cookieTransform ? \", light\" + i + \"_cookieMatrix, light\" + i + \"_cookieOffset\" : \"\") + \").\" + light._cookieChannel + \";\\n\";\n            } else {\n              code += \"    dAtten3 = getCookieCube(light\" + i + \"_cookie, light\" + i + \"_shadowMatrix, light\" + i + \"_cookieIntensity).\" + light._cookieChannel + \";\\n\";\n            }\n          }\n          if (lightShape === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTSHAPE_PUNCTUAL) {\n            if (light._falloffMode === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTFALLOFF_LINEAR) {\n              code += \"    dAtten = getFalloffLinear(light\" + i + \"_radius);\\n\";\n              usesLinearFalloff = true;\n            } else {\n              code += \"    dAtten = getFalloffInvSquared(light\" + i + \"_radius);\\n\";\n              usesInvSquaredFalloff = true;\n            }\n          } else {\n            code += \"    dAtten = getFalloffWindow(light\" + i + \"_radius);\\n\";\n            usesInvSquaredFalloff = true;\n          }\n          code += \"    if (dAtten > 0.00001) {\\n\";\n          if (lightType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_SPOT) {\n            if (!(usesCookieNow && !light._cookieFalloff)) {\n              code += \"    dAtten *= getSpotEffect(light\" + i + \"_direction, light\" + i + \"_innerConeAngle, light\" + i + \"_outerConeAngle);\\n\";\n              usesSpot = true;\n            }\n          }\n        }\n        if (lightShape !== _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTSHAPE_PUNCTUAL) {\n          if (lightType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_DIRECTIONAL) {\n            code += \"    dAttenD = getLightDiffuse();\\n\";\n          } else {\n            code += \"    dAttenD = get\" + shapeString + \"LightDiffuse() * 16.0;\\n\";\n          }\n        } else {\n          code += \"    dAtten *= getLightDiffuse();\\n\";\n        }\n        if (light.castShadows && !options.noShadow) {\n          let shadowReadMode = null;\n          let evsmExp;\n          if (light._shadowType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.SHADOW_VSM8) {\n            shadowReadMode = \"VSM8\";\n            evsmExp = \"0.0\";\n          } else if (light._shadowType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.SHADOW_VSM16) {\n            shadowReadMode = \"VSM16\";\n            evsmExp = \"5.54\";\n          } else if (light._shadowType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.SHADOW_VSM32) {\n            shadowReadMode = \"VSM32\";\n            if (device.textureFloatHighPrecision) {\n              evsmExp = \"15.0\";\n            } else {\n              evsmExp = \"5.54\";\n            }\n          } else if (light._shadowType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.SHADOW_PCF5) {\n            shadowReadMode = \"PCF5x5\";\n          } else {\n            shadowReadMode = \"PCF3x3\";\n          }\n          if (shadowReadMode !== null) {\n            if (lightType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_OMNI) {\n              const shadowCoordArgs = \"(light\" + i + \"_shadowMap, light\" + i + \"_shadowParams);\\n\";\n              if (light._normalOffsetBias) {\n                code += \"    normalOffsetPointShadow(light\" + i + \"_shadowParams);\\n\";\n              }\n              code += `    float shadow${i} = getShadowPoint${shadowReadMode}${shadowCoordArgs}`;\n              code += `    dAtten *= mix(1.0, shadow${i}, light${i}_shadowIntensity);\\n`;\n            } else {\n              const shadowMatArg = `light${i}_shadowMatrix`;\n              const shadowParamArg = `light${i}_shadowParams`;\n              code += this._nonPointShadowMapProjection(device, options.lights[i], shadowMatArg, shadowParamArg, i);\n              if (lightType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_SPOT) shadowReadMode = \"Spot\" + shadowReadMode;\n              code += `    float shadow${i} = getShadow${shadowReadMode}(SHADOWMAP_PASS(light${i}_shadowMap), light${i}_shadowParams${light._isVsm ? \", \" + evsmExp : \"\"});\\n`;\n              code += `    dAtten *= mix(1.0, shadow${i}, light${i}_shadowIntensity);\\n`;\n            }\n          }\n        }\n        if (lightShape !== _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTSHAPE_PUNCTUAL) {\n          if (options.conserveEnergy && options.useSpecular) {\n            code += \"    dDiffuseLight += ((dAttenD * dAtten) * light\" + i + \"_color\" + (usesCookieNow ? \" * dAtten3\" : \"\") + \") * (1.0 - dLTCSpecFres);\\n\";\n          } else {\n            code += \"    dDiffuseLight += (dAttenD * dAtten) * light\" + i + \"_color\" + (usesCookieNow ? \" * dAtten3\" : \"\") + \";\\n\";\n          }\n        } else {\n          if (hasAreaLights && options.conserveEnergy && options.useSpecular) {\n            code += \"    dDiffuseLight += (dAtten * light\" + i + \"_color\" + (usesCookieNow ? \" * dAtten3\" : \"\") + \") * (1.0 - dSpecularity);\\n\";\n          } else {\n            code += \"    dDiffuseLight += dAtten * light\" + i + \"_color\" + (usesCookieNow ? \" * dAtten3\" : \"\") + \";\\n\";\n          }\n        }\n        if (options.useSpecular) {\n          code += \"    dHalfDirW = normalize(-dLightDirNormW + dViewDirW);\\n\";\n        }\n        if (lightShape !== _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTSHAPE_PUNCTUAL) {\n          if (options.useClearCoat) code += \"    ccSpecularLight += ccLTCSpecFres * get\" + shapeString + \"LightSpecularCC() * dAtten * light\" + i + \"_color\" + (usesCookieNow ? \" * dAtten3\" : \"\") + \";\\n\";\n          if (options.useSpecular) code += \"    dSpecularLight += dLTCSpecFres * get\" + shapeString + \"LightSpecular() * dAtten * light\" + i + \"_color\" + (usesCookieNow ? \" * dAtten3\" : \"\") + \";\\n\";\n        } else {\n          var calcFresnel = false;\n          if (lightType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_DIRECTIONAL && options.fresnelModel > 0) {\n            calcFresnel = true;\n          }\n          if (options.useClearCoat) {\n            code += \"    ccSpecularLight += getLightSpecularCC(dHalfDirW) * dAtten * light\" + i + \"_color\";\n            code += usesCookieNow ? \" * dAtten3\" : \"\";\n            code += calcFresnel ? \" * getFresnelCC(dot(dViewDirW, dHalfDirW))\" : \"\";\n            code += \";\\n\";\n          }\n          if (options.useSheen) {\n            code += \"    sSpecularLight += getLightSpecularSheen(dHalfDirW) * dAtten * light\" + i + \"_color\";\n            code += usesCookieNow ? \" * dAtten3\" : \"\";\n            code += \";\\n\";\n          }\n          if (options.useSpecular) {\n            code += \"    dSpecularLight += getLightSpecular(dHalfDirW) * dAtten * light\" + i + \"_color\";\n            code += usesCookieNow ? \" * dAtten3\" : \"\";\n            code += calcFresnel ? \" * getFresnel(dot(dViewDirW, dHalfDirW), dSpecularity)\" : \"* dSpecularity\";\n            code += \";\\n\";\n          }\n        }\n        if (lightType !== _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIGHTTYPE_DIRECTIONAL) {\n          code += \"    }\\n\";\n        }\n        code += \"\\n\";\n      }\n      if (options.clusteredLightingEnabled && this.lighting) {\n        usesLinearFalloff = true;\n        usesInvSquaredFalloff = true;\n        hasPointLights = true;\n        code += \"    addClusteredLights();\\n\";\n      }\n      if (hasAreaLights) {\n        if (options.useClearCoat) {\n          code += \"    ccSpecularity = 1.0;\\n\";\n        }\n        if (options.useSpecular) {\n          code += \"    dSpecularity = vec3(1);\\n\";\n        }\n      }\n      if (options.useRefraction) {\n        code += \"    addRefraction();\\n\";\n      }\n    }\n    code += \"\\n\";\n    if (useAo) {\n      if (options.occludeDirect) {\n        code += \"    occludeDiffuse();\\n\";\n      }\n      if (options.occludeSpecular === _constants_js__WEBPACK_IMPORTED_MODULE_3__.SPECOCC_AO || options.occludeSpecular === _constants_js__WEBPACK_IMPORTED_MODULE_3__.SPECOCC_GLOSSDEPENDENT) {\n        code += \"    occludeSpecular();\\n\";\n      }\n    }\n    if (options.useSpecularityFactor) {\n      code += \"    dSpecularLight *= dSpecularityFactor;\\n\";\n    }\n    if (options.opacityFadesSpecular === false) {\n      if (options.blendType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.BLEND_NORMAL || options.blendType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.BLEND_PREMULTIPLIED) {\n        code += \"float specLum = dot((dSpecularLight + dReflection.rgb * dReflection.a), vec3( 0.2126, 0.7152, 0.0722 ));\\n\";\n        code += \"#ifdef LIT_CLEARCOAT\\n specLum += dot(ccSpecularLight * ccSpecularity + ccReflection.rgb * ccSpecularity, vec3( 0.2126, 0.7152, 0.0722 ));\\n#endif\\n\";\n        code += \"dAlpha = clamp(dAlpha + gammaCorrectInput(specLum), 0.0, 1.0);\\n\";\n      }\n      code += \"dAlpha *= material_alphaFade;\\n\";\n    }\n    code += chunks.endPS;\n    if (options.blendType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.BLEND_NORMAL || options.blendType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.BLEND_ADDITIVEALPHA || options.alphaToCoverage) {\n      code += chunks.outputAlphaPS;\n    } else if (options.blendType === _constants_js__WEBPACK_IMPORTED_MODULE_3__.BLEND_PREMULTIPLIED) {\n      code += chunks.outputAlphaPremulPS;\n    } else {\n      code += chunks.outputAlphaOpaquePS;\n    }\n    if (options.useMsdf) {\n      code += \"    gl_FragColor = applyMsdf(gl_FragColor);\\n\";\n    }\n    code += \"\\n\";\n    code += (0,_common_js__WEBPACK_IMPORTED_MODULE_4__.end)();\n    if (hasPointLights) {\n      code = chunks.lightDirPointPS + code;\n    }\n    if (usesLinearFalloff) {\n      code = chunks.falloffLinearPS + code;\n    }\n    if (usesInvSquaredFalloff) {\n      code = chunks.falloffInvSquaredPS + code;\n    }\n    if (usesSpot) {\n      code = chunks.spotPS + code;\n    }\n    if (usesCookie && !options.clusteredLightingEnabled) {\n      code = chunks.cookiePS + code;\n    }\n    let structCode = \"\";\n    if (code.includes(\"dReflection\")) structCode += \"vec4 dReflection;\\n\";\n    if (code.includes(\"dTBN\")) structCode += \"mat3 dTBN;\\n\";\n    if (code.includes(\"dVertexNormalW\")) structCode += \"vec3 dVertexNormalW;\\n\";\n    if (code.includes(\"dTangentW\")) structCode += \"vec3 dTangentW;\\n\";\n    if (code.includes(\"dBinormalW\")) structCode += \"vec3 dBinormalW;\\n\";\n    if (code.includes(\"dViewDirW\")) structCode += \"vec3 dViewDirW;\\n\";\n    if (code.includes(\"dReflDirW\")) structCode += \"vec3 dReflDirW;\\n\";\n    if (code.includes(\"dHalfDirW\")) structCode += \"vec3 dHalfDirW;\\n\";\n    if (code.includes(\"dDiffuseLight\")) structCode += \"vec3 dDiffuseLight;\\n\";\n    if (code.includes(\"dSpecularLight\")) structCode += \"vec3 dSpecularLight;\\n\";\n    if (code.includes(\"dLightDirNormW\")) structCode += \"vec3 dLightDirNormW;\\n\";\n    if (code.includes(\"dLightDirW\")) structCode += \"vec3 dLightDirW;\\n\";\n    if (code.includes(\"dLightPosW\")) structCode += \"vec3 dLightPosW;\\n\";\n    if (code.includes(\"dShadowCoord\")) structCode += \"vec3 dShadowCoord;\\n\";\n    if (code.includes(\"dAtten\")) structCode += \"float dAtten;\\n\";\n    if (code.includes(\"dAttenD\")) structCode += \"float dAttenD;\\n\";\n    if (code.includes(\"dAtten3\")) structCode += \"vec3 dAtten3;\\n\";\n    if (code.includes(\"dMsdf\")) structCode += \"vec4 dMsdf;\\n\";\n    if (code.includes(\"ccFresnel\")) structCode += \"float ccFresnel;\\n\";\n    if (code.includes(\"ccReflection\")) structCode += \"vec3 ccReflection;\\n\";\n    if (code.includes(\"ccReflDirW\")) structCode += \"vec3 ccReflDirW;\\n\";\n    if (code.includes(\"ccSpecularLight\")) structCode += \"vec3 ccSpecularLight;\\n\";\n    if (code.includes(\"ccSpecularityNoFres\")) structCode += \"float ccSpecularityNoFres;\\n\";\n    if (code.includes(\"sSpecularLight\")) structCode += \"vec3 sSpecularLight;\\n\";\n    if (code.includes(\"sReflection\")) structCode += \"vec3 sReflection;\\n\";\n    const result = this._fsGetBeginCode() + this.varyings + this._fsGetBaseCode() + (options.detailModes ? chunks.detailModesPS : \"\") + structCode + this.frontendDecl + code;\n    return result;\n  }\n  generateFragmentShader(frontendDecl, frontendCode, frontendFunc, lightingUv) {\n    const options = this.options;\n    this.frontendDecl = frontendDecl;\n    this.frontendCode = frontendCode;\n    this.frontendFunc = frontendFunc;\n    this.lightingUv = lightingUv;\n    if (options.pass === _constants_js__WEBPACK_IMPORTED_MODULE_3__.SHADER_PICK) {\n      this.fshader = this._fsGetPickPassCode();\n    } else if (options.pass === _constants_js__WEBPACK_IMPORTED_MODULE_3__.SHADER_DEPTH) {\n      this.fshader = this._fsGetDepthPassCode();\n    } else if (this.shadowPass) {\n      this.fshader = this._fsGetShadowPassCode();\n    } else if (options.customFragmentShader) {\n      this.fshader = this._fsGetBeginCode() + options.customFragmentShader;\n    } else {\n      this.fshader = this._fsGetLitPassCode();\n    }\n  }\n  getDefinition() {\n    const definition = _platform_graphics_shader_utils_js__WEBPACK_IMPORTED_MODULE_7__.ShaderUtils.createDefinition(this.device, {\n      name: 'LitShader',\n      attributes: this.attributes,\n      vertexCode: this.vshader,\n      fragmentCode: this.fshader\n    });\n    if (_shader_pass_js__WEBPACK_IMPORTED_MODULE_2__.ShaderPass.isForward(this.options.pass)) {\n      definition.tag = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADERTAG_MATERIAL;\n    }\n    return definition;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/programs/lit-shader.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/programs/particle.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/programs/particle.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"particle\": () => (/* binding */ particle)\n/* harmony export */ });\n/* harmony import */ var _platform_graphics_shader_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../platform/graphics/shader-utils.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-utils.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../chunks/chunks.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/chunks.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/programs/common.js\");\n\n\n\n\n\nconst particle = {\n  generateKey: function (options) {\n    let key = \"particle\";\n    for (const prop in options) {\n      if (options.hasOwnProperty(prop)) {\n        key += options[prop];\n      }\n    }\n    return key;\n  },\n  _animTex: function (options) {\n    let vshader = \"\";\n    vshader += options.animTexLoop ? _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particleAnimFrameLoopVS : _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particleAnimFrameClampVS;\n    vshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particleAnimTexVS;\n    return vshader;\n  },\n  createShaderDefinition: function (device, options) {\n    let fshader = '#define PARTICLE\\n';\n    let vshader = \"#define VERTEXSHADER\\n\";\n    if (options.mesh) vshader += \"#define USE_MESH\\n\";\n    if (options.localSpace) vshader += \"#define LOCAL_SPACE\\n\";\n    if (options.screenSpace) vshader += \"#define SCREEN_SPACE\\n\";\n    if (options.animTex) vshader += \"\\nuniform vec2 animTexTilesParams;\\n\";\n    if (options.animTex) vshader += \"\\nuniform vec4 animTexParams;\\n\";\n    if (options.animTex) vshader += \"\\nuniform vec2 animTexIndexParams;\\n\";\n    if (options.normal === 2) vshader += \"\\nvarying mat3 ParticleMat;\\n\";\n    if (options.normal === 1) vshader += \"\\nvarying vec3 Normal;\\n\";\n    if (options.soft) vshader += \"\\nvarying float vDepth;\\n\";\n    const faceVS = options.customFace ? _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_customFaceVS : _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_billboardVS;\n    if (!options.useCpu) {\n      vshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_initVS;\n      vshader += options.pack8 ? _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particleInputRgba8PS : _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particleInputFloatPS;\n      if (options.soft > 0) vshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.screenDepthPS;\n      vshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particleVS;\n      if (options.localSpace) vshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_localShiftVS;\n      if (options.animTex) vshader += this._animTex(options);\n      if (options.wrap) vshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_wrapVS;\n      if (options.alignToMotion) vshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_pointAlongVS;\n      vshader += options.mesh ? _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_meshVS : faceVS;\n      if (options.normal === 1) vshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_normalVS;\n      if (options.normal === 2) vshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_TBNVS;\n      if (options.stretch > 0.0) vshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_stretchVS;\n      vshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_endVS;\n      if (options.soft > 0) vshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_softVS;\n    } else {\n      if (options.soft > 0) vshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.screenDepthPS;\n      vshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_cpuVS;\n      if (options.localSpace) vshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_localShiftVS;\n      if (options.animTex) vshader += this._animTex(options);\n      if (options.alignToMotion) vshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_pointAlongVS;\n      vshader += options.mesh ? _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_meshVS : faceVS;\n      if (options.normal === 1) vshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_normalVS;\n      if (options.normal === 2) vshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_TBNVS;\n      if (options.stretch > 0.0) vshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_stretchVS;\n      vshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_cpu_endVS;\n      if (options.soft > 0) vshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_softVS;\n    }\n    vshader += \"}\\n\";\n    if (options.normal > 0) {\n      if (options.normal === 1) {\n        fshader += \"\\nvarying vec3 Normal;\\n\";\n      } else if (options.normal === 2) {\n        fshader += \"\\nvarying mat3 ParticleMat;\\n\";\n      }\n      fshader += \"\\nuniform vec3 lightCube[6];\\n\";\n    }\n    if (options.soft) fshader += \"\\nvarying float vDepth;\\n\";\n    if (options.normal === 0 && options.fog === \"none\") options.srgb = false;\n    fshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.decodePS;\n    fshader += (0,_common_js__WEBPACK_IMPORTED_MODULE_1__.gammaCode)(options.gamma);\n    fshader += (0,_common_js__WEBPACK_IMPORTED_MODULE_1__.tonemapCode)(options.toneMap);\n    if (options.fog === 'linear') {\n      fshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.fogLinearPS;\n    } else if (options.fog === 'exp') {\n      fshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.fogExpPS;\n    } else if (options.fog === 'exp2') {\n      fshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.fogExp2PS;\n    } else {\n      fshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.fogNonePS;\n    }\n    if (options.normal === 2) fshader += \"\\nuniform sampler2D normalMap;\\n\";\n    if (options.soft > 0) fshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.screenDepthPS;\n    fshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particlePS;\n    if (options.soft > 0) fshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_softPS;\n    if (options.normal === 1) fshader += \"\\nvec3 normal = Normal;\\n\";\n    if (options.normal === 2) fshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_normalMapPS;\n    if (options.normal > 0) fshader += options.halflambert ? _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_halflambertPS : _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_lambertPS;\n    if (options.normal > 0) fshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_lightingPS;\n    if (options.blend === _constants_js__WEBPACK_IMPORTED_MODULE_2__.BLEND_NORMAL) {\n      fshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_blendNormalPS;\n    } else if (options.blend === _constants_js__WEBPACK_IMPORTED_MODULE_2__.BLEND_ADDITIVE) {\n      fshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_blendAddPS;\n    } else if (options.blend === _constants_js__WEBPACK_IMPORTED_MODULE_2__.BLEND_MULTIPLICATIVE) {\n      fshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_blendMultiplyPS;\n    }\n    fshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.particle_endPS;\n    return _platform_graphics_shader_utils_js__WEBPACK_IMPORTED_MODULE_3__.ShaderUtils.createDefinition(device, {\n      vertexCode: vshader,\n      fragmentCode: fshader\n    });\n  }\n};\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/programs/particle.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/programs/skybox.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/programs/skybox.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"skybox\": () => (/* binding */ skybox)\n/* harmony export */ });\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../chunks/chunks.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/chunks.js\");\n/* harmony import */ var _chunk_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../chunk-utils.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunk-utils.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/programs/common.js\");\n/* harmony import */ var _platform_graphics_shader_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../platform/graphics/shader-utils.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-utils.js\");\n\n\n\n\n\n\nconst skybox = {\n  generateKey: function (options) {\n    return options.type === 'cubemap' ? `skybox-${options.type}-${options.encoding}-${options.useIntensity}-${options.gamma}-${options.toneMapping}-${options.fixSeams}-${options.mip}` : `skybox-${options.type}-${options.encoding}-${options.useIntensity}-${options.gamma}-${options.toneMapping}`;\n  },\n  createShaderDefinition: function (device, options) {\n    let fshader = '';\n    if (options.type === 'cubemap') {\n      const mip2size = [128, 64, 16, 8, 4, 2];\n      fshader += options.mip ? _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.fixCubemapSeamsStretchPS : _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.fixCubemapSeamsNonePS;\n      fshader += options.useIntensity ? _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.envMultiplyPS : _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.envConstPS;\n      fshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.decodePS;\n      fshader += (0,_common_js__WEBPACK_IMPORTED_MODULE_1__.gammaCode)(options.gamma);\n      fshader += (0,_common_js__WEBPACK_IMPORTED_MODULE_1__.tonemapCode)(options.toneMapping);\n      fshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.skyboxHDRPS.replace(/\\$DECODE/g, _chunk_utils_js__WEBPACK_IMPORTED_MODULE_2__.ChunkUtils.decodeFunc(options.encoding)).replace(/\\$FIXCONST/g, 1 - 1 / mip2size[options.mip] + \"\");\n    } else {\n      fshader += options.useIntensity ? _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.envMultiplyPS : _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.envConstPS;\n      fshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.decodePS;\n      fshader += (0,_common_js__WEBPACK_IMPORTED_MODULE_1__.gammaCode)(options.gamma);\n      fshader += (0,_common_js__WEBPACK_IMPORTED_MODULE_1__.tonemapCode)(options.toneMapping);\n      fshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.sphericalPS;\n      fshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.envAtlasPS;\n      fshader += _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.skyboxEnvPS.replace(/\\$DECODE/g, _chunk_utils_js__WEBPACK_IMPORTED_MODULE_2__.ChunkUtils.decodeFunc(options.encoding));\n    }\n    return _platform_graphics_shader_utils_js__WEBPACK_IMPORTED_MODULE_3__.ShaderUtils.createDefinition(device, {\n      attributes: {\n        aPosition: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_4__.SEMANTIC_POSITION\n      },\n      vertexCode: _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_0__.shaderChunks.skyboxVS,\n      fragmentCode: fshader\n    });\n  }\n};\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/programs/skybox.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/programs/standard.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/programs/standard.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"_matTex2D\": () => (/* binding */ _matTex2D),\n/* harmony export */   \"standard\": () => (/* binding */ standard)\n/* harmony export */ });\n/* harmony import */ var _core_hash_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/hash.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/hash.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _shader_pass_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shader-pass.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-pass.js\");\n/* harmony import */ var _lit_shader_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lit-shader.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/programs/lit-shader.js\");\n/* harmony import */ var _chunk_builder_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../chunk-builder.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunk-builder.js\");\n/* harmony import */ var _chunk_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../chunk-utils.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunk-utils.js\");\n/* harmony import */ var _materials_standard_material_options_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../materials/standard-material-options.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/standard-material-options.js\");\n\n\n\n\n\n\n\n\n\nconst _matTex2D = [];\nconst standard = {\n  optionsContext: new _materials_standard_material_options_js__WEBPACK_IMPORTED_MODULE_0__.StandardMaterialOptions(),\n  optionsContextMin: new _materials_standard_material_options_js__WEBPACK_IMPORTED_MODULE_0__.StandardMaterialOptions(),\n  generateKey: function (options) {\n    const buildPropertiesList = function buildPropertiesList(options) {\n      const props = [];\n      for (const prop in options) {\n        if (options.hasOwnProperty(prop) && prop !== \"chunks\" && prop !== \"lights\") props.push(prop);\n      }\n      return props.sort();\n    };\n    let props;\n    if (options === this.optionsContextMin) {\n      if (!this.propsMin) this.propsMin = buildPropertiesList(options);\n      props = this.propsMin;\n    } else if (options === this.optionsContext) {\n      if (!this.props) this.props = buildPropertiesList(options);\n      props = this.props;\n    } else {\n      props = buildPropertiesList(options);\n    }\n    let key = \"standard\";\n    for (let i = 0; i < props.length; i++) {\n      if (options[props[i]]) key += props[i] + options[props[i]];\n    }\n    if (options.chunks) {\n      const chunks = [];\n      for (const p in options.chunks) {\n        if (options.chunks.hasOwnProperty(p)) {\n          chunks.push(p + options.chunks[p]);\n        }\n      }\n      chunks.sort();\n      key += chunks;\n    }\n    if (options.litOptions) {\n      for (const m in options.litOptions) {\n        if (m === 'lights') {\n          const isClustered = options.litOptions.clusteredLightingEnabled;\n          for (let i = 0; i < options.litOptions.lights.length; i++) {\n            const light = options.litOptions.lights[i];\n            if (!isClustered || light._type === _constants_js__WEBPACK_IMPORTED_MODULE_1__.LIGHTTYPE_DIRECTIONAL) {\n              key += light.key;\n            }\n          }\n        } else {\n          key += m + options.litOptions[m];\n        }\n      }\n    }\n    return (0,_core_hash_js__WEBPACK_IMPORTED_MODULE_2__.hashCode)(key);\n  },\n  _getUvSourceExpression: function (transformPropName, uVPropName, options) {\n    const transformId = options[transformPropName];\n    const uvChannel = options[uVPropName];\n    const isMainPass = _shader_pass_js__WEBPACK_IMPORTED_MODULE_3__.ShaderPass.isForward(options.pass);\n    let expression;\n    if (isMainPass && options.litOptions.nineSlicedMode === _constants_js__WEBPACK_IMPORTED_MODULE_1__.SPRITE_RENDERMODE_SLICED) {\n      expression = \"nineSlicedUv\";\n    } else if (isMainPass && options.litOptions.nineSlicedMode === _constants_js__WEBPACK_IMPORTED_MODULE_1__.SPRITE_RENDERMODE_TILED) {\n      expression = \"nineSlicedUv\";\n    } else {\n      if (transformId === 0) {\n        expression = \"vUv\" + uvChannel;\n      } else {\n        expression = \"vUV\" + uvChannel + \"_\" + transformId;\n      }\n      if (options.heightMap && transformPropName !== \"heightMapTransform\") {\n        expression += \" + dUvOffset\";\n      }\n    }\n    return expression;\n  },\n  _addMapDef: function (name, enabled) {\n    return enabled ? `#define ${name}\\n` : `#undef ${name}\\n`;\n  },\n  _addMapDefs: function (float, color, vertex, map, invert) {\n    return this._addMapDef(\"MAPFLOAT\", float) + this._addMapDef(\"MAPCOLOR\", color) + this._addMapDef(\"MAPVERTEX\", vertex) + this._addMapDef(\"MAPTEXTURE\", map) + this._addMapDef(\"MAPINVERT\", invert);\n  },\n  _addMap: function (propName, chunkName, options, chunks, mapping, encoding = null) {\n    const mapPropName = propName + \"Map\";\n    const uVPropName = mapPropName + \"Uv\";\n    const identifierPropName = mapPropName + \"Identifier\";\n    const transformPropName = mapPropName + \"Transform\";\n    const channelPropName = mapPropName + \"Channel\";\n    const vertexColorChannelPropName = propName + \"VertexColorChannel\";\n    const tintPropName = propName + \"Tint\";\n    const vertexColorPropName = propName + \"VertexColor\";\n    const detailModePropName = propName + \"Mode\";\n    const invertName = propName + \"Invert\";\n    const tintOption = options[tintPropName];\n    const vertexColorOption = options[vertexColorPropName];\n    const textureOption = options[mapPropName];\n    const textureIdentifier = options[identifierPropName];\n    const detailModeOption = options[detailModePropName];\n    let subCode = chunks[chunkName];\n    if (textureOption) {\n      const uv = this._getUvSourceExpression(transformPropName, uVPropName, options);\n      subCode = subCode.replace(/\\$UV/g, uv).replace(/\\$CH/g, options[channelPropName]);\n      if (mapping && subCode.search(/\\$SAMPLER/g) !== -1) {\n        let samplerName = \"texture_\" + mapPropName;\n        const alias = mapping[textureIdentifier];\n        if (alias) {\n          samplerName = alias;\n        } else {\n          mapping[textureIdentifier] = samplerName;\n        }\n        subCode = subCode.replace(/\\$SAMPLER/g, samplerName);\n      }\n      if (encoding) {\n        if (options[channelPropName] === 'aaa') {\n          subCode = subCode.replace(/\\$DECODE/g, 'passThrough');\n        } else {\n          subCode = subCode.replace(/\\$DECODE/g, _chunk_utils_js__WEBPACK_IMPORTED_MODULE_4__.ChunkUtils.decodeFunc(!options.litOptions.gamma && encoding === 'srgb' ? 'linear' : encoding));\n        }\n        if (subCode.indexOf('$texture2DSAMPLE')) {\n          const decodeTable = {\n            linear: 'texture2D',\n            srgb: 'texture2DSRGB',\n            rgbm: 'texture2DRGBM',\n            rgbe: 'texture2DRGBE'\n          };\n          subCode = subCode.replace(/\\$texture2DSAMPLE/g, decodeTable[encoding] || 'texture2D');\n        }\n      }\n    }\n    if (vertexColorOption) {\n      subCode = subCode.replace(/\\$VC/g, options[vertexColorChannelPropName]);\n    }\n    if (detailModeOption) {\n      subCode = subCode.replace(/\\$DETAILMODE/g, detailModeOption);\n    }\n    const isFloatTint = !!(tintOption & 1);\n    const isVecTint = !!(tintOption & 2);\n    const invertOption = !!options[invertName];\n    subCode = this._addMapDefs(isFloatTint, isVecTint, vertexColorOption, textureOption, invertOption) + subCode;\n    return subCode.replace(/\\$/g, \"\");\n  },\n  _correctChannel: function (p, chan, _matTex2D) {\n    if (_matTex2D[p] > 0) {\n      if (_matTex2D[p] < chan.length) {\n        return chan.substring(0, _matTex2D[p]);\n      } else if (_matTex2D[p] > chan.length) {\n        let str = chan;\n        const chr = str.charAt(str.length - 1);\n        const addLen = _matTex2D[p] - str.length;\n        for (let i = 0; i < addLen; i++) str += chr;\n        return str;\n      }\n      return chan;\n    }\n  },\n  createShaderDefinition: function (device, options) {\n    const litShader = new _lit_shader_js__WEBPACK_IMPORTED_MODULE_5__.LitShader(device, options.litOptions);\n    const useUv = [];\n    const useUnmodifiedUv = [];\n    const mapTransforms = [];\n    const maxUvSets = 2;\n    const textureMapping = {};\n    for (const p in _matTex2D) {\n      const mname = p + \"Map\";\n      if (options[p + \"VertexColor\"]) {\n        const cname = p + \"VertexColorChannel\";\n        options[cname] = this._correctChannel(p, options[cname], _matTex2D);\n      }\n      if (options[mname]) {\n        const cname = mname + \"Channel\";\n        const tname = mname + \"Transform\";\n        const uname = mname + \"Uv\";\n        options[uname] = Math.min(options[uname], maxUvSets - 1);\n        options[cname] = this._correctChannel(p, options[cname], _matTex2D);\n        const uvSet = options[uname];\n        useUv[uvSet] = true;\n        useUnmodifiedUv[uvSet] = useUnmodifiedUv[uvSet] || options[mname] && !options[tname];\n        if (options[tname]) {\n          mapTransforms.push({\n            name: p,\n            id: options[tname],\n            uv: options[uname]\n          });\n        }\n      }\n    }\n    if (options.forceUv1) {\n      useUv[1] = true;\n      useUnmodifiedUv[1] = useUnmodifiedUv[1] !== undefined ? useUnmodifiedUv[1] : true;\n    }\n    litShader.generateVertexShader(useUv, useUnmodifiedUv, mapTransforms);\n    if (options.litOptions.shadingModel === _constants_js__WEBPACK_IMPORTED_MODULE_1__.SPECULAR_PHONG) {\n      options.litOptions.fresnelModel = 0;\n      options.litOptions.ambientSH = false;\n    } else {\n      options.litOptions.fresnelModel = options.litOptions.fresnelModel === 0 ? _constants_js__WEBPACK_IMPORTED_MODULE_1__.FRESNEL_SCHLICK : options.litOptions.fresnelModel;\n    }\n    const decl = new _chunk_builder_js__WEBPACK_IMPORTED_MODULE_6__.ChunkBuilder();\n    const code = new _chunk_builder_js__WEBPACK_IMPORTED_MODULE_6__.ChunkBuilder();\n    const func = new _chunk_builder_js__WEBPACK_IMPORTED_MODULE_6__.ChunkBuilder();\n    let lightingUv = \"\";\n    if (options.litOptions.nineSlicedMode === _constants_js__WEBPACK_IMPORTED_MODULE_1__.SPRITE_RENDERMODE_TILED) {\n      decl.append(`const float textureBias = -1000.0;`);\n    } else {\n      decl.append(`uniform float textureBias;`);\n    }\n    if (_shader_pass_js__WEBPACK_IMPORTED_MODULE_3__.ShaderPass.isForward(options.pass)) {\n      if (options.heightMap) {\n        decl.append(\"vec2 dUvOffset;\");\n        code.append(this._addMap(\"height\", \"parallaxPS\", options, litShader.chunks, textureMapping));\n        func.append(\"getParallax();\");\n      }\n      if (options.litOptions.blendType !== _constants_js__WEBPACK_IMPORTED_MODULE_1__.BLEND_NONE || options.litOptions.alphaTest || options.litOptions.alphaToCoverage) {\n        decl.append(\"float dAlpha;\");\n        code.append(this._addMap(\"opacity\", \"opacityPS\", options, litShader.chunks, textureMapping));\n        func.append(\"getOpacity();\");\n        if (options.litOptions.alphaTest) {\n          code.append(litShader.chunks.alphaTestPS);\n          func.append(\"alphaTest(dAlpha);\");\n        }\n      } else {\n        decl.append(\"float dAlpha = 1.0;\");\n      }\n      if (litShader.needsNormal) {\n        if (options.normalMap || options.clearCoatNormalMap) {\n          code.append(options.packedNormal ? litShader.chunks.normalXYPS : litShader.chunks.normalXYZPS);\n          if (!options.litOptions.hasTangents) {\n            const baseName = options.normalMap ? \"normalMap\" : \"clearCoatNormalMap\";\n            lightingUv = this._getUvSourceExpression(`${baseName}Transform`, `${baseName}Uv`, options);\n          }\n        }\n        decl.append(\"vec3 dNormalW;\");\n        code.append(this._addMap(\"normalDetail\", \"normalDetailMapPS\", options, litShader.chunks, textureMapping));\n        code.append(this._addMap(\"normal\", \"normalMapPS\", options, litShader.chunks, textureMapping));\n        func.append(\"getNormal();\");\n      }\n      if (litShader.needsSceneColor) {\n        decl.append(\"uniform sampler2D uSceneColorMap;\");\n      }\n      if (litShader.needsScreenSize) {\n        decl.append(\"uniform vec4 uScreenSize;\");\n      }\n      if (litShader.needsTransforms) {\n        decl.append(\"uniform mat4 matrix_viewProjection;\");\n        decl.append(\"uniform mat4 matrix_model;\");\n      }\n      decl.append(\"vec3 dAlbedo;\");\n      if (options.diffuseDetail) {\n        code.append(this._addMap(\"diffuseDetail\", \"diffuseDetailMapPS\", options, litShader.chunks, textureMapping, options.diffuseDetailEncoding));\n      }\n      code.append(this._addMap(\"diffuse\", \"diffusePS\", options, litShader.chunks, textureMapping, options.diffuseEncoding));\n      func.append(\"getAlbedo();\");\n      if (options.litOptions.useRefraction) {\n        decl.append(\"float dTransmission;\");\n        code.append(this._addMap(\"refraction\", \"transmissionPS\", options, litShader.chunks, textureMapping));\n        func.append(\"getRefraction();\");\n        decl.append(\"float dThickness;\");\n        code.append(this._addMap(\"thickness\", \"thicknessPS\", options, litShader.chunks, textureMapping));\n        func.append(\"getThickness();\");\n      }\n      if (options.litOptions.useIridescence) {\n        decl.append(\"vec3 dIridescenceFresnel;\");\n        decl.append(\"float dIridescence;\");\n        code.append(this._addMap(\"iridescence\", \"iridescencePS\", options, litShader.chunks, textureMapping));\n        func.append(\"getIridescence();\");\n        decl.append(\"float dIridescenceThickness;\");\n        code.append(this._addMap(\"iridescenceThickness\", \"iridescenceThicknessPS\", options, litShader.chunks, textureMapping));\n        func.append(\"getIridescenceThickness();\");\n      }\n      if (litShader.lighting && options.litOptions.useSpecular || litShader.reflections) {\n        decl.append(\"vec3 dSpecularity;\");\n        decl.append(\"float dGlossiness;\");\n        if (options.litOptions.useSheen) {\n          decl.append(\"vec3 sSpecularity;\");\n          code.append(this._addMap(\"sheen\", \"sheenPS\", options, litShader.chunks, textureMapping, options.sheenEncoding));\n          func.append(\"getSheen();\");\n          decl.append(\"float sGlossiness;\");\n          code.append(this._addMap(\"sheenGloss\", \"sheenGlossPS\", options, litShader.chunks, textureMapping));\n          func.append(\"getSheenGlossiness();\");\n        }\n        if (options.litOptions.useMetalness) {\n          decl.append(\"float dMetalness;\");\n          code.append(this._addMap(\"metalness\", \"metalnessPS\", options, litShader.chunks, textureMapping));\n          func.append(\"getMetalness();\");\n        }\n        if (options.litOptions.useSpecularityFactor) {\n          decl.append(\"float dSpecularityFactor;\");\n          code.append(this._addMap(\"specularityFactor\", \"specularityFactorPS\", options, litShader.chunks, textureMapping));\n          func.append(\"getSpecularityFactor();\");\n        }\n        if (options.litOptions.useSpecularColor) {\n          code.append(this._addMap(\"specular\", \"specularPS\", options, litShader.chunks, textureMapping, options.specularEncoding));\n        } else {\n          code.append(\"void getSpecularity() { dSpecularity = vec3(1); }\");\n        }\n        code.append(this._addMap(\"gloss\", \"glossPS\", options, litShader.chunks, textureMapping));\n        func.append(\"getGlossiness();\");\n        func.append(\"getSpecularity();\");\n      } else {\n        decl.append(\"vec3 dSpecularity = vec3(0.0);\");\n        decl.append(\"float dGlossiness = 0.0;\");\n      }\n      if (options.aoMap || options.aoVertexColor) {\n        decl.append(\"float dAo;\");\n        code.append(this._addMap(\"ao\", \"aoPS\", options, litShader.chunks, textureMapping));\n        func.append(\"getAO();\");\n      }\n      decl.append(\"vec3 dEmission;\");\n      code.append(this._addMap(\"emissive\", \"emissivePS\", options, litShader.chunks, textureMapping, options.emissiveEncoding));\n      func.append(\"getEmission();\");\n      if (options.litOptions.useClearCoat) {\n        decl.append(\"float ccSpecularity;\");\n        decl.append(\"float ccGlossiness;\");\n        decl.append(\"vec3 ccNormalW;\");\n        code.append(this._addMap(\"clearCoat\", \"clearCoatPS\", options, litShader.chunks, textureMapping));\n        code.append(this._addMap(\"clearCoatGloss\", \"clearCoatGlossPS\", options, litShader.chunks, textureMapping));\n        code.append(this._addMap(\"clearCoatNormal\", \"clearCoatNormalPS\", options, litShader.chunks, textureMapping));\n        func.append(\"getClearCoat();\");\n        func.append(\"getClearCoatGlossiness();\");\n        func.append(\"getClearCoatNormal();\");\n      }\n      if (options.litOptions.lightMapEnabled || options.lightMapVertexColors) {\n        const lightmapDir = options.litOptions.dirLightMapEnabled && options.litOptions.useSpecular;\n        const lightmapChunkPropName = lightmapDir ? 'lightmapDirPS' : 'lightmapSinglePS';\n        decl.append(\"vec3 dLightmap;\");\n        if (lightmapDir) {\n          decl.append(\"vec3 dLightmapDir;\");\n        }\n        code.append(this._addMap(\"light\", lightmapChunkPropName, options, litShader.chunks, textureMapping, options.lightMapEncoding));\n        func.append(\"getLightMap();\");\n      }\n      if (code.code.indexOf('texture2DSRGB') !== -1 || code.code.indexOf('texture2DRGBM') !== -1 || code.code.indexOf('texture2DRGBE') !== -1) {\n        code.prepend(litShader.chunks.textureSamplePS);\n      }\n    } else {\n      if (options.litOptions.alphaTest) {\n        decl.append(\"float dAlpha;\");\n        code.append(this._addMap(\"opacity\", \"opacityPS\", options, litShader.chunks, textureMapping));\n        code.append(litShader.chunks.alphaTestPS);\n        func.append(\"getOpacity();\");\n        func.append(\"alphaTest(dAlpha);\");\n      }\n    }\n    for (const texture in textureMapping) {\n      decl.append(`uniform sampler2D ${textureMapping[texture]};`);\n    }\n    func.code = `\\n${func.code.split('\\n').map(l => `    ${l}`).join('\\n')}\\n\\n`;\n    litShader.generateFragmentShader(decl.code, code.code, func.code, lightingUv);\n    return litShader.getDefinition();\n  }\n};\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/programs/standard.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/utils.js":
/*!********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/utils.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createShader\": () => (/* binding */ createShader),\n/* harmony export */   \"createShaderFromCode\": () => (/* binding */ createShaderFromCode)\n/* harmony export */ });\n/* harmony import */ var _platform_graphics_shader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/graphics/shader.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader.js\");\n/* harmony import */ var _platform_graphics_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../platform/graphics/shader-utils.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-utils.js\");\n/* harmony import */ var _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunks/chunks.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/chunks/chunks.js\");\n/* harmony import */ var _get_program_library_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get-program-library.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/get-program-library.js\");\n\n\n\n\n\nfunction createShader(device, vsName, fsName, useTransformFeedback = false) {\n  return new _platform_graphics_shader_js__WEBPACK_IMPORTED_MODULE_0__.Shader(device, _platform_graphics_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.ShaderUtils.createDefinition(device, {\n    name: `${vsName}_${fsName}`,\n    vertexCode: _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_2__.shaderChunks[vsName],\n    fragmentCode: _chunks_chunks_js__WEBPACK_IMPORTED_MODULE_2__.shaderChunks[fsName],\n    useTransformFeedback: useTransformFeedback\n  }));\n}\nfunction createShaderFromCode(device, vsCode, fsCode, uniqueName, useTransformFeedback = false, fragmentPreamble = '') {\n  const programLibrary = (0,_get_program_library_js__WEBPACK_IMPORTED_MODULE_3__.getProgramLibrary)(device);\n  let shader = programLibrary.getCachedShader(uniqueName);\n  if (!shader) {\n    shader = new _platform_graphics_shader_js__WEBPACK_IMPORTED_MODULE_0__.Shader(device, _platform_graphics_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.ShaderUtils.createDefinition(device, {\n      name: uniqueName,\n      vertexCode: vsCode,\n      fragmentCode: fsCode,\n      fragmentPreamble: fragmentPreamble,\n      useTransformFeedback: useTransformFeedback\n    }));\n    programLibrary.setCachedShader(uniqueName, shader);\n  }\n  return shader;\n}\n_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_2__.shaderChunks.createShader = createShader;\n_chunks_chunks_js__WEBPACK_IMPORTED_MODULE_2__.shaderChunks.createShaderFromCode = createShaderFromCode;\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/utils.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-pass.js":
/*!***************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-pass.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ShaderPass\": () => (/* binding */ ShaderPass)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n\n\n\nclass ShaderPass {\n  static getType(shaderPass) {\n    switch (shaderPass) {\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADER_FORWARD:\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADER_FORWARDHDR:\n        return _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADERTYPE_FORWARD;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADER_DEPTH:\n        return _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADERTYPE_DEPTH;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADER_PICK:\n        return _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADERTYPE_PICK;\n      default:\n        return shaderPass >= _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADER_SHADOW && shaderPass < _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADER_SHADOW + _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADOW_COUNT * _constants_js__WEBPACK_IMPORTED_MODULE_0__.LIGHTTYPE_COUNT ? _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADERTYPE_SHADOW : _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADERTYPE_FORWARD;\n    }\n  }\n  static isForward(pass) {\n    return this.getType(pass) === _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADERTYPE_FORWARD;\n  }\n  static isShadow(pass) {\n    return this.getType(pass) === _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADERTYPE_SHADOW;\n  }\n  static toLightType(pass) {\n    const shadowMode = pass - _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADER_SHADOW;\n    return Math.floor(shadowMode / _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADOW_COUNT);\n  }\n  static toShadowType(pass) {\n    const shadowMode = pass - _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADER_SHADOW;\n    const lightType = Math.floor(shadowMode / _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADOW_COUNT);\n    return shadowMode - lightType * _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADOW_COUNT;\n  }\n  static getShadow(lightType, shadowType) {\n    const shadowMode = shadowType + lightType * _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADOW_COUNT;\n    const pass = _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADER_SHADOW + shadowMode;\n    return pass;\n  }\n  static getPassShaderDefine(pass) {\n    if (pass === _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADER_PICK) {\n      return '#define PICK_PASS\\n';\n    } else if (pass === _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHADER_DEPTH) {\n      return '#define DEPTH_PASS\\n';\n    } else if (ShaderPass.isShadow(pass)) {\n      return '#define SHADOW_PASS\\n';\n    }\n    return '';\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-pass.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/skin-instance-cache.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/skin-instance-cache.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SkinInstanceCache\": () => (/* binding */ SkinInstanceCache)\n/* harmony export */ });\n/* harmony import */ var _core_ref_counted_object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ref-counted-object.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/ref-counted-object.js\");\n/* harmony import */ var _skin_instance_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./skin-instance.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/skin-instance.js\");\n\n\n\nclass SkinInstanceCachedObject extends _core_ref_counted_object_js__WEBPACK_IMPORTED_MODULE_0__.RefCountedObject {\n  constructor(skin, skinInstance) {\n    super();\n    this.skin = skin;\n    this.skinInstance = skinInstance;\n  }\n}\nclass SkinInstanceCache {\n  static createCachedSkinInstance(skin, rootBone, entity) {\n    let skinInst = SkinInstanceCache.getCachedSkinInstance(skin, rootBone);\n    if (!skinInst) {\n      skinInst = new _skin_instance_js__WEBPACK_IMPORTED_MODULE_1__.SkinInstance(skin);\n      skinInst.resolve(rootBone, entity);\n      SkinInstanceCache.addCachedSkinInstance(skin, rootBone, skinInst);\n    }\n    return skinInst;\n  }\n  static getCachedSkinInstance(skin, rootBone) {\n    let skinInstance = null;\n    const cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);\n    if (cachedObjArray) {\n      const cachedObj = cachedObjArray.find(element => element.skin === skin);\n      if (cachedObj) {\n        cachedObj.incRefCount();\n        skinInstance = cachedObj.skinInstance;\n      }\n    }\n    return skinInstance;\n  }\n  static addCachedSkinInstance(skin, rootBone, skinInstance) {\n    let cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);\n    if (!cachedObjArray) {\n      cachedObjArray = [];\n      SkinInstanceCache._skinInstanceCache.set(rootBone, cachedObjArray);\n    }\n    let cachedObj = cachedObjArray.find(element => element.skin === skin);\n    if (!cachedObj) {\n      cachedObj = new SkinInstanceCachedObject(skin, skinInstance);\n      cachedObjArray.push(cachedObj);\n    }\n    cachedObj.incRefCount();\n  }\n  static removeCachedSkinInstance(skinInstance) {\n    if (skinInstance) {\n      const rootBone = skinInstance.rootBone;\n      if (rootBone) {\n        const cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);\n        if (cachedObjArray) {\n          const cachedObjIndex = cachedObjArray.findIndex(element => element.skinInstance === skinInstance);\n          if (cachedObjIndex >= 0) {\n            const cachedObj = cachedObjArray[cachedObjIndex];\n            cachedObj.decRefCount();\n            if (cachedObj.refCount === 0) {\n              cachedObjArray.splice(cachedObjIndex, 1);\n              if (!cachedObjArray.length) {\n                SkinInstanceCache._skinInstanceCache.delete(rootBone);\n              }\n              if (skinInstance) {\n                skinInstance.destroy();\n                cachedObj.skinInstance = null;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\nSkinInstanceCache._skinInstanceCache = new Map();\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/skin-instance-cache.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/skin-instance.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/skin-instance.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SkinInstance\": () => (/* binding */ SkinInstance)\n/* harmony export */ });\n/* harmony import */ var _core_math_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/math/math.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/math.js\");\n/* harmony import */ var _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/math/mat4.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/mat4.js\");\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../platform/graphics/texture.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/texture.js\");\n\n\n\n\n\n\nconst _invMatrix = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\nclass SkinInstance {\n  constructor(skin) {\n    this.bones = void 0;\n    this._dirty = true;\n    this._rootBone = null;\n    this._skinUpdateIndex = -1;\n    this._updateBeforeCull = true;\n    if (skin) {\n      this.initSkin(skin);\n    }\n  }\n  set rootBone(rootBone) {\n    this._rootBone = rootBone;\n  }\n  get rootBone() {\n    return this._rootBone;\n  }\n  init(device, numBones) {\n    if (device.supportsBoneTextures) {\n      const numPixels = numBones * 3;\n      let width = Math.ceil(Math.sqrt(numPixels));\n      width = _core_math_math_js__WEBPACK_IMPORTED_MODULE_1__.math.roundUp(width, 3);\n      const height = Math.ceil(numPixels / width);\n      this.boneTexture = new _platform_graphics_texture_js__WEBPACK_IMPORTED_MODULE_2__.Texture(device, {\n        width: width,\n        height: height,\n        format: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.PIXELFORMAT_RGBA32F,\n        mipmaps: false,\n        minFilter: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.FILTER_NEAREST,\n        magFilter: _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_3__.FILTER_NEAREST,\n        name: 'skin'\n      });\n      this.matrixPalette = this.boneTexture.lock();\n    } else {\n      this.matrixPalette = new Float32Array(numBones * 12);\n    }\n  }\n  destroy() {\n    if (this.boneTexture) {\n      this.boneTexture.destroy();\n      this.boneTexture = null;\n    }\n  }\n  resolve(rootBone, entity) {\n    this.rootBone = rootBone;\n    const skin = this.skin;\n    const bones = [];\n    for (let j = 0; j < skin.boneNames.length; j++) {\n      const boneName = skin.boneNames[j];\n      let bone = rootBone.findByName(boneName);\n      if (!bone) {\n        bone = entity;\n      }\n      bones.push(bone);\n    }\n    this.bones = bones;\n  }\n  initSkin(skin) {\n    this.skin = skin;\n    this.bones = [];\n    const numBones = skin.inverseBindPose.length;\n    this.init(skin.device, numBones);\n    this.matrices = [];\n    for (let i = 0; i < numBones; i++) {\n      this.matrices[i] = new _core_math_mat4_js__WEBPACK_IMPORTED_MODULE_0__.Mat4();\n    }\n  }\n  uploadBones(device) {\n    if (device.supportsBoneTextures) {\n      this.boneTexture.lock();\n      this.boneTexture.unlock();\n    }\n  }\n  _updateMatrices(rootNode, skinUpdateIndex) {\n    if (this._skinUpdateIndex !== skinUpdateIndex) {\n      this._skinUpdateIndex = skinUpdateIndex;\n      _invMatrix.copy(rootNode.getWorldTransform()).invert();\n      for (let i = this.bones.length - 1; i >= 0; i--) {\n        this.matrices[i].mulAffine2(_invMatrix, this.bones[i].getWorldTransform());\n        this.matrices[i].mulAffine2(this.matrices[i], this.skin.inverseBindPose[i]);\n      }\n    }\n  }\n  updateMatrices(rootNode, skinUpdateIndex) {\n    if (this._updateBeforeCull) {\n      this._updateMatrices(rootNode, skinUpdateIndex);\n    }\n  }\n  updateMatrixPalette(rootNode, skinUpdateIndex) {\n    this._updateMatrices(rootNode, skinUpdateIndex);\n    const mp = this.matrixPalette;\n    const count = this.bones.length;\n    for (let i = 0; i < count; i++) {\n      const pe = this.matrices[i].data;\n      const base = i * 12;\n      mp[base] = pe[0];\n      mp[base + 1] = pe[4];\n      mp[base + 2] = pe[8];\n      mp[base + 3] = pe[12];\n      mp[base + 4] = pe[1];\n      mp[base + 5] = pe[5];\n      mp[base + 6] = pe[9];\n      mp[base + 7] = pe[13];\n      mp[base + 8] = pe[2];\n      mp[base + 9] = pe[6];\n      mp[base + 10] = pe[10];\n      mp[base + 11] = pe[14];\n    }\n    this.uploadBones(this.skin.device);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/skin-instance.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/skin-partition.js":
/*!******************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/skin-partition.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"partitionSkin\": () => (/* binding */ partitionSkin)\n/* harmony export */ });\nclass PartitionedVertex {\n  constructor() {\n    this.index = 0;\n    this.boneIndices = [0, 0, 0, 0];\n  }\n}\nclass SkinPartition {\n  constructor() {\n    this.partition = 0;\n    this.vertexStart = 0;\n    this.vertexCount = 0;\n    this.indexStart = 0;\n    this.indexCount = 0;\n    this.boneIndices = [];\n    this.vertices = [];\n    this.indices = [];\n    this.indexMap = {};\n    this.originalMesh = null;\n  }\n  addVertex(vertex, idx, vertexArray) {\n    let remappedIndex = -1;\n    if (this.indexMap[idx] !== undefined) {\n      remappedIndex = this.indexMap[idx];\n      this.indices.push(remappedIndex);\n    } else {\n      for (let influence = 0; influence < 4; influence++) {\n        if (vertexArray.blendWeight.data[idx * 4 + influence] === 0) continue;\n        const originalBoneIndex = vertexArray.blendIndices.data[vertex.index * 4 + influence];\n        vertex.boneIndices[influence] = this.getBoneRemap(originalBoneIndex);\n      }\n      remappedIndex = this.vertices.length;\n      this.indices.push(remappedIndex);\n      this.vertices.push(vertex);\n      this.indexMap[idx] = remappedIndex;\n    }\n  }\n  addPrimitive(vertices, vertexIndices, vertexArray, boneLimit) {\n    const bonesToAdd = [];\n    let bonesToAddCount = 0;\n    const vertexCount = vertices.length;\n    for (let i = 0; i < vertexCount; i++) {\n      const vertex = vertices[i];\n      const idx = vertex.index;\n      for (let influence = 0; influence < 4; influence++) {\n        if (vertexArray.blendWeight.data[idx * 4 + influence] > 0) {\n          const boneIndex = vertexArray.blendIndices.data[idx * 4 + influence];\n          let needToAdd = true;\n          for (let j = 0; j < bonesToAddCount; j++) {\n            if (bonesToAdd[j] === boneIndex) {\n              needToAdd = false;\n              break;\n            }\n          }\n          if (needToAdd) {\n            bonesToAdd[bonesToAddCount] = boneIndex;\n            const boneRemap = this.getBoneRemap(boneIndex);\n            bonesToAddCount += boneRemap === -1 ? 1 : 0;\n          }\n        }\n      }\n    }\n    if (this.boneIndices.length + bonesToAddCount > boneLimit) {\n      return false;\n    }\n    for (let i = 0; i < bonesToAddCount; i++) {\n      this.boneIndices.push(bonesToAdd[i]);\n    }\n    for (let i = 0; i < vertexCount; i++) {\n      this.addVertex(vertices[i], vertexIndices[i], vertexArray);\n    }\n    return true;\n  }\n  getBoneRemap(boneIndex) {\n    for (let i = 0; i < this.boneIndices.length; i++) {\n      if (this.boneIndices[i] === boneIndex) {\n        return i;\n      }\n    }\n    return -1;\n  }\n}\nfunction indicesToReferences(model) {\n  const vertices = model.vertices;\n  const skins = model.skins;\n  const meshes = model.meshes;\n  const meshInstances = model.meshInstances;\n  for (let i = 0; i < meshes.length; i++) {\n    meshes[i].vertices = vertices[meshes[i].vertices];\n    if (meshes[i].skin !== undefined) {\n      meshes[i].skin = skins[meshes[i].skin];\n    }\n  }\n  for (let i = 0; i < meshInstances.length; i++) {\n    meshInstances[i].mesh = meshes[meshInstances[i].mesh];\n  }\n}\nfunction referencesToIndices(model) {\n  const vertices = model.vertices;\n  const skins = model.skins;\n  const meshes = model.meshes;\n  const meshInstances = model.meshInstances;\n  for (let i = 0; i < meshes.length; i++) {\n    meshes[i].vertices = vertices.indexOf(meshes[i].vertices);\n    if (meshes[i].skin !== undefined) {\n      meshes[i].skin = skins.indexOf(meshes[i].skin);\n    }\n  }\n  for (let i = 0; i < meshInstances.length; i++) {\n    meshInstances[i].mesh = meshes.indexOf(meshInstances[i].mesh);\n  }\n}\nfunction partitionSkin(model, materialMappings, boneLimit) {\n  let i, j, k, index;\n  indicesToReferences(model);\n  const vertexArrays = model.vertices;\n  const skins = model.skins;\n  let mesh;\n  const meshes = model.meshes;\n  const meshInstances = model.meshInstances;\n  const getVertex = function getVertex(idx) {\n    const vert = new PartitionedVertex();\n    vert.index = idx;\n    return vert;\n  };\n  for (i = skins.length - 1; i >= 0; i--) {\n    if (skins[i].boneNames.length > boneLimit) {\n      const skin = skins.splice(i, 1)[0];\n      const meshesToSplit = [];\n      for (j = 0; j < meshes.length; j++) {\n        if (meshes[j].skin === skin) {\n          meshesToSplit.push(meshes[j]);\n        }\n      }\n      for (j = 0; j < meshesToSplit.length; j++) {\n        index = meshes.indexOf(meshesToSplit[j]);\n        if (index !== -1) {\n          meshes.splice(index, 1);\n        }\n      }\n      if (meshesToSplit.length === 0) {\n        throw new Error('partitionSkin: There should be at least one mesh that references a skin');\n      }\n      const vertexArray = meshesToSplit[0].vertices;\n      for (j = 1; j < meshesToSplit.length; j++) {\n        if (meshesToSplit[j].vertices !== vertexArray) {\n          throw new Error('partitionSkin: All meshes that share a skin should also share the same vertex buffer');\n        }\n      }\n      let partition;\n      const partitions = [];\n      const primitiveVertices = [];\n      const primitiveIndices = [];\n      let basePartition = 0;\n      for (j = 0; j < meshesToSplit.length; j++) {\n        mesh = meshesToSplit[j];\n        const indices = mesh.indices;\n        for (let iIndex = mesh.base; iIndex < mesh.base + mesh.count;) {\n          index = indices[iIndex++];\n          primitiveVertices[0] = getVertex(index);\n          primitiveIndices[0] = index;\n          index = indices[iIndex++];\n          primitiveVertices[1] = getVertex(index);\n          primitiveIndices[1] = index;\n          index = indices[iIndex++];\n          primitiveVertices[2] = getVertex(index);\n          primitiveIndices[2] = index;\n          let added = false;\n          for (let iBonePartition = basePartition; iBonePartition < partitions.length; iBonePartition++) {\n            partition = partitions[iBonePartition];\n            if (partition.addPrimitive(primitiveVertices, primitiveIndices, vertexArray, boneLimit)) {\n              added = true;\n              break;\n            }\n          }\n          if (!added) {\n            partition = new SkinPartition();\n            partition.originalMesh = mesh;\n            partition.addPrimitive(primitiveVertices, primitiveIndices, vertexArray, boneLimit);\n            partitions.push(partition);\n          }\n        }\n        basePartition = partitions.length;\n      }\n      const partitionedVertices = [];\n      const partitionedIndices = [];\n      for (j = 0; j < partitions.length; j++) {\n        partition = partitions[j];\n        if (partition.vertices.length && partition.indices.length) {\n          const vertexStart = partitionedVertices.length;\n          const vertexCount = partition.vertices.length;\n          const indexStart = partitionedIndices.length;\n          const indexCount = partition.indices.length;\n          partition.partition = j;\n          partition.vertexStart = vertexStart;\n          partition.vertexCount = vertexCount;\n          partition.indexStart = indexStart;\n          partition.indexCount = indexCount;\n          let iSour;\n          let iDest;\n          iSour = 0;\n          iDest = vertexStart;\n          while (iSour < vertexCount) {\n            partitionedVertices[iDest++] = partition.vertices[iSour++];\n          }\n          iSour = 0;\n          iDest = indexStart;\n          while (iSour < indexCount) {\n            partitionedIndices[iDest++] = partition.indices[iSour++] + vertexStart;\n          }\n        }\n      }\n      const splitSkins = [];\n      for (j = 0; j < partitions.length; j++) {\n        partition = partitions[j];\n        const ibp = [];\n        const boneNames = [];\n        for (k = 0; k < partition.boneIndices.length; k++) {\n          ibp.push(skin.inverseBindMatrices[partition.boneIndices[k]]);\n          boneNames.push(skin.boneNames[partition.boneIndices[k]]);\n        }\n        const splitSkin = {\n          inverseBindMatrices: ibp,\n          boneNames: boneNames\n        };\n        splitSkins.push(splitSkin);\n        skins.push(splitSkin);\n      }\n      let attrib, attribName, data, components;\n      const splitVertexArray = {};\n      for (attribName in vertexArray) {\n        splitVertexArray[attribName] = {\n          components: vertexArray[attribName].components,\n          data: [],\n          type: vertexArray[attribName].type\n        };\n      }\n      for (attribName in vertexArray) {\n        if (attribName === 'blendIndices') {\n          const dstBoneIndices = splitVertexArray[attribName].data;\n          for (j = 0; j < partitionedVertices.length; j++) {\n            const srcBoneIndices = partitionedVertices[j].boneIndices;\n            dstBoneIndices.push(srcBoneIndices[0], srcBoneIndices[1], srcBoneIndices[2], srcBoneIndices[3]);\n          }\n        } else {\n          attrib = vertexArray[attribName];\n          data = attrib.data;\n          components = attrib.components;\n          for (j = 0; j < partitionedVertices.length; j++) {\n            index = partitionedVertices[j].index;\n            for (k = 0; k < components; k++) {\n              splitVertexArray[attribName].data.push(data[index * components + k]);\n            }\n          }\n        }\n      }\n      vertexArrays[vertexArrays.indexOf(vertexArray)] = splitVertexArray;\n      for (j = 0; j < partitions.length; j++) {\n        partition = partitions[j];\n        mesh = {\n          aabb: {\n            min: [0, 0, 0],\n            max: [0, 0, 0]\n          },\n          vertices: splitVertexArray,\n          skin: splitSkins[j],\n          indices: partitionedIndices.splice(0, partition.indexCount),\n          type: 'triangles',\n          base: 0,\n          count: partition.indexCount\n        };\n        meshes.push(mesh);\n        for (k = meshInstances.length - 1; k >= 0; k--) {\n          if (meshInstances[k].mesh === partition.originalMesh) {\n            meshInstances.push({\n              mesh: mesh,\n              node: meshInstances[k].node\n            });\n            if (materialMappings) {\n              materialMappings.push({\n                material: materialMappings[k].material,\n                path: materialMappings[k].path\n              });\n            }\n          }\n        }\n      }\n      for (j = 0; j < partitions.length; j++) {\n        partition = partitions[j];\n        for (k = meshInstances.length - 1; k >= 0; k--) {\n          if (meshInstances[k].mesh === partition.originalMesh) {\n            meshInstances.splice(k, 1);\n            if (materialMappings) {\n              materialMappings.splice(k, 1);\n            }\n          }\n        }\n      }\n    }\n  }\n  referencesToIndices(model);\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/skin-partition.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/skin.js":
/*!********************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/skin.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Skin\": () => (/* binding */ Skin)\n/* harmony export */ });\nclass Skin {\n  constructor(graphicsDevice, ibp, boneNames) {\n    this.device = graphicsDevice;\n    this.inverseBindPose = ibp;\n    this.boneNames = boneNames;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/skin.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/sky.js":
/*!*******************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/sky.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Sky\": () => (/* binding */ Sky)\n/* harmony export */ });\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n/* harmony import */ var _platform_graphics_shader_processor_options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../platform/graphics/shader-processor-options.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/shader-processor-options.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _procedural_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./procedural.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/procedural.js\");\n/* harmony import */ var _graph_node_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./graph-node.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/graph-node.js\");\n/* harmony import */ var _materials_material_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./materials/material.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/materials/material.js\");\n/* harmony import */ var _mesh_instance_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mesh-instance.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/mesh-instance.js\");\n/* harmony import */ var _shader_lib_get_program_library_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shader-lib/get-program-library.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/get-program-library.js\");\n/* harmony import */ var _shader_lib_programs_skybox_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shader-lib/programs/skybox.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/shader-lib/programs/skybox.js\");\n\n\n\n\n\n\n\n\n\n\nclass Sky {\n  constructor(device, scene, texture) {\n    this.meshInstance = void 0;\n    const material = new _materials_material_js__WEBPACK_IMPORTED_MODULE_0__.Material();\n    material.getShaderVariant = function (dev, sc, defs, staticLightList, pass, sortedLights, viewUniformFormat, viewBindGroupFormat) {\n      const options = texture.cubemap ? {\n        type: 'cubemap',\n        encoding: texture.encoding,\n        useIntensity: scene.skyboxIntensity !== 1 || scene.physicalUnits,\n        mip: texture.fixCubemapSeams ? scene.skyboxMip : 0,\n        fixSeams: texture.fixCubemapSeams,\n        gamma: pass === _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHADER_FORWARDHDR ? scene.gammaCorrection ? _constants_js__WEBPACK_IMPORTED_MODULE_1__.GAMMA_SRGBHDR : _constants_js__WEBPACK_IMPORTED_MODULE_1__.GAMMA_NONE : scene.gammaCorrection,\n        toneMapping: pass === _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHADER_FORWARDHDR ? _constants_js__WEBPACK_IMPORTED_MODULE_1__.TONEMAP_LINEAR : scene.toneMapping\n      } : {\n        type: 'envAtlas',\n        encoding: texture.encoding,\n        useIntensity: scene.skyboxIntensity !== 1 || scene.physicalUnits,\n        gamma: pass === _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHADER_FORWARDHDR ? scene.gammaCorrection ? _constants_js__WEBPACK_IMPORTED_MODULE_1__.GAMMA_SRGBHDR : _constants_js__WEBPACK_IMPORTED_MODULE_1__.GAMMA_NONE : scene.gammaCorrection,\n        toneMapping: pass === _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHADER_FORWARDHDR ? _constants_js__WEBPACK_IMPORTED_MODULE_1__.TONEMAP_LINEAR : scene.toneMapping\n      };\n      const processingOptions = new _platform_graphics_shader_processor_options_js__WEBPACK_IMPORTED_MODULE_2__.ShaderProcessorOptions(viewUniformFormat, viewBindGroupFormat);\n      const library = (0,_shader_lib_get_program_library_js__WEBPACK_IMPORTED_MODULE_3__.getProgramLibrary)(device);\n      library.register('skybox', _shader_lib_programs_skybox_js__WEBPACK_IMPORTED_MODULE_4__.skybox);\n      return library.getProgram('skybox', options, processingOptions);\n    };\n    if (texture.cubemap) {\n      material.setParameter('texture_cubeMap', texture);\n    } else {\n      material.setParameter('texture_envAtlas', texture);\n      material.setParameter('mipLevel', scene._skyboxMip);\n    }\n    material.cull = _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_5__.CULLFACE_FRONT;\n    material.depthWrite = false;\n    const skyLayer = scene.layers.getLayerById(_constants_js__WEBPACK_IMPORTED_MODULE_1__.LAYERID_SKYBOX);\n    if (skyLayer) {\n      const node = new _graph_node_js__WEBPACK_IMPORTED_MODULE_6__.GraphNode('Skybox');\n      const mesh = (0,_procedural_js__WEBPACK_IMPORTED_MODULE_7__.createBox)(device);\n      const meshInstance = new _mesh_instance_js__WEBPACK_IMPORTED_MODULE_8__.MeshInstance(mesh, material, node);\n      this.meshInstance = meshInstance;\n      meshInstance.cull = false;\n      meshInstance._noDepthDrawGl1 = true;\n      meshInstance.pick = false;\n      skyLayer.addMeshInstances([meshInstance]);\n      this.skyLayer = skyLayer;\n    }\n  }\n  destroy() {\n    if (this.meshInstance) {\n      if (this.skyLayer) {\n        this.skyLayer.removeMeshInstances([this.meshInstance]);\n      }\n      this.meshInstance.destroy();\n      this.meshInstance = null;\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/sky.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/sprite.js":
/*!**********************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/sprite.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Sprite\": () => (/* binding */ Sprite)\n/* harmony export */ });\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n/* harmony import */ var _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/math/vec2.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/vec2.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/constants.js\");\n/* harmony import */ var _procedural_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./procedural.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/scene/procedural.js\");\n\n\n\n\n\nconst spriteNormals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1];\nconst spriteIndices = [0, 1, 3, 2, 3, 1];\nclass Sprite extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor(device, options) {\n    super();\n    this._device = device;\n    this._pixelsPerUnit = options && options.pixelsPerUnit !== undefined ? options.pixelsPerUnit : 1;\n    this._renderMode = options && options.renderMode !== undefined ? options.renderMode : _constants_js__WEBPACK_IMPORTED_MODULE_1__.SPRITE_RENDERMODE_SIMPLE;\n    this._atlas = options && options.atlas !== undefined ? options.atlas : null;\n    this._frameKeys = options && options.frameKeys !== undefined ? options.frameKeys : null;\n    this._meshes = [];\n    this._updatingProperties = false;\n    this._meshesDirty = false;\n    if (this._atlas && this._frameKeys) {\n      this._createMeshes();\n    }\n  }\n  set frameKeys(value) {\n    this._frameKeys = value;\n    if (this._atlas && this._frameKeys) {\n      if (this._updatingProperties) {\n        this._meshesDirty = true;\n      } else {\n        this._createMeshes();\n      }\n    }\n    this.fire('set:frameKeys', value);\n  }\n  get frameKeys() {\n    return this._frameKeys;\n  }\n  set atlas(value) {\n    if (value === this._atlas) return;\n    if (this._atlas) {\n      this._atlas.off('set:frames', this._onSetFrames, this);\n      this._atlas.off('set:frame', this._onFrameChanged, this);\n      this._atlas.off('remove:frame', this._onFrameRemoved, this);\n    }\n    this._atlas = value;\n    if (this._atlas && this._frameKeys) {\n      this._atlas.on('set:frames', this._onSetFrames, this);\n      this._atlas.on('set:frame', this._onFrameChanged, this);\n      this._atlas.on('remove:frame', this._onFrameRemoved, this);\n      if (this._updatingProperties) {\n        this._meshesDirty = true;\n      } else {\n        this._createMeshes();\n      }\n    }\n    this.fire('set:atlas', value);\n  }\n  get atlas() {\n    return this._atlas;\n  }\n  set pixelsPerUnit(value) {\n    if (this._pixelsPerUnit === value) return;\n    this._pixelsPerUnit = value;\n    this.fire('set:pixelsPerUnit', value);\n    if (this._atlas && this._frameKeys && this.renderMode === _constants_js__WEBPACK_IMPORTED_MODULE_1__.SPRITE_RENDERMODE_SIMPLE) {\n      if (this._updatingProperties) {\n        this._meshesDirty = true;\n      } else {\n        this._createMeshes();\n      }\n    }\n  }\n  get pixelsPerUnit() {\n    return this._pixelsPerUnit;\n  }\n  set renderMode(value) {\n    if (this._renderMode === value) return;\n    const prev = this._renderMode;\n    this._renderMode = value;\n    this.fire('set:renderMode', value);\n    if (prev === _constants_js__WEBPACK_IMPORTED_MODULE_1__.SPRITE_RENDERMODE_SIMPLE || value === _constants_js__WEBPACK_IMPORTED_MODULE_1__.SPRITE_RENDERMODE_SIMPLE) {\n      if (this._atlas && this._frameKeys) {\n        if (this._updatingProperties) {\n          this._meshesDirty = true;\n        } else {\n          this._createMeshes();\n        }\n      }\n    }\n  }\n  get renderMode() {\n    return this._renderMode;\n  }\n  get meshes() {\n    return this._meshes;\n  }\n  _createMeshes() {\n    const len = this._meshes.length;\n    for (let i = 0; i < len; i++) {\n      const mesh = this._meshes[i];\n      if (mesh) {\n        mesh.destroy();\n      }\n    }\n    const count = this._frameKeys.length;\n    this._meshes = new Array(count);\n    const createMeshFunc = this.renderMode === _constants_js__WEBPACK_IMPORTED_MODULE_1__.SPRITE_RENDERMODE_SLICED || this._renderMode === _constants_js__WEBPACK_IMPORTED_MODULE_1__.SPRITE_RENDERMODE_TILED ? this._create9SliceMesh : this._createSimpleMesh;\n    for (let i = 0; i < count; i++) {\n      const frame = this._atlas.frames[this._frameKeys[i]];\n      this._meshes[i] = frame ? createMeshFunc.call(this, frame) : null;\n    }\n    this.fire('set:meshes');\n  }\n  _createSimpleMesh(frame) {\n    const rect = frame.rect;\n    const texWidth = this._atlas.texture.width;\n    const texHeight = this._atlas.texture.height;\n    const w = rect.z / this._pixelsPerUnit;\n    const h = rect.w / this._pixelsPerUnit;\n    const hp = frame.pivot.x;\n    const vp = frame.pivot.y;\n    const positions = [-hp * w, -vp * h, 0, (1 - hp) * w, -vp * h, 0, (1 - hp) * w, (1 - vp) * h, 0, -hp * w, (1 - vp) * h, 0];\n    const lu = rect.x / texWidth;\n    const bv = 1.0 - rect.y / texHeight;\n    const ru = (rect.x + rect.z) / texWidth;\n    const tv = 1.0 - (rect.y + rect.w) / texHeight;\n    const uvs = [lu, bv, ru, bv, ru, tv, lu, tv];\n    const mesh = (0,_procedural_js__WEBPACK_IMPORTED_MODULE_2__.createMesh)(this._device, positions, {\n      uvs: uvs,\n      normals: spriteNormals,\n      indices: spriteIndices\n    });\n    return mesh;\n  }\n  _create9SliceMesh() {\n    const he = _core_math_vec2_js__WEBPACK_IMPORTED_MODULE_3__.Vec2.ONE;\n    const ws = 3;\n    const ls = 3;\n    const positions = [];\n    const normals = [];\n    const uvs = [];\n    const indices = [];\n    let vcounter = 0;\n    for (let i = 0; i <= ws; i++) {\n      const u = i === 0 || i === ws ? 0 : 1;\n      for (let j = 0; j <= ls; j++) {\n        const x = -he.x + 2.0 * he.x * (i <= 1 ? 0 : 3) / ws;\n        const y = 0.0;\n        const z = -(-he.y + 2.0 * he.y * (j <= 1 ? 0 : 3) / ls);\n        const v = j === 0 || j === ls ? 0 : 1;\n        positions.push(-x, y, z);\n        normals.push(0.0, 1.0, 0.0);\n        uvs.push(u, v);\n        if (i < ws && j < ls) {\n          indices.push(vcounter + ls + 1, vcounter + 1, vcounter);\n          indices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);\n        }\n        vcounter++;\n      }\n    }\n    const options = {\n      normals: normals,\n      uvs: uvs,\n      indices: indices\n    };\n    return (0,_procedural_js__WEBPACK_IMPORTED_MODULE_2__.createMesh)(this._device, positions, options);\n  }\n  _onSetFrames(frames) {\n    if (this._updatingProperties) {\n      this._meshesDirty = true;\n    } else {\n      this._createMeshes();\n    }\n  }\n  _onFrameChanged(frameKey, frame) {\n    const idx = this._frameKeys.indexOf(frameKey);\n    if (idx < 0) return;\n    if (frame) {\n      if (this.renderMode === _constants_js__WEBPACK_IMPORTED_MODULE_1__.SPRITE_RENDERMODE_SIMPLE) {\n        this._meshes[idx] = this._createSimpleMesh(frame);\n      }\n    } else {\n      this._meshes[idx] = null;\n    }\n    this.fire('set:meshes');\n  }\n  _onFrameRemoved(frameKey) {\n    const idx = this._frameKeys.indexOf(frameKey);\n    if (idx < 0) return;\n    this._meshes[idx] = null;\n    this.fire('set:meshes');\n  }\n  startUpdate() {\n    this._updatingProperties = true;\n    this._meshesDirty = false;\n  }\n  endUpdate() {\n    this._updatingProperties = false;\n    if (this._meshesDirty && this._atlas && this._frameKeys) {\n      this._createMeshes();\n    }\n    this._meshesDirty = false;\n  }\n  destroy() {\n    for (const mesh of this._meshes) {\n      if (mesh) mesh.destroy();\n    }\n    this._meshes.length = 0;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/sprite.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/stencil-parameters.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/stencil-parameters.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"StencilParameters\": () => (/* binding */ StencilParameters)\n/* harmony export */ });\n/* harmony import */ var _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/graphics/constants.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/graphics/constants.js\");\n\n\nclass StencilParameters {\n  constructor(options) {\n    this.func = options.func === undefined ? _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.FUNC_ALWAYS : options.func;\n    this.ref = options.ref || 0;\n    this.readMask = options.readMask === undefined ? 0xFF : options.readMask;\n    this.writeMask = options.writeMask === undefined ? 0xFF : options.writeMask;\n    this.fail = options.fail || _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.STENCILOP_KEEP;\n    this.zfail = options.zfail || _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.STENCILOP_KEEP;\n    this.zpass = options.zpass || _platform_graphics_constants_js__WEBPACK_IMPORTED_MODULE_0__.STENCILOP_KEEP;\n  }\n  clone() {\n    return new StencilParameters({\n      func: this.func,\n      ref: this.ref,\n      readMask: this.readMask,\n      writeMask: this.writeMask,\n      fail: this.fail,\n      zfail: this.zfail,\n      zpass: this.zpass\n    });\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/stencil-parameters.js?");

/***/ }),

/***/ "./node_modules/playcanvas/build/playcanvas.mjs/scene/texture-atlas.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/playcanvas/build/playcanvas.mjs/scene/texture-atlas.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TextureAtlas\": () => (/* binding */ TextureAtlas)\n/* harmony export */ });\n/* harmony import */ var _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/event-handler.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/event-handler.js\");\n\n\nclass TextureAtlas extends _core_event_handler_js__WEBPACK_IMPORTED_MODULE_0__.EventHandler {\n  constructor() {\n    super();\n    this._texture = null;\n    this._frames = null;\n  }\n  set texture(value) {\n    this._texture = value;\n    this.fire('set:texture', value);\n  }\n  get texture() {\n    return this._texture;\n  }\n  set frames(value) {\n    this._frames = value;\n    this.fire('set:frames', value);\n  }\n  get frames() {\n    return this._frames;\n  }\n  setFrame(key, data) {\n    let frame = this._frames[key];\n    if (!frame) {\n      frame = {\n        rect: data.rect.clone(),\n        pivot: data.pivot.clone(),\n        border: data.border.clone()\n      };\n      this._frames[key] = frame;\n    } else {\n      frame.rect.copy(data.rect);\n      frame.pivot.copy(data.pivot);\n      frame.border.copy(data.border);\n    }\n    this.fire('set:frame', key.toString(), frame);\n  }\n  removeFrame(key) {\n    const frame = this._frames[key];\n    if (frame) {\n      delete this._frames[key];\n      this.fire('remove:frame', key.toString(), frame);\n    }\n  }\n  destroy() {\n    if (this._texture) {\n      this._texture.destroy();\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mycan_webpack/./node_modules/playcanvas/build/playcanvas.mjs/scene/texture-atlas.js?");

/***/ }),

/***/ "./src/App.js":
/*!********************!*\
  !*** ./src/App.js ***!
  \********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ App)\n/* harmony export */ });\n/* harmony import */ var _node_modules_playcanvas_build_playcanvas_mjs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/playcanvas/build/playcanvas.mjs/index.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/entity.js\");\n/* harmony import */ var _node_modules_playcanvas_build_playcanvas_mjs_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/playcanvas/build/playcanvas.mjs/index.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/input/mouse.js\");\n/* harmony import */ var _node_modules_playcanvas_build_playcanvas_mjs_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../node_modules/playcanvas/build/playcanvas.mjs/index.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/application.js\");\n/* harmony import */ var _node_modules_playcanvas_build_playcanvas_mjs_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../node_modules/playcanvas/build/playcanvas.mjs/index.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/input/touch-device.js\");\n/* harmony import */ var _node_modules_playcanvas_build_playcanvas_mjs_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../node_modules/playcanvas/build/playcanvas.mjs/index.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/framework/input/element-input.js\");\n/* harmony import */ var _node_modules_playcanvas_build_playcanvas_mjs_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../node_modules/playcanvas/build/playcanvas.mjs/index.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/platform/input/constants.js\");\n/* harmony import */ var _node_modules_playcanvas_build_playcanvas_mjs_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../node_modules/playcanvas/build/playcanvas.mjs/index.js */ \"./node_modules/playcanvas/build/playcanvas.mjs/core/math/color.js\");\n\r\n\r\n//namespace pc;\r\nlet canvas;\r\nlet app;\r\nvar CANVAS_ID = 'application-canvas';\r\n\r\nlet button;\r\nlet _mouse;\r\nlet _camera;\r\n\r\n\r\nfunction example() \r\n{\r\n    button = new _node_modules_playcanvas_build_playcanvas_mjs_index_js__WEBPACK_IMPORTED_MODULE_0__.Entity(\"2d screeb\");\r\n    app.root.addChild(button);\r\n\r\n    button.addComponent(\"screen\", {resolution: { width : 100, height: 100}});\r\n    \r\n\r\n\r\n\r\n    const b1 = new _node_modules_playcanvas_build_playcanvas_mjs_index_js__WEBPACK_IMPORTED_MODULE_0__.Entity(\"cube ME\");\r\n    b1.addComponent(\"render\", { type: \"box\", });    \r\n    app.root.addChild(b1);\r\n\r\n    // create box entity\r\n    const box = new _node_modules_playcanvas_build_playcanvas_mjs_index_js__WEBPACK_IMPORTED_MODULE_0__.Entity(\"cube\");\r\n    box.addComponent(\"render\", { type: \"box\", });\r\n    box.setLocalPosition(0.2,0.2,0.2);\r\n    b1.addChild(box);\r\n\r\n    // create directional light entity\r\n    const light = new _node_modules_playcanvas_build_playcanvas_mjs_index_js__WEBPACK_IMPORTED_MODULE_0__.Entity(\"light\");\r\n    light.addComponent(\"light\");        \r\n    light.setEulerAngles(45, 0, 0);\r\n    app.root.addChild(light);\r\n\r\n    // rotate the box according to the delta time since the last frame\r\n    app.on(\"update\", (dt) => b1.rotate(10 * dt, 20 * dt, 30 * dt));\r\n\r\n    app.start();\r\n}\r\n\r\n\r\n\r\nclass App \r\n{\r\n    constructor(_) \r\n    {\r\n\r\n        console.log(\"MY TEST!!!\");\r\n        CreateCanvas();\r\n        CreateApp();\r\n        CreateCamera();\r\n    \texample();\r\n    }\r\n}\r\n\r\n\r\nfunction CreateCanvas()\r\n{\r\n    canvas = document.createElement('canvas');\r\n    canvas.width = 1300;\r\n    canvas.height = 1300;\r\n    canvas.setAttribute('id', CANVAS_ID);\r\n    //canvas.setAttribute('tabindex', 0);\r\n    // canvas.style.visibility = 'hidden';\r\n\r\n    // Disable I-bar cursor on click+drag\r\n    canvas.onselectstart = function () { return false; };\r\n    document.body.appendChild(canvas);\r\n}\r\n\r\nfunction CreateApp()\r\n{\r\n    _mouse = new _node_modules_playcanvas_build_playcanvas_mjs_index_js__WEBPACK_IMPORTED_MODULE_1__.Mouse(document.body)    \r\n\r\n    app = new _node_modules_playcanvas_build_playcanvas_mjs_index_js__WEBPACK_IMPORTED_MODULE_2__.Application(canvas, { \r\n\r\n        mouse: _mouse,\r\n        touch: new _node_modules_playcanvas_build_playcanvas_mjs_index_js__WEBPACK_IMPORTED_MODULE_3__.TouchDevice(document.body),\r\n        elementInput: new _node_modules_playcanvas_build_playcanvas_mjs_index_js__WEBPACK_IMPORTED_MODULE_4__.ElementInput(canvas),\r\n\r\n    });\r\n\r\n\r\n    let x = 0;\r\n    let y = 0;\r\n    _mouse.on(\"mousemove\", (event) =>\r\n    {\r\n        if (event.buttons[_node_modules_playcanvas_build_playcanvas_mjs_index_js__WEBPACK_IMPORTED_MODULE_5__.MOUSEBUTTON_LEFT]) \r\n        {\r\n            x += event.dx;\r\n            y += event.dy;\r\n\r\n            _camera.setLocalEulerAngles(0.02 * y, 0.02 * x, 0);\r\n        }\r\n\r\n        \r\n        if (event.buttons[_node_modules_playcanvas_build_playcanvas_mjs_index_js__WEBPACK_IMPORTED_MODULE_5__.EVENT_MOUSEWHEEL]) \r\n        {\r\n            x += event.dx;\r\n            \r\n\r\n            _camera.setEulerAngles(0, 0, x);\r\n        }\r\n        \r\n    });\r\n    \r\n}\r\n\r\nfunction CreateCamera()\r\n{\r\n    _camera = new _node_modules_playcanvas_build_playcanvas_mjs_index_js__WEBPACK_IMPORTED_MODULE_0__.Entity(\"camera\");\r\n    _camera.addComponent(\"camera\", { clearColor: new _node_modules_playcanvas_build_playcanvas_mjs_index_js__WEBPACK_IMPORTED_MODULE_6__.Color(0.5, 0.6, 0.9), });\r\n    _camera.setPosition(0, 0, 5);\r\n    app.root.addChild(_camera);\r\n}\n\n//# sourceURL=webpack://mycan_webpack/./src/App.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _App_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App.js */ \"./src/App.js\");\n//import {playcanvas}  from '../node_modules/playcanvas';\r\n\r\n\r\n\r\nconst app = new _App_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n\n\n//# sourceURL=webpack://mycan_webpack/./src/main.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.js");
/******/ 	
/******/ })()
;